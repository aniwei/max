export const lib = [["assert/strict.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"assert\").strict;\n}"],["dns/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst dnsPromises = require(\"internal/dns/promises\");\ndnsPromises.setServers = require(\"dns\").setServers;\nmodule.exports = dnsPromises;\n}"],["fs/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"internal/fs/promises\").exports;\n}"],["internal/abort_controller.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectAssign,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  ObjectDefineProperty,\n  Symbol,\n  SymbolToStringTag\n} = primordials;\nconst {\n  defineEventHandler,\n  EventTarget,\n  Event,\n  kTrustEvent\n} = require(\"internal/event_target\");\nconst {\n  customInspectSymbol\n} = require(\"internal/util\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst kAborted = Symbol(\"kAborted\");\nfunction customInspect(self, obj, depth, options) {\n  if (depth < 0)\n    return self;\n  const opts = ObjectAssign({}, options, {\n    depth: options.depth === null ? null : options.depth - 1\n  });\n  return `${self.constructor.name} ${inspect(obj, opts)}`;\n}\nfunction validateAbortSignal(obj) {\n  if (obj?.[kAborted] === void 0)\n    throw new ERR_INVALID_THIS(\"AbortSignal\");\n}\nclass AbortSignal extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get aborted() {\n    validateAbortSignal(this);\n    return !!this[kAborted];\n  }\n  [customInspectSymbol](depth, options) {\n    return customInspect(this, {\n      aborted: this.aborted\n    }, depth, options);\n  }\n  static abort() {\n    return createAbortSignal(true);\n  }\n}\nObjectDefineProperties(AbortSignal.prototype, {\n  aborted: { enumerable: true }\n});\nObjectDefineProperty(AbortSignal.prototype, SymbolToStringTag, {\n  writable: false,\n  enumerable: false,\n  configurable: true,\n  value: \"AbortSignal\"\n});\ndefineEventHandler(AbortSignal.prototype, \"abort\");\nfunction createAbortSignal(aborted = false) {\n  const signal = new EventTarget();\n  ObjectSetPrototypeOf(signal, AbortSignal.prototype);\n  signal[kAborted] = aborted;\n  return signal;\n}\nfunction abortSignal(signal) {\n  if (signal[kAborted])\n    return;\n  signal[kAborted] = true;\n  const event = new Event(\"abort\", {\n    [kTrustEvent]: true\n  });\n  signal.dispatchEvent(event);\n}\nconst kSignal = Symbol(\"signal\");\nfunction validateAbortController(obj) {\n  if (obj?.[kSignal] === void 0)\n    throw new ERR_INVALID_THIS(\"AbortController\");\n}\nclass AbortController {\n  constructor() {\n    this[kSignal] = createAbortSignal();\n  }\n  get signal() {\n    validateAbortController(this);\n    return this[kSignal];\n  }\n  abort() {\n    validateAbortController(this);\n    abortSignal(this[kSignal]);\n  }\n  [customInspectSymbol](depth, options) {\n    return customInspect(this, {\n      signal: this.signal\n    }, depth, options);\n  }\n}\nObjectDefineProperties(AbortController.prototype, {\n  signal: { enumerable: true },\n  abort: { enumerable: true }\n});\nObjectDefineProperty(AbortController.prototype, SymbolToStringTag, {\n  writable: false,\n  enumerable: false,\n  configurable: true,\n  value: \"AbortController\"\n});\nmodule.exports = {\n  kAborted,\n  AbortController,\n  AbortSignal\n};\n}"],["internal/assert.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require(\"internal/errors\").codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\nfunction assert(value, message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\nassert.fail = fail;\nmodule.exports = assert;\n}"],["internal/async_hooks.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeSlice,\n  ErrorCaptureStackTrace,\n  ObjectPrototypeHasOwnProperty,\n  ObjectDefineProperty,\n  Symbol\n} = primordials;\nconst async_wrap = internalBinding(\"async_wrap\");\nconst { setCallbackTrampoline } = async_wrap;\nconst {\n  async_hook_fields,\n  async_id_fields,\n  execution_async_resources\n} = async_wrap;\nconst {\n  pushAsyncContext: pushAsyncContext_,\n  popAsyncContext: popAsyncContext_,\n  executionAsyncResource: executionAsyncResource_,\n  clearAsyncIdStack\n} = async_wrap;\nconst { setPromiseHooks } = async_wrap;\nconst active_hooks = {\n  array: [],\n  call_depth: 0,\n  tmp_array: null,\n  tmp_fields: null\n};\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding(\"task_queue\");\nconst { owner_symbol } = internalBinding(\"symbols\");\nconst {\n  kInit,\n  kBefore,\n  kAfter,\n  kDestroy,\n  kTotals,\n  kPromiseResolve,\n  kCheck,\n  kExecutionAsyncId,\n  kAsyncIdCounter,\n  kTriggerAsyncId,\n  kDefaultTriggerAsyncId,\n  kStackLength,\n  kUsesExecutionAsyncResource\n} = async_wrap.constants;\nconst {\n  async_id_symbol,\n  trigger_async_id_symbol\n} = internalBinding(\"symbols\");\nlet inspect;\nconst init_symbol = Symbol(\"init\");\nconst before_symbol = Symbol(\"before\");\nconst after_symbol = Symbol(\"after\");\nconst destroy_symbol = Symbol(\"destroy\");\nconst promise_resolve_symbol = Symbol(\"promiseResolve\");\nconst emitBeforeNative = emitHookFactory(before_symbol, \"emitBeforeNative\");\nconst emitAfterNative = emitHookFactory(after_symbol, \"emitAfterNative\");\nconst emitDestroyNative = emitHookFactory(destroy_symbol, \"emitDestroyNative\");\nconst emitPromiseResolveNative = emitHookFactory(promise_resolve_symbol, \"emitPromiseResolveNative\");\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\nfunction callbackTrampoline(asyncId, resource, cb, ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n  let result;\n  if (asyncId === 0 && typeof domain_cb === \"function\") {\n    args.unshift(cb);\n    result = domain_cb.apply(this, args);\n  } else {\n    result = cb.apply(this, args);\n  }\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n  execution_async_resources.pop();\n  return result;\n}\nsetCallbackTrampoline(callbackTrampoline);\nconst topLevelResource = {};\nfunction executionAsyncResource() {\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1)\n    return topLevelResource;\n  const resource = execution_async_resources[index] || executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\nfunction inspectExceptionValue(e) {\n  inspect ??= require(\"internal/util/inspect\").inspect;\n  return { message: inspect(e) };\n}\nfunction fatalError(e) {\n  if (typeof e?.stack === \"string\") {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o, fatalError);\n    process._rawDebug(o.stack);\n  }\n  const { getOptionValue } = require(\"internal/options\");\n  if (getOptionValue(\"--abort-on-uncaught-exception\")) {\n    process.abort();\n  }\n  process.exit(1);\n}\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== \"object\" || resource === null)\n    return resource;\n  const publicResource = resource[owner_symbol];\n  if (publicResource != null) {\n    return publicResource;\n  }\n  return resource;\n}\nfunction emitInitNative(asyncId, type, triggerAsyncId2, resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  try {\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === \"function\") {\n        active_hooks.array[i][init_symbol](asyncId, type, triggerAsyncId2, resource);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\nfunction emitHook(symbol, asyncId) {\n  active_hooks.call_depth += 1;\n  try {\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === \"function\") {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\nfunction emitHookFactory(symbol, name) {\n  const fn = emitHook.bind(void 0, symbol);\n  ObjectDefineProperty(fn, \"name\", {\n    value: name\n  });\n  return fn;\n}\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array, async_hook_fields];\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array, active_hooks.tmp_fields];\n}\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields, async_hook_fields);\n}\nfunction copyHooks(destination, source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields, active_hooks.tmp_fields);\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\nfunction trackPromise(promise, parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n  const triggerAsyncId2 = parent ? getOrSetAsyncId(parent) : getDefaultTriggerAsyncId();\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId2;\n}\nfunction promiseInitHook(promise, parent) {\n  trackPromise(promise, parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId2 = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId, \"PROMISE\", triggerAsyncId2, promise);\n}\nfunction promiseInitHookWithDestroyTracking(promise, parent) {\n  promiseInitHook(promise, parent);\n  destroyTracking(promise, parent);\n}\nconst destroyedSymbol = Symbol(\"destroyed\");\nfunction destroyTracking(promise, parent) {\n  trackPromise(promise, parent);\n  const asyncId = promise[async_id_symbol];\n  const destroyed = { destroyed: false };\n  promise[destroyedSymbol] = destroyed;\n  registerDestroyHook(promise, asyncId, destroyed);\n}\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId, triggerId, promise);\n}\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    popAsyncContext(asyncId);\n  }\n}\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n}\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking : promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  setPromiseHooks(initHook, promiseBeforeHook, promiseAfterHook, promiseResolveHooksExist() ? promiseResolveHook : void 0);\n}\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n  wantPromiseHook = false;\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook) {\n    setPromiseHooks(void 0, void 0, void 0, void 0);\n  }\n}\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object, async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n  return object[async_id_symbol] = newAsyncId();\n}\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\nfunction defaultTriggerAsyncIdScope(triggerAsyncId2, block, ...args) {\n  if (triggerAsyncId2 === void 0)\n    return block.apply(null, args);\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId2;\n  try {\n    return block.apply(null, args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\nfunction emitInitScript(asyncId, type, triggerAsyncId2, resource) {\n  if (!hasHooks(kInit))\n    return;\n  if (triggerAsyncId2 === null) {\n    triggerAsyncId2 = getDefaultTriggerAsyncId();\n  }\n  emitInitNative(asyncId, type, triggerAsyncId2, resource);\n}\nfunction emitBeforeScript(asyncId, triggerAsyncId2, resource) {\n  pushAsyncContext(asyncId, triggerAsyncId2, resource);\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n  popAsyncContext(asyncId);\n}\nfunction emitDestroyScript(asyncId) {\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\nfunction pushAsyncContext(asyncId, triggerAsyncId2, resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId, triggerAsyncId2);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId2;\n}\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0)\n    return false;\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    return popAsyncContext_(asyncId);\n  }\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\nmodule.exports = {\n  executionAsyncId,\n  triggerAsyncId,\n  getHookArrays,\n  symbols: {\n    async_id_symbol,\n    trigger_async_id_symbol,\n    init_symbol,\n    before_symbol,\n    after_symbol,\n    destroy_symbol,\n    promise_resolve_symbol,\n    owner_symbol\n  },\n  constants: {\n    kInit,\n    kBefore,\n    kAfter,\n    kDestroy,\n    kTotals,\n    kPromiseResolve\n  },\n  enableHooks,\n  disableHooks,\n  updatePromiseHookMode,\n  clearDefaultTriggerAsyncId,\n  clearAsyncIdStack,\n  hasAsyncIdStack,\n  executionAsyncResource,\n  newAsyncId,\n  getOrSetAsyncId,\n  getDefaultTriggerAsyncId,\n  defaultTriggerAsyncIdScope,\n  enabledHooksExist,\n  initHooksExist,\n  afterHooksExist,\n  destroyHooksExist,\n  emitInit: emitInitScript,\n  emitBefore: emitBeforeScript,\n  emitAfter: emitAfterScript,\n  emitDestroy: emitDestroyScript,\n  pushAsyncContext,\n  popAsyncContext,\n  registerDestroyHook,\n  useDomainTrampoline,\n  nativeHooks: {\n    init: emitInitNative,\n    before: emitBeforeNative,\n    after: emitAfterNative,\n    destroy: emitDestroyNative,\n    promise_resolve: emitPromiseResolveNative\n  }\n};\n}"],["internal/blob.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  MathMax,\n  MathMin,\n  ObjectDefineProperty,\n  PromiseResolve,\n  PromiseReject,\n  SafePromisePrototypeFinally,\n  ReflectConstruct,\n  RegExpPrototypeSymbolReplace,\n  RegExpPrototypeTest,\n  StringPrototypeToLowerCase,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolIterator,\n  SymbolToStringTag,\n  Uint8Array\n} = primordials;\nconst {\n  createBlob: _createBlob,\n  FixedSizeBlobCopyJob,\n  getDataObject\n} = internalBinding(\"blob\");\nconst {\n  TextDecoder,\n  TextEncoder\n} = require(\"internal/encoding\");\nconst {\n  makeTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  createDeferredPromise,\n  customInspectSymbol: kInspect,\n  emitExperimentalWarning\n} = require(\"internal/util\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_THIS,\n    ERR_BUFFER_TOO_LARGE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateObject,\n  isUint32\n} = require(\"internal/validators\");\nconst kHandle = Symbol(\"kHandle\");\nconst kState = Symbol(\"kState\");\nconst kType = Symbol(\"kType\");\nconst kLength = Symbol(\"kLength\");\nconst kArrayBufferPromise = Symbol(\"kArrayBufferPromise\");\nconst kMaxChunkSize = 65536;\nconst disallowedTypeCharacters = /[^\\u{0020}-\\u{007E}]/u;\nlet ReadableStream;\nlet URL;\nlet EOL;\nconst enc = new TextEncoder();\nfunction lazyURL(id) {\n  URL ??= require(\"internal/url\").URL;\n  return new URL(id);\n}\nfunction lazyReadableStream(options) {\n  ReadableStream ??= require(\"internal/webstreams/readablestream\").ReadableStream;\n  return new ReadableStream(options);\n}\nfunction lazyEOL() {\n  EOL ??= require(\"os\").EOL;\n  return EOL;\n}\nfunction isBlob(object) {\n  return object?.[kHandle] !== void 0;\n}\nfunction getSource(source, endings) {\n  if (isBlob(source))\n    return [source.size, source[kHandle]];\n  if (isAnyArrayBuffer(source)) {\n    source = new Uint8Array(source);\n  } else if (!isArrayBufferView(source)) {\n    source = `${source}`;\n    if (endings === \"native\")\n      source = RegExpPrototypeSymbolReplace(/\\n|\\r\\n/g, source, lazyEOL());\n    source = enc.encode(source);\n  }\n  source = new Uint8Array(source);\n  return [source.byteLength, source];\n}\nclass Blob {\n  constructor(sources = [], options = {}) {\n    emitExperimentalWarning(\"buffer.Blob\");\n    if (sources === null || typeof sources[SymbolIterator] !== \"function\" || typeof sources === \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(\"sources\", \"Iterable\", sources);\n    }\n    validateObject(options, \"options\");\n    let {\n      type = \"\",\n      endings = \"transparent\"\n    } = options;\n    endings = `${endings}`;\n    if (endings !== \"transparent\" && endings !== \"native\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.endings\", endings);\n    let length = 0;\n    const sources_ = ArrayFrom(sources, (source) => {\n      const { 0: len, 1: src } = getSource(source, endings);\n      length += len;\n      return src;\n    });\n    if (!isUint32(length))\n      throw new ERR_BUFFER_TOO_LARGE(4294967295);\n    this[kHandle] = _createBlob(sources_, length);\n    this[kLength] = length;\n    type = `${type}`;\n    this[kType] = RegExpPrototypeTest(disallowedTypeCharacters, type) ? \"\" : StringPrototypeToLowerCase(type);\n    return makeTransferable(this);\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `Blob ${inspect({\n      size: this.size,\n      type: this.type\n    }, opts)}`;\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    const type = this[kType];\n    const length = this[kLength];\n    return {\n      data: { handle, type, length },\n      deserializeInfo: \"internal/blob:ClonedBlob\"\n    };\n  }\n  [kDeserialize]({ handle, type, length }) {\n    this[kHandle] = handle;\n    this[kType] = type;\n    this[kLength] = length;\n  }\n  get type() {\n    if (!isBlob(this))\n      throw new ERR_INVALID_THIS(\"Blob\");\n    return this[kType];\n  }\n  get size() {\n    if (!isBlob(this))\n      throw new ERR_INVALID_THIS(\"Blob\");\n    return this[kLength];\n  }\n  slice(start = 0, end = this[kLength], contentType = \"\") {\n    if (!isBlob(this))\n      throw new ERR_INVALID_THIS(\"Blob\");\n    if (start < 0) {\n      start = MathMax(this[kLength] + start, 0);\n    } else {\n      start = MathMin(start, this[kLength]);\n    }\n    start |= 0;\n    if (end < 0) {\n      end = MathMax(this[kLength] + end, 0);\n    } else {\n      end = MathMin(end, this[kLength]);\n    }\n    end |= 0;\n    contentType = `${contentType}`;\n    if (RegExpPrototypeTest(disallowedTypeCharacters, contentType)) {\n      contentType = \"\";\n    } else {\n      contentType = StringPrototypeToLowerCase(contentType);\n    }\n    const span = MathMax(end - start, 0);\n    return createBlob(this[kHandle].slice(start, start + span), span, contentType);\n  }\n  arrayBuffer() {\n    if (!isBlob(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"Blob\"));\n    if (this[kArrayBufferPromise])\n      return this[kArrayBufferPromise];\n    const job = new FixedSizeBlobCopyJob(this[kHandle]);\n    const ret = job.run();\n    if (ret !== void 0)\n      return PromiseResolve(ret);\n    const {\n      promise,\n      resolve,\n      reject\n    } = createDeferredPromise();\n    job.ondone = (err, ab) => {\n      if (err !== void 0)\n        return reject(new AbortError());\n      resolve(ab);\n    };\n    this[kArrayBufferPromise] = SafePromisePrototypeFinally(promise, () => this[kArrayBufferPromise] = void 0);\n    return this[kArrayBufferPromise];\n  }\n  async text() {\n    if (!isBlob(this))\n      throw new ERR_INVALID_THIS(\"Blob\");\n    const dec = new TextDecoder();\n    return dec.decode(await this.arrayBuffer());\n  }\n  stream() {\n    if (!isBlob(this))\n      throw new ERR_INVALID_THIS(\"Blob\");\n    const self = this;\n    return new lazyReadableStream({\n      async start() {\n        this[kState] = await self.arrayBuffer();\n      },\n      pull(controller) {\n        if (this[kState].byteLength <= kMaxChunkSize) {\n          controller.enqueue(new Uint8Array(this[kState]));\n          controller.close();\n          this[kState] = void 0;\n        } else {\n          const slice = this[kState].slice(0, kMaxChunkSize);\n          this[kState] = this[kState].slice(kMaxChunkSize);\n          controller.enqueue(new Uint8Array(slice));\n        }\n      }\n    });\n  }\n}\nfunction ClonedBlob() {\n  return makeTransferable(ReflectConstruct(function() {\n  }, [], Blob));\n}\nClonedBlob.prototype[kDeserialize] = () => {\n};\nfunction createBlob(handle, length, type = \"\") {\n  return makeTransferable(ReflectConstruct(function() {\n    this[kHandle] = handle;\n    this[kType] = type;\n    this[kLength] = length;\n  }, [], Blob));\n}\nObjectDefineProperty(Blob.prototype, SymbolToStringTag, {\n  configurable: true,\n  value: \"Blob\"\n});\nfunction resolveObjectURL(url) {\n  url = `${url}`;\n  try {\n    const parsed = new lazyURL(url);\n    const split = StringPrototypeSplit(parsed.pathname, \":\");\n    if (split.length !== 2)\n      return;\n    const {\n      0: base,\n      1: id\n    } = split;\n    if (base !== \"nodedata\")\n      return;\n    const ret = getDataObject(id);\n    if (ret === void 0)\n      return;\n    const {\n      0: handle,\n      1: length,\n      2: type\n    } = ret;\n    if (handle !== void 0)\n      return createBlob(handle, length, type);\n  } catch {\n  }\n}\nmodule.exports = {\n  Blob,\n  ClonedBlob,\n  createBlob,\n  isBlob,\n  kHandle,\n  resolveObjectURL\n};\n}"],["internal/blocklist.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Boolean,\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nconst {\n  BlockList: BlockListHandle\n} = internalBinding(\"block_list\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  SocketAddress,\n  kHandle: kSocketAddressHandle\n} = require(\"internal/socketaddress\");\nconst {\n  JSTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst kHandle = Symbol(\"kHandle\");\nconst { owner_symbol } = internalBinding(\"symbols\");\nconst {\n  ERR_INVALID_ARG_VALUE\n} = require(\"internal/errors\").codes;\nconst { validateInt32, validateString } = require(\"internal/validators\");\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `BlockList ${inspect({\n      rules: this.rules\n    }, opts)}`;\n  }\n  addAddress(address, family = \"ipv4\") {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address, \"address\");\n      validateString(family, \"family\");\n      address = new SocketAddress({\n        address,\n        family\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n  addRange(start, end, family = \"ipv4\") {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start, \"start\");\n      validateString(family, \"family\");\n      start = new SocketAddress({\n        address: start,\n        family\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end, \"end\");\n      validateString(family, \"family\");\n      end = new SocketAddress({\n        address: end,\n        family\n      });\n    }\n    const ret = this[kHandle].addRange(start[kSocketAddressHandle], end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE(\"start\", start, \"must come before end\");\n  }\n  addSubnet(network, prefix, family = \"ipv4\") {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network, \"network\");\n      validateString(family, \"family\");\n      network = new SocketAddress({\n        address: network,\n        family\n      });\n    }\n    switch (network.family) {\n      case \"ipv4\":\n        validateInt32(prefix, \"prefix\", 0, 32);\n        break;\n      case \"ipv6\":\n        validateInt32(prefix, \"prefix\", 0, 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle], prefix);\n  }\n  check(address, family = \"ipv4\") {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address, \"address\");\n      validateString(family, \"family\");\n      try {\n        address = new SocketAddress({\n          address,\n          family\n        });\n      } catch {\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n  get rules() {\n    return this[kHandle].getRules();\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/blocklist:InternalBlockList\"\n    };\n  }\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== void 0)\n      handle[owner_symbol] = this;\n  }\n}\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype, BlockList.prototype);\nmodule.exports = {\n  BlockList,\n  InternalBlockList\n};\n}"],["internal/buffer.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  BigInt,\n  Float32Array,\n  Float64Array,\n  MathFloor,\n  Number,\n  Uint8Array\n} = primordials;\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS,\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE\n} = require(\"internal/errors\").codes;\nconst { validateNumber } = require(\"internal/validators\");\nconst {\n  asciiSlice,\n  base64Slice,\n  base64urlSlice,\n  latin1Slice,\n  hexSlice,\n  ucs2Slice,\n  utf8Slice,\n  asciiWrite,\n  base64Write,\n  base64urlWrite,\n  latin1Write,\n  hexWrite,\n  ucs2Write,\n  utf8Write,\n  getZeroFillToggle\n} = internalBinding(\"buffer\");\nconst {\n  untransferable_object_private_symbol,\n  setHiddenValue\n} = internalBinding(\"util\");\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\nfloat32Array[0] = -1;\nconst bigEndian = uInt8Float32Array[3] === 0;\nfunction checkBounds(buf, offset, byteLength) {\n  validateNumber(offset, \"offset\");\n  if (buf[offset] === void 0 || buf[offset + byteLength] === void 0)\n    boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction checkInt(value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === \"bigint\" ? \"n\" : \"\";\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE(\"value\", range, value);\n  }\n  checkBounds(buf, offset, byteLength);\n}\nfunction boundsError(value, length, type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value, type);\n    throw new ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n  }\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n  throw new ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n  return (BigInt(val) << 32n) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n}\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n  return (BigInt(val) << 32n) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n}\nfunction readUIntLE(offset, byteLength) {\n  if (offset === void 0)\n    throw new ERR_INVALID_ARG_TYPE(\"offset\", \"number\", offset);\n  if (byteLength === 6)\n    return readUInt48LE(this, offset);\n  if (byteLength === 5)\n    return readUInt40LE(this, offset);\n  if (byteLength === 3)\n    return readUInt24LE(this, offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction readUInt48LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 6);\n  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\nfunction readUInt40LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 5);\n  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;\n}\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n}\nfunction readUInt24LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 3);\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 2);\n  return first + last * 2 ** 8;\n}\nfunction readUInt8(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const val = this[offset];\n  if (val === void 0)\n    boundsError(offset, this.length - 1);\n  return val;\n}\nfunction readUIntBE(offset, byteLength) {\n  if (offset === void 0)\n    throw new ERR_INVALID_ARG_TYPE(\"offset\", \"number\", offset);\n  if (byteLength === 6)\n    return readUInt48BE(this, offset);\n  if (byteLength === 5)\n    return readUInt40BE(this, offset);\n  if (byteLength === 3)\n    return readUInt24BE(this, offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction readUInt48BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 6);\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\nfunction readUInt40BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 5);\n  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n}\nfunction readUInt24BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 3);\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 2);\n  return first * 2 ** 8 + last;\n}\nfunction readIntLE(offset, byteLength) {\n  if (offset === void 0)\n    throw new ERR_INVALID_ARG_TYPE(\"offset\", \"number\", offset);\n  if (byteLength === 6)\n    return readInt48LE(this, offset);\n  if (byteLength === 5)\n    return readInt40LE(this, offset);\n  if (byteLength === 3)\n    return readInt24LE(this, offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction readInt48LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 6);\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;\n}\nfunction readInt40LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 5);\n  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;\n}\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);\n}\nfunction readInt24LE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 3);\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 510;\n}\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 2);\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 131070;\n}\nfunction readInt8(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const val = this[offset];\n  if (val === void 0)\n    boundsError(offset, this.length - 1);\n  return val | (val & 2 ** 7) * 33554430;\n}\nfunction readIntBE(offset, byteLength) {\n  if (offset === void 0)\n    throw new ERR_INVALID_ARG_TYPE(\"offset\", \"number\", offset);\n  if (byteLength === 6)\n    return readInt48BE(this, offset);\n  if (byteLength === 5)\n    return readInt40BE(this, offset);\n  if (byteLength === 3)\n    return readInt24BE(this, offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction readInt48BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 6);\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\nfunction readInt40BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 5);\n  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n}\nfunction readInt24BE(buf, offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, buf.length - 3);\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 510;\n}\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 2);\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 131070;\n}\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 4);\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset, \"offset\");\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === void 0 || last === void 0)\n    boundsError(offset, this.length - 8);\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\nfunction writeBigU_Int64LE(buf, value, offset, min, max) {\n  checkInt(value, min, max, buf, offset, 7);\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\nfunction writeBigUInt64LE(value, offset = 0) {\n  return writeBigU_Int64LE(this, value, offset, 0n, 0xffffffffffffffffn);\n}\nfunction writeBigU_Int64BE(buf, value, offset, min, max) {\n  checkInt(value, min, max, buf, offset, 7);\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\nfunction writeBigUInt64BE(value, offset = 0) {\n  return writeBigU_Int64BE(this, value, offset, 0n, 0xffffffffffffffffn);\n}\nfunction writeBigInt64LE(value, offset = 0) {\n  return writeBigU_Int64LE(this, value, offset, -0x8000000000000000n, 0x7fffffffffffffffn);\n}\nfunction writeBigInt64BE(value, offset = 0) {\n  return writeBigU_Int64BE(this, value, offset, -0x8000000000000000n, 0x7fffffffffffffffn);\n}\nfunction writeUIntLE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this, value, offset, 0, 281474976710655);\n  if (byteLength === 5)\n    return writeU_Int40LE(this, value, offset, 0, 1099511627775);\n  if (byteLength === 3)\n    return writeU_Int24LE(this, value, offset, 0, 16777215);\n  if (byteLength === 4)\n    return writeU_Int32LE(this, value, offset, 0, 4294967295);\n  if (byteLength === 2)\n    return writeU_Int16LE(this, value, offset, 0, 65535);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, 0, 255);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction writeU_Int48LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 5);\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = newVal >>> 8;\n  return offset;\n}\nfunction writeU_Int40LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 4);\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\nfunction writeU_Int32LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 3);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\nfunction writeUInt32LE(value, offset = 0) {\n  return writeU_Int32LE(this, value, offset, 0, 4294967295);\n}\nfunction writeU_Int24LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 2);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\nfunction writeU_Int16LE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 1);\n  buf[offset++] = value;\n  buf[offset++] = value >>> 8;\n  return offset;\n}\nfunction writeUInt16LE(value, offset = 0) {\n  return writeU_Int16LE(this, value, offset, 0, 65535);\n}\nfunction writeU_Int8(buf, value, offset, min, max) {\n  value = +value;\n  validateNumber(offset, \"offset\");\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE(\"value\", `>= ${min} and <= ${max}`, value);\n  }\n  if (buf[offset] === void 0)\n    boundsError(offset, buf.length - 1);\n  buf[offset] = value;\n  return offset + 1;\n}\nfunction writeUInt8(value, offset = 0) {\n  return writeU_Int8(this, value, offset, 0, 255);\n}\nfunction writeUIntBE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this, value, offset, 0, 281474976710655);\n  if (byteLength === 5)\n    return writeU_Int40BE(this, value, offset, 0, 1099511627775);\n  if (byteLength === 3)\n    return writeU_Int24BE(this, value, offset, 0, 16777215);\n  if (byteLength === 4)\n    return writeU_Int32BE(this, value, offset, 0, 4294967295);\n  if (byteLength === 2)\n    return writeU_Int16BE(this, value, offset, 0, 65535);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, 0, 255);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction writeU_Int48BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 5);\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = newVal >>> 8;\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\nfunction writeU_Int40BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 4);\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\nfunction writeU_Int32BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 3);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\nfunction writeUInt32BE(value, offset = 0) {\n  return writeU_Int32BE(this, value, offset, 0, 4294967295);\n}\nfunction writeU_Int24BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 2);\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\nfunction writeU_Int16BE(buf, value, offset, min, max) {\n  value = +value;\n  checkInt(value, min, max, buf, offset, 1);\n  buf[offset++] = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\nfunction writeUInt16BE(value, offset = 0) {\n  return writeU_Int16BE(this, value, offset, 0, 65535);\n}\nfunction writeIntLE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);\n  if (byteLength === 5)\n    return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);\n  if (byteLength === 3)\n    return writeU_Int24LE(this, value, offset, -8388608, 8388607);\n  if (byteLength === 4)\n    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);\n  if (byteLength === 2)\n    return writeU_Int16LE(this, value, offset, -32768, 32767);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, -128, 127);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction writeInt32LE(value, offset = 0) {\n  return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);\n}\nfunction writeInt16LE(value, offset = 0) {\n  return writeU_Int16LE(this, value, offset, -32768, 32767);\n}\nfunction writeInt8(value, offset = 0) {\n  return writeU_Int8(this, value, offset, -128, 127);\n}\nfunction writeIntBE(value, offset, byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);\n  if (byteLength === 5)\n    return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);\n  if (byteLength === 3)\n    return writeU_Int24BE(this, value, offset, -8388608, 8388607);\n  if (byteLength === 4)\n    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);\n  if (byteLength === 2)\n    return writeU_Int16BE(this, value, offset, -32768, 32767);\n  if (byteLength === 1)\n    return writeU_Int8(this, value, offset, -128, 127);\n  boundsError(byteLength, 6, \"byteLength\");\n}\nfunction writeInt32BE(value, offset = 0) {\n  return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);\n}\nfunction writeInt16BE(value, offset = 0) {\n  return writeU_Int16BE(this, value, offset, -32768, 32767);\n}\nfunction writeDoubleForwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 7);\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\nfunction writeDoubleBackwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 7);\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\nfunction writeFloatForwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 3);\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\nfunction writeFloatBackwards(val, offset = 0) {\n  val = +val;\n  checkBounds(this, offset, 3);\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\nclass FastBuffer extends Uint8Array {\n  constructor(bufferOrLength, byteOffset, length) {\n    super(bufferOrLength, byteOffset, length);\n  }\n}\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\nfunction markAsUntransferable(obj) {\n  if (typeof obj !== \"object\" && typeof obj !== \"function\" || obj === null)\n    return;\n  setHiddenValue(obj, untransferable_object_private_symbol, true);\n}\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\nmodule.exports = {\n  FastBuffer,\n  addBufferPrototypeMethods,\n  markAsUntransferable,\n  createUnsafeBuffer,\n  readUInt16BE,\n  readUInt32BE,\n  reconnectZeroFillToggle\n};\n}"],["internal/child_process.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypePush,\n  ArrayPrototypeReduce,\n  ArrayPrototypeSlice,\n  FunctionPrototype,\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  StringPrototypeSlice,\n  Symbol,\n  Uint8Array\n} = primordials;\nconst {\n  errnoException,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_HANDLE_TYPE,\n    ERR_INVALID_SYNC_FORK_INPUT,\n    ERR_IPC_CHANNEL_CLOSED,\n    ERR_IPC_DISCONNECTED,\n    ERR_IPC_ONE_PIPE,\n    ERR_IPC_SYNC_FORK,\n    ERR_MISSING_ARGS\n  }\n} = require(\"internal/errors\");\nconst {\n  validateArray,\n  validateObject,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst EventEmitter = require(\"events\");\nconst net = require(\"net\");\nconst dgram = require(\"dgram\");\nconst inspect = require(\"internal/util/inspect\").inspect;\nconst assert = require(\"internal/assert\");\nconst { Process } = internalBinding(\"process_wrap\");\nconst {\n  WriteWrap,\n  kReadBytesOrError,\n  kArrayBufferOffset,\n  kLastWriteWasAsync,\n  streamBaseState\n} = internalBinding(\"stream_wrap\");\nconst { Pipe, constants: PipeConstants } = internalBinding(\"pipe_wrap\");\nconst { TCP } = internalBinding(\"tcp_wrap\");\nconst { TTY } = internalBinding(\"tty_wrap\");\nconst { UDP } = internalBinding(\"udp_wrap\");\nconst SocketList = require(\"internal/socket_list\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst { convertToValidSignal, deprecate } = require(\"internal/util\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst spawn_sync = internalBinding(\"spawn_sync\");\nconst { kStateSymbol } = require(\"internal/dgram\");\nconst {\n  UV_EACCES,\n  UV_EAGAIN,\n  UV_EINVAL,\n  UV_EMFILE,\n  UV_ENFILE,\n  UV_ENOENT,\n  UV_ENOSYS,\n  UV_ESRCH\n} = internalBinding(\"uv\");\nconst { SocketListSend, SocketListReceive } = SocketList;\nlet freeParser;\nlet HTTPParser;\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol(\"kChannelHandle\");\nconst kIsUsedAsStdio = Symbol(\"kIsUsedAsStdio\");\nconst handleConversion = {\n  \"net.Native\": {\n    simultaneousAccepts: true,\n    send(message, handle, options) {\n      return handle;\n    },\n    got(message, handle, emit) {\n      emit(handle);\n    }\n  },\n  \"net.Server\": {\n    simultaneousAccepts: true,\n    send(message, server, options) {\n      return server._handle;\n    },\n    got(message, handle, emit) {\n      const server = new net.Server();\n      server.listen(handle, () => {\n        emit(server);\n      });\n    }\n  },\n  \"net.Socket\": {\n    send(message, socket, options) {\n      if (!socket._handle)\n        return;\n      if (socket.server) {\n        message.key = socket.server._connectionKey;\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList(\"send\", this, message.key);\n        if (firstTime)\n          socket.server._setupWorker(socketList);\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n      const handle = socket._handle;\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n        if (freeParser === void 0)\n          freeParser = require(\"_http_common\").freeParser;\n        if (HTTPParser === void 0)\n          HTTPParser = require(\"_http_common\").HTTPParser;\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser, null, socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n      return handle;\n    },\n    postSend(message, handle, options, callback, target) {\n      if (handle && !options.keepOpen) {\n        if (target) {\n          assert(!target._pendingMessage);\n          target._pendingMessage = { callback, message, handle, options, retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    },\n    got(message, handle, emit) {\n      const socket = new net.Socket({\n        handle,\n        readable: true,\n        writable: true\n      });\n      if (message.key) {\n        const socketList = getSocketList(\"got\", this, message.key);\n        socketList.add({\n          socket\n        });\n      }\n      emit(socket);\n    }\n  },\n  \"dgram.Native\": {\n    simultaneousAccepts: false,\n    send(message, handle, options) {\n      return handle;\n    },\n    got(message, handle, emit) {\n      emit(handle);\n    }\n  },\n  \"dgram.Socket\": {\n    simultaneousAccepts: false,\n    send(message, socket, options) {\n      message.dgramType = socket.type;\n      return socket[kStateSymbol].handle;\n    },\n    got(message, handle, emit) {\n      const socket = new dgram.Socket(message.dgramType);\n      socket.bind(handle, () => {\n        emit(socket);\n      });\n    }\n  }\n};\nfunction stdioStringToArray(stdio, channel) {\n  const options = [];\n  switch (stdio) {\n    case \"ignore\":\n    case \"overlapped\":\n    case \"pipe\":\n      ArrayPrototypePush(options, stdio, stdio, stdio);\n      break;\n    case \"inherit\":\n      ArrayPrototypePush(options, 0, 1, 2);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio);\n  }\n  if (channel)\n    ArrayPrototypePush(options, channel);\n  return options;\n}\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter, this);\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n  this._handle.onexit = (exitCode, signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n    this._handle.close();\n    this._handle = null;\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? \"spawn \" + this.spawnfile : \"spawn\";\n      const err = errnoException(exitCode, syscall);\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs, 1);\n      this.emit(\"error\", err);\n    } else {\n      this.emit(\"exit\", this.exitCode, this.signalCode);\n    }\n    process.nextTick(flushStdio, this);\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess, EventEmitter);\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n  if (stdio == null)\n    return;\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\nfunction createSocket(pipe, readable) {\n  return net.Socket({ handle: pipe, readable });\n}\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe)\n    return \"pipe\";\n  if (stream instanceof TTY)\n    return \"tty\";\n  if (stream instanceof TCP)\n    return \"tcp\";\n  if (stream instanceof UDP)\n    return \"udp\";\n  return false;\n}\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n  validateObject(options, \"options\");\n  let stdio = options.stdio || \"pipe\";\n  stdio = getValidStdio(stdio, false);\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n  validateOneOf(options.serialization, \"options.serialization\", [void 0, \"json\", \"advanced\"]);\n  const serialization2 = options.serialization || \"json\";\n  if (ipc !== void 0) {\n    if (options.envPairs === void 0)\n      options.envPairs = [];\n    else\n      validateArray(options.envPairs, \"options.envPairs\");\n    ArrayPrototypePush(options.envPairs, `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs, `NODE_CHANNEL_SERIALIZATION_MODE=${serialization2}`);\n  }\n  validateString(options.file, \"options.file\");\n  this.spawnfile = options.file;\n  if (options.args === void 0) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args, \"options.args\");\n    this.spawnargs = options.args;\n  }\n  const err = this._handle.spawn(options);\n  if (err === UV_EACCES || err === UV_EAGAIN || err === UV_EMFILE || err === UV_ENFILE || err === UV_ENOENT) {\n    process.nextTick(onErrorNT, this, err);\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === \"pipe\") {\n        stream.handle.close();\n      }\n    }\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err, \"spawn\");\n  } else {\n    process.nextTick(onSpawnNT, this);\n  }\n  this.pid = this._handle.pid;\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === \"ignore\")\n      continue;\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n    if (stream.type === \"wrap\") {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n    if (stream.handle) {\n      stream.socket = createSocket(this.pid !== 0 ? stream.handle : null, i > 0);\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on(\"close\", () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== void 0 ? stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== void 0 ? stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== void 0 ? stdio[2].socket : null;\n  this.stdio = [];\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio, stdio[i].socket === void 0 ? null : stdio[i].socket);\n  if (ipc !== void 0)\n    setupChannel(this, ipc, serialization2);\n  return err;\n};\nfunction onErrorNT(self, err) {\n  self._handle.onexit(err);\n}\nfunction onSpawnNT(self) {\n  self.emit(\"spawn\");\n}\nChildProcess.prototype.kill = function(sig) {\n  const signal = sig === 0 ? sig : convertToValidSignal(sig === void 0 ? \"SIGTERM\" : sig);\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      throw errnoException(err, \"kill\");\n    } else {\n      this.emit(\"error\", errnoException(err, \"kill\"));\n    }\n  }\n  return false;\n};\nChildProcess.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\nChildProcess.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n};\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n  }\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit(\"unref\");\n    }\n  }\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n  get fd() {\n    return this.#channel ? this.#channel.fd : void 0;\n  }\n}\nconst channelDeprecationMsg = \"_channel is deprecated. Use ChildProcess.channel instead.\";\nlet serialization;\nfunction setupChannel(target, channel, serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n  ObjectDefineProperty(target, \"_channel\", {\n    get: deprecate(() => {\n      return target.channel;\n    }, channelDeprecationMsg, \"DEP0129\"),\n    set: deprecate((val) => {\n      target.channel = val;\n    }, channelDeprecationMsg, \"DEP0129\"),\n    configurable: true,\n    enumerable: false\n  });\n  target._handleQueue = null;\n  target._pendingMessage = null;\n  if (serialization === void 0)\n    serialization = require(\"internal/child_process/serialization\");\n  const {\n    initMessageChannel,\n    parseChannelMessages,\n    writeChannelMessage\n  } = serialization[serializationMode];\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer, offset, nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n      for (const message of parseChannelMessages(channel, pool)) {\n        if (isInternal(message)) {\n          if (message.cmd === \"NODE_HANDLE\") {\n            handleMessage(message, pendingHandle, true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message, void 0, true);\n          }\n        } else {\n          handleMessage(message, void 0, false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n  channel.sockets = { got: {}, send: {} };\n  target.on(\"internalMessage\", function(message, handle) {\n    if (message.cmd === \"NODE_HANDLE_ACK\" || message.cmd === \"NODE_HANDLE_NACK\") {\n      if (target._pendingMessage) {\n        if (message.cmd === \"NODE_HANDLE_ACK\") {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ === MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning(\"Handle did not reach the receiving process correctly\", \"SentHandleNotReceivedWarning\");\n        }\n      }\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message, target._pendingMessage.handle, target._pendingMessage.options, target._pendingMessage.callback);\n      }\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message, args.handle, args.options, args.callback);\n      }\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n      return;\n    }\n    if (message.cmd !== \"NODE_HANDLE\")\n      return;\n    if (!handle)\n      return target._send({ cmd: \"NODE_HANDLE_NACK\" }, null, true);\n    target._send({ cmd: \"NODE_HANDLE_ACK\" }, null, true);\n    const obj = handleConversion[message.type];\n    if (process.platform === \"win32\") {\n      handle.setSimultaneousAccepts(false);\n    }\n    obj.got.call(this, message, handle, (handle2) => {\n      handleMessage(message.msg, handle2, isInternal(message.msg));\n    });\n  });\n  target.send = function(message, handle, options, callback) {\n    if (typeof handle === \"function\") {\n      callback = handle;\n      handle = void 0;\n      options = void 0;\n    } else if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    } else if (options !== void 0) {\n      validateObject(options, \"options\");\n    }\n    options = { swallowErrors: false, ...options };\n    if (this.connected) {\n      return this._send(message, handle, options, callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === \"function\") {\n      process.nextTick(callback, ex);\n    } else {\n      process.nextTick(() => this.emit(\"error\", ex));\n    }\n    return false;\n  };\n  target._send = function(message, handle, options, callback) {\n    assert(this.connected || this.channel);\n    if (message === void 0)\n      throw new ERR_MISSING_ARGS(\"message\");\n    if (typeof message !== \"string\" && typeof message !== \"object\" && typeof message !== \"number\" && typeof message !== \"boolean\") {\n      throw new ERR_INVALID_ARG_TYPE(\"message\", [\"string\", \"object\", \"number\", \"boolean\"], message);\n    }\n    if (typeof options === \"boolean\") {\n      options = { swallowErrors: options };\n    }\n    let obj;\n    if (handle) {\n      message = {\n        cmd: \"NODE_HANDLE\",\n        type: null,\n        msg: message\n      };\n      if (handle instanceof net.Socket) {\n        message.type = \"net.Socket\";\n      } else if (handle instanceof net.Server) {\n        message.type = \"net.Server\";\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = \"net.Native\";\n      } else if (handle instanceof dgram.Socket) {\n        message.type = \"dgram.Socket\";\n      } else if (handle instanceof UDP) {\n        message.type = \"dgram.Native\";\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue, {\n          callback,\n          handle,\n          options,\n          message: message.msg\n        });\n        return this._handleQueue.length === 1;\n      }\n      obj = handleConversion[message.type];\n      handle = ReflectApply(handleConversion[message.type].send, target, [message, handle, options]);\n      if (!handle)\n        message = message.msg;\n      if (obj.simultaneousAccepts && process.platform === \"win32\") {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue && !(message && (message.cmd === \"NODE_HANDLE_ACK\" || message.cmd === \"NODE_HANDLE_NACK\"))) {\n      ArrayPrototypePush(this._handleQueue, {\n        callback,\n        handle: null,\n        options,\n        message\n      });\n      return this._handleQueue.length === 1;\n    }\n    const req = new WriteWrap();\n    const err = writeChannelMessage(channel, req, message, handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message, handle, options, callback, target);\n      }\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === \"function\")\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === \"function\") {\n        process.nextTick(callback, null);\n      }\n    } else {\n      if (obj && obj.postSend)\n        obj.postSend(message, handle, options, callback);\n      if (!options.swallowErrors) {\n        const ex = errnoException(err, \"write\");\n        if (typeof callback === \"function\") {\n          process.nextTick(callback, ex);\n        } else {\n          process.nextTick(() => this.emit(\"error\", ex));\n        }\n      }\n    }\n    return channel.writeQueueSize < 65536 * 2;\n  };\n  target.connected = true;\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit(\"error\", new ERR_IPC_DISCONNECTED());\n      return;\n    }\n    this.connected = false;\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n  target._disconnect = function() {\n    assert(this.channel);\n    this.channel = null;\n    this[kChannelHandle] = null;\n    if (this._pendingMessage)\n      closePendingHandle(this);\n    let fired = false;\n    function finish() {\n      if (fired)\n        return;\n      fired = true;\n      channel.close();\n      target.emit(\"disconnect\");\n    }\n    if (channel.buffering) {\n      this.once(\"message\", finish);\n      this.once(\"internalMessage\", finish);\n      return;\n    }\n    process.nextTick(finish);\n  };\n  function emit(event, message, handle) {\n    target.emit(event, message, handle);\n  }\n  function handleMessage(message, handle, internal) {\n    if (!target.channel)\n      return;\n    const eventName = internal ? \"internalMessage\" : \"message\";\n    process.nextTick(emit, eventName, message, handle);\n  }\n  channel.readStart();\n  return control;\n}\nconst INTERNAL_PREFIX = \"NODE_\";\nfunction isInternal(message) {\n  return message !== null && typeof message === \"object\" && typeof message.cmd === \"string\" && message.cmd.length > INTERNAL_PREFIX.length && StringPrototypeSlice(message.cmd, 0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX;\n}\nconst nop = FunctionPrototype;\nfunction getValidStdio(stdio, sync) {\n  let ipc;\n  let ipcFd;\n  if (typeof stdio === \"string\") {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio);\n  }\n  while (stdio.length < 3)\n    ArrayPrototypePush(stdio, void 0);\n  stdio = ArrayPrototypeReduce(stdio, (acc, stdio2, i) => {\n    function cleanup() {\n      for (let i2 = 0; i2 < acc.length; i2++) {\n        if ((acc[i2].type === \"pipe\" || acc[i2].type === \"ipc\") && acc[i2].handle)\n          acc[i2].handle.close();\n      }\n    }\n    if (stdio2 == null) {\n      stdio2 = i < 3 ? \"pipe\" : \"ignore\";\n    }\n    if (stdio2 === \"ignore\") {\n      ArrayPrototypePush(acc, { type: \"ignore\" });\n    } else if (stdio2 === \"pipe\" || stdio2 === \"overlapped\" || typeof stdio2 === \"number\" && stdio2 < 0) {\n      const a = {\n        type: stdio2 === \"overlapped\" ? \"overlapped\" : \"pipe\",\n        readable: i === 0,\n        writable: i !== 0\n      };\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n      ArrayPrototypePush(acc, a);\n    } else if (stdio2 === \"ipc\") {\n      if (sync || ipc !== void 0) {\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n      ArrayPrototypePush(acc, {\n        type: \"pipe\",\n        handle: ipc,\n        ipc: true\n      });\n    } else if (stdio2 === \"inherit\") {\n      ArrayPrototypePush(acc, {\n        type: \"inherit\",\n        fd: i\n      });\n    } else if (typeof stdio2 === \"number\" || typeof stdio2.fd === \"number\") {\n      ArrayPrototypePush(acc, {\n        type: \"fd\",\n        fd: typeof stdio2 === \"number\" ? stdio2 : stdio2.fd\n      });\n    } else if (getHandleWrapType(stdio2) || getHandleWrapType(stdio2.handle) || getHandleWrapType(stdio2._handle)) {\n      const handle = getHandleWrapType(stdio2) ? stdio2 : getHandleWrapType(stdio2.handle) ? stdio2.handle : stdio2._handle;\n      ArrayPrototypePush(acc, {\n        type: \"wrap\",\n        wrapType: getHandleWrapType(handle),\n        handle,\n        _stdio: stdio2\n      });\n    } else if (isArrayBufferView(stdio2) || typeof stdio2 === \"string\") {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio2));\n      }\n    } else {\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE(\"stdio\", stdio2);\n    }\n    return acc;\n  }, []);\n  return { stdio, ipc, ipcFd };\n}\nfunction getSocketList(type, worker, key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === \"send\" ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker, key);\n  }\n  return socketList;\n}\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit(\"close\", subprocess.exitCode, subprocess.signalCode);\n  }\n}\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n  if (result.output && options.encoding && options.encoding !== \"buffer\") {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n  if (result.error) {\n    result.error = errnoException(result.error, \"spawnSync \" + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args, 1);\n  }\n  return result;\n}\nmodule.exports = {\n  ChildProcess,\n  kChannelHandle,\n  setupChannel,\n  getValidStdio,\n  stdioStringToArray,\n  spawnSync\n};\n}"],["internal/cli_table.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  MathCeil,\n  MathMax,\n  MathMaxApply,\n  ObjectPrototypeHasOwnProperty,\n  StringPrototypeRepeat\n} = primordials;\nconst { getStringWidth } = require(\"internal/util/inspect\");\nconst tableChars = {\n  middleMiddle: \"\\u2500\",\n  rowMiddle: \"\\u253C\",\n  topRight: \"\\u2510\",\n  topLeft: \"\\u250C\",\n  leftMiddle: \"\\u251C\",\n  topMiddle: \"\\u252C\",\n  bottomRight: \"\\u2518\",\n  bottomLeft: \"\\u2514\",\n  bottomMiddle: \"\\u2534\",\n  rightMiddle: \"\\u2524\",\n  left: \"\\u2502 \",\n  right: \" \\u2502\",\n  middle: \" \\u2502 \"\n};\nconst renderRow = (row, columnWidths) => {\n  let out = tableChars.left;\n  for (let i = 0; i < row.length; i++) {\n    const cell = row[i];\n    const len = getStringWidth(cell);\n    const needed = (columnWidths[i] - len) / 2;\n    out += StringPrototypeRepeat(\" \", needed) + cell + StringPrototypeRepeat(\" \", MathCeil(needed));\n    if (i !== row.length - 1)\n      out += tableChars.middle;\n  }\n  out += tableChars.right;\n  return out;\n};\nconst table = (head, columns) => {\n  const rows = [];\n  const columnWidths = ArrayPrototypeMap(head, (h) => getStringWidth(h));\n  const longestColumn = MathMaxApply(ArrayPrototypeMap(columns, (a) => a.length));\n  for (let i = 0; i < head.length; i++) {\n    const column = columns[i];\n    for (let j = 0; j < longestColumn; j++) {\n      if (rows[j] === void 0)\n        rows[j] = [];\n      const value = rows[j][i] = ObjectPrototypeHasOwnProperty(column, j) ? column[j] : \"\";\n      const width = columnWidths[i] || 0;\n      const counted = getStringWidth(value);\n      columnWidths[i] = MathMax(width, counted);\n    }\n  }\n  const divider = ArrayPrototypeMap(columnWidths, (i) => StringPrototypeRepeat(tableChars.middleMiddle, i + 2));\n  let result = tableChars.topLeft + ArrayPrototypeJoin(divider, tableChars.topMiddle) + tableChars.topRight + \"\\n\" + renderRow(head, columnWidths) + \"\\n\" + tableChars.leftMiddle + ArrayPrototypeJoin(divider, tableChars.rowMiddle) + tableChars.rightMiddle + \"\\n\";\n  for (const row of rows)\n    result += `${renderRow(row, columnWidths)}\n`;\n  result += tableChars.bottomLeft + ArrayPrototypeJoin(divider, tableChars.bottomMiddle) + tableChars.bottomRight;\n  return result;\n};\nmodule.exports = table;\n}"],["internal/constants.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst isWindows = process.platform === \"win32\";\nmodule.exports = {\n  CHAR_UPPERCASE_A: 65,\n  CHAR_LOWERCASE_A: 97,\n  CHAR_UPPERCASE_Z: 90,\n  CHAR_LOWERCASE_Z: 122,\n  CHAR_UPPERCASE_C: 67,\n  CHAR_LOWERCASE_B: 98,\n  CHAR_LOWERCASE_E: 101,\n  CHAR_LOWERCASE_N: 110,\n  CHAR_DOT: 46,\n  CHAR_FORWARD_SLASH: 47,\n  CHAR_BACKWARD_SLASH: 92,\n  CHAR_VERTICAL_LINE: 124,\n  CHAR_COLON: 58,\n  CHAR_QUESTION_MARK: 63,\n  CHAR_UNDERSCORE: 95,\n  CHAR_LINE_FEED: 10,\n  CHAR_CARRIAGE_RETURN: 13,\n  CHAR_TAB: 9,\n  CHAR_FORM_FEED: 12,\n  CHAR_EXCLAMATION_MARK: 33,\n  CHAR_HASH: 35,\n  CHAR_SPACE: 32,\n  CHAR_NO_BREAK_SPACE: 160,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n  CHAR_LEFT_SQUARE_BRACKET: 91,\n  CHAR_RIGHT_SQUARE_BRACKET: 93,\n  CHAR_LEFT_ANGLE_BRACKET: 60,\n  CHAR_RIGHT_ANGLE_BRACKET: 62,\n  CHAR_LEFT_CURLY_BRACKET: 123,\n  CHAR_RIGHT_CURLY_BRACKET: 125,\n  CHAR_HYPHEN_MINUS: 45,\n  CHAR_PLUS: 43,\n  CHAR_DOUBLE_QUOTE: 34,\n  CHAR_SINGLE_QUOTE: 39,\n  CHAR_PERCENT: 37,\n  CHAR_SEMICOLON: 59,\n  CHAR_CIRCUMFLEX_ACCENT: 94,\n  CHAR_GRAVE_ACCENT: 96,\n  CHAR_AT: 64,\n  CHAR_AMPERSAND: 38,\n  CHAR_EQUAL: 61,\n  CHAR_0: 48,\n  CHAR_9: 57,\n  EOL: isWindows ? \"\\r\\n\" : \"\\n\"\n};\n}"],["internal/dgram.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  Symbol\n} = primordials;\nconst { codes } = require(\"internal/errors\");\nconst { UDP } = internalBinding(\"udp_wrap\");\nconst { guessHandleType } = internalBinding(\"util\");\nconst {\n  isInt32,\n  validateFunction\n} = require(\"internal/validators\");\nconst { UV_EINVAL } = internalBinding(\"uv\");\nconst {\n  ERR_SOCKET_BAD_TYPE\n} = codes;\nconst kStateSymbol = Symbol(\"state symbol\");\nlet dns;\nfunction lookup4(lookup, address, callback) {\n  return lookup(address || \"127.0.0.1\", 4, callback);\n}\nfunction lookup6(lookup, address, callback) {\n  return lookup(address || \"::1\", 6, callback);\n}\nfunction newHandle(type, lookup) {\n  if (lookup === void 0) {\n    if (dns === void 0) {\n      dns = require(\"dns\");\n    }\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup, \"lookup\");\n  }\n  if (type === \"udp4\") {\n    const handle = new UDP();\n    handle.lookup = FunctionPrototypeBind(lookup4, handle, lookup);\n    return handle;\n  }\n  if (type === \"udp6\") {\n    const handle = new UDP();\n    handle.lookup = FunctionPrototypeBind(lookup6, handle, lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n  throw new ERR_SOCKET_BAD_TYPE();\n}\nfunction _createSocketHandle(address, port, addressType, fd, flags) {\n  const handle = newHandle(addressType);\n  let err;\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== \"UDP\") {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address, port || 0, flags);\n  }\n  if (err) {\n    handle.close();\n    return err;\n  }\n  return handle;\n}\nmodule.exports = {\n  kStateSymbol,\n  _createSocketHandle,\n  newHandle\n};\n}"],["internal/dtrace.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst config = internalBinding(\"config\");\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {\n  },\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {\n  },\n  DTRACE_HTTP_SERVER_REQUEST = () => {\n  },\n  DTRACE_HTTP_SERVER_RESPONSE = () => {\n  },\n  DTRACE_NET_SERVER_CONNECTION = () => {\n  },\n  DTRACE_NET_STREAM_END = () => {\n  }\n} = config.hasDtrace ? internalBinding(\"dtrace\") : {};\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST,\n  DTRACE_HTTP_CLIENT_RESPONSE,\n  DTRACE_HTTP_SERVER_REQUEST,\n  DTRACE_HTTP_SERVER_RESPONSE,\n  DTRACE_NET_SERVER_CONNECTION,\n  DTRACE_NET_STREAM_END\n};\n}"],["internal/encoding.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptors,\n  SafeMap,\n  StringPrototypeSlice,\n  Symbol,\n  SymbolToStringTag,\n  Uint32Array,\n  Uint8Array\n} = primordials;\nconst {\n  ERR_ENCODING_INVALID_ENCODED_DATA,\n  ERR_ENCODING_NOT_SUPPORTED,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_THIS,\n  ERR_NO_ICU\n} = require(\"internal/errors\").codes;\nconst kHandle = Symbol(\"handle\");\nconst kFlags = Symbol(\"flags\");\nconst kEncoding = Symbol(\"encoding\");\nconst kDecoder = Symbol(\"decoder\");\nconst kEncoder = Symbol(\"encoder\");\nconst {\n  getConstructorOf,\n  customInspectSymbol: inspect\n} = require(\"internal/util\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isUint8Array\n} = require(\"internal/util/types\");\nconst {\n  validateString,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  encodeInto,\n  encodeUtf8String\n} = internalBinding(\"buffer\");\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === void 0)\n    Buffer = require(\"buffer\").Buffer;\n  return Buffer;\n}\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS(\"TextEncoder\");\n}\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS(\"TextDecoder\");\n}\nconst CONVERTER_FLAGS_FLUSH = 1;\nconst CONVERTER_FLAGS_FATAL = 2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 4;\nconst empty = new Uint8Array(0);\nconst encodings = new SafeMap([\n  [\"unicode-1-1-utf-8\", \"utf-8\"],\n  [\"utf8\", \"utf-8\"],\n  [\"utf-8\", \"utf-8\"],\n  [\"866\", \"ibm866\"],\n  [\"cp866\", \"ibm866\"],\n  [\"csibm866\", \"ibm866\"],\n  [\"ibm866\", \"ibm866\"],\n  [\"csisolatin2\", \"iso-8859-2\"],\n  [\"iso-8859-2\", \"iso-8859-2\"],\n  [\"iso-ir-101\", \"iso-8859-2\"],\n  [\"iso8859-2\", \"iso-8859-2\"],\n  [\"iso88592\", \"iso-8859-2\"],\n  [\"iso_8859-2\", \"iso-8859-2\"],\n  [\"iso_8859-2:1987\", \"iso-8859-2\"],\n  [\"l2\", \"iso-8859-2\"],\n  [\"latin2\", \"iso-8859-2\"],\n  [\"csisolatin3\", \"iso-8859-3\"],\n  [\"iso-8859-3\", \"iso-8859-3\"],\n  [\"iso-ir-109\", \"iso-8859-3\"],\n  [\"iso8859-3\", \"iso-8859-3\"],\n  [\"iso88593\", \"iso-8859-3\"],\n  [\"iso_8859-3\", \"iso-8859-3\"],\n  [\"iso_8859-3:1988\", \"iso-8859-3\"],\n  [\"l3\", \"iso-8859-3\"],\n  [\"latin3\", \"iso-8859-3\"],\n  [\"csisolatin4\", \"iso-8859-4\"],\n  [\"iso-8859-4\", \"iso-8859-4\"],\n  [\"iso-ir-110\", \"iso-8859-4\"],\n  [\"iso8859-4\", \"iso-8859-4\"],\n  [\"iso88594\", \"iso-8859-4\"],\n  [\"iso_8859-4\", \"iso-8859-4\"],\n  [\"iso_8859-4:1988\", \"iso-8859-4\"],\n  [\"l4\", \"iso-8859-4\"],\n  [\"latin4\", \"iso-8859-4\"],\n  [\"csisolatincyrillic\", \"iso-8859-5\"],\n  [\"cyrillic\", \"iso-8859-5\"],\n  [\"iso-8859-5\", \"iso-8859-5\"],\n  [\"iso-ir-144\", \"iso-8859-5\"],\n  [\"iso8859-5\", \"iso-8859-5\"],\n  [\"iso88595\", \"iso-8859-5\"],\n  [\"iso_8859-5\", \"iso-8859-5\"],\n  [\"iso_8859-5:1988\", \"iso-8859-5\"],\n  [\"arabic\", \"iso-8859-6\"],\n  [\"asmo-708\", \"iso-8859-6\"],\n  [\"csiso88596e\", \"iso-8859-6\"],\n  [\"csiso88596i\", \"iso-8859-6\"],\n  [\"csisolatinarabic\", \"iso-8859-6\"],\n  [\"ecma-114\", \"iso-8859-6\"],\n  [\"iso-8859-6\", \"iso-8859-6\"],\n  [\"iso-8859-6-e\", \"iso-8859-6\"],\n  [\"iso-8859-6-i\", \"iso-8859-6\"],\n  [\"iso-ir-127\", \"iso-8859-6\"],\n  [\"iso8859-6\", \"iso-8859-6\"],\n  [\"iso88596\", \"iso-8859-6\"],\n  [\"iso_8859-6\", \"iso-8859-6\"],\n  [\"iso_8859-6:1987\", \"iso-8859-6\"],\n  [\"csisolatingreek\", \"iso-8859-7\"],\n  [\"ecma-118\", \"iso-8859-7\"],\n  [\"elot_928\", \"iso-8859-7\"],\n  [\"greek\", \"iso-8859-7\"],\n  [\"greek8\", \"iso-8859-7\"],\n  [\"iso-8859-7\", \"iso-8859-7\"],\n  [\"iso-ir-126\", \"iso-8859-7\"],\n  [\"iso8859-7\", \"iso-8859-7\"],\n  [\"iso88597\", \"iso-8859-7\"],\n  [\"iso_8859-7\", \"iso-8859-7\"],\n  [\"iso_8859-7:1987\", \"iso-8859-7\"],\n  [\"sun_eu_greek\", \"iso-8859-7\"],\n  [\"csiso88598e\", \"iso-8859-8\"],\n  [\"csisolatinhebrew\", \"iso-8859-8\"],\n  [\"hebrew\", \"iso-8859-8\"],\n  [\"iso-8859-8\", \"iso-8859-8\"],\n  [\"iso-8859-8-e\", \"iso-8859-8\"],\n  [\"iso-ir-138\", \"iso-8859-8\"],\n  [\"iso8859-8\", \"iso-8859-8\"],\n  [\"iso88598\", \"iso-8859-8\"],\n  [\"iso_8859-8\", \"iso-8859-8\"],\n  [\"iso_8859-8:1988\", \"iso-8859-8\"],\n  [\"visual\", \"iso-8859-8\"],\n  [\"csiso88598i\", \"iso-8859-8-i\"],\n  [\"iso-8859-8-i\", \"iso-8859-8-i\"],\n  [\"logical\", \"iso-8859-8-i\"],\n  [\"csisolatin6\", \"iso-8859-10\"],\n  [\"iso-8859-10\", \"iso-8859-10\"],\n  [\"iso-ir-157\", \"iso-8859-10\"],\n  [\"iso8859-10\", \"iso-8859-10\"],\n  [\"iso885910\", \"iso-8859-10\"],\n  [\"l6\", \"iso-8859-10\"],\n  [\"latin6\", \"iso-8859-10\"],\n  [\"iso-8859-13\", \"iso-8859-13\"],\n  [\"iso8859-13\", \"iso-8859-13\"],\n  [\"iso885913\", \"iso-8859-13\"],\n  [\"iso-8859-14\", \"iso-8859-14\"],\n  [\"iso8859-14\", \"iso-8859-14\"],\n  [\"iso885914\", \"iso-8859-14\"],\n  [\"csisolatin9\", \"iso-8859-15\"],\n  [\"iso-8859-15\", \"iso-8859-15\"],\n  [\"iso8859-15\", \"iso-8859-15\"],\n  [\"iso885915\", \"iso-8859-15\"],\n  [\"iso_8859-15\", \"iso-8859-15\"],\n  [\"l9\", \"iso-8859-15\"],\n  [\"cskoi8r\", \"koi8-r\"],\n  [\"koi\", \"koi8-r\"],\n  [\"koi8\", \"koi8-r\"],\n  [\"koi8-r\", \"koi8-r\"],\n  [\"koi8_r\", \"koi8-r\"],\n  [\"koi8-ru\", \"koi8-u\"],\n  [\"koi8-u\", \"koi8-u\"],\n  [\"csmacintosh\", \"macintosh\"],\n  [\"mac\", \"macintosh\"],\n  [\"macintosh\", \"macintosh\"],\n  [\"x-mac-roman\", \"macintosh\"],\n  [\"dos-874\", \"windows-874\"],\n  [\"iso-8859-11\", \"windows-874\"],\n  [\"iso8859-11\", \"windows-874\"],\n  [\"iso885911\", \"windows-874\"],\n  [\"tis-620\", \"windows-874\"],\n  [\"windows-874\", \"windows-874\"],\n  [\"cp1250\", \"windows-1250\"],\n  [\"windows-1250\", \"windows-1250\"],\n  [\"x-cp1250\", \"windows-1250\"],\n  [\"cp1251\", \"windows-1251\"],\n  [\"windows-1251\", \"windows-1251\"],\n  [\"x-cp1251\", \"windows-1251\"],\n  [\"ansi_x3.4-1968\", \"windows-1252\"],\n  [\"ascii\", \"windows-1252\"],\n  [\"cp1252\", \"windows-1252\"],\n  [\"cp819\", \"windows-1252\"],\n  [\"csisolatin1\", \"windows-1252\"],\n  [\"ibm819\", \"windows-1252\"],\n  [\"iso-8859-1\", \"windows-1252\"],\n  [\"iso-ir-100\", \"windows-1252\"],\n  [\"iso8859-1\", \"windows-1252\"],\n  [\"iso88591\", \"windows-1252\"],\n  [\"iso_8859-1\", \"windows-1252\"],\n  [\"iso_8859-1:1987\", \"windows-1252\"],\n  [\"l1\", \"windows-1252\"],\n  [\"latin1\", \"windows-1252\"],\n  [\"us-ascii\", \"windows-1252\"],\n  [\"windows-1252\", \"windows-1252\"],\n  [\"x-cp1252\", \"windows-1252\"],\n  [\"cp1253\", \"windows-1253\"],\n  [\"windows-1253\", \"windows-1253\"],\n  [\"x-cp1253\", \"windows-1253\"],\n  [\"cp1254\", \"windows-1254\"],\n  [\"csisolatin5\", \"windows-1254\"],\n  [\"iso-8859-9\", \"windows-1254\"],\n  [\"iso-ir-148\", \"windows-1254\"],\n  [\"iso8859-9\", \"windows-1254\"],\n  [\"iso88599\", \"windows-1254\"],\n  [\"iso_8859-9\", \"windows-1254\"],\n  [\"iso_8859-9:1989\", \"windows-1254\"],\n  [\"l5\", \"windows-1254\"],\n  [\"latin5\", \"windows-1254\"],\n  [\"windows-1254\", \"windows-1254\"],\n  [\"x-cp1254\", \"windows-1254\"],\n  [\"cp1255\", \"windows-1255\"],\n  [\"windows-1255\", \"windows-1255\"],\n  [\"x-cp1255\", \"windows-1255\"],\n  [\"cp1256\", \"windows-1256\"],\n  [\"windows-1256\", \"windows-1256\"],\n  [\"x-cp1256\", \"windows-1256\"],\n  [\"cp1257\", \"windows-1257\"],\n  [\"windows-1257\", \"windows-1257\"],\n  [\"x-cp1257\", \"windows-1257\"],\n  [\"cp1258\", \"windows-1258\"],\n  [\"windows-1258\", \"windows-1258\"],\n  [\"x-cp1258\", \"windows-1258\"],\n  [\"x-mac-cyrillic\", \"x-mac-cyrillic\"],\n  [\"x-mac-ukrainian\", \"x-mac-cyrillic\"],\n  [\"chinese\", \"gbk\"],\n  [\"csgb2312\", \"gbk\"],\n  [\"csiso58gb231280\", \"gbk\"],\n  [\"gb2312\", \"gbk\"],\n  [\"gb_2312\", \"gbk\"],\n  [\"gb_2312-80\", \"gbk\"],\n  [\"gbk\", \"gbk\"],\n  [\"iso-ir-58\", \"gbk\"],\n  [\"x-gbk\", \"gbk\"],\n  [\"gb18030\", \"gb18030\"],\n  [\"big5\", \"big5\"],\n  [\"big5-hkscs\", \"big5\"],\n  [\"cn-big5\", \"big5\"],\n  [\"csbig5\", \"big5\"],\n  [\"x-x-big5\", \"big5\"],\n  [\"cseucpkdfmtjapanese\", \"euc-jp\"],\n  [\"euc-jp\", \"euc-jp\"],\n  [\"x-euc-jp\", \"euc-jp\"],\n  [\"csiso2022jp\", \"iso-2022-jp\"],\n  [\"iso-2022-jp\", \"iso-2022-jp\"],\n  [\"csshiftjis\", \"shift_jis\"],\n  [\"ms932\", \"shift_jis\"],\n  [\"ms_kanji\", \"shift_jis\"],\n  [\"shift-jis\", \"shift_jis\"],\n  [\"shift_jis\", \"shift_jis\"],\n  [\"sjis\", \"shift_jis\"],\n  [\"windows-31j\", \"shift_jis\"],\n  [\"x-sjis\", \"shift_jis\"],\n  [\"cseuckr\", \"euc-kr\"],\n  [\"csksc56011987\", \"euc-kr\"],\n  [\"euc-kr\", \"euc-kr\"],\n  [\"iso-ir-149\", \"euc-kr\"],\n  [\"korean\", \"euc-kr\"],\n  [\"ks_c_5601-1987\", \"euc-kr\"],\n  [\"ks_c_5601-1989\", \"euc-kr\"],\n  [\"ksc5601\", \"euc-kr\"],\n  [\"ksc_5601\", \"euc-kr\"],\n  [\"windows-949\", \"euc-kr\"],\n  [\"utf-16be\", \"utf-16be\"],\n  [\"utf-16le\", \"utf-16le\"],\n  [\"utf-16\", \"utf-16le\"]\n]);\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (label[s] === \"\t\" || label[s] === \"\\n\" || label[s] === \"\\f\" || label[s] === \"\\r\" || label[s] === \" \")) {\n    s++;\n  }\n  while (e > s && (label[e - 1] === \"\t\" || label[e - 1] === \"\\n\" || label[e - 1] === \"\\f\" || label[e - 1] === \"\\r\" || label[e - 1] === \" \")) {\n    e--;\n  }\n  return StringPrototypeSlice(label, s, e);\n}\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== void 0)\n    return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\nconst encodeIntoResults = new Uint32Array(2);\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n  get encoding() {\n    validateEncoder(this);\n    return \"utf-8\";\n  }\n  encode(input = \"\") {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n  encodeInto(src, dest) {\n    validateEncoder(this);\n    validateString(src, \"src\");\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE(\"dest\", \"Uint8Array\", dest);\n    encodeInto(src, dest, encodeIntoResults);\n    return { read: encodeIntoResults[0], written: encodeIntoResults[1] };\n  }\n  [inspect](depth, opts) {\n    validateEncoder(this);\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\n    });\n    obj.encoding = this.encoding;\n    return require(\"internal/util/inspect\").inspect(obj, opts);\n  }\n}\nObjectDefineProperties(TextEncoder.prototype, {\n  \"encode\": { enumerable: true },\n  \"encodeInto\": { enumerable: true },\n  \"encoding\": { enumerable: true },\n  [SymbolToStringTag]: { configurable: true, value: \"TextEncoder\" }\n});\nconst TextDecoder = internalBinding(\"config\").hasIntl ? makeTextDecoderICU() : makeTextDecoderJS();\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode,\n    getConverter\n  } = internalBinding(\"icu\");\n  class TextDecoder2 {\n    constructor(encoding = \"utf-8\", options = {}) {\n      encoding = `${encoding}`;\n      validateObject(options, \"options\", {\n        nullable: true,\n        allowArray: true,\n        allowFunction: true\n      });\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === void 0)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n      const handle = getConverter(enc, flags);\n      if (handle === void 0)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n      this[kDecoder] = true;\n      this[kHandle] = handle;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n    }\n    decode(input = empty, options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (!isArrayBufferView(input)) {\n        throw new ERR_INVALID_ARG_TYPE(\"input\", [\"ArrayBuffer\", \"ArrayBufferView\"], input);\n      }\n      validateObject(options, \"options\", {\n        nullable: true,\n        allowArray: true,\n        allowFunction: true\n      });\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n      const ret = _decode(this[kHandle], input, flags);\n      if (typeof ret === \"number\") {\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding, ret);\n      }\n      return ret.toString(\"ucs2\");\n    }\n  }\n  return TextDecoder2;\n}\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === void 0)\n      ({ StringDecoder } = require(\"string_decoder\"));\n    return StringDecoder;\n  }\n  const kBOMSeen = Symbol(\"BOM seen\");\n  function hasConverter(encoding) {\n    return encoding === \"utf-8\" || encoding === \"utf-16le\";\n  }\n  class TextDecoder2 {\n    constructor(encoding = \"utf-8\", options = {}) {\n      encoding = `${encoding}`;\n      validateObject(options, \"options\", {\n        nullable: true,\n        allowArray: true,\n        allowFunction: true\n      });\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === void 0 || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('\"fatal\" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n      this[kDecoder] = true;\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n    decode(input = empty, options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (isArrayBufferView(input)) {\n        input = lazyBuffer().from(input.buffer, input.byteOffset, input.byteLength);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"input\", [\"ArrayBuffer\", \"ArrayBufferView\"], input);\n      }\n      validateObject(options, \"options\", {\n        nullable: true,\n        allowArray: true,\n        allowFunction: true\n      });\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ? this[kHandle].end(input) : this[kHandle].write(input);\n      if (result.length > 0 && !this[kBOMSeen] && !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        if (result[0] === \"\\uFEFF\") {\n          result = StringPrototypeSlice(result, 1);\n        }\n        this[kBOMSeen] = true;\n      }\n      return result;\n    }\n  }\n  return TextDecoder2;\n}\nObjectDefineProperties(TextDecoder.prototype, ObjectGetOwnPropertyDescriptors({\n  get encoding() {\n    validateDecoder(this);\n    return this[kEncoding];\n  },\n  get fatal() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n  },\n  get ignoreBOM() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) === CONVERTER_FLAGS_IGNORE_BOM;\n  },\n  [inspect](depth, opts) {\n    validateDecoder(this);\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const constructor = getConstructorOf(this) || TextDecoder;\n    const obj = ObjectCreate({ constructor });\n    obj.encoding = this.encoding;\n    obj.fatal = this.fatal;\n    obj.ignoreBOM = this.ignoreBOM;\n    if (opts.showHidden) {\n      obj[kFlags] = this[kFlags];\n      obj[kHandle] = this[kHandle];\n    }\n    const { inspect: inspect2 } = require(\"internal/util/inspect\");\n    return `${constructor.name} ${inspect2(obj)}`;\n  }\n}));\nObjectDefineProperties(TextDecoder.prototype, {\n  decode: { enumerable: true },\n  [inspect]: { enumerable: false },\n  [SymbolToStringTag]: {\n    configurable: true,\n    value: \"TextDecoder\"\n  }\n});\nmodule.exports = {\n  getEncodingFromLabel,\n  TextDecoder,\n  TextEncoder\n};\n}"],["internal/error_serdes.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst Buffer = require(\"buffer\").Buffer;\nconst {\n  ArrayPrototypeForEach,\n  Error,\n  EvalError,\n  FunctionPrototypeCall,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ObjectPrototypeToString,\n  RangeError,\n  ReferenceError,\n  SafeSet,\n  SymbolToStringTag,\n  SyntaxError,\n  TypeError,\n  URIError\n} = primordials;\nconst kSerializedError = 0;\nconst kSerializedObject = 1;\nconst kInspectedError = 2;\nconst errors = {\n  Error,\n  TypeError,\n  RangeError,\n  URIError,\n  SyntaxError,\n  ReferenceError,\n  EvalError\n};\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\nfunction TryGetAllProperties(object, target = object) {\n  const all = ObjectCreate(null);\n  if (object === null)\n    return all;\n  ObjectAssign(all, TryGetAllProperties(ObjectGetPrototypeOf(object), target));\n  const keys = ObjectGetOwnPropertyNames(object);\n  ArrayPrototypeForEach(keys, (key) => {\n    let descriptor;\n    try {\n      descriptor = ObjectGetOwnPropertyDescriptor(object, key);\n    } catch {\n      return;\n    }\n    const getter = descriptor.get;\n    if (getter && key !== \"__proto__\") {\n      try {\n        descriptor.value = FunctionPrototypeCall(getter, target);\n      } catch {\n      }\n    }\n    if (\"value\" in descriptor && typeof descriptor.value !== \"function\") {\n      delete descriptor.get;\n      delete descriptor.set;\n      all[key] = descriptor;\n    }\n  });\n  return all;\n}\nfunction GetConstructors(object) {\n  const constructors = [];\n  for (let current = object; current !== null; current = ObjectGetPrototypeOf(current)) {\n    const desc = ObjectGetOwnPropertyDescriptor(current, \"constructor\");\n    if (desc && desc.value) {\n      ObjectDefineProperty(constructors, constructors.length, {\n        value: desc.value,\n        enumerable: true\n      });\n    }\n  }\n  return constructors;\n}\nfunction GetName(object) {\n  const desc = ObjectGetOwnPropertyDescriptor(object, \"name\");\n  return desc && desc.value;\n}\nlet internalUtilInspect;\nfunction inspect(...args) {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require(\"internal/util/inspect\");\n  }\n  return internalUtilInspect.inspect(...args);\n}\nlet serialize;\nfunction serializeError(error) {\n  if (!serialize)\n    serialize = require(\"v8\").serialize;\n  try {\n    if (typeof error === \"object\" && ObjectPrototypeToString(error) === \"[object Error]\") {\n      const constructors = GetConstructors(error);\n      for (let i = 0; i < constructors.length; i++) {\n        const name = GetName(constructors[i]);\n        if (errorConstructorNames.has(name)) {\n          const serialized = serialize({\n            constructor: name,\n            properties: TryGetAllProperties(error)\n          });\n          return Buffer.concat([Buffer.from([kSerializedError]), serialized]);\n        }\n      }\n    }\n  } catch {\n  }\n  try {\n    const serialized = serialize(error);\n    return Buffer.concat([Buffer.from([kSerializedObject]), serialized]);\n  } catch {\n  }\n  return Buffer.concat([\n    Buffer.from([kInspectedError]),\n    Buffer.from(inspect(error), \"utf8\")\n  ]);\n}\nlet deserialize;\nfunction deserializeError(error) {\n  if (!deserialize)\n    deserialize = require(\"v8\").deserialize;\n  switch (error[0]) {\n    case kSerializedError:\n      const { constructor, properties } = deserialize(error.subarray(1));\n      const ctor = errors[constructor];\n      ObjectDefineProperty(properties, SymbolToStringTag, {\n        value: { value: \"Error\", configurable: true },\n        enumerable: true\n      });\n      return ObjectCreate(ctor.prototype, properties);\n    case kSerializedObject:\n      return deserialize(error.subarray(1));\n    case kInspectedError:\n      const buf = Buffer.from(error.buffer, error.byteOffset + 1, error.byteLength - 1);\n      return buf.toString(\"utf8\");\n  }\n  require(\"assert\").fail(\"This should not happen\");\n}\nmodule.exports = { serializeError, deserializeError };\n}"],["internal/errors.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  AggregateError,\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Error,\n  ErrorCaptureStackTrace,\n  ErrorPrototypeToString,\n  JSONStringify,\n  MapPrototypeGet,\n  MathAbs,\n  MathMax,\n  Number,\n  NumberIsInteger,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectIsExtensible,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  RangeError,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  SafeMap,\n  SafeWeakMap,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolFor,\n  SyntaxError,\n  TypeError,\n  URIError\n} = primordials;\nconst kIsNodeError = Symbol(\"kIsNodeError\");\nconst isWindows = process.platform === \"win32\";\nconst messages = new SafeMap();\nconst codes = {};\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\nconst kTypes = [\n  \"string\",\n  \"function\",\n  \"number\",\n  \"object\",\n  \"Function\",\n  \"Object\",\n  \"boolean\",\n  \"bigint\",\n  \"symbol\"\n];\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol(\"kNoOverride\");\nlet userStackTraceLimit;\nconst nodeInternalPrefix = \"__node_internal_\";\nconst prepareStackTrace = (globalThis, error, trace) => {\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error, trace);\n  }\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame, nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn, nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace, 0, l + 1);\n        break;\n      }\n    }\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace, userStackTraceLimit);\n  }\n  const globalOverride = maybeOverridePrepareStackTrace(globalThis, error, trace);\n  if (globalOverride !== kNoOverride)\n    return globalOverride;\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\n    at ${ArrayPrototypeJoin(trace, \"\\n    at \")}`;\n};\nconst maybeOverridePrepareStackTrace = (globalThis, error, trace) => {\n  if (typeof globalThis.Error?.prepareStackTrace === \"function\") {\n    return globalThis.Error.prepareStackTrace(error, trace);\n  }\n  if (typeof MainContextError.prepareStackTrace === \"function\") {\n    return MainContextError.prepareStackTrace(error, trace);\n  }\n  return kNoOverride;\n};\nconst aggregateTwoErrors = hideStackFrames((innerError, outerError) => {\n  if (innerError && outerError && innerError !== outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      ArrayPrototypePush(outerError.errors, innerError);\n      return outerError;\n    }\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError,\n      innerError\n    ]), outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\nlet util;\nlet assert;\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require(\"internal/util\");\n  }\n  return internalUtil;\n}\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require(\"internal/util/inspect\");\n  }\n  return internalUtilInspect;\n}\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === void 0)\n    buffer = require(\"buffer\").Buffer;\n  return buffer;\n}\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n  if (desc === void 0) {\n    return ObjectIsExtensible(Error);\n  }\n  return ObjectPrototypeHasOwnProperty(desc, \"writable\") ? desc.writable : desc.set !== void 0;\n}\nclass SystemError extends Error {\n  constructor(key, context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = 0;\n    super();\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = limit;\n    const prefix = getMessage(key, [], this);\n    let message = `${prefix}: ${context.syscall} returned ${context.code} (${context.message})`;\n    if (context.path !== void 0)\n      message += ` ${context.path}`;\n    if (context.dest !== void 0)\n      message += ` => ${context.dest}`;\n    captureLargerStackTrace(this);\n    this.code = key;\n    ObjectDefineProperties(this, {\n      [kIsNodeError]: {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: true\n      },\n      name: {\n        value: \"SystemError\",\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      message: {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      info: {\n        value: context,\n        enumerable: true,\n        configurable: true,\n        writable: false\n      },\n      errno: {\n        get() {\n          return context.errno;\n        },\n        set: (value) => {\n          context.errno = value;\n        },\n        enumerable: true,\n        configurable: true\n      },\n      syscall: {\n        get() {\n          return context.syscall;\n        },\n        set: (value) => {\n          context.syscall = value;\n        },\n        enumerable: true,\n        configurable: true\n      }\n    });\n    if (context.path !== void 0) {\n      ObjectDefineProperty(this, \"path\", {\n        get() {\n          return context.path != null ? context.path.toString() : context.path;\n        },\n        set: (value) => {\n          context.path = value ? lazyBuffer().from(value.toString()) : void 0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n    if (context.dest !== void 0) {\n      ObjectDefineProperty(this, \"dest\", {\n        get() {\n          return context.dest != null ? context.dest.toString() : context.dest;\n        },\n        set: (value) => {\n          context.dest = value ? lazyBuffer().from(value.toString()) : void 0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n  [SymbolFor(\"nodejs.util.inspect.custom\")](recurseTimes, ctx) {\n    return lazyInternalUtilInspect().inspect(this, {\n      ...ctx,\n      getters: true,\n      customInspect: false\n    });\n  }\n}\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key, ctx);\n    }\n  };\n}\nfunction makeNodeErrorWithCode(Base, key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = 0;\n    const error = new Base();\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = limit;\n    const message = getMessage(key, args, error);\n    ObjectDefineProperties(error, {\n      [kIsNodeError]: {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: true\n      },\n      message: {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      toString: {\n        value() {\n          return `${this.name} [${key}]: ${this.message}`;\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    captureLargerStackTrace(error);\n    error.code = key;\n    return error;\n  };\n}\nfunction hideStackFrames(fn) {\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn, \"name\", { value: hidden });\n  return fn;\n}\nfunction E(sym, val, def, ...otherClasses) {\n  messages.set(sym, val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def, sym);\n  }\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);\n    });\n  }\n  codes[sym] = def;\n}\nfunction getMessage(key, args, self) {\n  const msg = messages.get(key);\n  if (assert === void 0)\n    assert = require(\"internal/assert\");\n  if (typeof msg === \"function\") {\n    assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`);\n    return ReflectApply(msg, self, args);\n  }\n  const expectedLength = (StringPrototypeMatch(msg, /%[dfijoOs]/g) || []).length;\n  assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`);\n  if (args.length === 0)\n    return msg;\n  ArrayPrototypeUnshift(args, msg);\n  return ReflectApply(lazyInternalUtilInspect().format, null, args);\n}\nlet uvBinding;\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding(\"uv\");\n  }\n  return uvBinding;\n}\nconst uvUnmappedError = [\"UNKNOWN\", \"unknown error\"];\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return MapPrototypeGet(uvBinding.errmap, name);\n}\nconst captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace2(err) {\n  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n  if (stackTraceLimitIsWritable) {\n    userStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = Infinity;\n  }\n  ErrorCaptureStackTrace(err);\n  if (stackTraceLimitIsWritable)\n    Error.stackTraceLimit = userStackTraceLimit;\n  return err;\n});\nconst uvException = hideStackFrames(function uvException2(ctx) {\n  const { 0: code, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpLimit;\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === \"message\" || prop === \"path\" || prop === \"dest\") {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n  return captureLargerStackTrace(err);\n});\nconst uvExceptionWithHostPort = hideStackFrames(function uvExceptionWithHostPort2(err, syscall, address, port) {\n  const { 0: code, 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n  const message = `${syscall} ${code}: ${uvmsg}`;\n  let details = \"\";\n  if (port && port > 0) {\n    details = ` ${address}:${port}`;\n  } else if (address) {\n    details = ` ${address}`;\n  }\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const ex = new Error(`${message}${details}`);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpLimit;\n  ex.code = code;\n  ex.errno = err;\n  ex.syscall = syscall;\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  return captureLargerStackTrace(ex);\n});\nconst errnoException = hideStackFrames(function errnoException2(err, syscall, original) {\n  if (util === void 0)\n    util = require(\"util\");\n  const code = util.getSystemErrorName(err);\n  const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpLimit;\n  ex.errno = err;\n  ex.code = code;\n  ex.syscall = syscall;\n  return captureLargerStackTrace(ex);\n});\nconst exceptionWithHostPort = hideStackFrames(function exceptionWithHostPort2(err, syscall, address, port, additional) {\n  if (util === void 0)\n    util = require(\"util\");\n  const code = util.getSystemErrorName(err);\n  let details = \"\";\n  if (port && port > 0) {\n    details = ` ${address}:${port}`;\n  } else if (address) {\n    details = ` ${address}`;\n  }\n  if (additional) {\n    details += ` - Local (${additional})`;\n  }\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const ex = new Error(`${syscall} ${code}${details}`);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpLimit;\n  ex.errno = err;\n  ex.code = code;\n  ex.syscall = syscall;\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  return captureLargerStackTrace(ex);\n});\nconst dnsException = hideStackFrames(function(code, syscall, hostname) {\n  let errno;\n  if (typeof code === \"number\") {\n    errno = code;\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = \"ENOTFOUND\";\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : \"\"}`;\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n  return captureLargerStackTrace(ex);\n});\nfunction connResetException(msg) {\n  const ex = new Error(msg);\n  ex.code = \"ECONNRESET\";\n  return ex;\n}\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === void 0) {\n    try {\n      let overflowStack = function() {\n        overflowStack();\n      };\n      overflowStack();\n    } catch (err2) {\n      maxStack_ErrorMessage = err2.message;\n      maxStack_ErrorName = err2.name;\n    }\n  }\n  return err && err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;\n}\nfunction addNumericalSeparator(val) {\n  let res = \"\";\n  let i = val.length;\n  const start = val[0] === \"-\" ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val, i - 3, i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val, 0, i)}${res}`;\n}\nconst kEnhanceStackBeforeInspector = Symbol(\"kEnhanceStackBeforeInspector\");\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== \"function\") {\n      return error.stack;\n    }\n    try {\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n    }\n    return error.stack;\n  },\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    if (process.platform === \"win32\") {\n      const info = internalBinding(\"os\").getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2], \".\"), Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect,\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors && (internalBinding(\"util\").guessHandleType(2) === \"TTY\" && require(\"internal/tty\").hasColors() || defaultColors);\n    try {\n      return inspect(error, {\n        colors,\n        customInspect: false,\n        depth: MathMax(inspect.defaultOptions.depth, 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\nlet _kArrowMessagePrivateSymbol, _setHiddenValue;\nfunction setArrowMessage(err, arrowMessage) {\n  if (!_kArrowMessagePrivateSymbol) {\n    ({\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol,\n      setHiddenValue: _setHiddenValue\n    } = internalBinding(\"util\"));\n  }\n  _setHiddenValue(err, _kArrowMessagePrivateSymbol, arrowMessage);\n}\nfunction hideInternalStackFrames(error) {\n  overrideStackTrace.set(error, (error2, stackFrames) => {\n    let frames = stackFrames;\n    if (typeof stackFrames === \"object\") {\n      frames = ArrayPrototypeFilter(stackFrames, (frm) => !StringPrototypeStartsWith(frm.getFileName() || \"\", \"node:internal\"));\n    }\n    ArrayPrototypeUnshift(frames, error2);\n    return ArrayPrototypeJoin(frames, \"\\n    at \");\n  });\n}\nclass AbortError extends Error {\n  constructor() {\n    super(\"The operation was aborted\");\n    this.code = \"ABORT_ERR\";\n    this.name = \"AbortError\";\n  }\n}\nmodule.exports = {\n  aggregateTwoErrors,\n  codes,\n  dnsException,\n  errnoException,\n  exceptionWithHostPort,\n  getMessage,\n  hideStackFrames,\n  hideInternalStackFrames,\n  isErrorStackTraceLimitWritable,\n  isStackOverflowError,\n  setArrowMessage,\n  connResetException,\n  uvErrmapGet,\n  uvException,\n  uvExceptionWithHostPort,\n  SystemError,\n  AbortError,\n  E,\n  kNoOverride,\n  prepareStackTrace,\n  maybeOverridePrepareStackTrace,\n  overrideStackTrace,\n  kEnhanceStackBeforeInspector,\n  fatalExceptionStackEnhancers,\n  kIsNodeError,\n  captureLargerStackTrace\n};\nE(\"ERR_AMBIGUOUS_ARGUMENT\", 'The \"%s\" argument is ambiguous. %s', TypeError);\nE(\"ERR_ARG_NOT_ITERABLE\", \"%s must be iterable\", TypeError);\nE(\"ERR_ASSERTION\", \"%s\", Error);\nE(\"ERR_ASYNC_CALLBACK\", \"%s must be a function\", TypeError);\nE(\"ERR_ASYNC_TYPE\", 'Invalid name for async \"type\": %s', TypeError);\nE(\"ERR_BROTLI_INVALID_PARAM\", \"%s is not a valid Brotli parameter\", RangeError);\nE(\"ERR_BUFFER_OUT_OF_BOUNDS\", (name = void 0) => {\n  if (name) {\n    return `\"${name}\" is outside of buffer bounds`;\n  }\n  return \"Attempt to access memory outside buffer bounds\";\n}, RangeError);\nE(\"ERR_BUFFER_TOO_LARGE\", \"Cannot create a Buffer larger than %s bytes\", RangeError);\nE(\"ERR_CANNOT_WATCH_SIGINT\", \"Cannot watch for SIGINT signals\", Error);\nE(\"ERR_CHILD_CLOSED_BEFORE_REPLY\", \"Child closed before reply received\", Error);\nE(\"ERR_CHILD_PROCESS_IPC_REQUIRED\", \"Forked processes must have an IPC channel, missing value 'ipc' in %s\", Error);\nE(\"ERR_CHILD_PROCESS_STDIO_MAXBUFFER\", \"%s maxBuffer length exceeded\", RangeError);\nE(\"ERR_CONSOLE_WRITABLE_STREAM\", \"Console expects a writable stream instance for %s\", TypeError);\nE(\"ERR_CONTEXT_NOT_INITIALIZED\", \"context used is not initialized\", Error);\nE(\"ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED\", \"Custom engines not supported by this OpenSSL\", Error);\nE(\"ERR_CRYPTO_ECDH_INVALID_FORMAT\", \"Invalid ECDH format: %s\", TypeError);\nE(\"ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY\", \"Public key is not valid for specified curve\", Error);\nE(\"ERR_CRYPTO_ENGINE_UNKNOWN\", 'Engine \"%s\" was not found', Error);\nE(\"ERR_CRYPTO_FIPS_FORCED\", \"Cannot set FIPS mode, it was forced with --force-fips at startup.\", Error);\nE(\"ERR_CRYPTO_FIPS_UNAVAILABLE\", \"Cannot set FIPS mode in a non-FIPS build.\", Error);\nE(\"ERR_CRYPTO_HASH_FINALIZED\", \"Digest already called\", Error);\nE(\"ERR_CRYPTO_HASH_UPDATE_FAILED\", \"Hash update failed\", Error);\nE(\"ERR_CRYPTO_INCOMPATIBLE_KEY\", \"Incompatible %s: %s\", Error);\nE(\"ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS\", \"The selected key encoding %s %s.\", Error);\nE(\"ERR_CRYPTO_INVALID_DIGEST\", \"Invalid digest: %s\", TypeError);\nE(\"ERR_CRYPTO_INVALID_JWK\", \"Invalid JWK data\", TypeError);\nE(\"ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE\", \"Invalid key object type %s, expected %s.\", TypeError);\nE(\"ERR_CRYPTO_INVALID_STATE\", \"Invalid state for operation %s\", Error);\nE(\"ERR_CRYPTO_PBKDF2_ERROR\", \"PBKDF2 error\", Error);\nE(\"ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\", \"Invalid scrypt parameter\", Error);\nE(\"ERR_CRYPTO_SCRYPT_NOT_SUPPORTED\", \"Scrypt algorithm not supported\", Error);\nE(\"ERR_CRYPTO_SIGN_KEY_REQUIRED\", \"No key provided to sign\", Error);\nE(\"ERR_DEBUGGER_ERROR\", \"%s\", Error);\nE(\"ERR_DEBUGGER_STARTUP_ERROR\", \"%s\", Error);\nE(\"ERR_DIR_CLOSED\", \"Directory handle was closed\", Error);\nE(\"ERR_DIR_CONCURRENT_OPERATION\", \"Cannot do synchronous work on directory handle with concurrent asynchronous operations\", Error);\nE(\"ERR_DNS_SET_SERVERS_FAILED\", 'c-ares failed to set servers: \"%s\" [%s]', Error);\nE(\"ERR_DOMAIN_CALLBACK_NOT_AVAILABLE\", \"A callback was registered through process.setUncaughtExceptionCaptureCallback(), which is mutually exclusive with using the `domain` module\", Error);\nE(\"ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE\", \"The `domain` module is in use, which is mutually exclusive with calling process.setUncaughtExceptionCaptureCallback()\", Error);\nE(\"ERR_ENCODING_INVALID_ENCODED_DATA\", function(encoding, ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}, TypeError);\nE(\"ERR_ENCODING_NOT_SUPPORTED\", 'The \"%s\" encoding is not supported', RangeError);\nE(\"ERR_EVAL_ESM_CANNOT_PRINT\", \"--print cannot be used with ESM input\", Error);\nE(\"ERR_EVENT_RECURSION\", 'The event \"%s\" is already being dispatched', Error);\nE(\"ERR_FALSY_VALUE_REJECTION\", function(reason) {\n  this.reason = reason;\n  return \"Promise was rejected with falsy value\";\n}, Error);\nE(\"ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\", \"The feature %s is unavailable on the current platform, which is being used to run Node.js\", TypeError);\nE(\"ERR_FS_CP_DIR_TO_NON_DIR\", \"Cannot overwrite directory with non-directory\", SystemError);\nE(\"ERR_FS_CP_EEXIST\", \"Target already exists\", SystemError);\nE(\"ERR_FS_CP_EINVAL\", \"Invalid src or dest\", SystemError);\nE(\"ERR_FS_CP_FIFO_PIPE\", \"Cannot copy a FIFO pipe\", SystemError);\nE(\"ERR_FS_CP_NON_DIR_TO_DIR\", \"Cannot overwrite non-directory with directory\", SystemError);\nE(\"ERR_FS_CP_SOCKET\", \"Cannot copy a socket file\", SystemError);\nE(\"ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY\", \"Cannot overwrite symlink in subdirectory of self\", SystemError);\nE(\"ERR_FS_CP_UNKNOWN\", \"Cannot copy an unknown file type\", SystemError);\nE(\"ERR_FS_EISDIR\", \"Path is a directory\", SystemError);\nE(\"ERR_FS_FILE_TOO_LARGE\", \"File size (%s) is greater than 2 GB\", RangeError);\nE(\"ERR_FS_INVALID_SYMLINK_TYPE\", 'Symlink type must be one of \"dir\", \"file\", or \"junction\". Received \"%s\"', Error);\nE(\"ERR_HTTP2_ALTSVC_INVALID_ORIGIN\", \"HTTP/2 ALTSVC frames require a valid origin\", TypeError);\nE(\"ERR_HTTP2_ALTSVC_LENGTH\", \"HTTP/2 ALTSVC frames are limited to 16382 bytes\", TypeError);\nE(\"ERR_HTTP2_CONNECT_AUTHORITY\", \":authority header is required for CONNECT requests\", Error);\nE(\"ERR_HTTP2_CONNECT_PATH\", \"The :path header is forbidden for CONNECT requests\", Error);\nE(\"ERR_HTTP2_CONNECT_SCHEME\", \"The :scheme header is forbidden for CONNECT requests\", Error);\nE(\"ERR_HTTP2_GOAWAY_SESSION\", \"New streams cannot be created after receiving a GOAWAY\", Error);\nE(\"ERR_HTTP2_HEADERS_AFTER_RESPOND\", \"Cannot specify additional headers after response initiated\", Error);\nE(\"ERR_HTTP2_HEADERS_SENT\", \"Response has already been initiated.\", Error);\nE(\"ERR_HTTP2_HEADER_SINGLE_VALUE\", 'Header field \"%s\" must only have a single value', TypeError);\nE(\"ERR_HTTP2_INFO_STATUS_NOT_ALLOWED\", \"Informational status codes cannot be used\", RangeError);\nE(\"ERR_HTTP2_INVALID_CONNECTION_HEADERS\", 'HTTP/1 Connection specific headers are forbidden: \"%s\"', TypeError);\nE(\"ERR_HTTP2_INVALID_HEADER_VALUE\", 'Invalid value \"%s\" for header \"%s\"', TypeError);\nE(\"ERR_HTTP2_INVALID_INFO_STATUS\", \"Invalid informational status code: %s\", RangeError);\nE(\"ERR_HTTP2_INVALID_ORIGIN\", \"HTTP/2 ORIGIN frames require a valid origin\", TypeError);\nE(\"ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH\", \"Packed settings length must be a multiple of six\", RangeError);\nE(\"ERR_HTTP2_INVALID_PSEUDOHEADER\", '\"%s\" is an invalid pseudoheader or is used incorrectly', TypeError);\nE(\"ERR_HTTP2_INVALID_SESSION\", \"The session has been destroyed\", Error);\nE(\"ERR_HTTP2_INVALID_SETTING_VALUE\", function(name, actual, min = void 0, max = void 0) {\n  this.actual = actual;\n  if (min !== void 0) {\n    this.min = min;\n    this.max = max;\n  }\n  return `Invalid value for setting \"${name}\": ${actual}`;\n}, TypeError, RangeError);\nE(\"ERR_HTTP2_INVALID_STREAM\", \"The stream has been destroyed\", Error);\nE(\"ERR_HTTP2_MAX_PENDING_SETTINGS_ACK\", \"Maximum number of pending settings acknowledgements\", Error);\nE(\"ERR_HTTP2_NESTED_PUSH\", \"A push stream cannot initiate another push stream.\", Error);\nE(\"ERR_HTTP2_NO_MEM\", \"Out of memory\", Error);\nE(\"ERR_HTTP2_NO_SOCKET_MANIPULATION\", \"HTTP/2 sockets should not be directly manipulated (e.g. read and written)\", Error);\nE(\"ERR_HTTP2_ORIGIN_LENGTH\", \"HTTP/2 ORIGIN frames are limited to 16382 bytes\", TypeError);\nE(\"ERR_HTTP2_OUT_OF_STREAMS\", \"No stream ID is available because maximum stream ID has been reached\", Error);\nE(\"ERR_HTTP2_PAYLOAD_FORBIDDEN\", \"Responses with %s status must not have a payload\", Error);\nE(\"ERR_HTTP2_PING_CANCEL\", \"HTTP2 ping cancelled\", Error);\nE(\"ERR_HTTP2_PING_LENGTH\", \"HTTP2 ping payload must be 8 bytes\", RangeError);\nE(\"ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED\", \"Cannot set HTTP/2 pseudo-headers\", TypeError);\nE(\"ERR_HTTP2_PUSH_DISABLED\", \"HTTP/2 client has disabled push streams\", Error);\nE(\"ERR_HTTP2_SEND_FILE\", \"Directories cannot be sent\", Error);\nE(\"ERR_HTTP2_SEND_FILE_NOSEEK\", \"Offset or length can only be specified for regular files\", Error);\nE(\"ERR_HTTP2_SESSION_ERROR\", \"Session closed with error code %s\", Error);\nE(\"ERR_HTTP2_SETTINGS_CANCEL\", \"HTTP2 session settings canceled\", Error);\nE(\"ERR_HTTP2_SOCKET_BOUND\", \"The socket is already bound to an Http2Session\", Error);\nE(\"ERR_HTTP2_SOCKET_UNBOUND\", \"The socket has been disconnected from the Http2Session\", Error);\nE(\"ERR_HTTP2_STATUS_101\", \"HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2\", Error);\nE(\"ERR_HTTP2_STATUS_INVALID\", \"Invalid status code: %s\", RangeError);\nE(\"ERR_HTTP2_STREAM_CANCEL\", function(error) {\n  let msg = \"The pending stream has been canceled\";\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === \"string\")\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}, Error);\nE(\"ERR_HTTP2_STREAM_ERROR\", \"Stream closed with error code %s\", Error);\nE(\"ERR_HTTP2_STREAM_SELF_DEPENDENCY\", \"A stream cannot depend on itself\", Error);\nE(\"ERR_HTTP2_TOO_MANY_INVALID_FRAMES\", \"Too many invalid HTTP/2 frames\", Error);\nE(\"ERR_HTTP2_TRAILERS_ALREADY_SENT\", \"Trailing headers have already been sent\", Error);\nE(\"ERR_HTTP2_TRAILERS_NOT_READY\", \"Trailing headers cannot be sent until after the wantTrailers event is emitted\", Error);\nE(\"ERR_HTTP2_UNSUPPORTED_PROTOCOL\", 'protocol \"%s\" is unsupported.', Error);\nE(\"ERR_HTTP_HEADERS_SENT\", \"Cannot %s headers after they are sent to the client\", Error);\nE(\"ERR_HTTP_INVALID_HEADER_VALUE\", 'Invalid value \"%s\" for header \"%s\"', TypeError);\nE(\"ERR_HTTP_INVALID_STATUS_CODE\", \"Invalid status code: %s\", RangeError);\nE(\"ERR_HTTP_REQUEST_TIMEOUT\", \"Request timeout\", Error);\nE(\"ERR_HTTP_SOCKET_ENCODING\", \"Changing the socket encoding is not allowed per RFC7230 Section 3.\", Error);\nE(\"ERR_HTTP_TRAILER_INVALID\", \"Trailers are invalid with this transfer encoding\", Error);\nE(\"ERR_ILLEGAL_CONSTRUCTOR\", \"Illegal constructor\", TypeError);\nE(\"ERR_INCOMPATIBLE_OPTION_PAIR\", 'Option \"%s\" cannot be used in combination with option \"%s\"', TypeError);\nE(\"ERR_INPUT_TYPE_NOT_ALLOWED\", \"--input-type can only be used with string input via --eval, --print, or STDIN\", Error);\nE(\"ERR_INSPECTOR_ALREADY_ACTIVATED\", \"Inspector is already activated. Close it with inspector.close() before activating it again.\", Error);\nE(\"ERR_INSPECTOR_ALREADY_CONNECTED\", \"%s is already connected\", Error);\nE(\"ERR_INSPECTOR_CLOSED\", \"Session was closed\", Error);\nE(\"ERR_INSPECTOR_COMMAND\", \"Inspector error %d: %s\", Error);\nE(\"ERR_INSPECTOR_NOT_ACTIVE\", \"Inspector is not active\", Error);\nE(\"ERR_INSPECTOR_NOT_AVAILABLE\", \"Inspector is not available\", Error);\nE(\"ERR_INSPECTOR_NOT_CONNECTED\", \"Session is not connected\", Error);\nE(\"ERR_INSPECTOR_NOT_WORKER\", \"Current thread is not a worker\", Error);\nE(\"ERR_INTERNAL_ASSERTION\", (message) => {\n  const suffix = \"This is caused by either a bug in Node.js or incorrect usage of Node.js internals.\\nPlease open an issue with this stack trace at https://github.com/nodejs/node/issues\\n\";\n  return message === void 0 ? suffix : `${message}\n${suffix}`;\n}, Error);\nE(\"ERR_INVALID_ADDRESS_FAMILY\", function(addressType, host, port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}, RangeError);\nE(\"ERR_INVALID_ARG_TYPE\", (name, expected, actual) => {\n  assert(typeof name === \"string\", \"'name' must be a string\");\n  if (!ArrayIsArray(expected)) {\n    expected = [expected];\n  }\n  let msg = \"The \";\n  if (StringPrototypeEndsWith(name, \" argument\")) {\n    msg += `${name} `;\n  } else {\n    const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n    msg += `\"${name}\" ${type} `;\n  }\n  msg += \"must be \";\n  const types = [];\n  const instances = [];\n  const other = [];\n  for (const value of expected) {\n    assert(typeof value === \"string\", \"All expected entries have to be of type string\");\n    if (ArrayPrototypeIncludes(kTypes, value)) {\n      ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n    } else if (RegExpPrototypeTest(classRegExp, value)) {\n      ArrayPrototypePush(instances, value);\n    } else {\n      assert(value !== \"object\", 'The value \"object\" should be written as \"Object\"');\n      ArrayPrototypePush(other, value);\n    }\n  }\n  if (instances.length > 0) {\n    const pos = ArrayPrototypeIndexOf(types, \"object\");\n    if (pos !== -1) {\n      ArrayPrototypeSplice(types, pos, 1);\n      ArrayPrototypePush(instances, \"Object\");\n    }\n  }\n  if (types.length > 0) {\n    if (types.length > 2) {\n      const last = ArrayPrototypePop(types);\n      msg += `one of type ${ArrayPrototypeJoin(types, \", \")}, or ${last}`;\n    } else if (types.length === 2) {\n      msg += `one of type ${types[0]} or ${types[1]}`;\n    } else {\n      msg += `of type ${types[0]}`;\n    }\n    if (instances.length > 0 || other.length > 0)\n      msg += \" or \";\n  }\n  if (instances.length > 0) {\n    if (instances.length > 2) {\n      const last = ArrayPrototypePop(instances);\n      msg += `an instance of ${ArrayPrototypeJoin(instances, \", \")}, or ${last}`;\n    } else {\n      msg += `an instance of ${instances[0]}`;\n      if (instances.length === 2) {\n        msg += ` or ${instances[1]}`;\n      }\n    }\n    if (other.length > 0)\n      msg += \" or \";\n  }\n  if (other.length > 0) {\n    if (other.length > 2) {\n      const last = ArrayPrototypePop(other);\n      msg += `one of ${ArrayPrototypeJoin(other, \", \")}, or ${last}`;\n    } else if (other.length === 2) {\n      msg += `one of ${other[0]} or ${other[1]}`;\n    } else {\n      if (StringPrototypeToLowerCase(other[0]) !== other[0])\n        msg += \"an \";\n      msg += `${other[0]}`;\n    }\n  }\n  if (actual == null) {\n    msg += `. Received ${actual}`;\n  } else if (typeof actual === \"function\" && actual.name) {\n    msg += `. Received function ${actual.name}`;\n  } else if (typeof actual === \"object\") {\n    if (actual.constructor && actual.constructor.name) {\n      msg += `. Received an instance of ${actual.constructor.name}`;\n    } else {\n      const inspected = lazyInternalUtilInspect().inspect(actual, { depth: -1 });\n      msg += `. Received ${inspected}`;\n    }\n  } else {\n    let inspected = lazyInternalUtilInspect().inspect(actual, { colors: false });\n    if (inspected.length > 25)\n      inspected = `${StringPrototypeSlice(inspected, 0, 25)}...`;\n    msg += `. Received type ${typeof actual} (${inspected})`;\n  }\n  return msg;\n}, TypeError);\nE(\"ERR_INVALID_ARG_VALUE\", (name, value, reason = \"is invalid\") => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected, 0, 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name, \".\") ? \"property\" : \"argument\";\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}, TypeError, RangeError);\nE(\"ERR_INVALID_ASYNC_ID\", \"Invalid %s value: %s\", RangeError);\nE(\"ERR_INVALID_BUFFER_SIZE\", \"Buffer size must be a multiple of %s\", RangeError);\nE(\"ERR_INVALID_CALLBACK\", \"Callback must be a function. Received %O\", TypeError);\nE(\"ERR_INVALID_CHAR\", (name, field = void 0) => {\n  let msg = `Invalid character in ${name}`;\n  if (field !== void 0) {\n    msg += ` [\"${field}\"]`;\n  }\n  return msg;\n}, TypeError);\nE(\"ERR_INVALID_CURSOR_POS\", \"Cannot set cursor row without setting its column\", TypeError);\nE(\"ERR_INVALID_FD\", '\"fd\" must be a positive integer: %s', RangeError);\nE(\"ERR_INVALID_FD_TYPE\", \"Unsupported fd type: %s\", TypeError);\nE(\"ERR_INVALID_FILE_URL_HOST\", 'File URL host must be \"localhost\" or empty on %s', TypeError);\nE(\"ERR_INVALID_FILE_URL_PATH\", \"File URL path %s\", TypeError);\nE(\"ERR_INVALID_HANDLE_TYPE\", \"This handle type cannot be sent\", TypeError);\nE(\"ERR_INVALID_HTTP_TOKEN\", '%s must be a valid HTTP token [\"%s\"]', TypeError);\nE(\"ERR_INVALID_IP_ADDRESS\", \"Invalid IP address: %s\", TypeError);\nE(\"ERR_INVALID_MODULE_SPECIFIER\", (request, reason, base = void 0) => {\n  return `Invalid module \"${request}\" ${reason}${base ? ` imported from ${base}` : \"\"}`;\n}, TypeError);\nE(\"ERR_INVALID_PACKAGE_CONFIG\", (path, base, message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` : \"\"}${message ? `. ${message}` : \"\"}`;\n}, Error);\nE(\"ERR_INVALID_PACKAGE_TARGET\", (pkgPath, key, target, isImport = false, base = void 0) => {\n  const relError = typeof target === \"string\" && !isImport && target.length && !StringPrototypeStartsWith(target, \"./\");\n  if (key === \".\") {\n    assert(isImport === false);\n    return `Invalid \"exports\" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}${relError ? '; targets must start with \"./\"' : \"\"}`;\n  }\n  return `Invalid \"${isImport ? \"imports\" : \"exports\"}\" target ${JSONStringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}${relError ? '; targets must start with \"./\"' : \"\"}`;\n}, Error);\nE(\"ERR_INVALID_PROTOCOL\", 'Protocol \"%s\" not supported. Expected \"%s\"', TypeError);\nE(\"ERR_INVALID_REPL_EVAL_CONFIG\", 'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL', TypeError);\nE(\"ERR_INVALID_REPL_INPUT\", \"%s\", TypeError);\nE(\"ERR_INVALID_RETURN_PROPERTY\", (input, name, prop, value) => {\n  return `Expected a valid ${input} to be returned for the \"${prop}\" from the \"${name}\" function but got ${value}.`;\n}, TypeError);\nE(\"ERR_INVALID_RETURN_PROPERTY_VALUE\", (input, name, prop, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the \"${prop}\" from the \"${name}\" function but got ${type}.`;\n}, TypeError);\nE(\"ERR_INVALID_RETURN_VALUE\", (input, name, value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the \"${name}\" function but got ${type}.`;\n}, TypeError, RangeError);\nE(\"ERR_INVALID_STATE\", \"Invalid state: %s\", Error, TypeError, RangeError);\nE(\"ERR_INVALID_SYNC_FORK_INPUT\", \"Asynchronous forks do not support Buffer, TypedArray, DataView or string input: %s\", TypeError);\nE(\"ERR_INVALID_THIS\", 'Value of \"this\" must be of type %s', TypeError);\nE(\"ERR_INVALID_TUPLE\", \"%s must be an iterable %s tuple\", TypeError);\nE(\"ERR_INVALID_URI\", \"URI malformed\", URIError);\nE(\"ERR_INVALID_URL\", function(input) {\n  this.input = input;\n  return \"Invalid URL\";\n}, TypeError);\nE(\"ERR_INVALID_URL_SCHEME\", (expected) => {\n  if (typeof expected === \"string\")\n    expected = [expected];\n  assert(expected.length <= 2);\n  const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;\n  return `The URL must be ${res}`;\n}, TypeError);\nE(\"ERR_IPC_CHANNEL_CLOSED\", \"Channel closed\", Error);\nE(\"ERR_IPC_DISCONNECTED\", \"IPC channel is already disconnected\", Error);\nE(\"ERR_IPC_ONE_PIPE\", \"Child process can have only one IPC pipe\", Error);\nE(\"ERR_IPC_SYNC_FORK\", \"IPC cannot be used with synchronous forks\", Error);\nE(\"ERR_MANIFEST_ASSERT_INTEGRITY\", (moduleURL, realIntegrities) => {\n  let msg = `The content of \"${moduleURL}\" does not match the expected integrity.`;\n  if (realIntegrities.size) {\n    const sri = ArrayPrototypeJoin(ArrayFrom(realIntegrities.entries(), ({ 0: alg, 1: dgs }) => `${alg}-${dgs}`), \" \");\n    msg += ` Integrities found are: ${sri}`;\n  } else {\n    msg += \" The resource was not found in the policy.\";\n  }\n  return msg;\n}, Error);\nE(\"ERR_MANIFEST_DEPENDENCY_MISSING\", \"Manifest resource %s does not list %s as a dependency specifier for conditions: %s\", Error);\nE(\"ERR_MANIFEST_INTEGRITY_MISMATCH\", \"Manifest resource %s has multiple entries but integrity lists do not match\", SyntaxError);\nE(\"ERR_MANIFEST_INVALID_RESOURCE_FIELD\", \"Manifest resource %s has invalid property value for %s\", TypeError);\nE(\"ERR_MANIFEST_INVALID_SPECIFIER\", \"Manifest resource %s has invalid dependency mapping %s\", TypeError);\nE(\"ERR_MANIFEST_TDZ\", \"Manifest initialization has not yet run\", Error);\nE(\"ERR_MANIFEST_UNKNOWN_ONERROR\", 'Manifest specified unknown error behavior \"%s\".', SyntaxError);\nE(\"ERR_METHOD_NOT_IMPLEMENTED\", \"The %s method is not implemented\", Error);\nE(\"ERR_MISSING_ARGS\", (...args) => {\n  assert(args.length > 0, \"At least one arg needs to be specified\");\n  let msg = \"The \";\n  const len = args.length;\n  const wrap = (a) => `\"${a}\"`;\n  args = ArrayPrototypeMap(args, (a) => ArrayIsArray(a) ? ArrayPrototypeJoin(ArrayPrototypeMap(a, wrap), \" or \") : wrap(a));\n  switch (len) {\n    case 1:\n      msg += `${args[0]} argument`;\n      break;\n    case 2:\n      msg += `${args[0]} and ${args[1]} arguments`;\n      break;\n    default:\n      msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args, 0, len - 1), \", \");\n      msg += `, and ${args[len - 1]} arguments`;\n      break;\n  }\n  return `${msg} must be specified`;\n}, TypeError);\nE(\"ERR_MISSING_OPTION\", \"%s is required\", TypeError);\nE(\"ERR_MODULE_NOT_FOUND\", (path, base, type = \"package\") => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}, Error);\nE(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\", Error);\nE(\"ERR_NAPI_CONS_FUNCTION\", \"Constructor must be a function\", TypeError);\nE(\"ERR_NAPI_INVALID_DATAVIEW_ARGS\", \"byte_offset + byte_length should be less than or equal to the size in bytes of the array passed in\", RangeError);\nE(\"ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT\", \"start offset of %s should be a multiple of %s\", RangeError);\nE(\"ERR_NAPI_INVALID_TYPEDARRAY_LENGTH\", \"Invalid typed array length\", RangeError);\nE(\"ERR_NO_CRYPTO\", \"Node.js is not compiled with OpenSSL crypto support\", Error);\nE(\"ERR_NO_ICU\", \"%s is not supported on Node.js compiled without ICU\", TypeError);\nE(\"ERR_OPERATION_FAILED\", \"Operation failed: %s\", Error, TypeError);\nE(\"ERR_OUT_OF_RANGE\", (str, range, input, replaceDefaultBoolean = false) => {\n  assert(range, 'Missing \"range\" argument');\n  let msg = replaceDefaultBoolean ? str : `The value of \"${str}\" is out of range.`;\n  let received;\n  if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n    received = addNumericalSeparator(String(input));\n  } else if (typeof input === \"bigint\") {\n    received = String(input);\n    if (input > 2n ** 32n || input < -(2n ** 32n)) {\n      received = addNumericalSeparator(received);\n    }\n    received += \"n\";\n  } else {\n    received = lazyInternalUtilInspect().inspect(input);\n  }\n  msg += ` It must be ${range}. Received ${received}`;\n  return msg;\n}, RangeError);\nE(\"ERR_PACKAGE_IMPORT_NOT_DEFINED\", (specifier, packagePath, base) => {\n  return `Package import specifier \"${specifier}\" is not defined${packagePath ? ` in package ${packagePath}package.json` : \"\"} imported from ${base}`;\n}, TypeError);\nE(\"ERR_PACKAGE_PATH_NOT_EXPORTED\", (pkgPath, subpath, base = void 0) => {\n  if (subpath === \".\")\n    return `No \"exports\" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}`;\n  return `Package subpath '${subpath}' is not defined by \"exports\" in ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}`;\n}, Error);\nE(\"ERR_PERFORMANCE_INVALID_TIMESTAMP\", \"%d is not a valid timestamp\", TypeError);\nE(\"ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS\", \"%s\", TypeError);\nE(\"ERR_REQUIRE_ESM\", function(filename, hasEsmSyntax, parentPath = null, packageJsonPath = null) {\n  hideInternalStackFrames(this);\n  let msg = `require() of ES Module ${filename}${parentPath ? ` from ${parentPath}` : \"\"} not supported.`;\n  if (!packageJsonPath) {\n    if (StringPrototypeEndsWith(filename, \".mjs\"))\n      msg += `\nInstead change the require of ${filename} to a dynamic import() which is available in all CommonJS modules.`;\n    return msg;\n  }\n  const path = require(\"path\");\n  const basename = path.basename(filename) === path.basename(parentPath) ? filename : path.basename(filename);\n  if (hasEsmSyntax) {\n    msg += `\nInstead change the require of ${basename} in ${parentPath} to a dynamic import() which is available in all CommonJS modules.`;\n    return msg;\n  }\n  msg += `\n${basename} is treated as an ES module file as it is a .js file whose nearest parent package.json contains \"type\": \"module\" which declares all .js files in that package scope as ES modules.\nInstead rename ${basename} to end in .cjs, change the requiring code to use dynamic import() which is available in all CommonJS modules, or change \"type\": \"module\" to \"type\": \"commonjs\" in ${packageJsonPath} to treat all .js files as CommonJS (using .mjs for all ES modules instead).\n`;\n  return msg;\n}, Error);\nE(\"ERR_SCRIPT_EXECUTION_INTERRUPTED\", \"Script execution was interrupted by `SIGINT`\", Error);\nE(\"ERR_SERVER_ALREADY_LISTEN\", \"Listen method has been called more than once without closing.\", Error);\nE(\"ERR_SERVER_NOT_RUNNING\", \"Server is not running.\", Error);\nE(\"ERR_SOCKET_ALREADY_BOUND\", \"Socket is already bound\", Error);\nE(\"ERR_SOCKET_BAD_BUFFER_SIZE\", \"Buffer size must be a positive integer\", TypeError);\nE(\"ERR_SOCKET_BAD_PORT\", (name, port, allowZero = true) => {\n  assert(typeof allowZero === \"boolean\", \"The 'allowZero' argument must be of type boolean.\");\n  const operator = allowZero ? \">=\" : \">\";\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}, RangeError);\nE(\"ERR_SOCKET_BAD_TYPE\", \"Bad socket type specified. Valid types are: udp4, udp6\", TypeError);\nE(\"ERR_SOCKET_BUFFER_SIZE\", \"Could not get or set buffer size\", SystemError);\nE(\"ERR_SOCKET_CLOSED\", \"Socket is closed\", Error);\nE(\"ERR_SOCKET_DGRAM_IS_CONNECTED\", \"Already connected\", Error);\nE(\"ERR_SOCKET_DGRAM_NOT_CONNECTED\", \"Not connected\", Error);\nE(\"ERR_SOCKET_DGRAM_NOT_RUNNING\", \"Not running\", Error);\nE(\"ERR_SRI_PARSE\", \"Subresource Integrity string %j had an unexpected %j at position %d\", SyntaxError);\nE(\"ERR_STREAM_ALREADY_FINISHED\", \"Cannot call %s after a stream was finished\", Error);\nE(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\", Error);\nE(\"ERR_STREAM_DESTROYED\", \"Cannot call %s after a stream was destroyed\", Error);\nE(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\nE(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\", Error);\nE(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\", Error);\nE(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\", Error);\nE(\"ERR_STREAM_WRAP\", \"Stream has StringDecoder set or is in objectMode\", Error);\nE(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\", Error);\nE(\"ERR_SYNTHETIC\", \"JavaScript Callstack\", Error);\nE(\"ERR_SYSTEM_ERROR\", \"A system error occurred\", SystemError);\nE(\"ERR_TLS_CERT_ALTNAME_INVALID\", function(reason, host, cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}, Error);\nE(\"ERR_TLS_DH_PARAM_SIZE\", \"DH parameter size %s is less than 2048\", Error);\nE(\"ERR_TLS_HANDSHAKE_TIMEOUT\", \"TLS handshake timeout\", Error);\nE(\"ERR_TLS_INVALID_CONTEXT\", \"%s must be a SecureContext\", TypeError);\nE(\"ERR_TLS_INVALID_PROTOCOL_VERSION\", \"%j is not a valid %s TLS protocol version\", TypeError);\nE(\"ERR_TLS_INVALID_STATE\", \"TLS socket connection must be securely established\", Error);\nE(\"ERR_TLS_PROTOCOL_VERSION_CONFLICT\", \"TLS protocol version %j conflicts with secureProtocol %j\", TypeError);\nE(\"ERR_TLS_RENEGOTIATION_DISABLED\", \"TLS session renegotiation disabled for this socket\", Error);\nE(\"ERR_TLS_REQUIRED_SERVER_NAME\", '\"servername\" is required parameter for Server.addContext', Error);\nE(\"ERR_TLS_SESSION_ATTACK\", \"TLS session renegotiation attack detected\", Error);\nE(\"ERR_TLS_SNI_FROM_SERVER\", \"Cannot issue SNI from a TLS server-side socket\", Error);\nE(\"ERR_TRACE_EVENTS_CATEGORY_REQUIRED\", \"At least one category is required\", TypeError);\nE(\"ERR_TRACE_EVENTS_UNAVAILABLE\", \"Trace events are unavailable\", Error);\nE(\"ERR_TTY_INIT_FAILED\", \"TTY initialization failed\", SystemError);\nE(\"ERR_UNAVAILABLE_DURING_EXIT\", \"Cannot call function in process exit handler\", Error);\nE(\"ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET\", \"`process.setupUncaughtExceptionCapture()` was called while a capture callback was already active\", Error);\nE(\"ERR_UNESCAPED_CHARACTERS\", \"%s contains unescaped characters\", TypeError);\nE(\"ERR_UNHANDLED_ERROR\", (err = void 0) => {\n  const msg = \"Unhandled error.\";\n  if (err === void 0)\n    return msg;\n  return `${msg} (${err})`;\n}, Error);\nE(\"ERR_UNKNOWN_BUILTIN_MODULE\", \"No such built-in module: %s\", Error);\nE(\"ERR_UNKNOWN_CREDENTIAL\", \"%s identifier does not exist: %s\", Error);\nE(\"ERR_UNKNOWN_ENCODING\", \"Unknown encoding: %s\", TypeError);\nE(\"ERR_UNKNOWN_FILE_EXTENSION\", 'Unknown file extension \"%s\" for %s', TypeError);\nE(\"ERR_UNKNOWN_MODULE_FORMAT\", \"Unknown module format: %s\", RangeError);\nE(\"ERR_UNKNOWN_SIGNAL\", \"Unknown signal: %s\", TypeError);\nE(\"ERR_UNSUPPORTED_DIR_IMPORT\", \"Directory import '%s' is not supported resolving ES modules imported from %s\", Error);\nE(\"ERR_UNSUPPORTED_ESM_URL_SCHEME\", (url) => {\n  let msg = \"Only file and data URLs are supported by the default ESM loader\";\n  if (isWindows && url.protocol.length === 2) {\n    msg += \". On Windows, absolute paths must be valid file:// URLs\";\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}, Error);\nE(\"ERR_VALID_PERFORMANCE_ENTRY_TYPE\", \"At least one valid performance entry type is required\", Error);\nE(\"ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\", \"A dynamic import callback was not specified.\", TypeError);\nE(\"ERR_VM_MODULE_ALREADY_LINKED\", \"Module has already been linked\", Error);\nE(\"ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\", \"Cached data cannot be created for a module which has been evaluated\", Error);\nE(\"ERR_VM_MODULE_DIFFERENT_CONTEXT\", \"Linked modules must use the same context\", Error);\nE(\"ERR_VM_MODULE_LINKING_ERRORED\", \"Linking has already failed for the provided module\", Error);\nE(\"ERR_VM_MODULE_NOT_MODULE\", \"Provided module is not an instance of Module\", Error);\nE(\"ERR_VM_MODULE_STATUS\", \"Module status %s\", Error);\nE(\"ERR_WASI_ALREADY_STARTED\", \"WASI instance has already started\", Error);\nE(\"ERR_WORKER_INIT_FAILED\", \"Worker initialization failure: %s\", Error);\nE(\"ERR_WORKER_INVALID_EXEC_ARGV\", (errors, msg = \"invalid execArgv flags\") => `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors, \", \")}`, Error);\nE(\"ERR_WORKER_NOT_RUNNING\", \"Worker instance not running\", Error);\nE(\"ERR_WORKER_OUT_OF_MEMORY\", \"Worker terminated due to reaching memory limit: %s\", Error);\nE(\"ERR_WORKER_PATH\", (filename) => \"The worker script or module filename must be an absolute path or a relative path starting with './' or '../'.\" + (StringPrototypeStartsWith(filename, \"file://\") ? \" Wrap file:// URLs with `new URL`.\" : \"\") + (StringPrototypeStartsWith(filename, \"data:text/javascript\") ? \" Wrap data: URLs with `new URL`.\" : \"\") + ` Received \"${filename}\"`, TypeError);\nE(\"ERR_WORKER_UNSERIALIZABLE_ERROR\", \"Serializing an uncaught exception failed\", Error);\nE(\"ERR_WORKER_UNSUPPORTED_OPERATION\", \"%s is not supported in workers\", TypeError);\nE(\"ERR_ZLIB_INITIALIZATION_FAILED\", \"Initialization failed\", Error);\n}"],["internal/event_target.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  Boolean,\n  Error,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  NumberIsInteger,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyDescriptors,\n  ReflectApply,\n  SafeArrayIterator,\n  SafeFinalizationRegistry,\n  SafeMap,\n  SafeWeakMap,\n  SafeWeakRef,\n  SafeWeakSet,\n  String,\n  Symbol,\n  SymbolFor,\n  SymbolToStringTag\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_EVENT_RECURSION,\n    ERR_MISSING_ARGS,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst { validateObject, validateString } = require(\"internal/validators\");\nconst { customInspectSymbol } = require(\"internal/util\");\nconst { inspect } = require(\"util\");\nconst kIsEventTarget = SymbolFor(\"nodejs.event_target\");\nconst kIsNodeEventTarget = Symbol(\"kIsNodeEventTarget\");\nconst EventEmitter = require(\"events\");\nconst {\n  kMaxEventTargetListeners,\n  kMaxEventTargetListenersWarned\n} = EventEmitter;\nconst kEvents = Symbol(\"kEvents\");\nconst kIsBeingDispatched = Symbol(\"kIsBeingDispatched\");\nconst kStop = Symbol(\"kStop\");\nconst kTarget = Symbol(\"kTarget\");\nconst kHandlers = Symbol(\"khandlers\");\nconst kWeakHandler = Symbol(\"kWeak\");\nconst kHybridDispatch = SymbolFor(\"nodejs.internal.kHybridDispatch\");\nconst kCreateEvent = Symbol(\"kCreateEvent\");\nconst kNewListener = Symbol(\"kNewListener\");\nconst kRemoveListener = Symbol(\"kRemoveListener\");\nconst kIsNodeStyleListener = Symbol(\"kIsNodeStyleListener\");\nconst kTrustEvent = Symbol(\"kTrustEvent\");\nconst { now } = require(\"internal/perf/utils\");\nconst kType = Symbol(\"type\");\nconst kDefaultPrevented = Symbol(\"defaultPrevented\");\nconst kCancelable = Symbol(\"cancelable\");\nconst kTimestamp = Symbol(\"timestamp\");\nconst kBubbles = Symbol(\"bubbles\");\nconst kComposed = Symbol(\"composed\");\nconst kPropagationStopped = Symbol(\"propagationStopped\");\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}, \"isTrusted\").get;\nfunction isEvent(value) {\n  return typeof value?.[kType] === \"string\";\n}\nclass Event {\n  constructor(type, options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS(\"type\");\n    validateObject(options, \"options\", {\n      allowArray: true,\n      allowFunction: true,\n      nullable: true\n    });\n    const { cancelable, bubbles, composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n    ObjectDefineProperty(this, \"isTrusted\", {\n      get: isTrusted,\n      enumerable: true,\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n  [customInspectSymbol](depth, options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n    const opts = ObjectAssign({}, options, {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n    return `${name} ${inspect({\n      type: this[kType],\n      defaultPrevented: this[kDefaultPrevented],\n      cancelable: this[kCancelable],\n      timeStamp: this[kTimestamp]\n    }, opts)}`;\n  }\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    this[kStop] = true;\n  }\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    this[kDefaultPrevented] = true;\n  }\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kTarget];\n  }\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kTarget];\n  }\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kTarget];\n  }\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kType];\n  }\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kCancelable];\n  }\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kTimestamp];\n  }\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return !this.defaultPrevented;\n  }\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kBubbles];\n  }\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kComposed];\n  }\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    return this[kPropagationStopped];\n  }\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS(\"Event\");\n    this[kPropagationStopped] = true;\n  }\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nObjectDefineProperties(Event.prototype, {\n  [SymbolToStringTag]: {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: \"Event\"\n  },\n  stopImmediatePropagation: kEnumerableProperty,\n  preventDefault: kEnumerableProperty,\n  target: kEnumerableProperty,\n  currentTarget: kEnumerableProperty,\n  srcElement: kEnumerableProperty,\n  type: kEnumerableProperty,\n  cancelable: kEnumerableProperty,\n  defaultPrevented: kEnumerableProperty,\n  timeStamp: kEnumerableProperty,\n  composedPath: kEnumerableProperty,\n  returnValue: kEnumerableProperty,\n  bubbles: kEnumerableProperty,\n  composed: kEnumerableProperty,\n  eventPhase: kEnumerableProperty,\n  cancelBubble: kEnumerableProperty,\n  stopPropagation: kEnumerableProperty\n});\nclass NodeCustomEvent extends Event {\n  constructor(type, options) {\n    super(type, options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\nlet weakListenersState = null;\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry((listener) => listener.remove());\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState, map: objectToWeakListenerMap };\n}\nclass Listener {\n  constructor(previous, listener, once, capture, passive, isNodeStyleListener, weak) {\n    this.next = void 0;\n    if (previous !== void 0)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak);\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener, this, this);\n      weakListeners().map.set(weak, listener);\n      this.listener = this.callback;\n    } else if (typeof listener === \"function\") {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent, listener);\n      this.listener = listener;\n    }\n  }\n  same(listener, capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n  remove() {\n    if (this.previous !== void 0)\n      this.previous.next = this.next;\n    if (this.next !== void 0)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\nclass EventTarget {\n  static [kIsEventTarget] = true;\n  constructor() {\n    initEventTarget(this);\n  }\n  [kNewListener](size, type, listener, once, capture, passive) {\n    if (this[kMaxEventTargetListeners] > 0 && size > this[kMaxEventTargetListeners] && !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      const w = new Error(`Possible EventTarget memory leak detected. ${size} ${type} listeners added to ${inspect(this, { depth: -1 })}. Use events.setMaxListeners() to increase limit`);\n      w.name = \"MaxListenersExceededWarning\";\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size, type, listener, capture) {\n  }\n  addEventListener(type, listener, options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS(\"EventTarget\");\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS(\"type\", \"listener\");\n    const {\n      once,\n      capture,\n      passive,\n      signal,\n      isNodeStyleListener,\n      weak\n    } = validateEventListenerOptions(options);\n    if (!shouldAddListener(listener)) {\n      const w = new Error(`addEventListener called with ${listener} which has no effect.`);\n      w.name = \"AddEventListenerArgumentTypeWarning\";\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      signal.addEventListener(\"abort\", () => {\n        this.removeEventListener(type, listener, options);\n      }, { once: true, [kWeakHandler]: this });\n    }\n    let root = this[kEvents].get(type);\n    if (root === void 0) {\n      root = { size: 1, next: void 0 };\n      new Listener(root, listener, once, capture, passive, isNodeStyleListener, weak);\n      this[kNewListener](root.size, type, listener, once, capture, passive);\n      this[kEvents].set(type, root);\n      return;\n    }\n    let handler = root.next;\n    let previous = root;\n    while (handler !== void 0 && !handler.same(listener, capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n    if (handler !== void 0) {\n      return;\n    }\n    new Listener(previous, listener, once, capture, passive, isNodeStyleListener, weak);\n    root.size++;\n    this[kNewListener](root.size, type, listener, once, capture, passive);\n  }\n  removeEventListener(type, listener, options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS(\"EventTarget\");\n    if (!shouldAddListener(listener))\n      return;\n    type = String(type);\n    const capture = options?.capture === true;\n    const root = this[kEvents].get(type);\n    if (root === void 0 || root.next === void 0)\n      return;\n    let handler = root.next;\n    while (handler !== void 0) {\n      if (handler.same(listener, capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size, type, listener, capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS(\"EventTarget\");\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE(\"event\", \"Event\", event);\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n    this[kHybridDispatch](event, event.type, event);\n    return event.defaultPrevented !== true;\n  }\n  [kHybridDispatch](nodeValue, type, event) {\n    const createEvent = () => {\n      if (event === void 0) {\n        event = this[kCreateEvent](nodeValue, type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== void 0) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n    const root = this[kEvents].get(type);\n    if (root === void 0 || root.next === void 0)\n      return true;\n    let handler = root.next;\n    let next;\n    while (handler !== void 0 && (handler.passive || event?.[kStop] !== true)) {\n      next = handler.next;\n      if (handler.removed) {\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener, capture } = handler;\n        this[kRemoveListener](root.size, type, listener, capture);\n      }\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ? handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback, this, arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== void 0 && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n      handler = next;\n    }\n    if (event !== void 0)\n      event[kIsBeingDispatched] = false;\n  }\n  [kCreateEvent](nodeValue, type) {\n    return new NodeCustomEvent(type, { detail: nodeValue });\n  }\n  [customInspectSymbol](depth, options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS(\"EventTarget\");\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n    const opts = ObjectAssign({}, options, {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n    return `${name} ${inspect({}, opts)}`;\n  }\n}\nObjectDefineProperties(EventTarget.prototype, {\n  addEventListener: kEnumerableProperty,\n  removeEventListener: kEnumerableProperty,\n  dispatchEvent: kEnumerableProperty,\n  [SymbolToStringTag]: {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: \"EventTarget\"\n  }\n});\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    EventEmitter.setMaxListeners(n, this);\n  }\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    return this[kMaxEventTargetListeners];\n  }\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    return ArrayFrom(this[kEvents].keys());\n  }\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    const root = this[kEvents].get(String(type));\n    return root !== void 0 ? root.size : 0;\n  }\n  off(type, listener, options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    this.removeEventListener(type, listener, options);\n    return this;\n  }\n  removeListener(type, listener, options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    this.removeEventListener(type, listener, options);\n    return this;\n  }\n  on(type, listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    this.addEventListener(type, listener, { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  addListener(type, listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    this.addEventListener(type, listener, { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  emit(type, arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    validateString(type, \"type\");\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg, type);\n    return hadListeners;\n  }\n  once(type, listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    this.addEventListener(type, listener, { once: true, [kIsNodeStyleListener]: true });\n    return this;\n  }\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS(\"NodeEventTarget\");\n    if (type !== void 0) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n    return this;\n  }\n}\nObjectDefineProperties(NodeEventTarget.prototype, {\n  setMaxListeners: kEnumerableProperty,\n  getMaxListeners: kEnumerableProperty,\n  eventNames: kEnumerableProperty,\n  listenerCount: kEnumerableProperty,\n  off: kEnumerableProperty,\n  removeListener: kEnumerableProperty,\n  on: kEnumerableProperty,\n  addListener: kEnumerableProperty,\n  once: kEnumerableProperty,\n  emit: kEnumerableProperty,\n  removeAllListeners: kEnumerableProperty\n});\nfunction shouldAddListener(listener) {\n  if (typeof listener === \"function\" || typeof listener?.handleEvent === \"function\") {\n    return true;\n  }\n  if (listener == null)\n    return false;\n  throw new ERR_INVALID_ARG_TYPE(\"listener\", \"EventListener\", listener);\n}\nfunction validateEventListenerOptions(options) {\n  if (typeof options === \"boolean\")\n    return { capture: options };\n  if (options === null)\n    return {};\n  validateObject(options, \"options\", {\n    allowArray: true,\n    allowFunction: true\n  });\n  return {\n    once: Boolean(options.once),\n    capture: Boolean(options.capture),\n    passive: Boolean(options.passive),\n    signal: options.signal,\n    weak: options[kWeakHandler],\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === \"function\") {\n    FunctionPrototypeCall(then, promise, void 0, function(err) {\n      emitUncaughtException(err);\n    });\n  }\n}\nfunction emitUncaughtException(err) {\n  process.nextTick(() => {\n    throw err;\n  });\n}\nfunction makeEventHandler(handler) {\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== \"function\") {\n      return;\n    }\n    return ReflectApply(eventHandler.handler, this, args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\nfunction defineEventHandler(emitter, name) {\n  ObjectDefineProperty(emitter, `on${name}`, {\n    get() {\n      return this[kHandlers]?.get(name)?.handler;\n    },\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === \"function\") {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size, name, wrappedHandler.handler, false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === \"function\") {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size, name, value, false, false, false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name, wrappedHandler);\n      }\n      this[kHandlers].set(name, wrappedHandler);\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter, this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype, protoProps);\n  return MixedEventEmitter;\n};\nmodule.exports = {\n  Event,\n  EventEmitterMixin,\n  EventTarget,\n  NodeEventTarget,\n  defineEventHandler,\n  initEventTarget,\n  initNodeEventTarget,\n  kCreateEvent,\n  kNewListener,\n  kTrustEvent,\n  kRemoveListener,\n  kEvents,\n  kWeakHandler,\n  isEventTarget\n};\n}"],["internal/fixed_queue.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array\n} = primordials;\nconst kSize = 2048;\nconst kMask = kSize - 1;\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n  isFull() {\n    return (this.top + 1 & kMask) === this.bottom;\n  }\n  push(data) {\n    this.list[this.top] = data;\n    this.top = this.top + 1 & kMask;\n  }\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === void 0)\n      return null;\n    this.list[this.bottom] = void 0;\n    this.bottom = this.bottom + 1 & kMask;\n    return nextItem;\n  }\n}\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n  push(data) {\n    if (this.head.isFull()) {\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n}"],["internal/freelist.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ReflectApply\n} = primordials;\nclass FreeList {\n  constructor(name, max, ctor) {\n    this.name = name;\n    this.ctor = ctor;\n    this.max = max;\n    this.list = [];\n  }\n  alloc() {\n    return this.list.length > 0 ? this.list.pop() : ReflectApply(this.ctor, this, arguments);\n  }\n  free(obj) {\n    if (this.list.length < this.max) {\n      this.list.push(obj);\n      return true;\n    }\n    return false;\n  }\n}\nmodule.exports = FreeList;\n}"],["internal/freeze_intrinsics.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  AggregateError,\n  AggregateErrorPrototype,\n  Array,\n  ArrayBuffer,\n  ArrayBufferPrototype,\n  ArrayIteratorPrototype,\n  ArrayPrototype,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  BigInt,\n  BigInt64Array,\n  BigInt64ArrayPrototype,\n  BigIntPrototype,\n  BigUint64Array,\n  BigUint64ArrayPrototype,\n  Boolean,\n  BooleanPrototype,\n  DataView,\n  DataViewPrototype,\n  Date,\n  DatePrototype,\n  Error,\n  ErrorPrototype,\n  EvalError,\n  EvalErrorPrototype,\n  FinalizationRegistry,\n  FinalizationRegistryPrototype,\n  Float32Array,\n  Float32ArrayPrototype,\n  Float64Array,\n  Float64ArrayPrototype,\n  Function,\n  FunctionPrototype,\n  Int16Array,\n  Int16ArrayPrototype,\n  Int32Array,\n  Int32ArrayPrototype,\n  Int8Array,\n  Int8ArrayPrototype,\n  Map,\n  MapPrototype,\n  Number,\n  NumberPrototype,\n  Object,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectGetOwnPropertyNames,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectPrototype,\n  ObjectPrototypeHasOwnProperty,\n  Promise,\n  PromisePrototype,\n  Proxy,\n  RangeError,\n  RangeErrorPrototype,\n  ReferenceError,\n  ReferenceErrorPrototype,\n  ReflectOwnKeys,\n  RegExp,\n  RegExpPrototype,\n  SafeSet,\n  Set,\n  SetPrototype,\n  String,\n  StringIteratorPrototype,\n  StringPrototype,\n  Symbol,\n  SymbolIterator,\n  SymbolMatchAll,\n  SymbolPrototype,\n  SyntaxError,\n  SyntaxErrorPrototype,\n  TypeError,\n  TypeErrorPrototype,\n  TypedArray,\n  TypedArrayPrototype,\n  Uint16Array,\n  Uint16ArrayPrototype,\n  Uint32Array,\n  Uint32ArrayPrototype,\n  Uint8Array,\n  Uint8ArrayPrototype,\n  Uint8ClampedArray,\n  Uint8ClampedArrayPrototype,\n  URIError,\n  URIErrorPrototype,\n  WeakMap,\n  WeakMapPrototype,\n  WeakRef,\n  WeakRefPrototype,\n  WeakSet,\n  WeakSetPrototype,\n  decodeURI,\n  decodeURIComponent,\n  encodeURI,\n  encodeURIComponent,\n  globalThis\n} = primordials;\nconst {\n  Atomics,\n  Intl,\n  SharedArrayBuffer,\n  WebAssembly\n} = globalThis;\nmodule.exports = function() {\n  const {\n    clearImmediate,\n    clearInterval,\n    clearTimeout,\n    setImmediate,\n    setInterval,\n    setTimeout\n  } = require(\"timers\");\n  const intrinsicPrototypes = [\n    ObjectPrototype,\n    FunctionPrototype,\n    BooleanPrototype,\n    SymbolPrototype,\n    ErrorPrototype,\n    AggregateErrorPrototype,\n    EvalErrorPrototype,\n    RangeErrorPrototype,\n    ReferenceErrorPrototype,\n    SyntaxErrorPrototype,\n    TypeErrorPrototype,\n    URIErrorPrototype,\n    NumberPrototype,\n    BigIntPrototype,\n    DatePrototype,\n    StringPrototype,\n    StringIteratorPrototype,\n    RegExpPrototype,\n    ObjectGetPrototypeOf(/e/[SymbolMatchAll]()),\n    ArrayPrototype,\n    ArrayIteratorPrototype,\n    TypedArrayPrototype,\n    Int8ArrayPrototype,\n    Uint8ArrayPrototype,\n    Uint8ClampedArrayPrototype,\n    Int16ArrayPrototype,\n    Uint16ArrayPrototype,\n    Int32ArrayPrototype,\n    Uint32ArrayPrototype,\n    Float32ArrayPrototype,\n    Float64ArrayPrototype,\n    BigInt64ArrayPrototype,\n    BigUint64ArrayPrototype,\n    MapPrototype,\n    ObjectGetPrototypeOf(new Map()[SymbolIterator]()),\n    SetPrototype,\n    ObjectGetPrototypeOf(new Set()[SymbolIterator]()),\n    WeakMapPrototype,\n    WeakSetPrototype,\n    ArrayBufferPrototype,\n    SharedArrayBuffer.prototype,\n    DataViewPrototype,\n    WeakRefPrototype,\n    FinalizationRegistryPrototype,\n    ObjectGetPrototypeOf(ArrayIteratorPrototype),\n    ObjectGetPrototypeOf(ObjectGetPrototypeOf(ObjectGetPrototypeOf(async function* () {\n    }()))),\n    PromisePrototype,\n    console.Console.prototype,\n    WebAssembly.Module.prototype,\n    WebAssembly.Instance.prototype,\n    WebAssembly.Table.prototype,\n    WebAssembly.Memory.prototype,\n    WebAssembly.CompileError.prototype,\n    WebAssembly.LinkError.prototype,\n    WebAssembly.RuntimeError.prototype\n  ];\n  const intrinsics = [\n    ObjectGetOwnPropertyDescriptor(FunctionPrototype, \"caller\").get,\n    eval,\n    isFinite,\n    isNaN,\n    parseFloat,\n    parseInt,\n    decodeURI,\n    decodeURIComponent,\n    encodeURI,\n    encodeURIComponent,\n    Object,\n    Function,\n    Boolean,\n    Symbol,\n    Error,\n    AggregateError,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n    Number,\n    BigInt,\n    Math,\n    Date,\n    String,\n    StringIteratorPrototype,\n    RegExp,\n    ObjectGetPrototypeOf(/e/[SymbolMatchAll]()),\n    Array,\n    ArrayIteratorPrototype,\n    TypedArray,\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    BigInt64Array,\n    BigUint64Array,\n    Map,\n    ObjectGetPrototypeOf(new Map()[SymbolIterator]()),\n    Set,\n    ObjectGetPrototypeOf(new Set()[SymbolIterator]()),\n    WeakMap,\n    WeakSet,\n    ArrayBuffer,\n    SharedArrayBuffer,\n    DataView,\n    Atomics,\n    JSON,\n    WeakRef,\n    FinalizationRegistry,\n    ObjectGetPrototypeOf(ArrayIteratorPrototype),\n    ObjectGetPrototypeOf(ObjectGetPrototypeOf(ObjectGetPrototypeOf(async function* () {\n    }()))),\n    Promise,\n    ObjectGetPrototypeOf(function* () {\n    }),\n    ObjectGetPrototypeOf(async function* () {\n    }),\n    ObjectGetPrototypeOf(async function() {\n    }),\n    Reflect,\n    Proxy,\n    escape,\n    unescape,\n    clearImmediate,\n    clearInterval,\n    clearTimeout,\n    setImmediate,\n    setInterval,\n    setTimeout,\n    console,\n    WebAssembly\n  ];\n  if (typeof Intl !== \"undefined\") {\n    ArrayPrototypePush(intrinsicPrototypes, Intl.Collator.prototype, Intl.DateTimeFormat.prototype, Intl.ListFormat.prototype, Intl.NumberFormat.prototype, Intl.PluralRules.prototype, Intl.RelativeTimeFormat.prototype);\n    ArrayPrototypePush(intrinsics, Intl);\n  }\n  ArrayPrototypeForEach(intrinsicPrototypes, enableDerivedOverrides);\n  const frozenSet = new WeakSet();\n  ArrayPrototypeForEach(intrinsics, deepFreeze);\n  ObjectDefineProperty(globalThis, \"globalThis\", {\n    configurable: false,\n    writable: false,\n    value: globalThis\n  });\n  function deepFreeze(root) {\n    function innerDeepFreeze(node) {\n      const freezingSet = new SafeSet();\n      function enqueue(val) {\n        if (Object(val) !== val) {\n          return;\n        }\n        const type = typeof val;\n        if (type !== \"object\" && type !== \"function\") {\n        }\n        if (frozenSet.has(val) || freezingSet.has(val)) {\n          return;\n        }\n        freezingSet.add(val);\n      }\n      function doFreeze(obj) {\n        ObjectFreeze(obj);\n        const proto = ObjectGetPrototypeOf(obj);\n        const descs = ObjectGetOwnPropertyDescriptors(obj);\n        enqueue(proto);\n        ArrayPrototypeForEach(ReflectOwnKeys(descs), (name) => {\n          const desc = descs[name];\n          if (\"value\" in desc) {\n            enqueue(desc.value);\n          } else {\n            enqueue(desc.get);\n            enqueue(desc.set);\n          }\n        });\n      }\n      function dequeue() {\n        freezingSet.forEach(doFreeze);\n      }\n      function commit() {\n        freezingSet.forEach(frozenSet.add, frozenSet);\n      }\n      enqueue(node);\n      dequeue();\n      commit();\n    }\n    innerDeepFreeze(root);\n    return root;\n  }\n  function enableDerivedOverride(obj, prop, desc) {\n    if (\"value\" in desc && desc.configurable) {\n      let getter = function() {\n        return value;\n      }, setter = function(newValue) {\n        if (obj === this) {\n          throw new TypeError(`Cannot assign to read only property '${prop}' of object '${obj}'`);\n        }\n        if (ObjectPrototypeHasOwnProperty(this, prop)) {\n          this[prop] = newValue;\n        } else {\n          ObjectDefineProperty(this, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      };\n      const value = desc.value;\n      getter.value = value;\n      ObjectDefineProperty(obj, prop, {\n        get: getter,\n        set: setter,\n        enumerable: desc.enumerable,\n        configurable: desc.configurable\n      });\n    }\n  }\n  function enableDerivedOverrides(obj) {\n    if (!obj) {\n      return;\n    }\n    const descs = ObjectGetOwnPropertyDescriptors(obj);\n    if (!descs) {\n      return;\n    }\n    ArrayPrototypeForEach(ObjectGetOwnPropertyNames(obj), (prop) => {\n      return enableDerivedOverride(obj, prop, descs[prop]);\n    });\n    ArrayPrototypeForEach(ObjectGetOwnPropertySymbols(obj), (prop) => {\n      return enableDerivedOverride(obj, prop, descs[prop]);\n    });\n  }\n};\n}"],["internal/heap_utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Symbol\n} = primordials;\nconst {\n  kUpdateTimer,\n  onStreamRead\n} = require(\"internal/stream_base_commons\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst { Readable } = require(\"stream\");\nconst kHandle = Symbol(\"kHandle\");\nclass HeapSnapshotStream extends Readable {\n  constructor(handle) {\n    super({ autoDestroy: true });\n    this[kHandle] = handle;\n    handle[owner_symbol] = this;\n    handle.onread = onStreamRead;\n  }\n  _read() {\n    if (this[kHandle])\n      this[kHandle].readStart();\n  }\n  _destroy() {\n    this[kHandle][owner_symbol] = void 0;\n    this[kHandle] = void 0;\n  }\n  [kUpdateTimer]() {\n  }\n}\nmodule.exports = {\n  HeapSnapshotStream\n};\n}"],["internal/histogram.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  NumberIsNaN,\n  NumberIsInteger,\n  NumberMAX_SAFE_INTEGER,\n  ObjectSetPrototypeOf,\n  SafeMap,\n  Symbol\n} = primordials;\nconst {\n  Histogram: _Histogram\n} = internalBinding(\"performance\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst { inspect } = require(\"util\");\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateNumber\n} = require(\"internal/validators\");\nconst kDestroy = Symbol(\"kDestroy\");\nconst kHandle = Symbol(\"kHandle\");\nconst kMap = Symbol(\"kMap\");\nconst {\n  kClone,\n  kDeserialize,\n  JSTransferable\n} = require(\"internal/worker/js_transferable\");\nfunction isHistogram(object) {\n  return object?.[kHandle] !== void 0;\n}\nclass Histogram extends JSTransferable {\n  constructor(internal) {\n    super();\n    this[kHandle] = internal;\n    this[kMap] = new SafeMap();\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `Histogram ${inspect({\n      min: this.min,\n      max: this.max,\n      mean: this.mean,\n      exceeds: this.exceeds,\n      stddev: this.stddev,\n      percentiles: this.percentiles\n    }, opts)}`;\n  }\n  get min() {\n    return this[kHandle]?.min();\n  }\n  get max() {\n    return this[kHandle]?.max();\n  }\n  get mean() {\n    return this[kHandle]?.mean();\n  }\n  get exceeds() {\n    return this[kHandle]?.exceeds();\n  }\n  get stddev() {\n    return this[kHandle]?.stddev();\n  }\n  percentile(percentile) {\n    validateNumber(percentile, \"percentile\");\n    if (NumberIsNaN(percentile) || percentile <= 0 || percentile > 100)\n      throw new ERR_INVALID_ARG_VALUE.RangeError(\"percentile\", percentile);\n    return this[kHandle]?.percentile(percentile);\n  }\n  get percentiles() {\n    this[kMap].clear();\n    this[kHandle]?.percentiles(this[kMap]);\n    return this[kMap];\n  }\n  reset() {\n    this[kHandle]?.reset();\n  }\n  [kDestroy]() {\n    this[kHandle] = void 0;\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/histogram:InternalHistogram\"\n    };\n  }\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n  }\n}\nclass RecordableHistogram extends Histogram {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  record(val) {\n    if (typeof val === \"bigint\") {\n      this[kHandle]?.record(val);\n      return;\n    }\n    if (!NumberIsInteger(val))\n      throw new ERR_INVALID_ARG_TYPE(\"val\", [\"integer\", \"bigint\"], val);\n    if (val < 1 || val > NumberMAX_SAFE_INTEGER)\n      throw new ERR_OUT_OF_RANGE(\"val\", \"a safe integer greater than 0\", val);\n    this[kHandle]?.record(val);\n  }\n  recordDelta() {\n    this[kHandle]?.recordDelta();\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/histogram:InternalRecordableHistogram\"\n    };\n  }\n}\nclass InternalHistogram extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    this[kMap] = new SafeMap();\n  }\n}\nclass InternalRecordableHistogram extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    this[kMap] = new SafeMap();\n  }\n}\nInternalHistogram.prototype.constructor = Histogram;\nObjectSetPrototypeOf(InternalHistogram.prototype, Histogram.prototype);\nInternalRecordableHistogram.prototype.constructor = RecordableHistogram;\nObjectSetPrototypeOf(InternalRecordableHistogram.prototype, RecordableHistogram.prototype);\nfunction createHistogram() {\n  return new InternalRecordableHistogram(new _Histogram());\n}\nmodule.exports = {\n  Histogram,\n  RecordableHistogram,\n  InternalHistogram,\n  InternalRecordableHistogram,\n  isHistogram,\n  kDestroy,\n  kHandle,\n  createHistogram\n};\n}"],["internal/http.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Symbol,\n  Date,\n  DatePrototypeGetMilliseconds,\n  DatePrototypeToUTCString\n} = primordials;\nconst { setUnrefTimeout } = require(\"internal/timers\");\nconst { InternalPerformanceEntry } = require(\"internal/perf/performance_entry\");\nconst {\n  enqueue,\n  hasObserver\n} = require(\"internal/perf/observe\");\nlet utcCache;\nfunction utcDate() {\n  if (!utcCache)\n    cache();\n  return utcCache;\n}\nfunction cache() {\n  const d = new Date();\n  utcCache = DatePrototypeToUTCString(d);\n  setUnrefTimeout(resetCache, 1e3 - DatePrototypeGetMilliseconds(d));\n}\nfunction resetCache() {\n  utcCache = void 0;\n}\nfunction emitStatistics(statistics) {\n  if (!hasObserver(\"http\") || statistics == null)\n    return;\n  const startTime = statistics.startTime;\n  const diff = process.hrtime(startTime);\n  const entry = new InternalPerformanceEntry(\"HttpRequest\", \"http\", startTime[0] * 1e3 + startTime[1] / 1e6, diff[0] * 1e3 + diff[1] / 1e6, void 0);\n  enqueue(entry);\n}\nmodule.exports = {\n  kOutHeaders: Symbol(\"kOutHeaders\"),\n  kNeedDrain: Symbol(\"kNeedDrain\"),\n  utcDate,\n  emitStatistics\n};\n}"],["internal/idna.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nif (internalBinding(\"config\").hasIntl) {\n  const { toASCII, toUnicode } = internalBinding(\"icu\");\n  module.exports = { toASCII, toUnicode };\n} else {\n  const { domainToASCII, domainToUnicode } = require(\"internal/url\");\n  module.exports = { toASCII: domainToASCII, toUnicode: domainToUnicode };\n}\n}"],["internal/inspector_async_hook.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nlet hook;\nlet config;\nconst {\n  SafeSet\n} = primordials;\nfunction lazyHookCreation() {\n  const inspector = internalBinding(\"inspector\");\n  const { createHook } = require(\"async_hooks\");\n  config = internalBinding(\"config\");\n  hook = createHook({\n    init(asyncId, type, triggerAsyncId, resource) {\n      const recurring = true;\n      if (type === \"PROMISE\")\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type, asyncId, recurring);\n    },\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    },\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    },\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\n  });\n  hook.promiseIds = new SafeSet();\n}\nfunction enable() {\n  if (hook === void 0)\n    lazyHookCreation();\n  if (config.bits < 64) {\n    process.emitWarning(`Warning: Async stack traces in debugger are not available on ${config.bits}bit platforms. The feature is disabled.`, {\n      code: \"INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE\"\n    });\n  } else {\n    hook.enable();\n  }\n}\nfunction disable() {\n  if (hook === void 0)\n    lazyHookCreation();\n  hook.disable();\n}\nmodule.exports = {\n  enable,\n  disable\n};\n}"],["internal/js_stream_socket.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Symbol\n} = primordials;\nconst { setImmediate } = require(\"timers\");\nconst assert = require(\"internal/assert\");\nconst { Socket } = require(\"net\");\nconst { JSStream } = internalBinding(\"js_stream\");\nconst uv = internalBinding(\"uv\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"stream_socket\", (fn) => {\n  debug = fn;\n});\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst { ERR_STREAM_WRAP } = require(\"internal/errors\").codes;\nconst kCurrentWriteRequest = Symbol(\"kCurrentWriteRequest\");\nconst kCurrentShutdownRequest = Symbol(\"kCurrentShutdownRequest\");\nconst kPendingShutdownRequest = Symbol(\"kPendingShutdownRequest\");\nfunction checkReusedHandle(self) {\n  let socket = self[owner_symbol];\n  if (socket.constructor.name === \"ReusedHandle\")\n    socket = socket.handle;\n  return socket;\n}\nfunction isClosing() {\n  const socket = checkReusedHandle(this);\n  return socket.isClosing();\n}\nfunction onreadstart() {\n  const socket = checkReusedHandle(this);\n  return socket.readStart();\n}\nfunction onreadstop() {\n  const socket = checkReusedHandle(this);\n  return socket.readStop();\n}\nfunction onshutdown(req) {\n  const socket = checkReusedHandle(this);\n  return socket.doShutdown(req);\n}\nfunction onwrite(req, bufs) {\n  const socket = checkReusedHandle(this);\n  return socket.doWrite(req, bufs);\n}\nclass JSStreamSocket extends Socket {\n  constructor(stream) {\n    const handle = new JSStream();\n    handle.close = (cb) => {\n      debug(\"close\");\n      this.doClose(cb);\n    };\n    handle.isClosing = isClosing;\n    handle.onreadstart = onreadstart;\n    handle.onreadstop = onreadstop;\n    handle.onshutdown = onshutdown;\n    handle.onwrite = onwrite;\n    stream.pause();\n    stream.on(\"error\", (err) => this.emit(\"error\", err));\n    const ondata = (chunk) => {\n      if (typeof chunk === \"string\" || stream.readableObjectMode === true) {\n        stream.pause();\n        stream.removeListener(\"data\", ondata);\n        this.emit(\"error\", new ERR_STREAM_WRAP());\n        return;\n      }\n      debug(\"data\", chunk.length);\n      if (this._handle)\n        this._handle.readBuffer(chunk);\n    };\n    stream.on(\"data\", ondata);\n    stream.once(\"end\", () => {\n      debug(\"end\");\n      if (this._handle)\n        this._handle.emitEOF();\n    });\n    stream.once(\"close\", () => {\n      this.destroy();\n    });\n    super({ handle, manualStart: true });\n    this.stream = stream;\n    this[kCurrentWriteRequest] = null;\n    this[kCurrentShutdownRequest] = null;\n    this[kPendingShutdownRequest] = null;\n    this.readable = stream.readable;\n    this.writable = stream.writable;\n    this.read(0);\n  }\n  static get StreamWrap() {\n    return JSStreamSocket;\n  }\n  isClosing() {\n    return !this.readable || !this.writable;\n  }\n  readStart() {\n    this.stream.resume();\n    return 0;\n  }\n  readStop() {\n    this.stream.pause();\n    return 0;\n  }\n  doShutdown(req) {\n    if (this[kCurrentWriteRequest] !== null) {\n      this[kPendingShutdownRequest] = req;\n      return 0;\n    }\n    assert(this[kCurrentWriteRequest] === null);\n    assert(this[kCurrentShutdownRequest] === null);\n    this[kCurrentShutdownRequest] = req;\n    const handle = this._handle;\n    setImmediate(() => {\n      this.stream.end(() => {\n        this.finishShutdown(handle, 0);\n      });\n    });\n    return 0;\n  }\n  finishShutdown(handle, errCode) {\n    if (this[kCurrentShutdownRequest] === null)\n      return;\n    const req = this[kCurrentShutdownRequest];\n    this[kCurrentShutdownRequest] = null;\n    handle.finishShutdown(req, errCode);\n  }\n  doWrite(req, bufs) {\n    assert(this[kCurrentWriteRequest] === null);\n    assert(this[kCurrentShutdownRequest] === null);\n    const handle = this._handle;\n    const self = this;\n    let pending = bufs.length;\n    this.stream.cork();\n    for (var i = 0; i < bufs.length; ++i)\n      this.stream.write(bufs[i], done);\n    this.stream.uncork();\n    this[kCurrentWriteRequest] = req;\n    function done(err) {\n      if (!err && --pending !== 0)\n        return;\n      pending = 0;\n      let errCode = 0;\n      if (err) {\n        errCode = uv[`UV_${err.code}`] || uv.UV_EPIPE;\n      }\n      setImmediate(() => {\n        self.finishWrite(handle, errCode);\n      });\n    }\n    return 0;\n  }\n  finishWrite(handle, errCode) {\n    if (this[kCurrentWriteRequest] === null)\n      return;\n    const req = this[kCurrentWriteRequest];\n    this[kCurrentWriteRequest] = null;\n    handle.finishWrite(req, errCode);\n    if (this[kPendingShutdownRequest]) {\n      const req2 = this[kPendingShutdownRequest];\n      this[kPendingShutdownRequest] = null;\n      this.doShutdown(req2);\n    }\n  }\n  doClose(cb) {\n    const handle = this._handle;\n    this.stream.destroy();\n    setImmediate(() => {\n      assert(this._handle === null);\n      this.finishWrite(handle, uv.UV_ECANCELED);\n      this.finishShutdown(handle, uv.UV_ECANCELED);\n      cb();\n    });\n  }\n}\nmodule.exports = JSStreamSocket;\n}"],["internal/linkedlist.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n}\nfunction peek(list) {\n  if (list._idlePrev === list)\n    return null;\n  return list._idlePrev;\n}\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n  item._idleNext = null;\n  item._idlePrev = null;\n}\nfunction append(list, item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\nmodule.exports = {\n  init,\n  peek,\n  remove,\n  append,\n  isEmpty\n};\n}"],["internal/net.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  RegExp,\n  RegExpPrototypeTest,\n  Symbol\n} = primordials;\nconst Buffer = require(\"buffer\").Buffer;\nconst { writeBuffer } = internalBinding(\"fs\");\nconst errors = require(\"internal/errors\");\nconst v4Seg = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\nconst v6Seg = \"(?:[0-9a-fA-F]{1,4})\";\nconst IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg, s);\n}\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg, s);\n}\nfunction isIP(s) {\n  if (isIPv4(s))\n    return 4;\n  if (isIPv6(s))\n    return 6;\n  return 0;\n}\nfunction makeSyncWrite(fd) {\n  return function(chunk, enc, cb) {\n    if (enc !== \"buffer\")\n      chunk = Buffer.from(chunk, enc);\n    this._handle.bytesWritten += chunk.length;\n    const ctx = {};\n    writeBuffer(fd, chunk, 0, chunk.length, null, void 0, ctx);\n    if (ctx.errno !== void 0) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\nmodule.exports = {\n  isIP,\n  isIPv4,\n  isIPv6,\n  makeSyncWrite,\n  normalizedArgsSymbol: Symbol(\"normalizedArgs\")\n};\n}"],["internal/options.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  getOptions,\n  noGlobalSearchPaths,\n  shouldNotRegisterESMLoader\n} = internalBinding(\"options\");\nlet warnOnAllowUnauthorized = true;\nlet optionsMap;\nlet aliasesMap;\nfunction getOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getOptions());\n  }\n  return optionsMap;\n}\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getOptions());\n  }\n  return aliasesMap;\n}\nfunction getOptionValue(optionName) {\n  const options = getOptionsFromBinding();\n  if (optionName.startsWith(\"--no-\")) {\n    const option = options.get(\"--\" + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === \"0\";\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\"Setting the NODE_TLS_REJECT_UNAUTHORIZED environment variable to '0' makes TLS connections and HTTPS requests insecure by disabling certificate verification.\");\n  }\n  return allowUnauthorized;\n}\nmodule.exports = {\n  get options() {\n    return getOptionsFromBinding();\n  },\n  get aliases() {\n    return getAliasesFromBinding();\n  },\n  getOptionValue,\n  getAllowUnauthorized,\n  noGlobalSearchPaths,\n  shouldNotRegisterESMLoader\n};\n}"],["internal/priority_queue.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  Symbol\n} = primordials;\nconst kCompare = Symbol(\"compare\");\nconst kHeap = Symbol(\"heap\");\nconst kSetPosition = Symbol(\"setPosition\");\nconst kSize = Symbol(\"size\");\nmodule.exports = class PriorityQueue {\n  constructor(comparator, setPosition) {\n    if (comparator !== void 0)\n      this[kCompare] = comparator;\n    if (setPosition !== void 0)\n      this[kSetPosition] = setPosition;\n    this[kHeap] = new Array(64);\n    this[kSize] = 0;\n  }\n  [kCompare](a, b) {\n    return a - b;\n  }\n  insert(value) {\n    const heap = this[kHeap];\n    const pos = ++this[kSize];\n    heap[pos] = value;\n    if (heap.length === pos)\n      heap.length *= 2;\n    this.percolateUp(pos);\n  }\n  peek() {\n    return this[kHeap][1];\n  }\n  percolateDown(pos) {\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const heap = this[kHeap];\n    const size = this[kSize];\n    const item = heap[pos];\n    while (pos * 2 <= size) {\n      let childIndex = pos * 2 + 1;\n      if (childIndex > size || compare(heap[pos * 2], heap[childIndex]) < 0)\n        childIndex = pos * 2;\n      const child = heap[childIndex];\n      if (compare(item, child) <= 0)\n        break;\n      if (setPosition !== void 0)\n        setPosition(child, pos);\n      heap[pos] = child;\n      pos = childIndex;\n    }\n    heap[pos] = item;\n    if (setPosition !== void 0)\n      setPosition(item, pos);\n  }\n  percolateUp(pos) {\n    const heap = this[kHeap];\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const item = heap[pos];\n    while (pos > 1) {\n      const parent = heap[pos / 2 | 0];\n      if (compare(parent, item) <= 0)\n        break;\n      heap[pos] = parent;\n      if (setPosition !== void 0)\n        setPosition(parent, pos);\n      pos = pos / 2 | 0;\n    }\n    heap[pos] = item;\n    if (setPosition !== void 0)\n      setPosition(item, pos);\n  }\n  removeAt(pos) {\n    const heap = this[kHeap];\n    const size = --this[kSize];\n    heap[pos] = heap[size + 1];\n    heap[size + 1] = void 0;\n    if (size > 0 && pos <= size) {\n      if (pos > 1 && this[kCompare](heap[pos / 2 | 0], heap[pos]) > 0)\n        this.percolateUp(pos);\n      else\n        this.percolateDown(pos);\n    }\n  }\n  shift() {\n    const heap = this[kHeap];\n    const value = heap[1];\n    if (value === void 0)\n      return;\n    this.removeAt(1);\n    return value;\n  }\n};\n}"],["internal/querystring.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  Int8Array,\n  NumberPrototypeToString,\n  StringPrototypeCharCodeAt,\n  StringPrototypeSlice,\n  StringPrototypeToUpperCase\n} = primordials;\nconst { ERR_INVALID_URI } = require(\"internal/errors\").codes;\nconst hexTable = new Array(256);\nfor (let i = 0; i < 256; ++i)\n  hexTable[i] = \"%\" + StringPrototypeToUpperCase((i < 16 ? \"0\" : \"\") + NumberPrototypeToString(i, 16));\nconst isHexTable = new Int8Array([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n]);\nfunction encodeStr(str, noEscapeTable, hexTable2) {\n  const len = str.length;\n  if (len === 0)\n    return \"\";\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n  outer:\n    for (; i < len; i++) {\n      let c = StringPrototypeCharCodeAt(str, i);\n      while (c < 128) {\n        if (noEscapeTable[c] !== 1) {\n          if (lastPos < i)\n            out += StringPrototypeSlice(str, lastPos, i);\n          lastPos = i + 1;\n          out += hexTable2[c];\n        }\n        if (++i === len)\n          break outer;\n        c = StringPrototypeCharCodeAt(str, i);\n      }\n      if (lastPos < i)\n        out += StringPrototypeSlice(str, lastPos, i);\n      if (c < 2048) {\n        lastPos = i + 1;\n        out += hexTable2[192 | c >> 6] + hexTable2[128 | c & 63];\n        continue;\n      }\n      if (c < 55296 || c >= 57344) {\n        lastPos = i + 1;\n        out += hexTable2[224 | c >> 12] + hexTable2[128 | c >> 6 & 63] + hexTable2[128 | c & 63];\n        continue;\n      }\n      ++i;\n      if (i >= len)\n        throw new ERR_INVALID_URI();\n      const c2 = StringPrototypeCharCodeAt(str, i) & 1023;\n      lastPos = i + 1;\n      c = 65536 + ((c & 1023) << 10 | c2);\n      out += hexTable2[240 | c >> 18] + hexTable2[128 | c >> 12 & 63] + hexTable2[128 | c >> 6 & 63] + hexTable2[128 | c & 63];\n    }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < len)\n    return out + StringPrototypeSlice(str, lastPos);\n  return out;\n}\nmodule.exports = {\n  encodeStr,\n  hexTable,\n  isHexTable\n};\n}"],["internal/repl.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Number,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectCreate\n} = primordials;\nconst REPL = require(\"repl\");\nconst { kStandaloneREPL } = require(\"internal/repl/utils\");\nmodule.exports = ObjectCreate(REPL);\nmodule.exports.createInternalRepl = createRepl;\nfunction createRepl(env, opts, cb) {\n  if (typeof opts === \"function\") {\n    cb = opts;\n    opts = null;\n  }\n  opts = {\n    [kStandaloneREPL]: true,\n    ignoreUndefined: false,\n    useGlobal: true,\n    breakEvalOnSigint: true,\n    ...opts\n  };\n  if (NumberParseInt(env.NODE_NO_READLINE)) {\n    opts.terminal = false;\n  }\n  if (env.NODE_REPL_MODE) {\n    opts.replMode = {\n      \"strict\": REPL.REPL_MODE_STRICT,\n      \"sloppy\": REPL.REPL_MODE_SLOPPY\n    }[env.NODE_REPL_MODE.toLowerCase().trim()];\n  }\n  if (opts.replMode === void 0) {\n    opts.replMode = REPL.REPL_MODE_SLOPPY;\n  }\n  const historySize = Number(env.NODE_REPL_HISTORY_SIZE);\n  if (!NumberIsNaN(historySize) && historySize > 0) {\n    opts.historySize = historySize;\n  } else {\n    opts.historySize = 1e3;\n  }\n  const repl = REPL.start(opts);\n  const term = \"terminal\" in opts ? opts.terminal : process.stdout.isTTY;\n  repl.setupHistory(term ? env.NODE_REPL_HISTORY : \"\", cb);\n}\n}"],["internal/socket_list.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require(\"internal/errors\").codes;\nconst EventEmitter = require(\"events\");\nclass SocketListSend extends EventEmitter {\n  constructor(child, key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once(\"exit\", () => this.emit(\"exit\", this));\n  }\n  _request(msg, cmd, swallowErrors, callback) {\n    const self = this;\n    if (!this.child.connected)\n      return onclose();\n    this.child._send(msg, void 0, swallowErrors);\n    function onclose() {\n      self.child.removeListener(\"internalMessage\", onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n    function onreply(msg2) {\n      if (!(msg2.cmd === cmd && msg2.key === self.key))\n        return;\n      self.child.removeListener(\"disconnect\", onclose);\n      self.child.removeListener(\"internalMessage\", onreply);\n      callback(null, msg2);\n    }\n    this.child.once(\"disconnect\", onclose);\n    this.child.on(\"internalMessage\", onreply);\n  }\n  close(callback) {\n    this._request({\n      cmd: \"NODE_SOCKET_NOTIFY_CLOSE\",\n      key: this.key\n    }, \"NODE_SOCKET_ALL_CLOSED\", true, callback);\n  }\n  getConnections(callback) {\n    this._request({\n      cmd: \"NODE_SOCKET_GET_COUNT\",\n      key: this.key\n    }, \"NODE_SOCKET_COUNT\", false, (err, msg) => {\n      if (err)\n        return callback(err);\n      callback(null, msg.count);\n    });\n  }\n}\nclass SocketListReceive extends EventEmitter {\n  constructor(child, key) {\n    super();\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n    function onempty(self) {\n      if (!self.child.connected)\n        return;\n      self.child._send({\n        cmd: \"NODE_SOCKET_ALL_CLOSED\",\n        key: self.key\n      }, void 0, true);\n    }\n    this.child.on(\"internalMessage\", (msg) => {\n      if (msg.key !== this.key)\n        return;\n      if (msg.cmd === \"NODE_SOCKET_NOTIFY_CLOSE\") {\n        if (this.connections === 0)\n          return onempty(this);\n        this.once(\"empty\", onempty);\n      } else if (msg.cmd === \"NODE_SOCKET_GET_COUNT\") {\n        if (!this.child.connected)\n          return;\n        this.child._send({\n          cmd: \"NODE_SOCKET_COUNT\",\n          key: this.key,\n          count: this.connections\n        });\n      }\n    });\n  }\n  add(obj) {\n    this.connections++;\n    obj.socket.once(\"close\", () => {\n      this.connections--;\n      if (this.connections === 0)\n        this.emit(\"empty\", this);\n    });\n  }\n}\nmodule.exports = { SocketListSend, SocketListReceive };\n}"],["internal/socketaddress.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nconst {\n  SocketAddress: _SocketAddress,\n  AF_INET,\n  AF_INET6\n} = internalBinding(\"block_list\");\nconst {\n  validateObject,\n  validateString,\n  validatePort,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  JSTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nconst kHandle = Symbol(\"kHandle\");\nconst kDetail = Symbol(\"kDetail\");\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== void 0;\n  }\n  constructor(options = {}) {\n    super();\n    validateObject(options, \"options\");\n    let { family = \"ipv4\" } = options;\n    const {\n      address = family === \"ipv4\" ? \"127.0.0.1\" : \"::\",\n      port = 0,\n      flowlabel = 0\n    } = options;\n    let type;\n    if (typeof family?.toLowerCase === \"function\")\n      family = family.toLowerCase();\n    switch (family) {\n      case \"ipv4\":\n        type = AF_INET;\n        break;\n      case \"ipv6\":\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE(\"options.family\", options.family);\n    }\n    validateString(address, \"options.address\");\n    validatePort(port, \"options.port\");\n    validateUint32(flowlabel, \"options.flowlabel\", false);\n    this[kHandle] = new _SocketAddress(address, port, type, flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: void 0,\n      port: void 0,\n      family: void 0,\n      flowlabel: void 0\n    });\n  }\n  get address() {\n    return this[kDetail].address;\n  }\n  get port() {\n    return this[kDetail].port;\n  }\n  get family() {\n    return this[kDetail].family === AF_INET ? \"ipv4\" : \"ipv6\";\n  }\n  get flowlabel() {\n    return this[kHandle].flowlabel();\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `SocketAddress ${inspect(this.toJSON(), opts)}`;\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/socketaddress:InternalSocketAddress\"\n    };\n  }\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: void 0,\n      port: void 0,\n      family: void 0,\n      flowlabel: void 0\n    });\n  }\n  toJSON() {\n    return {\n      address: this.address,\n      port: this.port,\n      family: this.family,\n      flowlabel: this.flowlabel\n    };\n  }\n}\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\nInternalSocketAddress.prototype.constructor = SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype, SocketAddress.prototype);\nmodule.exports = {\n  SocketAddress,\n  InternalSocketAddress,\n  kHandle\n};\n}"],["internal/stream_base_commons.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  Symbol\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst { FastBuffer } = require(\"internal/buffer\");\nconst {\n  WriteWrap,\n  kReadBytesOrError,\n  kArrayBufferOffset,\n  kBytesWritten,\n  kLastWriteWasAsync,\n  streamBaseState\n} = internalBinding(\"stream_wrap\");\nconst { UV_EOF } = internalBinding(\"uv\");\nconst {\n  errnoException\n} = require(\"internal/errors\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst {\n  kTimeout,\n  setUnrefTimeout,\n  getTimerDuration\n} = require(\"internal/timers\");\nconst { isUint8Array } = require(\"internal/util/types\");\nconst { clearTimeout } = require(\"timers\");\nconst { validateCallback } = require(\"internal/validators\");\nconst kMaybeDestroy = Symbol(\"kMaybeDestroy\");\nconst kUpdateTimer = Symbol(\"kUpdateTimer\");\nconst kAfterAsyncWrite = Symbol(\"kAfterAsyncWrite\");\nconst kHandle = Symbol(\"kHandle\");\nconst kSession = Symbol(\"kSession\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"stream\", (fn) => {\n  debug = fn;\n});\nconst kBuffer = Symbol(\"kBuffer\");\nconst kBufferGen = Symbol(\"kBufferGen\");\nconst kBufferCb = Symbol(\"kBufferCb\");\nfunction handleWriteReq(req, data, encoding) {\n  const { handle } = req;\n  switch (encoding) {\n    case \"buffer\": {\n      const ret = handle.writeBuffer(req, data);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = data;\n      return ret;\n    }\n    case \"latin1\":\n    case \"binary\":\n      return handle.writeLatin1String(req, data);\n    case \"utf8\":\n    case \"utf-8\":\n      return handle.writeUtf8String(req, data);\n    case \"ascii\":\n      return handle.writeAsciiString(req, data);\n    case \"ucs2\":\n    case \"ucs-2\":\n    case \"utf16le\":\n    case \"utf-16le\":\n      return handle.writeUcs2String(req, data);\n    default: {\n      const buffer = Buffer.from(data, encoding);\n      const ret = handle.writeBuffer(req, buffer);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = buffer;\n      return ret;\n    }\n  }\n}\nfunction onWriteComplete(status) {\n  debug(\"onWriteComplete\", status, this.error);\n  let stream = this.handle[owner_symbol];\n  if (stream.constructor.name === \"ReusedHandle\") {\n    stream = stream.handle;\n  }\n  if (stream.destroyed) {\n    if (typeof this.callback === \"function\")\n      this.callback(null);\n    return;\n  }\n  if (status < 0) {\n    const ex = errnoException(status, \"write\", this.error);\n    if (typeof this.callback === \"function\")\n      this.callback(ex);\n    else\n      stream.destroy(ex);\n    return;\n  }\n  stream[kUpdateTimer]();\n  stream[kAfterAsyncWrite](this);\n  if (typeof this.callback === \"function\")\n    this.callback(null);\n}\nfunction createWriteWrap(handle, callback) {\n  const req = new WriteWrap();\n  req.handle = handle;\n  req.oncomplete = onWriteComplete;\n  req.async = false;\n  req.bytes = 0;\n  req.buffer = null;\n  req.callback = callback;\n  return req;\n}\nfunction writevGeneric(self, data, cb) {\n  const req = createWriteWrap(self[kHandle], cb);\n  const allBuffers = data.allBuffers;\n  let chunks;\n  if (allBuffers) {\n    chunks = data;\n    for (let i = 0; i < data.length; i++)\n      data[i] = data[i].chunk;\n  } else {\n    chunks = new Array(data.length << 1);\n    for (let i = 0; i < data.length; i++) {\n      const entry = data[i];\n      chunks[i * 2] = entry.chunk;\n      chunks[i * 2 + 1] = entry.encoding;\n    }\n  }\n  const err = req.handle.writev(req, chunks, allBuffers);\n  if (err === 0)\n    req._chunks = chunks;\n  afterWriteDispatched(req, err, cb);\n  return req;\n}\nfunction writeGeneric(self, data, encoding, cb) {\n  const req = createWriteWrap(self[kHandle], cb);\n  const err = handleWriteReq(req, data, encoding);\n  afterWriteDispatched(req, err, cb);\n  return req;\n}\nfunction afterWriteDispatched(req, err, cb) {\n  req.bytes = streamBaseState[kBytesWritten];\n  req.async = !!streamBaseState[kLastWriteWasAsync];\n  if (err !== 0)\n    return cb(errnoException(err, \"write\", req.error));\n  if (!req.async && typeof req.callback === \"function\") {\n    req.callback();\n  }\n}\nfunction onStreamRead(arrayBuffer) {\n  const nread = streamBaseState[kReadBytesOrError];\n  const handle = this;\n  let stream = this[owner_symbol];\n  if (stream.constructor.name === \"ReusedHandle\") {\n    stream = stream.handle;\n  }\n  stream[kUpdateTimer]();\n  if (nread > 0 && !stream.destroyed) {\n    let ret;\n    let result;\n    const userBuf = stream[kBuffer];\n    if (userBuf) {\n      result = stream[kBufferCb](nread, userBuf) !== false;\n      const bufGen = stream[kBufferGen];\n      if (bufGen !== null) {\n        const nextBuf = bufGen();\n        if (isUint8Array(nextBuf))\n          stream[kBuffer] = ret = nextBuf;\n      }\n    } else {\n      const offset = streamBaseState[kArrayBufferOffset];\n      const buf = new FastBuffer(arrayBuffer, offset, nread);\n      result = stream.push(buf);\n    }\n    if (!result) {\n      handle.reading = false;\n      if (!stream.destroyed) {\n        const err = handle.readStop();\n        if (err)\n          stream.destroy(errnoException(err, \"read\"));\n      }\n    }\n    return ret;\n  }\n  if (nread === 0) {\n    return;\n  }\n  if (nread !== UV_EOF) {\n    stream.destroy(errnoException(nread, \"read\"));\n    return;\n  }\n  if (stream._readableState.endEmitted) {\n    if (stream[kMaybeDestroy])\n      stream[kMaybeDestroy]();\n  } else {\n    if (stream[kMaybeDestroy])\n      stream.on(\"end\", stream[kMaybeDestroy]);\n    if (handle.readStop) {\n      const err = handle.readStop();\n      if (err) {\n        stream.destroy(errnoException(err, \"read\"));\n        return;\n      }\n    }\n    stream.push(null);\n    stream.read(0);\n  }\n}\nfunction setStreamTimeout(msecs, callback) {\n  if (this.destroyed)\n    return this;\n  this.timeout = msecs;\n  msecs = getTimerDuration(msecs, \"msecs\");\n  clearTimeout(this[kTimeout]);\n  if (msecs === 0) {\n    if (callback !== void 0) {\n      validateCallback(callback);\n      this.removeListener(\"timeout\", callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);\n    if (this[kSession])\n      this[kSession][kUpdateTimer]();\n    if (callback !== void 0) {\n      validateCallback(callback);\n      this.once(\"timeout\", callback);\n    }\n  }\n  return this;\n}\nmodule.exports = {\n  writevGeneric,\n  writeGeneric,\n  onStreamRead,\n  kAfterAsyncWrite,\n  kMaybeDestroy,\n  kUpdateTimer,\n  kHandle,\n  kSession,\n  setStreamTimeout,\n  kBuffer,\n  kBufferCb,\n  kBufferGen\n};\n}"],["internal/structured_clone.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  MessageChannel,\n  receiveMessageOnPort\n} = require(\"internal/worker/io\");\nlet channel;\nfunction structuredClone(value, transfer) {\n  channel ??= new MessageChannel();\n  channel.port1.unref();\n  channel.port2.unref();\n  channel.port1.postMessage(value, transfer);\n  return receiveMessageOnPort(channel.port2).message;\n}\nmodule.exports = {\n  structuredClone\n};\n}"],["internal/timers.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  MathMax,\n  MathTrunc,\n  NumberIsFinite,\n  NumberMIN_SAFE_INTEGER,\n  ObjectCreate,\n  ReflectApply,\n  Symbol\n} = primordials;\nconst {\n  scheduleTimer,\n  toggleTimerRef,\n  getLibuvNow,\n  immediateInfo,\n  toggleImmediateRef\n} = internalBinding(\"timers\");\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy\n} = require(\"internal/async_hooks\");\nconst async_id_symbol = Symbol(\"asyncId\");\nconst trigger_async_id_symbol = Symbol(\"triggerId\");\nconst kHasPrimitive = Symbol(\"kHasPrimitive\");\nconst {\n  ERR_OUT_OF_RANGE\n} = require(\"internal/errors\").codes;\nconst {\n  validateCallback,\n  validateNumber\n} = require(\"internal/validators\");\nconst L = require(\"internal/linkedlist\");\nconst PriorityQueue = require(\"internal/priority_queue\");\nconst { inspect } = require(\"internal/util/inspect\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"timer\", (fn) => {\n  debug = fn;\n});\nconst kCount = 0;\nconst kRefCount = 1;\nconst kHasOutstanding = 2;\nconst TIMEOUT_MAX = 2 ** 31 - 1;\nlet timerListId = NumberMIN_SAFE_INTEGER;\nconst kRefed = Symbol(\"refed\");\nconst immediateQueue = new ImmediateList();\nlet nextExpiry = Infinity;\nlet refCount = 0;\nconst timerListQueue = new PriorityQueue(compareTimersLists, setPosition);\nconst timerListMap = ObjectCreate(null);\nfunction initAsyncResource(resource, type) {\n  const asyncId = resource[async_id_symbol] = newAsyncId();\n  const triggerAsyncId = resource[trigger_async_id_symbol] = getDefaultTriggerAsyncId();\n  if (initHooksExist())\n    emitInit(asyncId, type, triggerAsyncId, resource);\n}\nfunction Timeout(callback, after, args, isRepeat, isRefed) {\n  after *= 1;\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    if (after > TIMEOUT_MAX) {\n      process.emitWarning(`${after} does not fit into a 32-bit signed integer.\nTimeout duration was set to 1.`, \"TimeoutOverflowWarning\");\n    }\n    after = 1;\n  }\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = isRepeat ? after : null;\n  this._destroyed = false;\n  if (isRefed)\n    incRefCount();\n  this[kRefed] = isRefed;\n  this[kHasPrimitive] = false;\n  initAsyncResource(this, \"Timeout\");\n}\nTimeout.prototype[inspect.custom] = function(_, options) {\n  return inspect(this, {\n    ...options,\n    depth: 0,\n    customInspect: false\n  });\n};\nTimeout.prototype.refresh = function() {\n  if (this[kRefed])\n    active(this);\n  else\n    unrefActive(this);\n  return this;\n};\nTimeout.prototype.unref = function() {\n  if (this[kRefed]) {\n    this[kRefed] = false;\n    if (!this._destroyed)\n      decRefCount();\n  }\n  return this;\n};\nTimeout.prototype.ref = function() {\n  if (!this[kRefed]) {\n    this[kRefed] = true;\n    if (!this._destroyed)\n      incRefCount();\n  }\n  return this;\n};\nTimeout.prototype.hasRef = function() {\n  return this[kRefed];\n};\nfunction TimersList(expiry, msecs) {\n  this._idleNext = this;\n  this._idlePrev = this;\n  this.expiry = expiry;\n  this.id = timerListId++;\n  this.msecs = msecs;\n  this.priorityQueuePosition = null;\n}\nTimersList.prototype[inspect.custom] = function(_, options) {\n  return inspect(this, {\n    ...options,\n    depth: 0,\n    customInspect: false\n  });\n};\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\nImmediateList.prototype.append = function(item) {\n  if (this.tail !== null) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n  item._idleNext = null;\n  item._idlePrev = null;\n};\nfunction incRefCount() {\n  if (refCount++ === 0)\n    toggleTimerRef(true);\n}\nfunction decRefCount() {\n  if (--refCount === 0)\n    toggleTimerRef(false);\n}\nfunction active(item) {\n  insertGuarded(item, true);\n}\nfunction unrefActive(item) {\n  insertGuarded(item, false);\n}\nfunction insertGuarded(item, refed, start) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === void 0)\n    return;\n  insert(item, msecs, start);\n  const isDestroyed = item._destroyed;\n  if (isDestroyed || !item[async_id_symbol]) {\n    item._destroyed = false;\n    initAsyncResource(item, \"Timeout\");\n  }\n  if (isDestroyed) {\n    if (refed)\n      incRefCount();\n  } else if (refed === !item[kRefed]) {\n    if (refed)\n      incRefCount();\n    else\n      decRefCount();\n  }\n  item[kRefed] = refed;\n}\nfunction insert(item, msecs, start = getLibuvNow()) {\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n  let list = timerListMap[msecs];\n  if (list === void 0) {\n    debug(\"no %d list was found in insert, creating a new one\", msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry, msecs);\n    timerListQueue.insert(list);\n    if (nextExpiry > expiry) {\n      scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n  L.append(list, item);\n}\nfunction setUnrefTimeout(callback, after) {\n  validateCallback(callback);\n  const timer = new Timeout(callback, after, void 0, false, false);\n  insert(timer, timer._idleTimeout);\n  return timer;\n}\nfunction getTimerDuration(msecs, name) {\n  validateNumber(msecs, name);\n  if (msecs < 0 || !NumberIsFinite(msecs)) {\n    throw new ERR_OUT_OF_RANGE(name, \"a non-negative finite number\", msecs);\n  }\n  if (msecs > TIMEOUT_MAX) {\n    process.emitWarning(`${msecs} does not fit into a 32-bit signed integer.\nTimer duration was truncated to ${TIMEOUT_MAX}.`, \"TimeoutOverflowWarning\");\n    return TIMEOUT_MAX;\n  }\n  return msecs;\n}\nfunction compareTimersLists(a, b) {\n  const expiryDiff = a.expiry - b.expiry;\n  if (expiryDiff === 0) {\n    if (a.id < b.id)\n      return -1;\n    if (a.id > b.id)\n      return 1;\n  }\n  return expiryDiff;\n}\nfunction setPosition(node, pos) {\n  node.priorityQueuePosition = pos;\n}\nfunction getTimerCallbacks(runNextTicks) {\n  const outstandingQueue = new ImmediateList();\n  function processImmediate() {\n    const queue = outstandingQueue.head !== null ? outstandingQueue : immediateQueue;\n    let immediate = queue.head;\n    if (queue !== outstandingQueue) {\n      queue.head = queue.tail = null;\n      immediateInfo[kHasOutstanding] = 1;\n    }\n    let prevImmediate;\n    let ranAtLeastOneImmediate = false;\n    while (immediate !== null) {\n      if (ranAtLeastOneImmediate)\n        runNextTicks();\n      else\n        ranAtLeastOneImmediate = true;\n      if (immediate._destroyed) {\n        outstandingQueue.head = immediate = prevImmediate._idleNext;\n        continue;\n      }\n      immediate._destroyed = true;\n      immediateInfo[kCount]--;\n      if (immediate[kRefed])\n        immediateInfo[kRefCount]--;\n      immediate[kRefed] = null;\n      prevImmediate = immediate;\n      const asyncId = immediate[async_id_symbol];\n      emitBefore(asyncId, immediate[trigger_async_id_symbol], immediate);\n      try {\n        const argv = immediate._argv;\n        if (!argv)\n          immediate._onImmediate();\n        else\n          immediate._onImmediate(...argv);\n      } finally {\n        immediate._onImmediate = null;\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n        outstandingQueue.head = immediate = immediate._idleNext;\n      }\n      emitAfter(asyncId);\n    }\n    if (queue === outstandingQueue)\n      outstandingQueue.head = null;\n    immediateInfo[kHasOutstanding] = 0;\n  }\n  function processTimers(now) {\n    debug(\"process timer lists %d\", now);\n    nextExpiry = Infinity;\n    let list;\n    let ranAtLeastOneList = false;\n    while (list = timerListQueue.peek()) {\n      if (list.expiry > now) {\n        nextExpiry = list.expiry;\n        return refCount > 0 ? nextExpiry : -nextExpiry;\n      }\n      if (ranAtLeastOneList)\n        runNextTicks();\n      else\n        ranAtLeastOneList = true;\n      listOnTimeout(list, now);\n    }\n    return 0;\n  }\n  function listOnTimeout(list, now) {\n    const msecs = list.msecs;\n    debug(\"timeout callback %d\", msecs);\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while (timer = L.peek(list)) {\n      const diff = now - timer._idleStart;\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs, now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug(\"%d list wait because diff is %d\", msecs, diff);\n        return;\n      }\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n      L.remove(timer);\n      const asyncId = timer[async_id_symbol];\n      if (!timer._onTimeout) {\n        if (!timer._destroyed) {\n          timer._destroyed = true;\n          if (timer[kRefed])\n            refCount--;\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n        continue;\n      }\n      emitBefore(asyncId, timer[trigger_async_id_symbol], timer);\n      let start;\n      if (timer._repeat)\n        start = getLibuvNow();\n      try {\n        const args = timer._timerArgs;\n        if (args === void 0)\n          timer._onTimeout();\n        else\n          ReflectApply(timer._onTimeout, timer, args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer, timer._idleTimeout, start);\n        } else if (!timer._idleNext && !timer._idlePrev && !timer._destroyed) {\n          timer._destroyed = true;\n          if (timer[kRefed])\n            refCount--;\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n      }\n      emitAfter(asyncId);\n    }\n    debug(\"%d list empty\", msecs);\n    if (list === timerListMap[msecs]) {\n      delete timerListMap[msecs];\n      timerListQueue.shift();\n    }\n  }\n  return {\n    processImmediate,\n    processTimers\n  };\n}\nclass Immediate {\n  constructor(callback, args) {\n    this._idleNext = null;\n    this._idlePrev = null;\n    this._onImmediate = callback;\n    this._argv = args;\n    this._destroyed = false;\n    this[kRefed] = false;\n    initAsyncResource(this, \"Immediate\");\n    this.ref();\n    immediateInfo[kCount]++;\n    immediateQueue.append(this);\n  }\n  ref() {\n    if (this[kRefed] === false) {\n      this[kRefed] = true;\n      if (immediateInfo[kRefCount]++ === 0)\n        toggleImmediateRef(true);\n    }\n    return this;\n  }\n  unref() {\n    if (this[kRefed] === true) {\n      this[kRefed] = false;\n      if (--immediateInfo[kRefCount] === 0)\n        toggleImmediateRef(false);\n    }\n    return this;\n  }\n  hasRef() {\n    return !!this[kRefed];\n  }\n}\nmodule.exports = {\n  TIMEOUT_MAX,\n  kTimeout: Symbol(\"timeout\"),\n  async_id_symbol,\n  trigger_async_id_symbol,\n  Timeout,\n  Immediate,\n  kRefed,\n  kHasPrimitive,\n  initAsyncResource,\n  setUnrefTimeout,\n  getTimerDuration,\n  immediateQueue,\n  getTimerCallbacks,\n  immediateInfoFields: {\n    kCount,\n    kRefCount,\n    kHasOutstanding\n  },\n  active,\n  unrefActive,\n  insert,\n  timerListMap,\n  timerListQueue,\n  decRefCount,\n  incRefCount\n};\n}"],["internal/trace_events_async_hooks.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectKeys,\n  SafeMap,\n  SafeSet,\n  Symbol\n} = primordials;\nconst { trace } = internalBinding(\"trace_events\");\nconst async_wrap = internalBinding(\"async_wrap\");\nconst async_hooks = require(\"async_hooks\");\nconst {\n  CHAR_LOWERCASE_B,\n  CHAR_LOWERCASE_E\n} = require(\"internal/constants\");\nconst kBeforeEvent = CHAR_LOWERCASE_B;\nconst kEndEvent = CHAR_LOWERCASE_E;\nconst kTraceEventCategory = \"node,node.async_hooks\";\nconst kEnabled = Symbol(\"enabled\");\nconst nativeProviders = new SafeSet(ObjectKeys(async_wrap.Providers));\nconst typeMemory = new SafeMap();\nnativeProviders.delete(\"PROMISE\");\nfunction createHook() {\n  const hook = async_hooks.createHook({\n    init(asyncId, type, triggerAsyncId, resource) {\n      if (nativeProviders.has(type))\n        return;\n      typeMemory.set(asyncId, type);\n      trace(kBeforeEvent, kTraceEventCategory, type, asyncId, {\n        triggerAsyncId,\n        executionAsyncId: async_hooks.executionAsyncId()\n      });\n    },\n    before(asyncId) {\n      const type = typeMemory.get(asyncId);\n      if (type === void 0)\n        return;\n      trace(kBeforeEvent, kTraceEventCategory, `${type}_CALLBACK`, asyncId);\n    },\n    after(asyncId) {\n      const type = typeMemory.get(asyncId);\n      if (type === void 0)\n        return;\n      trace(kEndEvent, kTraceEventCategory, `${type}_CALLBACK`, asyncId);\n    },\n    destroy(asyncId) {\n      const type = typeMemory.get(asyncId);\n      if (type === void 0)\n        return;\n      trace(kEndEvent, kTraceEventCategory, type, asyncId);\n      typeMemory.delete(asyncId);\n    }\n  });\n  return {\n    enable() {\n      if (this[kEnabled])\n        return;\n      this[kEnabled] = true;\n      hook.enable();\n    },\n    disable() {\n      if (!this[kEnabled])\n        return;\n      this[kEnabled] = false;\n      hook.disable();\n      typeMemory.clear();\n    }\n  };\n}\nexports.createHook = createHook;\n}"],["internal/tty.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeSome,\n  RegExpPrototypeTest,\n  StringPrototypeSplit,\n  StringPrototypeToLowerCase\n} = primordials;\nconst { validateInteger } = require(\"internal/validators\");\nlet OSRelease;\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\nconst TERM_ENVS = {\n  \"eterm\": COLORS_16,\n  \"cons25\": COLORS_16,\n  \"console\": COLORS_16,\n  \"cygwin\": COLORS_16,\n  \"dtterm\": COLORS_16,\n  \"gnome\": COLORS_16,\n  \"hurd\": COLORS_16,\n  \"jfbterm\": COLORS_16,\n  \"konsole\": COLORS_16,\n  \"kterm\": COLORS_16,\n  \"mlterm\": COLORS_16,\n  \"mosh\": COLORS_16m,\n  \"putty\": COLORS_16,\n  \"st\": COLORS_16,\n  \"rxvt-unicode-24bit\": COLORS_16m,\n  \"terminator\": COLORS_16m\n};\nconst TERM_ENVS_REG_EXP = [\n  /ansi/,\n  /color/,\n  /linux/,\n  /^con[0-9]*x[0-9]/,\n  /^rxvt/,\n  /^screen/,\n  /^xterm/,\n  /^vt100/\n];\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = \"\";\n  if (env.NODE_DISABLE_COLORS !== void 0)\n    name = \"NODE_DISABLE_COLORS\";\n  if (env.NO_COLOR !== void 0) {\n    if (name !== \"\") {\n      name += \"' and '\";\n    }\n    name += \"NO_COLOR\";\n  }\n  if (name !== \"\") {\n    process.emitWarning(`The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`, \"Warning\");\n    warned = true;\n  }\n}\nfunction getColorDepth(env = process.env) {\n  if (env.FORCE_COLOR !== void 0) {\n    switch (env.FORCE_COLOR) {\n      case \"\":\n      case \"1\":\n      case \"true\":\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case \"2\":\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case \"3\":\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n  if (env.NODE_DISABLE_COLORS !== void 0 || env.NO_COLOR !== void 0 || env.TERM === \"dumb\") {\n    return COLORS_2;\n  }\n  if (process.platform === \"win32\") {\n    if (OSRelease === void 0) {\n      const { release } = require(\"os\");\n      OSRelease = StringPrototypeSplit(release(), \".\");\n    }\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n    return COLORS_16;\n  }\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n  if (env.CI) {\n    if (\"TRAVIS\" in env || \"CIRCLECI\" in env || \"APPVEYOR\" in env || \"GITLAB_CI\" in env || env.CI_NAME === \"codeship\") {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n  if (\"TEAMCITY_VERSION\" in env) {\n    return RegExpPrototypeTest(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/, env.TEAMCITY_VERSION) ? COLORS_16 : COLORS_2;\n  }\n  switch (env.TERM_PROGRAM) {\n    case \"iTerm.app\":\n      if (!env.TERM_PROGRAM_VERSION || RegExpPrototypeTest(/^[0-2]\\./, env.TERM_PROGRAM_VERSION)) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case \"HyperTerm\":\n    case \"MacTerm\":\n      return COLORS_16m;\n    case \"Apple_Terminal\":\n      return COLORS_256;\n  }\n  if (env.COLORTERM === \"truecolor\" || env.COLORTERM === \"24bit\") {\n    return COLORS_16m;\n  }\n  if (env.TERM) {\n    if (RegExpPrototypeTest(/^xterm-256/, env.TERM)) {\n      return COLORS_256;\n    }\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP, (term) => RegExpPrototypeTest(term, termEnv))) {\n      return COLORS_16;\n    }\n  }\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\nfunction hasColors(count, env) {\n  if (env === void 0 && (count === void 0 || typeof count === \"object\" && count !== null)) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count, \"count\", 2);\n  }\n  return count <= 2 ** getColorDepth(env);\n}\nmodule.exports = {\n  getColorDepth,\n  hasColors\n};\n}"],["internal/url.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypeReduce,\n  ArrayPrototypeSlice,\n  FunctionPrototypeBind,\n  Int8Array,\n  Number,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ReflectApply,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIncludes,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  Symbol,\n  SymbolIterator,\n  SymbolToStringTag,\n  decodeURIComponent\n} = primordials;\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  encodeStr,\n  hexTable,\n  isHexTable\n} = require(\"internal/querystring\");\nconst {\n  getConstructorOf,\n  removeColors,\n  toUSVString\n} = require(\"internal/util\");\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_FILE_URL_HOST,\n    ERR_INVALID_FILE_URL_PATH,\n    ERR_INVALID_THIS,\n    ERR_INVALID_TUPLE,\n    ERR_INVALID_URL,\n    ERR_INVALID_URL_SCHEME,\n    ERR_MISSING_ARGS,\n    ERR_NO_CRYPTO\n  }\n} = require(\"internal/errors\");\nconst {\n  CHAR_AMPERSAND,\n  CHAR_BACKWARD_SLASH,\n  CHAR_EQUAL,\n  CHAR_FORWARD_SLASH,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_PERCENT,\n  CHAR_PLUS\n} = require(\"internal/constants\");\nconst path = require(\"path\");\nconst {\n  validateCallback,\n  validateObject\n} = require(\"internal/validators\");\nconst querystring = require(\"querystring\");\nconst { platform } = process;\nconst isWindows = platform === \"win32\";\nconst {\n  domainToASCII: _domainToASCII,\n  domainToUnicode: _domainToUnicode,\n  encodeAuth,\n  parse,\n  setURLConstructor,\n  URL_FLAGS_CANNOT_BE_BASE,\n  URL_FLAGS_HAS_FRAGMENT,\n  URL_FLAGS_HAS_HOST,\n  URL_FLAGS_HAS_PASSWORD,\n  URL_FLAGS_HAS_PATH,\n  URL_FLAGS_HAS_QUERY,\n  URL_FLAGS_HAS_USERNAME,\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT,\n  URL_FLAGS_SPECIAL,\n  kFragment,\n  kHost,\n  kHostname,\n  kPathStart,\n  kPort,\n  kQuery,\n  kSchemeStart\n} = internalBinding(\"url\");\nconst {\n  storeDataObject,\n  revokeDataObject\n} = internalBinding(\"blob\");\nconst context = Symbol(\"context\");\nconst cannotBeBase = Symbol(\"cannot-be-base\");\nconst cannotHaveUsernamePasswordPort = Symbol(\"cannot-have-username-password-port\");\nconst special = Symbol(\"special\");\nconst searchParams = Symbol(\"query\");\nconst kFormat = Symbol(\"format\");\nlet blob;\nlet cryptoRandom;\nfunction lazyBlob() {\n  blob ??= require(\"internal/blob\");\n  return blob;\n}\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require(\"internal/crypto/random\");\n  } catch {\n  }\n  return cryptoRandom;\n}\nconst IteratorPrototype = ObjectGetPrototypeOf(ObjectGetPrototypeOf([][SymbolIterator]()));\nconst kOpaqueOrigin = \"null\";\nfunction serializeTupleOrigin(scheme, host, port) {\n  return `${scheme}//${host}${port === null ? \"\" : `:${port}`}`;\n}\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = \":\";\n    this.username = \"\";\n    this.password = \"\";\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\nclass URLSearchParams {\n  constructor(init = void 0) {\n    if (init === null || init === void 0) {\n      this[searchParams] = [];\n    } else if (typeof init === \"object\" || typeof init === \"function\") {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== void 0) {\n        if (typeof method !== \"function\") {\n          throw new ERR_ARG_NOT_ITERABLE(\"Query pairs\");\n        }\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== \"object\" && typeof pair !== \"function\" || pair === null || typeof pair[SymbolIterator] !== \"function\") {\n            throw new ERR_INVALID_TUPLE(\"Each query pair\", \"[name, value]\");\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair, toUSVString(element));\n          ArrayPrototypePush(pairs, convertedPair);\n        }\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE(\"Each query pair\", \"[name, value]\");\n          }\n          ArrayPrototypePush(this[searchParams], pair[0], pair[1]);\n        }\n      } else {\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init, key);\n          if (desc !== void 0 && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey, typedValue);\n          }\n        }\n      }\n    } else {\n      init = toUSVString(init);\n      if (init[0] === \"?\")\n        init = init.slice(1);\n      initSearchParams(this, init);\n    }\n    this[context] = null;\n  }\n  [inspect.custom](recurseTimes, ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (typeof recurseTimes === \"number\" && recurseTimes < 0)\n      return ctx.stylize(\"[Object]\", \"special\");\n    const separator = \", \";\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v, innerOpts);\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(output, `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n    const length = ArrayPrototypeReduce(output, (prev, cur) => prev + removeColors(cur).length + separator.length, -separator.length);\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\n  ${ArrayPrototypeJoin(output, \",\\n  \")} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ${ArrayPrototypeJoin(output, separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n  append(name, value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS(\"name\", \"value\");\n    }\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams], name, value);\n    update(this[context], this);\n  }\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS(\"name\");\n    }\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; ) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context], this);\n  }\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS(\"name\");\n    }\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS(\"name\");\n    }\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS(\"name\");\n    }\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n  set(name, value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS(\"name\", \"value\");\n    }\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n    let found = false;\n    for (let i = 0; i < list.length; ) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i, 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n    if (!found) {\n      ArrayPrototypePush(list, name, value);\n    }\n    update(this[context], this);\n  }\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n    if (len <= 2) {\n    } else if (len < 100) {\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a, start, mid, end, lBuffer, rBuffer);\n        }\n      }\n    }\n    update(this[context], this);\n  }\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    return createSearchParamsIterator(this, \"key+value\");\n  }\n  forEach(callback, thisArg = void 0) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    validateCallback(callback);\n    let list = this[searchParams];\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg, value, key, this);\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    return createSearchParamsIterator(this, \"key\");\n  }\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    return createSearchParamsIterator(this, \"value\");\n  }\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS(\"URLSearchParams\");\n    return serializeParams(this[searchParams]);\n  }\n}\nObjectDefineProperties(URLSearchParams.prototype, {\n  append: { enumerable: true },\n  delete: { enumerable: true },\n  get: { enumerable: true },\n  getAll: { enumerable: true },\n  has: { enumerable: true },\n  set: { enumerable: true },\n  sort: { enumerable: true },\n  entries: { enumerable: true },\n  forEach: { enumerable: true },\n  keys: { enumerable: true },\n  values: { enumerable: true },\n  toString: { enumerable: true },\n  [SymbolToStringTag]: { configurable: true, value: \"URLSearchParams\" },\n  [SymbolIterator]: {\n    configurable: true,\n    writable: true,\n    value: URLSearchParams.prototype.entries\n  }\n});\nfunction onParseComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : \"\";\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : \"\";\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path2 : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) {\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams], query);\n}\nfunction onParseError(flags, input) {\n  throw new ERR_INVALID_URL(input);\n}\nfunction onParseProtocolComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\nfunction onParseHostnameComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\nfunction onParsePortComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  this[context].port = port;\n}\nfunction onParseHostComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  ReflectApply(onParseHostnameComplete, this, arguments);\n  if (port !== null || (flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0)\n    ReflectApply(onParsePortComplete, this, arguments);\n}\nfunction onParsePathComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path2;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\nfunction onParseSearchComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  this[context].query = query;\n}\nfunction onParseHashComplete(flags, protocol, username, password, host, port, path2, query, fragment) {\n  this[context].fragment = fragment;\n}\nfunction isURLThis(self) {\n  return self !== void 0 && self !== null && self[context] !== void 0;\n}\nclass URL {\n  constructor(input, base = void 0) {\n    input = `${input}`;\n    let base_context;\n    if (base !== void 0) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input, -1, base_context, void 0, FunctionPrototypeBind(onParseComplete, this), onParseError);\n  }\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host, scheme } = this[context];\n    return host == null || host === \"\" || this[cannotBeBase] || scheme === \"file:\";\n  }\n  [inspect.custom](depth, opts) {\n    if (this == null || ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS(\"URL\");\n    }\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n    return `${constructor.name} ${inspect(obj, opts)}`;\n  }\n  [kFormat](options) {\n    if (options)\n      validateObject(options, \"options\");\n    options = {\n      fragment: true,\n      unicode: false,\n      search: true,\n      auth: true,\n      ...options\n    };\n    const ctx = this[context];\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += \"//\";\n      const has_username = ctx.username !== \"\";\n      const has_password = ctx.password !== \"\";\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += \"@\";\n      }\n      ret += options.unicode ? domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === \"\") {\n        ret += \"/.\";\n      }\n      if (ctx.path.length) {\n        ret += \"/\" + ArrayPrototypeJoin(ctx.path, \"/\");\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n  toString() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[kFormat]({});\n  }\n  get href() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[kFormat]({});\n  }\n  set href(input) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    input = `${input}`;\n    parse(input, -1, void 0, void 0, FunctionPrototypeBind(onParseComplete, this), onParseError);\n  }\n  get origin() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case \"blob:\":\n        if (ctx.path.length > 0) {\n          try {\n            return new URL(ctx.path[0]).origin;\n          } catch {\n          }\n        }\n        return kOpaqueOrigin;\n      case \"ftp:\":\n      case \"http:\":\n      case \"https:\":\n      case \"ws:\":\n      case \"wss:\":\n        return serializeTupleOrigin(ctx.scheme, ctx.host, ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n  get protocol() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[context].scheme;\n  }\n  set protocol(scheme) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme, kSchemeStart, null, ctx, FunctionPrototypeBind(onParseProtocolComplete, this));\n  }\n  get username() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[context].username;\n  }\n  set username(username) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === \"\") {\n      ctx.username = \"\";\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n  get password() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[context].password;\n  }\n  set password(password) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === \"\") {\n      ctx.password = \"\";\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n  get host() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    let ret = ctx.host || \"\";\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n  set host(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      return;\n    }\n    parse(host, kHost, null, ctx, FunctionPrototypeBind(onParseHostComplete, this));\n  }\n  get hostname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[context].host || \"\";\n  }\n  set hostname(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      return;\n    }\n    parse(host, kHostname, null, ctx, onParseHostnameComplete.bind(this));\n  }\n  get port() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const port = this[context].port;\n    return port === null ? \"\" : String(port);\n  }\n  set port(port) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === \"\") {\n      ctx.port = null;\n      return;\n    }\n    parse(port, kPort, null, ctx, FunctionPrototypeBind(onParsePortComplete, this));\n  }\n  get pathname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return \"\";\n    return `/${ArrayPrototypeJoin(ctx.path, \"/\")}`;\n  }\n  set pathname(path2) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    path2 = `${path2}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path2, kPathStart, null, this[context], onParsePathComplete.bind(this));\n  }\n  get search() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const { query } = this[context];\n    if (query === null || query === \"\")\n      return \"\";\n    return `?${query}`;\n  }\n  set search(search) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === \"\") {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === \"?\")\n        search = StringPrototypeSlice(search, 1);\n      ctx.query = \"\";\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search, kQuery, null, ctx, FunctionPrototypeBind(onParseSearchComplete, this));\n      }\n    }\n    initSearchParams(this[searchParams], search);\n  }\n  get searchParams() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[searchParams];\n  }\n  get hash() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const { fragment } = this[context];\n    if (fragment === null || fragment === \"\")\n      return \"\";\n    return `#${fragment}`;\n  }\n  set hash(hash) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    const ctx = this[context];\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === \"#\")\n      hash = StringPrototypeSlice(hash, 1);\n    ctx.fragment = \"\";\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash, kFragment, null, ctx, FunctionPrototypeBind(onParseHashComplete, this));\n  }\n  toJSON() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS(\"URL\");\n    return this[kFormat]({});\n  }\n  static createObjectURL(obj) {\n    const cryptoRandom2 = lazyCryptoRandom();\n    if (cryptoRandom2 === void 0)\n      throw new ERR_NO_CRYPTO();\n    const blob2 = lazyBlob();\n    if (!blob2.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE(\"obj\", \"Blob\", obj);\n    const id = cryptoRandom2.randomUUID();\n    storeDataObject(id, obj[blob2.kHandle], obj.size, obj.type);\n    return `blob:nodedata:${id}`;\n  }\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname, \":\");\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n    }\n  }\n}\nObjectDefineProperties(URL.prototype, {\n  [kFormat]: { configurable: false, writable: false },\n  [SymbolToStringTag]: { configurable: true, value: \"URL\" },\n  toString: { enumerable: true },\n  href: { enumerable: true },\n  origin: { enumerable: true },\n  protocol: { enumerable: true },\n  username: { enumerable: true },\n  password: { enumerable: true },\n  host: { enumerable: true },\n  hostname: { enumerable: true },\n  port: { enumerable: true },\n  pathname: { enumerable: true },\n  search: { enumerable: true },\n  searchParams: { enumerable: true },\n  hash: { enumerable: true },\n  toJSON: { enumerable: true }\n});\nfunction update(url, params) {\n  if (!url)\n    return;\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\nfunction initSearchParams(url, init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = \"\";\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs, i);\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n      if (!seenSep)\n        out.push(\"\");\n      seenSep = false;\n      buf = \"\";\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n    if (!seenSep && code === CHAR_EQUAL) {\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n      seenSep = true;\n      buf = \"\";\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs, lastPos, i);\n      buf += \" \";\n      lastPos = i + 1;\n    } else if (!encoded) {\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n  if (pairStart === i)\n    return out;\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs, lastPos, i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out, buf);\n  if (!seenSep)\n    ArrayPrototypePush(out, \"\");\n  return out;\n}\nconst noEscape = new Int8Array([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0\n]);\nconst paramHexTable = hexTable.slice();\nparamHexTable[32] = \"+\";\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return \"\";\n  const firstEncodedParam = encodeStr(array[0], noEscape, paramHexTable);\n  const firstEncodedValue = encodeStr(array[1], noEscape, paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i], noEscape, paramHexTable);\n    const encodedValue = encodeStr(array[i + 1], noEscape, paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n  return output;\n}\nfunction defineIDLClass(proto, classStr, obj) {\n  ObjectDefineProperty(proto, SymbolToStringTag, {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: classStr\n  });\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto, key, {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto, key, {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n}\nfunction merge(out, start, mid, end, lBuffer, rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l, r, o;\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\nfunction createSearchParamsIterator(target, kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\ndefineIDLClass(URLSearchParamsIteratorPrototype, \"URLSearchParams Iterator\", {\n  next() {\n    if (!this || ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS(\"URLSearchParamsIterator\");\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: void 0,\n        done: true\n      };\n    }\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n    let result;\n    if (kind === \"key\") {\n      result = name;\n    } else if (kind === \"value\") {\n      result = value;\n    } else {\n      result = [name, value];\n    }\n    return {\n      value: result,\n      done: false\n    };\n  },\n  [inspect.custom](recurseTimes, ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS(\"URLSearchParamsIterator\");\n    if (typeof recurseTimes === \"number\" && recurseTimes < 0)\n      return ctx.stylize(\"[Object]\", \"special\");\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(ArrayPrototypeSlice(target[searchParams], index), (prev, cur, i) => {\n      const key = i % 2 === 0;\n      if (kind === \"key\" && key) {\n        ArrayPrototypePush(prev, cur);\n      } else if (kind === \"value\" && !key) {\n        ArrayPrototypePush(prev, cur);\n      } else if (kind === \"key+value\" && !key) {\n        ArrayPrototypePush(prev, [target[searchParams][index + i - 1], cur]);\n      }\n      return prev;\n    }, []);\n    const breakLn = inspect(output, innerOpts).includes(\"\\n\");\n    const outputStrs = ArrayPrototypeMap(output, (p) => inspect(p, innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\n  ${ArrayPrototypeJoin(outputStrs, \",\\n  \")}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs, \", \")}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS(\"domain\");\n  return _domainToASCII(`${domain}`);\n}\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS(\"domain\");\n  return _domainToUnicode(`${domain}`);\n}\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol,\n    hostname: typeof url.hostname === \"string\" && StringPrototypeStartsWith(url.hostname, \"[\") ? StringPrototypeSlice(url.hostname, 1, -1) : url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname || \"\"}${url.search || \"\"}`,\n    href: url.href\n  };\n  if (url.port !== \"\") {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\nconst forwardSlashRegEx = /\\//g;\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === \"%\") {\n      const third = pathname.codePointAt(n + 2) | 32;\n      if (pathname[n + 1] === \"2\" && third === 102 || pathname[n + 1] === \"5\" && third === 99) {\n        throw new ERR_INVALID_FILE_URL_PATH(\"must not include encoded \\\\ or / characters\");\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx, \"\\\\\");\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== \"\") {\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  const letter = pathname.codePointAt(1) | 32;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || sep !== \":\") {\n    throw new ERR_INVALID_FILE_URL_PATH(\"must be absolute\");\n  }\n  return pathname.slice(1);\n}\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== \"\") {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === \"%\") {\n      const third = pathname.codePointAt(n + 2) | 32;\n      if (pathname[n + 1] === \"2\" && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\"must not include encoded / characters\");\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\nfunction fileURLToPath(path2) {\n  if (typeof path2 === \"string\")\n    path2 = new URL(path2);\n  else if (!isURLInstance(path2))\n    throw new ERR_INVALID_ARG_TYPE(\"path\", [\"string\", \"URL\"], path2);\n  if (path2.protocol !== \"file:\")\n    throw new ERR_INVALID_URL_SCHEME(\"file\");\n  return isWindows ? getPathFromURLWin32(path2) : getPathFromURLPosix(path2);\n}\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath, \"%\"))\n    filepath = StringPrototypeReplace(filepath, percentRegEx, \"%25\");\n  if (!isWindows && StringPrototypeIncludes(filepath, \"\\\\\"))\n    filepath = StringPrototypeReplace(filepath, backslashRegEx, \"%5C\");\n  if (StringPrototypeIncludes(filepath, \"\\n\"))\n    filepath = StringPrototypeReplace(filepath, newlineRegEx, \"%0A\");\n  if (StringPrototypeIncludes(filepath, \"\\r\"))\n    filepath = StringPrototypeReplace(filepath, carriageReturnRegEx, \"%0D\");\n  if (StringPrototypeIncludes(filepath, \"\t\"))\n    filepath = StringPrototypeReplace(filepath, tabRegEx, \"%09\");\n  return filepath;\n}\nfunction pathToFileURL(filepath) {\n  const outURL = new URL(\"file://\");\n  if (isWindows && StringPrototypeStartsWith(filepath, \"\\\\\\\\\")) {\n    const paths = StringPrototypeSplit(filepath, \"\\\\\");\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\"filepath\", filepath, \"Missing UNC resource path\");\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\"filepath\", filepath, \"Empty UNC servername\");\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(ArrayPrototypeJoin(ArrayPrototypeSlice(paths, 3), \"/\"));\n  } else {\n    let resolved = path.resolve(filepath);\n    const filePathLast = StringPrototypeCharCodeAt(filepath, filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== path.sep)\n      resolved += \"/\";\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\nfunction constructUrl(flags, protocol, username, password, host, port, path2, query, fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : \"\";\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : \"\";\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path2 : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params, query);\n  return url;\n}\nsetURLConstructor(constructUrl);\nmodule.exports = {\n  toUSVString,\n  fileURLToPath,\n  pathToFileURL,\n  toPathIfFileURL,\n  isURLInstance,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  urlToHttpOptions,\n  formatSymbol: kFormat,\n  searchParamsSymbol: searchParams,\n  encodeStr\n};\n}"],["internal/util.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  Error,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  ReflectApply,\n  ReflectConstruct,\n  RegExpPrototypeExec,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeReplace,\n  StringPrototypeToLowerCase,\n  StringPrototypeToUpperCase,\n  Symbol,\n  SymbolFor\n} = primordials;\nconst {\n  toUSVString: _toUSVString\n} = internalBinding(\"url\");\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_NO_CRYPTO,\n    ERR_UNKNOWN_SIGNAL\n  },\n  uvErrmapGet,\n  overrideStackTrace\n} = require(\"internal/errors\");\nconst { signals } = internalBinding(\"constants\").os;\nconst {\n  getHiddenValue,\n  setHiddenValue,\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex,\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex,\n  sleep: _sleep\n} = internalBinding(\"util\");\nconst { isNativeError } = internalBinding(\"types\");\nconst noCrypto = !process.versions.openssl;\nconst experimentalWarnings = new SafeSet();\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g;\nconst unpairedSurrogateRe = /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  const match = RegExpPrototypeExec(unpairedSurrogateRe, str);\n  if (!match)\n    return str;\n  return _toUSVString(str, match.index);\n}\nlet uvBinding;\nfunction lazyUv() {\n  uvBinding ??= internalBinding(\"uv\");\n  return uvBinding;\n}\nfunction removeColors(str) {\n  return StringPrototypeReplace(str, colorRegExp, \"\");\n}\nfunction isError(e) {\n  return isNativeError(e) || e instanceof Error;\n}\nconst codesWarned = new SafeSet();\nlet validateString;\nfunction deprecate(fn, msg, code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n  if (validateString === void 0)\n    ({ validateString } = require(\"internal/validators\"));\n  if (code !== void 0)\n    validateString(code, \"code\");\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== void 0) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg, \"DeprecationWarning\", code, deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg, \"DeprecationWarning\", deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn, args, new.target);\n    }\n    return ReflectApply(fn, this, args);\n  }\n  ObjectSetPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    deprecated.prototype = fn.prototype;\n  }\n  return deprecated;\n}\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) || getHiddenValue(err, kDecoratedPrivateSymbolIndex) === true)\n    return;\n  const arrow = getHiddenValue(err, kArrowMessagePrivateSymbolIndex);\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err, kDecoratedPrivateSymbolIndex, true);\n  }\n}\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === \"utf8\" || enc === \"utf-8\")\n    return \"utf8\";\n  return slowCases(enc);\n}\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === \"UTF8\")\n        return \"utf8\";\n      if (enc === \"ucs2\" || enc === \"UCS2\")\n        return \"utf16le\";\n      enc = `${enc}`.toLowerCase();\n      if (enc === \"utf8\")\n        return \"utf8\";\n      if (enc === \"ucs2\")\n        return \"utf16le\";\n      break;\n    case 3:\n      if (enc === \"hex\" || enc === \"HEX\" || `${enc}`.toLowerCase() === \"hex\")\n        return \"hex\";\n      break;\n    case 5:\n      if (enc === \"ascii\")\n        return \"ascii\";\n      if (enc === \"ucs-2\")\n        return \"utf16le\";\n      if (enc === \"UTF-8\")\n        return \"utf8\";\n      if (enc === \"ASCII\")\n        return \"ascii\";\n      if (enc === \"UCS-2\")\n        return \"utf16le\";\n      enc = `${enc}`.toLowerCase();\n      if (enc === \"utf-8\")\n        return \"utf8\";\n      if (enc === \"ascii\")\n        return \"ascii\";\n      if (enc === \"ucs-2\")\n        return \"utf16le\";\n      break;\n    case 6:\n      if (enc === \"base64\")\n        return \"base64\";\n      if (enc === \"latin1\" || enc === \"binary\")\n        return \"latin1\";\n      if (enc === \"BASE64\")\n        return \"base64\";\n      if (enc === \"LATIN1\" || enc === \"BINARY\")\n        return \"latin1\";\n      enc = `${enc}`.toLowerCase();\n      if (enc === \"base64\")\n        return \"base64\";\n      if (enc === \"latin1\" || enc === \"binary\")\n        return \"latin1\";\n      break;\n    case 7:\n      if (enc === \"utf16le\" || enc === \"UTF16LE\" || `${enc}`.toLowerCase() === \"utf16le\")\n        return \"utf16le\";\n      break;\n    case 8:\n      if (enc === \"utf-16le\" || enc === \"UTF-16LE\" || `${enc}`.toLowerCase() === \"utf-16le\")\n        return \"utf16le\";\n      break;\n    case 9:\n      if (enc === \"base64url\" || enc === \"BASE64URL\" || `${enc}`.toLowerCase() === \"base64url\")\n        return \"base64url\";\n      break;\n    default:\n      if (enc === \"\")\n        return \"utf8\";\n  }\n}\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature))\n    return;\n  const msg = `${feature} is an experimental feature. This feature could change at any time`;\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg, \"ExperimentalWarning\");\n}\nfunction filterDuplicateStrings(items, low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key, key);\n    } else {\n      map.set(key, item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === void 0)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type, args, new.target || type);\n  }\n  ObjectDefineProperties(fn, {\n    name: { value: type.name },\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn, type);\n  fn.prototype = type.prototype;\n  return fn;\n}\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== void 0)\n    return signalsToNamesMapping;\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n  return signalsToNamesMapping;\n}\nfunction convertToValidSignal(signal) {\n  if (typeof signal === \"number\" && getSignalsToNamesMapping()[signal])\n    return signal;\n  if (typeof signal === \"string\") {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName)\n      return signalName;\n  }\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, \"constructor\");\n    if (descriptor !== void 0 && typeof descriptor.value === \"function\" && descriptor.value.name !== \"\") {\n      return descriptor.value;\n    }\n    obj = ObjectGetPrototypeOf(obj);\n  }\n  return null;\n}\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\nconst kCustomPromisifiedSymbol = SymbolFor(\"nodejs.util.promisify.custom\");\nconst kCustomPromisifyArgsSymbol = Symbol(\"customPromisifyArgs\");\nlet validateFunction;\nfunction promisify(original) {\n  if (validateFunction === void 0)\n    ({ validateFunction } = require(\"internal/validators\"));\n  validateFunction(original, \"original\");\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn2 = original[kCustomPromisifiedSymbol];\n    validateFunction(fn2, \"util.promisify.custom\");\n    return ObjectDefineProperty(fn2, kCustomPromisifiedSymbol, {\n      value: fn2,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n  function fn(...args) {\n    return new Promise((resolve, reject) => {\n      ArrayPrototypePush(args, (err, ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== void 0 && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original, this, args);\n    });\n  }\n  ObjectSetPrototypeOf(fn, ObjectGetPrototypeOf(original));\n  ObjectDefineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  });\n  return ObjectDefineProperties(fn, ObjectGetOwnPropertyDescriptors(original));\n}\npromisify.custom = kCustomPromisifiedSymbol;\nfunction join(output, separator) {\n  let str = \"\";\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\nlet getStructuredStack;\nfunction isInsideNodeModules() {\n  if (getStructuredStack === void 0) {\n    const { runInNewContext } = require(\"vm\");\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e, (err, trace) => trace);\n        return e.stack;\n      };\n    })()`, { overrideStackTrace }, { filename: \"structured-stack\" });\n  }\n  const stack = getStructuredStack();\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      if (!RegExpPrototypeTest(/^\\/|\\\\/, filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE, filename);\n    }\n  }\n  return false;\n}\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called)\n      return;\n    called = true;\n    ReflectApply(callback, this, args);\n  };\n}\nlet validateUint32;\nfunction sleep(msec) {\n  if (validateUint32 === void 0)\n    ({ validateUint32 } = require(\"internal/validators\"));\n  validateUint32(msec, \"msec\");\n  _sleep(msec);\n}\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding(\"messaging\").DOMException;\n  return _DOMException;\n};\nconst lazyDOMException = hideStackFrames((message, name) => {\n  _DOMException ??= internalBinding(\"messaging\").DOMException;\n  return new _DOMException(message, name);\n});\nfunction structuredClone(value) {\n  const {\n    DefaultSerializer,\n    DefaultDeserializer\n  } = require(\"v8\");\n  const ser = new DefaultSerializer();\n  ser._getDataCloneError = hideStackFrames((message) => lazyDOMException(message, \"DataCloneError\"));\n  ser.writeValue(value);\n  const serialized = ser.releaseBuffer();\n  const des = new DefaultDeserializer(serialized);\n  return des.readValue();\n}\nmodule.exports = {\n  assertCrypto,\n  cachedResult,\n  convertToValidSignal,\n  createClassWrapper,\n  createDeferredPromise,\n  decorateErrorStack,\n  deprecate,\n  emitExperimentalWarning,\n  filterDuplicateStrings,\n  getConstructorOf,\n  getSystemErrorMap,\n  getSystemErrorName,\n  isError,\n  isInsideNodeModules,\n  join,\n  lazyDOMException,\n  lazyDOMExceptionClass,\n  normalizeEncoding,\n  once,\n  promisify,\n  sleep,\n  spliceOne,\n  structuredClone,\n  toUSVString,\n  removeColors,\n  customPromisifyArgs: kCustomPromisifyArgsSymbol,\n  customInspectSymbol: SymbolFor(\"nodejs.util.inspect.custom\"),\n  kIsEncodingSymbol: Symbol(\"kIsEncodingSymbol\"),\n  kVmBreakFirstLineSymbol: Symbol(\"kVmBreakFirstLineSymbol\")\n};\n}"],["internal/v8_prof_polyfill.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = { versionCheck };\nif (module.id === \"internal/v8_prof_polyfill\")\n  return;\nconst fs = require(\"fs\");\nconst cp = require(\"child_process\");\nconst { Buffer } = require(\"buffer\");\nconst os = {\n  system: function(name, args) {\n    if (process.platform === \"linux\" && name === \"nm\") {\n      const arg = args[args.length - 1];\n      if (arg === \"[vdso]\" || arg === \"[vsyscall]\" || /^[0-9a-f]+-[0-9a-f]+$/.test(arg)) {\n        return \"\";\n      }\n    }\n    let out = cp.spawnSync(name, args).stdout.toString();\n    if (process.platform === \"darwin\" && name === \"nm\") {\n      const match = out.match(/(?:^|\\n)([^\\n]*xcodebuild[^\\n]*)(?:\\n|$)/);\n      if (match)\n        throw new Error(match[1]);\n      out = macCppfiltNm(out);\n    }\n    return out;\n  }\n};\nconst print = console.log;\nfunction read(fileName) {\n  return fs.readFileSync(fileName, \"utf8\");\n}\nconst quit = process.exit;\nconst logFile = globalThis.arguments[globalThis.arguments.length - 1];\ntry {\n  fs.accessSync(logFile);\n} catch {\n  console.error(\"Please provide a valid isolate file as the final argument.\");\n  process.exit(1);\n}\nconst fd = fs.openSync(logFile, \"r\");\nconst buf = Buffer.allocUnsafe(4096);\nconst dec = new (require(\"string_decoder\")).StringDecoder(\"utf-8\");\nlet line = \"\";\n{\n  const message = versionCheck(peekline(), process.versions.v8);\n  if (message)\n    console.log(message);\n}\nfunction peekline() {\n  const s = readline();\n  line = `${s}\n${line}`;\n  return s;\n}\nfunction readline() {\n  while (true) {\n    const lineBreak = line.indexOf(\"\\n\");\n    if (lineBreak !== -1) {\n      const res = line.slice(0, lineBreak);\n      line = line.slice(lineBreak + 1);\n      return res;\n    }\n    const bytes = fs.readSync(fd, buf, 0, buf.length);\n    line += dec.write(buf.slice(0, bytes));\n    if (line.length === 0) {\n      return \"\";\n    }\n    if (bytes === 0) {\n      process.emitWarning(`Profile file ${logFile} is broken`, {\n        code: \"BROKEN_PROFILE_FILE\",\n        detail: `${JSON.stringify(line)} at the file end is broken`\n      });\n      return \"\";\n    }\n  }\n}\nfunction versionCheck(firstLine, expected) {\n  firstLine = firstLine.split(\",\");\n  const curVer = expected.split(/[.-]/);\n  if (firstLine.length !== 6 && firstLine.length !== 7 || firstLine[0] !== \"v8-version\") {\n    return \"Unable to read v8-version from log file.\";\n  }\n  for (let i = 0; i < 3; i++)\n    if (curVer[i] !== firstLine[i + 1])\n      return \"Testing v8 version different from logging version\";\n}\nfunction macCppfiltNm(out) {\n  const FUNC_RE = /^([0-9a-fA-F]{8,16} [iItT] )(.*)$/gm;\n  const CLEAN_RE = /^[0-9a-fA-F]{8,16} [iItT] /;\n  let entries = out.match(FUNC_RE);\n  if (entries === null)\n    return out;\n  entries = entries.map((entry) => entry.replace(CLEAN_RE, \"\"));\n  let filtered;\n  try {\n    filtered = cp.spawnSync(\"c++filt\", [\"-p\", \"-i\"], {\n      input: entries.join(\"\\n\")\n    }).stdout.toString();\n  } catch {\n    return out;\n  }\n  let i = 0;\n  filtered = filtered.split(\"\\n\");\n  return out.replace(FUNC_RE, (all, prefix, postfix) => {\n    return prefix + (filtered[i++] || postfix);\n  });\n}\nObject.assign(globalThis, {\n  os,\n  print,\n  read,\n  quit,\n  readline\n});\n}"],["internal/v8_prof_processor.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  StringPrototypeSlice\n} = primordials;\nconst Buffer = require(\"buffer\").Buffer;\nconst console = require(\"internal/console/global\");\nconst vm = require(\"vm\");\nconst { SourceTextModule } = require(\"internal/vm/module\");\nconst natives = internalBinding(\"natives\");\nasync function linker(specifier, referencingModule) {\n  const file = StringPrototypeSlice(specifier, 2, -4);\n  const code = natives[`internal/deps/v8/tools/${file}`];\n  return new SourceTextModule(code, { context: referencingModule.context });\n}\n(async () => {\n  const tickArguments = [];\n  if (process.platform === \"darwin\") {\n    ArrayPrototypePush(tickArguments, \"--mac\");\n  } else if (process.platform === \"win32\") {\n    ArrayPrototypePush(tickArguments, \"--windows\");\n  }\n  ArrayPrototypePush(tickArguments, ...ArrayPrototypeSlice(process.argv, 1));\n  const context = vm.createContext({\n    arguments: tickArguments,\n    write(s) {\n      process.stdout.write(s);\n    },\n    printErr(err) {\n      console.error(err);\n    },\n    console,\n    process,\n    Buffer\n  });\n  const polyfill = natives[\"internal/v8_prof_polyfill\"];\n  const script = `(function(module, require) {\n    ${polyfill}\n  })`;\n  vm.runInContext(script, context)(module, require);\n  const tickProcessor = natives[\"internal/deps/v8/tools/tickprocessor-driver\"];\n  const tickprocessorDriver = new SourceTextModule(tickProcessor, { context });\n  await tickprocessorDriver.link(linker);\n  await tickprocessorDriver.evaluate();\n})();\n}"],["internal/validators.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  NumberIsInteger,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  NumberParseInt,\n  RegExpPrototypeTest,\n  String,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = primordials;\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_SOCKET_BAD_PORT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL,\n    ERR_INVALID_CALLBACK\n  }\n} = require(\"internal/errors\");\nconst { normalizeEncoding } = require(\"internal/util\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst { signals } = internalBinding(\"constants\").os;\nfunction isInt32(value) {\n  return value === (value | 0);\n}\nfunction isUint32(value) {\n  return value === value >>> 0;\n}\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = \"must be a 32-bit unsigned integer or an octal string\";\nfunction parseFileMode(value, name, def) {\n  value ??= def;\n  if (typeof value === \"string\") {\n    if (!RegExpPrototypeTest(octalReg, value)) {\n      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);\n    }\n    value = NumberParseInt(value, 8);\n  }\n  validateInt32(value, name, 0, 2 ** 32 - 1);\n  return value;\n}\nconst validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n  if (!NumberIsInteger(value))\n    throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n  if (value < min || value > max)\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n});\nconst validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {\n  if (!isInt32(value)) {\n    if (typeof value !== \"number\") {\n      throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n    }\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);\n  }\n});\nconst validateUint32 = hideStackFrames((value, name, positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== \"number\") {\n      throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name, \"an integer\", value);\n    }\n    const min = positive ? 1 : 0;\n    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name, \">= 1 && < 4294967296\", value);\n  }\n});\nfunction validateString(value, name) {\n  if (typeof value !== \"string\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"string\", value);\n}\nfunction validateNumber(value, name) {\n  if (typeof value !== \"number\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"number\", value);\n}\nconst validateOneOf = hideStackFrames((value, name, oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf, value)) {\n    const allowed = ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === \"string\" ? `'${v}'` : String(v)), \", \");\n    const reason = \"must be one of: \" + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\nfunction validateBoolean(value, name) {\n  if (typeof value !== \"boolean\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"boolean\", value);\n}\nconst validateObject = hideStackFrames((value, name, options) => {\n  const useDefaultOptions = options == null;\n  const allowArray = useDefaultOptions ? false : options.allowArray;\n  const allowFunction = useDefaultOptions ? false : options.allowFunction;\n  const nullable = useDefaultOptions ? false : options.nullable;\n  if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== \"object\" && (!allowFunction || typeof value !== \"function\")) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Object\", value);\n  }\n});\nconst validateArray = hideStackFrames((value, name, minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"Array\", value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name, value, reason);\n  }\n});\nfunction validateSignalName(signal, name = \"signal\") {\n  validateString(signal, name);\n  if (signals[signal] === void 0) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {\n      throw new ERR_UNKNOWN_SIGNAL(signal + \" (signals must use all capital letters)\");\n    }\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\nconst validateBuffer = hideStackFrames((buffer, name = \"buffer\") => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, [\"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n  }\n});\nfunction validateEncoding(data, encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n  if (normalizedEncoding === \"hex\" && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"encoding\", encoding, `is invalid for data of length ${length}`);\n  }\n}\nfunction validatePort(port, name = \"Port\", allowZero = true) {\n  if (typeof port !== \"number\" && typeof port !== \"string\" || typeof port === \"string\" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {\n    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);\n  }\n  return port | 0;\n}\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== \"function\")\n    throw new ERR_INVALID_CALLBACK(callback);\n});\nconst validateAbortSignal = hideStackFrames((signal, name) => {\n  if (signal !== void 0 && (signal === null || typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n});\nconst validateFunction = hideStackFrames((value, name) => {\n  if (typeof value !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(name, \"Function\", value);\n});\nconst validateUndefined = hideStackFrames((value, name) => {\n  if (value !== void 0)\n    throw new ERR_INVALID_ARG_TYPE(name, \"undefined\", value);\n});\nmodule.exports = {\n  isInt32,\n  isUint32,\n  parseFileMode,\n  validateArray,\n  validateBoolean,\n  validateBuffer,\n  validateEncoding,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateObject,\n  validateOneOf,\n  validatePort,\n  validateSignalName,\n  validateString,\n  validateUint32,\n  validateUndefined,\n  validateCallback,\n  validateAbortSignal\n};\n}"],["internal/watchdog.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  TraceSigintWatchdog\n} = internalBinding(\"watchdog\");\nclass SigintWatchdog extends TraceSigintWatchdog {\n  _started = false;\n  _effective = false;\n  _onNewListener = (eve) => {\n    if (eve === \"SIGINT\" && this._effective) {\n      super.stop();\n      this._effective = false;\n    }\n  };\n  _onRemoveListener = (eve) => {\n    if (eve === \"SIGINT\" && process.listenerCount(\"SIGINT\") === 0 && !this._effective) {\n      super.start();\n      this._effective = true;\n    }\n  };\n  start() {\n    if (this._started) {\n      return;\n    }\n    this._started = true;\n    process.prependListener(\"newListener\", this._onNewListener);\n    process.addListener(\"removeListener\", this._onRemoveListener);\n    if (process.listenerCount(\"SIGINT\") === 0) {\n      super.start();\n      this._effective = true;\n    }\n  }\n  stop() {\n    if (!this._started) {\n      return;\n    }\n    this._started = false;\n    process.removeListener(\"newListener\", this._onNewListener);\n    process.removeListener(\"removeListener\", this._onRemoveListener);\n    if (this._effective) {\n      super.stop();\n      this._effective = false;\n    }\n  }\n}\nmodule.exports = {\n  SigintWatchdog\n};\n}"],["internal/worker.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  Float64Array,\n  FunctionPrototypeBind,\n  JSONStringify,\n  MathMax,\n  ObjectCreate,\n  ObjectEntries,\n  Promise,\n  PromiseResolve,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  SafeMap,\n  String,\n  Symbol,\n  SymbolFor,\n  TypedArrayPrototypeFill,\n  Uint32Array,\n  globalThis: { Atomics, SharedArrayBuffer }\n} = primordials;\nconst EventEmitter = require(\"events\");\nconst assert = require(\"internal/assert\");\nconst path = require(\"path\");\nconst { now } = require(\"internal/perf/utils\");\nconst errorCodes = require(\"internal/errors\").codes;\nconst {\n  ERR_WORKER_NOT_RUNNING,\n  ERR_WORKER_PATH,\n  ERR_WORKER_UNSERIALIZABLE_ERROR,\n  ERR_WORKER_INVALID_EXEC_ARGV,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE\n} = errorCodes;\nconst { getOptionValue } = require(\"internal/options\");\nconst workerIo = require(\"internal/worker/io\");\nconst {\n  drainMessagePort,\n  MessageChannel,\n  messageTypes,\n  kPort,\n  kIncrementsPortRef,\n  kWaitingStreams,\n  kStdioWantsMoreDataCallback,\n  setupPortReferencing,\n  ReadableWorkerStdio,\n  WritableWorkerStdio\n} = workerIo;\nconst { deserializeError } = require(\"internal/error_serdes\");\nconst { fileURLToPath, isURLInstance, pathToFileURL } = require(\"internal/url\");\nconst { validateArray } = require(\"internal/validators\");\nconst {\n  ownsProcessState,\n  isMainThread,\n  resourceLimits: resourceLimitsRaw,\n  threadId,\n  Worker: WorkerImpl,\n  kMaxYoungGenerationSizeMb,\n  kMaxOldGenerationSizeMb,\n  kCodeRangeSizeMb,\n  kStackSizeMb,\n  kTotalResourceLimitCount\n} = internalBinding(\"worker\");\nconst kHandle = Symbol(\"kHandle\");\nconst kPublicPort = Symbol(\"kPublicPort\");\nconst kDispose = Symbol(\"kDispose\");\nconst kOnExit = Symbol(\"kOnExit\");\nconst kOnMessage = Symbol(\"kOnMessage\");\nconst kOnCouldNotSerializeErr = Symbol(\"kOnCouldNotSerializeErr\");\nconst kOnErrorMessage = Symbol(\"kOnErrorMessage\");\nconst kParentSideStdio = Symbol(\"kParentSideStdio\");\nconst kLoopStartTime = Symbol(\"kLoopStartTime\");\nconst kIsOnline = Symbol(\"kIsOnline\");\nconst SHARE_ENV = SymbolFor(\"nodejs.worker_threads.SHARE_ENV\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"worker\", (fn) => {\n  debug = fn;\n});\nlet cwdCounter;\nconst environmentData = new SafeMap();\nif (isMainThread) {\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\n  const originalChdir = process.chdir;\n  process.chdir = function(path2) {\n    Atomics.add(cwdCounter, 0, 1);\n    originalChdir(path2);\n  };\n}\nfunction setEnvironmentData(key, value) {\n  if (value === void 0)\n    environmentData.delete(key);\n  else\n    environmentData.set(key, value);\n}\nfunction getEnvironmentData(key) {\n  return environmentData.get(key);\n}\nfunction assignEnvironmentData(data) {\n  if (data === void 0)\n    return;\n  data.forEach((value, key) => {\n    environmentData.set(key, value);\n  });\n}\nclass Worker extends EventEmitter {\n  constructor(filename, options = {}) {\n    super();\n    debug(`[${threadId}] create new worker`, filename, options);\n    if (options.execArgv && !ArrayIsArray(options.execArgv)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.execArgv\", \"Array\", options.execArgv);\n    }\n    let argv;\n    if (options.argv) {\n      validateArray(options.argv, \"options.argv\");\n      argv = ArrayPrototypeMap(options.argv, String);\n    }\n    let url, doEval;\n    if (options.eval) {\n      if (typeof filename !== \"string\") {\n        throw new ERR_INVALID_ARG_VALUE(\"options.eval\", options.eval, \"must be false when 'filename' is not a string\");\n      }\n      url = null;\n      doEval = \"classic\";\n    } else if (isURLInstance(filename) && filename.protocol === \"data:\") {\n      url = null;\n      doEval = \"module\";\n      filename = `import ${JSONStringify(`${filename}`)}`;\n    } else {\n      doEval = false;\n      if (isURLInstance(filename)) {\n        url = filename;\n        filename = fileURLToPath(filename);\n      } else if (typeof filename !== \"string\") {\n        throw new ERR_INVALID_ARG_TYPE(\"filename\", [\"string\", \"URL\"], filename);\n      } else if (path.isAbsolute(filename) || RegExpPrototypeTest(/^\\.\\.?[\\\\/]/, filename)) {\n        filename = path.resolve(filename);\n        url = pathToFileURL(filename);\n      } else {\n        throw new ERR_WORKER_PATH(filename);\n      }\n    }\n    let env;\n    if (typeof options.env === \"object\" && options.env !== null) {\n      env = ObjectCreate(null);\n      ArrayPrototypeForEach(ObjectEntries(options.env), ({ 0: key, 1: value }) => {\n        env[key] = `${value}`;\n      });\n    } else if (options.env == null) {\n      env = process.env;\n    } else if (options.env !== SHARE_ENV) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.env\", [\"object\", \"undefined\", \"null\", \"worker_threads.SHARE_ENV\"], options.env);\n    }\n    this[kHandle] = new WorkerImpl(url, env === process.env ? null : env, options.execArgv, parseResourceLimits(options.resourceLimits), !!(options.trackUnmanagedFds ?? true));\n    if (this[kHandle].invalidExecArgv) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\n    }\n    if (this[kHandle].invalidNodeOptions) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidNodeOptions, \"invalid NODE_OPTIONS env variable\");\n    }\n    this[kHandle].onexit = (code, customErr, customErrReason) => {\n      this[kOnExit](code, customErr, customErrReason);\n    };\n    this[kPort] = this[kHandle].messagePort;\n    this[kPort].on(\"message\", (data) => this[kOnMessage](data));\n    this[kPort].start();\n    this[kPort].unref();\n    this[kPort][kWaitingStreams] = 0;\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n    let stdin = null;\n    if (options.stdin)\n      stdin = new WritableWorkerStdio(this[kPort], \"stdin\");\n    const stdout = new ReadableWorkerStdio(this[kPort], \"stdout\");\n    if (!options.stdout) {\n      stdout[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stdout, process.stdout);\n    }\n    const stderr = new ReadableWorkerStdio(this[kPort], \"stderr\");\n    if (!options.stderr) {\n      stderr[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stderr, process.stderr);\n    }\n    this[kParentSideStdio] = { stdin, stdout, stderr };\n    const { port1, port2 } = new MessageChannel();\n    const transferList = [port2];\n    if (options.transferList)\n      ArrayPrototypePush(transferList, ...new SafeArrayIterator(options.transferList));\n    this[kPublicPort] = port1;\n    ArrayPrototypeForEach([\"message\", \"messageerror\"], (event) => {\n      this[kPublicPort].on(event, (message) => this.emit(event, message));\n    });\n    setupPortReferencing(this[kPublicPort], this, \"message\");\n    this[kPort].postMessage({\n      argv,\n      type: messageTypes.LOAD_SCRIPT,\n      filename,\n      doEval,\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter,\n      workerData: options.workerData,\n      environmentData,\n      publicPort: port2,\n      manifestURL: getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\").url : null,\n      manifestSrc: getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\").src : null,\n      hasStdin: !!options.stdin\n    }, transferList);\n    this[kLoopStartTime] = -1;\n    this[kIsOnline] = false;\n    this.performance = {\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization, this)\n    };\n    this[kHandle].startThread();\n    process.nextTick(() => process.emit(\"worker\", this));\n  }\n  [kOnExit](code, customErr, customErrReason) {\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n    drainMessagePort(this[kPublicPort]);\n    drainMessagePort(this[kPort]);\n    this.removeAllListeners(\"message\");\n    this.removeAllListeners(\"messageerrors\");\n    this[kPublicPort].unref();\n    this[kPort].unref();\n    this[kDispose]();\n    if (customErr) {\n      debug(`[${threadId}] failing with custom error ${customErr}         and with reason ${customErrReason}`);\n      this.emit(\"error\", new errorCodes[customErr](customErrReason));\n    }\n    this.emit(\"exit\", code);\n    this.removeAllListeners();\n  }\n  [kOnCouldNotSerializeErr]() {\n    this.emit(\"error\", new ERR_WORKER_UNSERIALIZABLE_ERROR());\n  }\n  [kOnErrorMessage](serialized) {\n    const error = deserializeError(serialized);\n    this.emit(\"error\", error);\n  }\n  [kOnMessage](message) {\n    switch (message.type) {\n      case messageTypes.UP_AND_RUNNING:\n        this[kIsOnline] = true;\n        return this.emit(\"online\");\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\n        return this[kOnCouldNotSerializeErr]();\n      case messageTypes.ERROR_MESSAGE:\n        return this[kOnErrorMessage](message.error);\n      case messageTypes.STDIO_PAYLOAD: {\n        const { stream, chunks } = message;\n        const readable = this[kParentSideStdio][stream];\n        ArrayPrototypeForEach(chunks, ({ chunk, encoding }) => {\n          readable.push(chunk, encoding);\n        });\n        return;\n      }\n      case messageTypes.STDIO_WANTS_MORE_DATA: {\n        const { stream } = message;\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n      }\n    }\n    assert.fail(`Unknown worker message type ${message.type}`);\n  }\n  [kDispose]() {\n    this[kHandle].onexit = null;\n    this[kHandle] = null;\n    this[kPort] = null;\n    this[kPublicPort] = null;\n    const { stdout, stderr } = this[kParentSideStdio];\n    if (!stdout.readableEnded) {\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n      stdout.push(null);\n    }\n    if (!stderr.readableEnded) {\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n      stderr.push(null);\n    }\n  }\n  postMessage(...args) {\n    if (this[kPublicPort] === null)\n      return;\n    ReflectApply(this[kPublicPort].postMessage, this[kPublicPort], args);\n  }\n  terminate(callback) {\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n    this.ref();\n    if (typeof callback === \"function\") {\n      process.emitWarning(\"Passing a callback to worker.terminate() is deprecated. It returns a Promise instead.\", \"DeprecationWarning\", \"DEP0132\");\n      if (this[kHandle] === null)\n        return PromiseResolve();\n      this.once(\"exit\", (exitCode) => callback(null, exitCode));\n    }\n    if (this[kHandle] === null)\n      return PromiseResolve();\n    this[kHandle].stopThread();\n    return new Promise((resolve) => {\n      this.once(\"exit\", resolve);\n    });\n  }\n  ref() {\n    if (this[kHandle] === null)\n      return;\n    this[kHandle].ref();\n    this[kPublicPort].ref();\n  }\n  unref() {\n    if (this[kHandle] === null)\n      return;\n    this[kHandle].unref();\n    this[kPublicPort].unref();\n  }\n  get threadId() {\n    if (this[kHandle] === null)\n      return -1;\n    return this[kHandle].threadId;\n  }\n  get stdin() {\n    return this[kParentSideStdio].stdin;\n  }\n  get stdout() {\n    return this[kParentSideStdio].stdout;\n  }\n  get stderr() {\n    return this[kParentSideStdio].stderr;\n  }\n  get resourceLimits() {\n    if (this[kHandle] === null)\n      return {};\n    return makeResourceLimits(this[kHandle].getResourceLimits());\n  }\n  getHeapSnapshot() {\n    const heapSnapshotTaker = this[kHandle] && this[kHandle].takeHeapSnapshot();\n    return new Promise((resolve, reject) => {\n      if (!heapSnapshotTaker)\n        return reject(new ERR_WORKER_NOT_RUNNING());\n      heapSnapshotTaker.ondone = (handle) => {\n        const { HeapSnapshotStream } = require(\"internal/heap_utils\");\n        resolve(new HeapSnapshotStream(handle));\n      };\n    });\n  }\n}\nfunction pipeWithoutWarning(source, dest) {\n  const sourceMaxListeners = source._maxListeners;\n  const destMaxListeners = dest._maxListeners;\n  source.setMaxListeners(Infinity);\n  dest.setMaxListeners(Infinity);\n  source.pipe(dest);\n  source._maxListeners = sourceMaxListeners;\n  dest._maxListeners = destMaxListeners;\n}\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\nfunction parseResourceLimits(obj) {\n  const ret = resourceLimitsArray;\n  TypedArrayPrototypeFill(ret, -1);\n  if (typeof obj !== \"object\" || obj === null)\n    return ret;\n  if (typeof obj.maxOldGenerationSizeMb === \"number\")\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb, 2);\n  if (typeof obj.maxYoungGenerationSizeMb === \"number\")\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\n  if (typeof obj.codeRangeSizeMb === \"number\")\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\n  if (typeof obj.stackSizeMb === \"number\")\n    ret[kStackSizeMb] = obj.stackSizeMb;\n  return ret;\n}\nfunction makeResourceLimits(float64arr) {\n  return {\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb],\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb],\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb],\n    stackSizeMb: float64arr[kStackSizeMb]\n  };\n}\nfunction eventLoopUtilization(util1, util2) {\n  if (!this[kIsOnline] || !this[kHandle]) {\n    return { idle: 0, active: 0, utilization: 0 };\n  }\n  if (this[kLoopStartTime] === -1) {\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\n    if (this[kLoopStartTime] === -1)\n      return { idle: 0, active: 0, utilization: 0 };\n  }\n  if (util2) {\n    const idle2 = util1.idle - util2.idle;\n    const active2 = util1.active - util2.active;\n    return { idle: idle2, active: active2, utilization: active2 / (idle2 + active2) };\n  }\n  const idle = this[kHandle].loopIdleTime();\n  const active = now() - this[kLoopStartTime] - idle;\n  if (!util1) {\n    return { idle, active, utilization: active / (idle + active) };\n  }\n  const idle_delta = idle - util1.idle;\n  const active_delta = active - util1.active;\n  const utilization = active_delta / (idle_delta + active_delta);\n  return { idle: idle_delta, active: active_delta, utilization };\n}\nmodule.exports = {\n  ownsProcessState,\n  isMainThread,\n  SHARE_ENV,\n  resourceLimits: !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {},\n  setEnvironmentData,\n  getEnvironmentData,\n  assignEnvironmentData,\n  threadId,\n  Worker\n};\n}"],["path/posix.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"path\").posix;\n}"],["path/win32.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"path\").win32;\n}"],["readline/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Promise\n} = primordials;\nconst {\n  Readline\n} = require(\"internal/readline/promises\");\nconst {\n  Interface: _Interface,\n  kQuestionCancel\n} = require(\"internal/readline/interface\");\nconst {\n  AbortError\n} = require(\"internal/errors\");\nconst { validateAbortSignal } = require(\"internal/validators\");\nclass Interface extends _Interface {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  question(query, options = {}) {\n    return new Promise((resolve, reject) => {\n      let cb = resolve;\n      if (options?.signal) {\n        validateAbortSignal(options.signal, \"options.signal\");\n        if (options.signal.aborted) {\n          return reject(new AbortError());\n        }\n        const onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError());\n        };\n        options.signal.addEventListener(\"abort\", onAbort, { once: true });\n        cb = (answer) => {\n          options.signal.removeEventListener(\"abort\", onAbort);\n          resolve(answer);\n        };\n      }\n      super.question(query, cb);\n    });\n  }\n}\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\nmodule.exports = {\n  Interface,\n  Readline,\n  createInterface\n};\n}"],["stream/consumers.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  JSONParse\n} = primordials;\nconst {\n  TextDecoder\n} = require(\"internal/encoding\");\nconst {\n  Blob\n} = require(\"internal/blob\");\nconst {\n  Buffer\n} = require(\"buffer\");\nasync function blob(stream) {\n  const chunks = [];\n  for await (const chunk of stream)\n    chunks.push(chunk);\n  return new Blob(chunks);\n}\nasync function arrayBuffer(stream) {\n  const ret = await blob(stream);\n  return ret.arrayBuffer();\n}\nasync function buffer(stream) {\n  return Buffer.from(await arrayBuffer(stream));\n}\nasync function text(stream) {\n  const dec = new TextDecoder();\n  let str = \"\";\n  for await (const chunk of stream) {\n    if (typeof chunk === \"string\")\n      str += chunk;\n    else\n      str += dec.decode(chunk, { stream: true });\n  }\n  str += dec.decode(void 0, { stream: false });\n  return str;\n}\nasync function json(stream) {\n  const str = await text(stream);\n  return JSONParse(str);\n}\nmodule.exports = {\n  arrayBuffer,\n  blob,\n  buffer,\n  text,\n  json\n};\n}"],["stream/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePop,\n  Promise\n} = primordials;\nconst {\n  isIterable,\n  isNodeStream\n} = require(\"internal/streams/utils\");\nconst { pipelineImpl: pl } = require(\"internal/streams/pipeline\");\nconst eos = require(\"internal/streams/end-of-stream\");\nfunction pipeline(...streams) {\n  return new Promise((resolve, reject) => {\n    let signal;\n    const lastArg = streams[streams.length - 1];\n    if (lastArg && typeof lastArg === \"object\" && !isNodeStream(lastArg) && !isIterable(lastArg)) {\n      const options = ArrayPrototypePop(streams);\n      signal = options.signal;\n    }\n    pl(streams, (err, value) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(value);\n      }\n    }, { signal });\n  });\n}\nfunction finished(stream, opts) {\n  return new Promise((resolve, reject) => {\n    eos(stream, opts, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nmodule.exports = {\n  finished,\n  pipeline\n};\n}"],["stream/web.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  emitExperimentalWarning\n} = require(\"internal/util\");\nemitExperimentalWarning(\"stream/web\");\nconst {\n  TransformStream,\n  TransformStreamDefaultController\n} = require(\"internal/webstreams/transformstream\");\nconst {\n  WritableStream,\n  WritableStreamDefaultController,\n  WritableStreamDefaultWriter\n} = require(\"internal/webstreams/writablestream\");\nconst {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController\n} = require(\"internal/webstreams/readablestream\");\nconst {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy\n} = require(\"internal/webstreams/queuingstrategies\");\nconst {\n  TextEncoderStream,\n  TextDecoderStream\n} = require(\"internal/webstreams/encoding\");\nconst {\n  CompressionStream,\n  DecompressionStream\n} = require(\"internal/webstreams/compression\");\nmodule.exports = {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController,\n  TransformStream,\n  TransformStreamDefaultController,\n  WritableStream,\n  WritableStreamDefaultWriter,\n  WritableStreamDefaultController,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TextEncoderStream,\n  TextDecoderStream,\n  CompressionStream,\n  DecompressionStream\n};\n}"],["timers/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  Promise,\n  PromiseReject,\n  SafePromisePrototypeFinally\n} = primordials;\nconst {\n  Timeout,\n  Immediate,\n  insert\n} = require(\"internal/timers\");\nconst {\n  AbortError,\n  codes: { ERR_INVALID_ARG_TYPE }\n} = require(\"internal/errors\");\nconst {\n  validateAbortSignal,\n  validateBoolean,\n  validateObject\n} = require(\"internal/validators\");\nfunction cancelListenerHandler(clear, reject) {\n  if (!this._destroyed) {\n    clear(this);\n    reject(new AbortError());\n  }\n}\nfunction setTimeout(after, value, options = {}) {\n  const args = value !== void 0 ? [value] : value;\n  if (options == null || typeof options !== \"object\") {\n    return PromiseReject(new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options));\n  }\n  const { signal, ref = true } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (err) {\n    return PromiseReject(err);\n  }\n  if (typeof ref !== \"boolean\") {\n    return PromiseReject(new ERR_INVALID_ARG_TYPE(\"options.ref\", \"boolean\", ref));\n  }\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError());\n  }\n  let oncancel;\n  const ret = new Promise((resolve, reject) => {\n    const timeout = new Timeout(resolve, after, args, false, ref);\n    insert(timeout, timeout._idleTimeout);\n    if (signal) {\n      oncancel = FunctionPrototypeBind(cancelListenerHandler, timeout, clearTimeout, reject);\n      signal.addEventListener(\"abort\", oncancel);\n    }\n  });\n  return oncancel !== void 0 ? SafePromisePrototypeFinally(ret, () => signal.removeEventListener(\"abort\", oncancel)) : ret;\n}\nfunction setImmediate(value, options = {}) {\n  if (options == null || typeof options !== \"object\") {\n    return PromiseReject(new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options));\n  }\n  const { signal, ref = true } = options;\n  try {\n    validateAbortSignal(signal, \"options.signal\");\n  } catch (err) {\n    return PromiseReject(err);\n  }\n  if (typeof ref !== \"boolean\") {\n    return PromiseReject(new ERR_INVALID_ARG_TYPE(\"options.ref\", \"boolean\", ref));\n  }\n  if (signal && signal.aborted) {\n    return PromiseReject(new AbortError());\n  }\n  let oncancel;\n  const ret = new Promise((resolve, reject) => {\n    const immediate = new Immediate(resolve, [value]);\n    if (!ref)\n      immediate.unref();\n    if (signal) {\n      oncancel = FunctionPrototypeBind(cancelListenerHandler, immediate, clearImmediate, reject);\n      signal.addEventListener(\"abort\", oncancel);\n    }\n  });\n  return oncancel !== void 0 ? SafePromisePrototypeFinally(ret, () => signal.removeEventListener(\"abort\", oncancel)) : ret;\n}\nasync function* setInterval(after, value, options = {}) {\n  validateObject(options, \"options\");\n  const { signal, ref = true } = options;\n  validateAbortSignal(signal, \"options.signal\");\n  validateBoolean(ref, \"options.ref\");\n  if (signal?.aborted)\n    throw new AbortError();\n  let onCancel;\n  let interval;\n  try {\n    let notYielded = 0;\n    let callback;\n    interval = new Timeout(() => {\n      notYielded++;\n      if (callback) {\n        callback();\n        callback = void 0;\n      }\n    }, after, void 0, true, ref);\n    insert(interval, interval._idleTimeout);\n    if (signal) {\n      onCancel = () => {\n        clearInterval(interval);\n        if (callback) {\n          callback(PromiseReject(new AbortError()));\n          callback = void 0;\n        }\n      };\n      signal.addEventListener(\"abort\", onCancel, { once: true });\n    }\n    while (!signal?.aborted) {\n      if (notYielded === 0) {\n        await new Promise((resolve) => callback = resolve);\n      }\n      for (; notYielded > 0; notYielded--) {\n        yield value;\n      }\n    }\n    throw new AbortError();\n  } finally {\n    clearInterval(interval);\n    signal?.removeEventListener(\"abort\", onCancel);\n  }\n}\nmodule.exports = {\n  setTimeout,\n  setImmediate,\n  setInterval\n};\n}"],["util/types.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"internal/util/types\");\n}"],["internal/assert/assertion_error.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  Error,\n  ErrorCaptureStackTrace,\n  MathMax,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeRepeat,\n  StringPrototypeSlice,\n  StringPrototypeSplit\n} = primordials;\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  removeColors\n} = require(\"internal/util\");\nconst {\n  validateObject\n} = require(\"internal/validators\");\nconst { isErrorStackTraceLimitWritable } = require(\"internal/errors\");\nlet blue = \"\";\nlet green = \"\";\nlet red = \"\";\nlet white = \"\";\nconst kReadableOperator = {\n  deepStrictEqual: \"Expected values to be strictly deep-equal:\",\n  strictEqual: \"Expected values to be strictly equal:\",\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n  deepEqual: \"Expected values to be loosely deep-equal:\",\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notIdentical: \"Values have same structure but are not reference-equal:\",\n  notDeepEqualUnequal: \"Expected values not to be loosely deep-equal:\"\n};\nconst kMaxShortLength = 12;\nfunction copyError(source) {\n  const keys = ObjectKeys(source);\n  const target = ObjectCreate(ObjectGetPrototypeOf(source));\n  for (const key of keys) {\n    target[key] = source[key];\n  }\n  ObjectDefineProperty(target, \"message\", { value: source.message });\n  return target;\n}\nfunction inspectValue(val) {\n  return inspect(val, {\n    compact: false,\n    customInspect: false,\n    depth: 1e3,\n    maxArrayLength: Infinity,\n    showHidden: false,\n    showProxy: false,\n    sorted: true,\n    getters: true\n  });\n}\nfunction createErrDiff(actual, expected, operator) {\n  let other = \"\";\n  let res = \"\";\n  let end = \"\";\n  let skipped = false;\n  const actualInspected = inspectValue(actual);\n  const actualLines = StringPrototypeSplit(actualInspected, \"\\n\");\n  const expectedLines = StringPrototypeSplit(inspectValue(expected), \"\\n\");\n  let i = 0;\n  let indicator = \"\";\n  if (operator === \"strictEqual\" && (typeof actual === \"object\" && actual !== null && typeof expected === \"object\" && expected !== null || typeof actual === \"function\" && typeof expected === \"function\")) {\n    operator = \"strictEqualObject\";\n  }\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n    const c = inspect.defaultOptions.colors;\n    const actualRaw = c ? removeColors(actualLines[0]) : actualLines[0];\n    const expectedRaw = c ? removeColors(expectedLines[0]) : expectedLines[0];\n    const inputLength = actualRaw.length + expectedRaw.length;\n    if (inputLength <= kMaxShortLength) {\n      if ((typeof actual !== \"object\" || actual === null) && (typeof expected !== \"object\" || expected === null) && (actual !== 0 || expected !== 0)) {\n        return `${kReadableOperator[operator]}\n\n${actualLines[0]} !== ${expectedLines[0]}\n`;\n      }\n    } else if (operator !== \"strictEqualObject\") {\n      const maxLength2 = process.stderr.isTTY ? process.stderr.columns : 80;\n      if (inputLength < maxLength2) {\n        while (actualRaw[i] === expectedRaw[i]) {\n          i++;\n        }\n        if (i > 2) {\n          indicator = `\n  ${StringPrototypeRepeat(\" \", i)}^`;\n          i = 0;\n        }\n      }\n    }\n  }\n  let a = actualLines[actualLines.length - 1];\n  let b = expectedLines[expectedLines.length - 1];\n  while (a === b) {\n    if (i++ < 3) {\n      end = `\n  ${a}${end}`;\n    } else {\n      other = a;\n    }\n    ArrayPrototypePop(actualLines);\n    ArrayPrototypePop(expectedLines);\n    if (actualLines.length === 0 || expectedLines.length === 0)\n      break;\n    a = actualLines[actualLines.length - 1];\n    b = expectedLines[expectedLines.length - 1];\n  }\n  const maxLines = MathMax(actualLines.length, expectedLines.length);\n  if (maxLines === 0) {\n    const actualLines2 = StringPrototypeSplit(actualInspected, \"\\n\");\n    if (actualLines2.length > 50) {\n      actualLines2[46] = `${blue}...${white}`;\n      while (actualLines2.length > 47) {\n        ArrayPrototypePop(actualLines2);\n      }\n    }\n    return `${kReadableOperator.notIdentical}\n\n${ArrayPrototypeJoin(actualLines2, \"\\n\")}\n`;\n  }\n  if (i >= 5) {\n    end = `\n${blue}...${white}${end}`;\n    skipped = true;\n  }\n  if (other !== \"\") {\n    end = `\n  ${other}${end}`;\n    other = \"\";\n  }\n  let printedLines = 0;\n  let identical = 0;\n  const msg = kReadableOperator[operator] + `\n${green}+ actual${white} ${red}- expected${white}`;\n  const skippedMsg = ` ${blue}...${white} Lines skipped`;\n  let lines = actualLines;\n  let plusMinus = `${green}+${white}`;\n  let maxLength = expectedLines.length;\n  if (actualLines.length < maxLines) {\n    lines = expectedLines;\n    plusMinus = `${red}-${white}`;\n    maxLength = actualLines.length;\n  }\n  for (i = 0; i < maxLines; i++) {\n    if (maxLength < i + 1) {\n      if (identical > 2) {\n        if (identical > 3) {\n          if (identical > 4) {\n            if (identical === 5) {\n              res += `\n  ${lines[i - 3]}`;\n              printedLines++;\n            } else {\n              res += `\n${blue}...${white}`;\n              skipped = true;\n            }\n          }\n          res += `\n  ${lines[i - 2]}`;\n          printedLines++;\n        }\n        res += `\n  ${lines[i - 1]}`;\n        printedLines++;\n      }\n      identical = 0;\n      if (lines === actualLines) {\n        res += `\n${plusMinus} ${lines[i]}`;\n      } else {\n        other += `\n${plusMinus} ${lines[i]}`;\n      }\n      printedLines++;\n    } else {\n      const expectedLine = expectedLines[i];\n      let actualLine = actualLines[i];\n      let divergingLines = actualLine !== expectedLine && (!StringPrototypeEndsWith(actualLine, \",\") || StringPrototypeSlice(actualLine, 0, -1) !== expectedLine);\n      if (divergingLines && StringPrototypeEndsWith(expectedLine, \",\") && StringPrototypeSlice(expectedLine, 0, -1) === actualLine) {\n        divergingLines = false;\n        actualLine += \",\";\n      }\n      if (divergingLines) {\n        if (identical > 2) {\n          if (identical > 3) {\n            if (identical > 4) {\n              if (identical === 5) {\n                res += `\n  ${actualLines[i - 3]}`;\n                printedLines++;\n              } else {\n                res += `\n${blue}...${white}`;\n                skipped = true;\n              }\n            }\n            res += `\n  ${actualLines[i - 2]}`;\n            printedLines++;\n          }\n          res += `\n  ${actualLines[i - 1]}`;\n          printedLines++;\n        }\n        identical = 0;\n        res += `\n${green}+${white} ${actualLine}`;\n        other += `\n${red}-${white} ${expectedLine}`;\n        printedLines += 2;\n      } else {\n        res += other;\n        other = \"\";\n        identical++;\n        if (identical <= 2) {\n          res += `\n  ${actualLine}`;\n          printedLines++;\n        }\n      }\n    }\n    if (printedLines > 50 && i < maxLines - 2) {\n      return `${msg}${skippedMsg}\n${res}\n${blue}...${white}${other}\n${blue}...${white}`;\n    }\n  }\n  return `${msg}${skipped ? skippedMsg : \"\"}\n${res}${other}${end}${indicator}`;\n}\nfunction addEllipsis(string) {\n  const lines = StringPrototypeSplit(string, \"\\n\", 11);\n  if (lines.length > 10) {\n    lines.length = 10;\n    return `${ArrayPrototypeJoin(lines, \"\\n\")}\n...`;\n  } else if (string.length > 512) {\n    return `${StringPrototypeSlice(string, 512)}...`;\n  }\n  return string;\n}\nclass AssertionError extends Error {\n  constructor(options) {\n    validateObject(options, \"options\");\n    const {\n      message,\n      operator,\n      stackStartFn,\n      details,\n      stackStartFunction\n    } = options;\n    let {\n      actual,\n      expected\n    } = options;\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = 0;\n    if (message != null) {\n      super(String(message));\n    } else {\n      if (process.stderr.isTTY) {\n        if (process.stderr.hasColors()) {\n          blue = \"\u001b[34m\";\n          green = \"\u001b[32m\";\n          white = \"\u001b[39m\";\n          red = \"\u001b[31m\";\n        } else {\n          blue = \"\";\n          green = \"\";\n          white = \"\";\n          red = \"\";\n        }\n      }\n      if (typeof actual === \"object\" && actual !== null && typeof expected === \"object\" && expected !== null && \"stack\" in actual && actual instanceof Error && \"stack\" in expected && expected instanceof Error) {\n        actual = copyError(actual);\n        expected = copyError(expected);\n      }\n      if (operator === \"deepStrictEqual\" || operator === \"strictEqual\") {\n        super(createErrDiff(actual, expected, operator));\n      } else if (operator === \"notDeepStrictEqual\" || operator === \"notStrictEqual\") {\n        let base = kReadableOperator[operator];\n        const res = StringPrototypeSplit(inspectValue(actual), \"\\n\");\n        if (operator === \"notStrictEqual\" && (typeof actual === \"object\" && actual !== null || typeof actual === \"function\")) {\n          base = kReadableOperator.notStrictEqualObject;\n        }\n        if (res.length > 50) {\n          res[46] = `${blue}...${white}`;\n          while (res.length > 47) {\n            ArrayPrototypePop(res);\n          }\n        }\n        if (res.length === 1) {\n          super(`${base}${res[0].length > 5 ? \"\\n\\n\" : \" \"}${res[0]}`);\n        } else {\n          super(`${base}\n\n${ArrayPrototypeJoin(res, \"\\n\")}\n`);\n        }\n      } else {\n        let res = inspectValue(actual);\n        let other = inspectValue(expected);\n        const knownOperator = kReadableOperator[operator];\n        if (operator === \"notDeepEqual\" && res === other) {\n          res = `${knownOperator}\n\n${res}`;\n          if (res.length > 1024) {\n            res = `${StringPrototypeSlice(res, 0, 1021)}...`;\n          }\n          super(res);\n        } else {\n          if (res.length > 512) {\n            res = `${StringPrototypeSlice(res, 0, 509)}...`;\n          }\n          if (other.length > 512) {\n            other = `${StringPrototypeSlice(other, 0, 509)}...`;\n          }\n          if (operator === \"deepEqual\") {\n            res = `${knownOperator}\n\n${res}\n\nshould loosely deep-equal\n\n`;\n          } else {\n            const newOp = kReadableOperator[`${operator}Unequal`];\n            if (newOp) {\n              res = `${newOp}\n\n${res}\n\nshould not loosely deep-equal\n\n`;\n            } else {\n              other = ` ${operator} ${other}`;\n            }\n          }\n          super(`${res}${other}`);\n        }\n      }\n    }\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = limit;\n    this.generatedMessage = !message;\n    ObjectDefineProperty(this, \"name\", {\n      value: \"AssertionError [ERR_ASSERTION]\",\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    this.code = \"ERR_ASSERTION\";\n    if (details) {\n      this.actual = void 0;\n      this.expected = void 0;\n      this.operator = void 0;\n      for (let i = 0; i < details.length; i++) {\n        this[\"message \" + i] = details[i].message;\n        this[\"actual \" + i] = details[i].actual;\n        this[\"expected \" + i] = details[i].expected;\n        this[\"operator \" + i] = details[i].operator;\n        this[\"stack trace \" + i] = details[i].stack;\n      }\n    } else {\n      this.actual = actual;\n      this.expected = expected;\n      this.operator = operator;\n    }\n    ErrorCaptureStackTrace(this, stackStartFn || stackStartFunction);\n    this.stack;\n    this.name = \"AssertionError\";\n  }\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n  [inspect.custom](recurseTimes, ctx) {\n    const tmpActual = this.actual;\n    const tmpExpected = this.expected;\n    if (typeof this.actual === \"string\") {\n      this.actual = addEllipsis(this.actual);\n    }\n    if (typeof this.expected === \"string\") {\n      this.expected = addEllipsis(this.expected);\n    }\n    const result = inspect(this, {\n      ...ctx,\n      customInspect: false,\n      depth: 0\n    });\n    this.actual = tmpActual;\n    this.expected = tmpExpected;\n    return result;\n  }\n}\nmodule.exports = AssertionError;\n}"],["internal/assert/calltracker.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  Error,\n  FunctionPrototype,\n  ReflectApply,\n  SafeSet\n} = primordials;\nconst {\n  codes: {\n    ERR_UNAVAILABLE_DURING_EXIT\n  }\n} = require(\"internal/errors\");\nconst AssertionError = require(\"internal/assert/assertion_error\");\nconst {\n  validateUint32\n} = require(\"internal/validators\");\nconst noop = FunctionPrototype;\nclass CallTracker {\n  #callChecks = new SafeSet();\n  calls(fn, exact = 1) {\n    if (process._exiting)\n      throw new ERR_UNAVAILABLE_DURING_EXIT();\n    if (typeof fn === \"number\") {\n      exact = fn;\n      fn = noop;\n    } else if (fn === void 0) {\n      fn = noop;\n    }\n    validateUint32(exact, \"exact\", true);\n    const context = {\n      exact,\n      actual: 0,\n      stackTrace: new Error(),\n      name: fn.name || \"calls\"\n    };\n    const callChecks = this.#callChecks;\n    callChecks.add(context);\n    return function() {\n      context.actual++;\n      if (context.actual === context.exact) {\n        callChecks.delete(context);\n      }\n      if (context.actual === context.exact + 1) {\n        callChecks.add(context);\n      }\n      return ReflectApply(fn, this, arguments);\n    };\n  }\n  report() {\n    const errors = [];\n    for (const context of this.#callChecks) {\n      if (context.actual !== context.exact) {\n        const message = `Expected the ${context.name} function to be executed ${context.exact} time(s) but was executed ${context.actual} time(s).`;\n        ArrayPrototypePush(errors, {\n          message,\n          actual: context.actual,\n          expected: context.exact,\n          operator: context.name,\n          stack: context.stackTrace\n        });\n      }\n    }\n    return errors;\n  }\n  verify() {\n    const errors = this.report();\n    if (errors.length > 0) {\n      throw new AssertionError({\n        message: \"Function(s) were not called the expected number of times\",\n        details: errors\n      });\n    }\n  }\n}\nmodule.exports = CallTracker;\n}"],["internal/bootstrap/environment.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nprepareMainThreadExecution();\nmarkBootstrapComplete();\n}"],["internal/bootstrap/loaders.js","function (process, getLinkedBinding, getInternalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  Error,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ReflectGet,\n  SafeMap,\n  SafeSet,\n  String,\n  StringPrototypeStartsWith,\n  TypeError\n} = primordials;\nconst moduleLoadList = [];\nObjectDefineProperty(process, \"moduleLoadList\", {\n  value: moduleLoadList,\n  configurable: true,\n  enumerable: true,\n  writable: false\n});\nconst internalBindingAllowlist = new SafeSet([\n  \"async_wrap\",\n  \"buffer\",\n  \"cares_wrap\",\n  \"config\",\n  \"constants\",\n  \"contextify\",\n  \"crypto\",\n  \"fs\",\n  \"fs_event_wrap\",\n  \"http_parser\",\n  \"icu\",\n  \"inspector\",\n  \"js_stream\",\n  \"natives\",\n  \"os\",\n  \"pipe_wrap\",\n  \"process_wrap\",\n  \"signal_wrap\",\n  \"spawn_sync\",\n  \"stream_wrap\",\n  \"tcp_wrap\",\n  \"tls_wrap\",\n  \"tty_wrap\",\n  \"udp_wrap\",\n  \"url\",\n  \"util\",\n  \"uv\",\n  \"v8\",\n  \"zlib\"\n]);\nconst runtimeDeprecatedList = new SafeSet([\n  \"async_wrap\",\n  \"crypto\",\n  \"http_parser\",\n  \"signal_wrap\",\n  \"url\",\n  \"v8\"\n]);\nconst legacyWrapperList = new SafeSet([\n  \"util\"\n]);\n{\n  const bindingObj = ObjectCreate(null);\n  process.binding = function binding(module) {\n    module = String(module);\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(`Access to process.binding('${module}') is deprecated.`, \"DeprecationWarning\", \"DEP0111\");\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire(\"internal/legacy/processbinding\")[module]();\n      }\n      return internalBinding(module);\n    }\n    throw new Error(`No such module: ${module}`);\n  };\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== \"object\")\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  internalBinding = function internalBinding2(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== \"object\") {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList, `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\nconst loaderId = \"internal/bootstrap/loaders\";\nconst {\n  moduleIds,\n  compileFunction\n} = internalBinding(\"native_module\");\nconst getOwn = (target, property, receiver) => {\n  return ObjectPrototypeHasOwnProperty(target, property) ? ReflectGet(target, property, receiver) : void 0;\n};\nclass NativeModule {\n  static map = new SafeMap(ArrayPrototypeMap(moduleIds, (id) => [id, new NativeModule(id)]));\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id, \"internal/\");\n    this.exports = {};\n    this.loaded = false;\n    this.loading = false;\n    this.module = void 0;\n    this.exportKeys = void 0;\n  }\n  static exposeInternals() {\n    for (const { 0: id, 1: mod } of NativeModule.map) {\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      const internal = StringPrototypeStartsWith(this.id, \"internal/\");\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n  getESMFacade() {\n    if (this.module)\n      return this.module;\n    const { ModuleWrap } = internalBinding(\"module_wrap\");\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys, \"default\");\n    this.module = new ModuleWrap(url, void 0, exportsKeys, function() {\n      nativeModule.syncExports();\n      this.setExport(\"default\", nativeModule.exports);\n    });\n    this.module.instantiate();\n    this.module.evaluate(-1, false);\n    return this.module;\n  }\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === \"default\")\n          continue;\n        this.module.setExport(exportName, getOwn(this.exports, exportName, this.exports));\n      }\n    }\n  }\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n    const id = this.id;\n    this.loading = true;\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id, \"internal/deps/\") ? requireWithFallbackInDeps : nativeModuleRequire;\n      const fn = compileFunction(id);\n      fn(this.exports, requireFn, this, process, internalBinding, primordials);\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n    ArrayPrototypePush(moduleLoadList, `NativeModule ${id}`);\n    return this.exports;\n  }\n}\nconst loaderExports = {\n  internalBinding,\n  NativeModule,\n  require: nativeModuleRequire\n};\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n  const mod = NativeModule.map.get(id);\n  if (!mod)\n    throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\nreturn loaderExports;\n}"],["internal/bootstrap/node.js","function (process, require, internalBinding, primordials, markBootstrapComplete) { \n  \"use strict\";\nsetupPrepareStackTrace();\nconst {\n  FunctionPrototypeCall,\n  JSONParse,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectGetPrototypeOf,\n  ObjectPreventExtensions,\n  ObjectSetPrototypeOf,\n  ReflectGet,\n  ReflectSet,\n  SymbolToStringTag,\n  globalThis\n} = primordials;\nconst config = internalBinding(\"config\");\nconst { deprecate, lazyDOMExceptionClass } = require(\"internal/util\");\nsetupProcessObject();\nsetupGlobalProxy();\nsetupBuffer();\nprocess.domain = null;\nprocess._exiting = false;\nconst nativeModule = internalBinding(\"native_module\");\nconst deprecationHandler = {\n  warned: false,\n  message: \"Setting process.config is deprecated. In the future the property will be read-only.\",\n  code: \"DEP0150\",\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message, {\n        type: \"DeprecationWarning\",\n        code: this.code\n      });\n      this.warned = true;\n    }\n  },\n  defineProperty(target, key, descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target, key, descriptor);\n  },\n  deleteProperty(target, key) {\n    this.maybeWarn();\n    delete target[key];\n  },\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  },\n  set(target, key, value) {\n    this.maybeWarn();\n    return ReflectSet(target, key, value);\n  },\n  get(target, key, receiver) {\n    const val = ReflectGet(target, key, receiver);\n    if (val != null && typeof val === \"object\") {\n      return new Proxy(val, deprecationHandler);\n    }\n    return val;\n  },\n  setPrototypeOf(target, proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target, proto);\n  }\n};\nlet processConfig = new Proxy(JSONParse(nativeModule.config), deprecationHandler);\nObjectDefineProperty(process, \"config\", {\n  enumerable: true,\n  configurable: true,\n  get() {\n    return processConfig;\n  },\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\n});\nrequire(\"internal/worker/js_transferable\").setup();\nconst perThreadSetup = require(\"internal/process/per_thread\");\nconst rawMethods = internalBinding(\"process_methods\");\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\nconst credentials = internalBinding(\"credentials\");\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\nconst { nativeHooks } = require(\"internal/async_hooks\");\ninternalBinding(\"async_wrap\").setupHooks(nativeHooks);\nconst {\n  setupTaskQueue,\n  queueMicrotask\n} = require(\"internal/process/task_queues\");\nif (!config.noBrowserGlobals) {\n  exposeNamespace(globalThis, \"console\", createGlobalConsole(globalThis.console));\n  const { URL, URLSearchParams } = require(\"internal/url\");\n  exposeInterface(globalThis, \"URL\", URL);\n  exposeInterface(globalThis, \"URLSearchParams\", URLSearchParams);\n  exposeGetterAndSetter(globalThis, \"DOMException\", lazyDOMExceptionClass, (value) => {\n    exposeInterface(globalThis, \"DOMException\", value);\n  });\n  const {\n    TextEncoder,\n    TextDecoder\n  } = require(\"internal/encoding\");\n  exposeInterface(globalThis, \"TextEncoder\", TextEncoder);\n  exposeInterface(globalThis, \"TextDecoder\", TextDecoder);\n  const {\n    AbortController,\n    AbortSignal\n  } = require(\"internal/abort_controller\");\n  exposeInterface(globalThis, \"AbortController\", AbortController);\n  exposeInterface(globalThis, \"AbortSignal\", AbortSignal);\n  const {\n    EventTarget,\n    Event\n  } = require(\"internal/event_target\");\n  exposeInterface(globalThis, \"EventTarget\", EventTarget);\n  exposeInterface(globalThis, \"Event\", Event);\n  const {\n    MessageChannel,\n    MessagePort,\n    MessageEvent\n  } = require(\"internal/worker/io\");\n  exposeInterface(globalThis, \"MessageChannel\", MessageChannel);\n  exposeInterface(globalThis, \"MessagePort\", MessagePort);\n  exposeInterface(globalThis, \"MessageEvent\", MessageEvent);\n  const timers = require(\"timers\");\n  defineOperation(globalThis, \"clearInterval\", timers.clearInterval);\n  defineOperation(globalThis, \"clearTimeout\", timers.clearTimeout);\n  defineOperation(globalThis, \"setInterval\", timers.setInterval);\n  defineOperation(globalThis, \"setTimeout\", timers.setTimeout);\n  defineOperation(globalThis, \"queueMicrotask\", queueMicrotask);\n  defineReplacableAttribute(globalThis, \"performance\", require(\"perf_hooks\").performance);\n  defineOperation(globalThis, \"clearImmediate\", timers.clearImmediate);\n  defineOperation(globalThis, \"setImmediate\", timers.setImmediate);\n  const {\n    structuredClone\n  } = require(\"internal/structured_clone\");\n  defineOperation(globalThis, \"structuredClone\", structuredClone);\n}\nconst { setTraceCategoryStateUpdateHandler } = internalBinding(\"trace_events\");\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\nObjectDefineProperty(process, \"allowedNodeEnvironmentFlags\", {\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  },\n  set(value) {\n    ObjectDefineProperty(this, \"allowedNodeEnvironmentFlags\", {\n      value,\n      configurable: true,\n      enumerable: true,\n      writable: true\n    });\n  },\n  enumerable: true,\n  configurable: true\n});\nprocess.assert = deprecate(perThreadSetup.assert, \"process.assert() is deprecated. Please use the `assert` module instead.\", \"DEP0100\");\nconst { isDebugBuild, hasOpenSSL, hasInspector } = config;\nconst features = {\n  inspector: hasInspector,\n  debug: isDebugBuild,\n  uv: true,\n  ipv6: true,\n  tls_alpn: hasOpenSSL,\n  tls_sni: hasOpenSSL,\n  tls_ocsp: hasOpenSSL,\n  tls: hasOpenSSL,\n  get cached_builtins() {\n    return nativeModule.hasCachedBuiltins();\n  }\n};\nObjectDefineProperty(process, \"features\", {\n  enumerable: true,\n  writable: false,\n  configurable: false,\n  value: features\n});\n{\n  const {\n    onGlobalUncaughtException,\n    setUncaughtExceptionCaptureCallback,\n    hasUncaughtExceptionCaptureCallback\n  } = require(\"internal/process/execution\");\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback = setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback = hasUncaughtExceptionCaptureCallback;\n}\nconst { emitWarning } = require(\"internal/process/warning\");\nprocess.emitWarning = emitWarning;\n{\n  const { nextTick, runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  process._tickCallback = runNextTicks;\n  const { getTimerCallbacks } = require(\"internal/timers\");\n  const { setupTimers } = internalBinding(\"timers\");\n  const { processImmediate, processTimers } = getTimerCallbacks(runNextTicks);\n  setupTimers(processImmediate, processTimers);\n}\nrequire(\"fs\");\nrequire(\"v8\");\nrequire(\"vm\");\nrequire(\"url\");\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException,\n    setPrepareStackTraceCallback\n  } = internalBinding(\"errors\");\n  const {\n    prepareStackTrace,\n    fatalExceptionStackEnhancers: {\n      beforeInspector,\n      afterInspector\n    }\n  } = require(\"internal/errors\");\n  setPrepareStackTraceCallback(prepareStackTrace);\n  setEnhanceStackForFatalException(beforeInspector, afterInspector);\n}\nfunction setupProcessObject() {\n  const EventEmitter = require(\"events\");\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto, EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter, process);\n  ObjectDefineProperty(process, SymbolToStringTag, {\n    enumerable: false,\n    writable: true,\n    configurable: false,\n    value: \"process\"\n  });\n  ObjectDefineProperty(globalThis, \"process\", {\n    value: process,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n}\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis, SymbolToStringTag, {\n    value: \"global\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\nfunction setupBuffer() {\n  const {\n    Buffer,\n    atob,\n    btoa\n  } = require(\"buffer\");\n  const bufferBinding = internalBinding(\"buffer\");\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n  ObjectDefineProperties(globalThis, {\n    \"Buffer\": {\n      value: Buffer,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    },\n    \"atob\": {\n      value: atob,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    },\n    \"btoa\": {\n      value: btoa,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\nfunction createGlobalConsole(consoleFromVM) {\n  const consoleFromNode = require(\"internal/console/global\");\n  if (config.hasInspector) {\n    const inspector = require(\"internal/util/inspector\");\n    inspector.consoleFromVM = consoleFromVM;\n    inspector.wrapConsole(consoleFromNode, consoleFromVM);\n    const { setConsoleExtensionInstaller } = internalBinding(\"inspector\");\n    setConsoleExtensionInstaller(inspector.installConsoleExtensions);\n  }\n  return consoleFromNode;\n}\nfunction exposeNamespace(target, name, namespaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: namespaceObject\n  });\n}\nfunction exposeInterface(target, name, interfaceObject) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: interfaceObject\n  });\n}\nfunction exposeGetterAndSetter(target, name, getter, setter = void 0) {\n  ObjectDefineProperty(target, name, {\n    enumerable: false,\n    configurable: true,\n    get: getter,\n    set: setter\n  });\n}\nfunction defineOperation(target, name, method) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value: method\n  });\n}\nfunction defineReplacableAttribute(target, name, value) {\n  ObjectDefineProperty(target, name, {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    value\n  });\n}\n}"],["internal/bootstrap/pre_execution.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  NumberParseInt,\n  ObjectDefineProperty,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeStartsWith,\n  globalThis\n} = primordials;\nconst {\n  getOptionValue,\n  noGlobalSearchPaths,\n  shouldNotRegisterESMLoader\n} = require(\"internal/options\");\nconst { reconnectZeroFillToggle } = require(\"internal/buffer\");\nconst { Buffer } = require(\"buffer\");\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require(\"internal/errors\").codes;\nconst assert = require(\"internal/assert\");\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  reconnectZeroFillToggle();\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE = setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n  setupDebugEnv();\n  setupStacktracePrinterOnSigint();\n  initializeReport();\n  initializeReportSignalHandlers();\n  initializeHeapSnapshotSignalHandlers();\n  setupChildProcessIpcChannel();\n  initializePolicy();\n  initializeClusterIPC();\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n  const CJSLoader = require(\"internal/modules/cjs/loader\");\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding(\"process_methods\");\n  binding.patchProcessObject(process);\n  const {\n    hrtime,\n    hrtimeBigInt\n  } = require(\"internal/process/per_thread\").getFastAPIs(binding);\n  process.hrtime = hrtime;\n  process.hrtime.bigint = hrtimeBigInt;\n  ObjectDefineProperty(process, \"argv0\", {\n    enumerable: true,\n    configurable: false,\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n  if (expandArgv1 && process.argv[1] && !StringPrototypeStartsWith(process.argv[1], \"-\")) {\n    const path = require(\"path\");\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {\n    }\n  }\n  addReadOnlyProcessAlias(\"_eval\", \"--eval\");\n  addReadOnlyProcessAlias(\"_print_eval\", \"--print\");\n  addReadOnlyProcessAlias(\"_syntax_check_only\", \"--check\");\n  addReadOnlyProcessAlias(\"_forceRepl\", \"--interactive\");\n  addReadOnlyProcessAlias(\"_preload_modules\", \"--require\");\n  addReadOnlyProcessAlias(\"noDeprecation\", \"--no-deprecation\");\n  addReadOnlyProcessAlias(\"noProcessWarnings\", \"--no-warnings\");\n  addReadOnlyProcessAlias(\"traceProcessWarnings\", \"--trace-warnings\");\n  addReadOnlyProcessAlias(\"throwDeprecation\", \"--throw-deprecation\");\n  addReadOnlyProcessAlias(\"profProcess\", \"--prof-process\");\n  addReadOnlyProcessAlias(\"traceDeprecation\", \"--trace-deprecation\");\n  addReadOnlyProcessAlias(\"_breakFirstLine\", \"--inspect-brk\", false);\n  addReadOnlyProcessAlias(\"_breakNodeFirstLine\", \"--inspect-brk-node\", false);\n}\nfunction addReadOnlyProcessAlias(name, option, enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process, name, {\n      writable: false,\n      configurable: true,\n      enumerable,\n      value\n    });\n  }\n}\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require(\"internal/process/warning\");\n  if (getOptionValue(\"--warnings\") && process.env.NODE_NO_WARNINGS !== \"1\") {\n    process.on(\"warning\", onWarning);\n  }\n}\nfunction setupCoverageHooks(dir) {\n  const cwd = require(\"internal/process/execution\").tryGetCwd();\n  const { resolve } = require(\"path\");\n  const coverageDirectory = resolve(cwd, dir);\n  const { sourceMapCacheToObject } = require(\"internal/source_map/source_map_cache\");\n  if (process.features.inspector) {\n    internalBinding(\"profiler\").setCoverageDirectory(coverageDirectory);\n    internalBinding(\"profiler\").setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning(\"The inspector is disabled, coverage could not be collected\", \"Warning\");\n    return \"\";\n  }\n  return coverageDirectory;\n}\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue(\"--trace-sigint\")) {\n    return;\n  }\n  const { SigintWatchdog } = require(\"internal/watchdog\");\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\nfunction initializeReport() {\n  const { report } = require(\"internal/process/report\");\n  ObjectDefineProperty(process, \"report\", {\n    enumerable: false,\n    configurable: true,\n    get() {\n      return report;\n    }\n  });\n}\nfunction setupDebugEnv() {\n  require(\"internal/util/debuglog\").initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue(\"--expose-internals\")) {\n    require(\"internal/bootstrap/loaders\").NativeModule.exposeInternals();\n  }\n}\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require(\"internal/process/report\");\n  addSignalHandler();\n}\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue(\"--heapsnapshot-signal\");\n  if (!signal)\n    return;\n  require(\"internal/validators\").validateSignalName(signal);\n  const { writeHeapSnapshot } = require(\"v8\");\n  process.on(signal, () => {\n    writeHeapSnapshot();\n  });\n}\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding(\"trace_events\");\n  const { toggleTraceCategoryState } = require(\"internal/process/per_thread\");\n  toggleTraceCategoryState(isTraceCategoryEnabled(\"node.async_hooks\"));\n}\nfunction setupPerfHooks() {\n  require(\"internal/perf/performance\").refreshTimeOrigin();\n  require(\"internal/perf/utils\").refreshTimeOrigin();\n}\nfunction setupInspectorHooks() {\n  if (internalBinding(\"config\").hasInspector) {\n    const {\n      enable,\n      disable\n    } = require(\"internal/inspector_async_hook\");\n    internalBinding(\"inspector\").registerAsyncHook(enable, disable);\n  }\n}\nfunction initializeDeprecations() {\n  const { deprecate } = require(\"internal/util\");\n  const pendingDeprecation = getOptionValue(\"--pending-deprecation\");\n  const utilBinding = internalBinding(\"util\");\n  const types = require(\"internal/util/types\");\n  for (const name of [\n    \"isArrayBuffer\",\n    \"isArrayBufferView\",\n    \"isAsyncFunction\",\n    \"isDataView\",\n    \"isDate\",\n    \"isExternal\",\n    \"isMap\",\n    \"isMapIterator\",\n    \"isNativeError\",\n    \"isPromise\",\n    \"isRegExp\",\n    \"isSet\",\n    \"isSetIterator\",\n    \"isTypedArray\",\n    \"isUint8Array\",\n    \"isAnyArrayBuffer\"\n  ]) {\n    utilBinding[name] = pendingDeprecation ? deprecate(types[name], `Accessing native typechecking bindings of Node directly is deprecated. Please use \\`util.types.${name}\\` instead.`, \"DEP0103\") : types[name];\n  }\n  const { noBrowserGlobals } = internalBinding(\"config\");\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process, \"_noBrowserGlobals\", {\n      writable: false,\n      enumerable: true,\n      configurable: true,\n      value: noBrowserGlobals\n    });\n  }\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding, \"process.binding() is deprecated. Please use public APIs instead.\", \"DEP0111\");\n    process._tickCallback = deprecate(process._tickCallback, \"process._tickCallback() is deprecated\", \"DEP0134\");\n  }\n  let _process = process;\n  ObjectDefineProperty(globalThis, \"process\", {\n    get() {\n      return _process;\n    },\n    set(value) {\n      _process = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis, \"Buffer\", {\n    get() {\n      return _Buffer;\n    },\n    set(value) {\n      _Buffer = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert2 = require(\"internal/assert\");\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD, 10);\n    assert2(fd >= 0);\n    delete process.env.NODE_CHANNEL_FD;\n    const serializationMode = process.env.NODE_CHANNEL_SERIALIZATION_MODE || \"json\";\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n    require(\"child_process\")._forkChild(fd, serializationMode);\n    assert2(process.send);\n  }\n}\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require(\"cluster\");\n    cluster._setupWorker();\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue(\"--experimental-policy\");\n  if (experimentalPolicy) {\n    process.emitWarning(\"Policies are experimental.\", \"ExperimentalWarning\");\n    const { pathToFileURL, URL } = require(\"internal/url\");\n    let manifestURL;\n    if (require(\"path\").isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += \"/\";\n      manifestURL = new URL(experimentalPolicy, cwdURL);\n    }\n    const fs = require(\"fs\");\n    const src = fs.readFileSync(manifestURL, \"utf8\");\n    const experimentalPolicyIntegrity = getOptionValue(\"--policy-integrity\");\n    if (experimentalPolicyIntegrity) {\n      const SRI = require(\"internal/policy/sri\");\n      const { createHash, timingSafeEqual } = require(\"crypto\");\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm,\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length && timingSafeEqual(digest, expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm, digest.toString(\"base64\"));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL, realIntegrities);\n      }\n    }\n    require(\"internal/process/policy\").setup(src, manifestURL.href);\n  }\n}\nfunction initializeWASI() {\n  const { NativeModule } = require(\"internal/bootstrap/loaders\");\n  const mod = NativeModule.map.get(\"wasi\");\n  mod.canBeRequiredByUsers = getOptionValue(\"--experimental-wasi-unstable-preview1\");\n}\nfunction initializeCJSLoader() {\n  const CJSLoader = require(\"internal/modules/cjs/loader\");\n  if (!noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  CJSLoader.Module.runMain = require(\"internal/modules/run_main\").executeUserEntryPoint;\n}\nfunction initializeESMLoader() {\n  internalBinding(\"module_wrap\").callbackMap = new SafeWeakMap();\n  if (shouldNotRegisterESMLoader)\n    return;\n  const {\n    setImportModuleDynamicallyCallback,\n    setInitializeImportMetaObjectCallback\n  } = internalBinding(\"module_wrap\");\n  const esm = require(\"internal/process/esm_loader\");\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n  if (getOptionValue(\"--experimental-vm-modules\")) {\n    const {\n      Module,\n      SourceTextModule,\n      SyntheticModule\n    } = require(\"internal/vm/module\");\n    const vm = require(\"vm\");\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } = require(\"internal/source_map/source_map_cache\");\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue(\"--frozen-intrinsics\")) {\n    process.emitWarning(\"The --frozen-intrinsics flag is experimental\", \"ExperimentalWarning\");\n    require(\"internal/freeze_intrinsics\")();\n  }\n}\nfunction loadPreloadModules() {\n  const preloadModules = getOptionValue(\"--require\");\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\n    } = require(\"internal/modules/cjs/loader\");\n    _preloadModules(preloadModules);\n  }\n}\nmodule.exports = {\n  patchProcessObject,\n  setupCoverageHooks,\n  setupWarningHandler,\n  setupDebugEnv,\n  setupPerfHooks,\n  prepareMainThreadExecution,\n  initializeDeprecations,\n  initializeESMLoader,\n  initializeFrozenIntrinsics,\n  initializeSourceMapsHandlers,\n  loadPreloadModules,\n  setupTraceCategoryState,\n  setupInspectorHooks,\n  initializeReport,\n  initializeCJSLoader,\n  initializeWASI\n};\n}"],["internal/child_process/serialization.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  JSONParse,\n  JSONStringify,\n  StringPrototypeSplit,\n  Symbol,\n  TypedArrayPrototypeSubarray\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst { StringDecoder } = require(\"string_decoder\");\nconst v8 = require(\"v8\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst assert = require(\"internal/assert\");\nconst { streamBaseState, kLastWriteWasAsync } = internalBinding(\"stream_wrap\");\nconst kMessageBuffer = Symbol(\"kMessageBuffer\");\nconst kJSONBuffer = Symbol(\"kJSONBuffer\");\nconst kStringDecoder = Symbol(\"kStringDecoder\");\nconst kArrayBufferViewTag = 0;\nconst kNotArrayBufferViewTag = 1;\nclass ChildProcessSerializer extends v8.DefaultSerializer {\n  _writeHostObject(object) {\n    if (isArrayBufferView(object)) {\n      this.writeUint32(kArrayBufferViewTag);\n      return super._writeHostObject(object);\n    }\n    this.writeUint32(kNotArrayBufferViewTag);\n    this.writeValue({ ...object });\n  }\n}\nclass ChildProcessDeserializer extends v8.DefaultDeserializer {\n  _readHostObject() {\n    const tag = this.readUint32();\n    if (tag === kArrayBufferViewTag)\n      return super._readHostObject();\n    assert(tag === kNotArrayBufferViewTag);\n    return this.readValue();\n  }\n}\nconst advanced = {\n  initMessageChannel(channel) {\n    channel[kMessageBuffer] = Buffer.alloc(0);\n    channel.buffering = false;\n  },\n  *parseChannelMessages(channel, readData) {\n    if (readData.length === 0)\n      return;\n    let messageBuffer = Buffer.concat([channel[kMessageBuffer], readData]);\n    while (messageBuffer.length > 4) {\n      const size = messageBuffer.readUInt32BE();\n      if (messageBuffer.length < 4 + size) {\n        break;\n      }\n      const deserializer = new ChildProcessDeserializer(TypedArrayPrototypeSubarray(messageBuffer, 4, 4 + size));\n      messageBuffer = TypedArrayPrototypeSubarray(messageBuffer, 4 + size);\n      deserializer.readHeader();\n      yield deserializer.readValue();\n    }\n    channel[kMessageBuffer] = messageBuffer;\n    channel.buffering = messageBuffer.length > 0;\n  },\n  writeChannelMessage(channel, req, message, handle) {\n    const ser = new ChildProcessSerializer();\n    ser.writeHeader();\n    ser.writeValue(message);\n    const serializedMessage = ser.releaseBuffer();\n    const sizeBuffer = Buffer.allocUnsafe(4);\n    sizeBuffer.writeUInt32BE(serializedMessage.length);\n    const buffer = Buffer.concat([\n      sizeBuffer,\n      serializedMessage\n    ]);\n    const result = channel.writeBuffer(req, buffer, handle);\n    if (streamBaseState[kLastWriteWasAsync])\n      req.buffer = buffer;\n    return result;\n  }\n};\nconst json = {\n  initMessageChannel(channel) {\n    channel[kJSONBuffer] = \"\";\n    channel[kStringDecoder] = void 0;\n  },\n  *parseChannelMessages(channel, readData) {\n    if (readData.length === 0)\n      return;\n    if (channel[kStringDecoder] === void 0)\n      channel[kStringDecoder] = new StringDecoder(\"utf8\");\n    const chunks = StringPrototypeSplit(channel[kStringDecoder].write(readData), \"\\n\");\n    const numCompleteChunks = chunks.length - 1;\n    const incompleteChunk = chunks[numCompleteChunks];\n    if (numCompleteChunks === 0) {\n      channel[kJSONBuffer] += incompleteChunk;\n    } else {\n      chunks[0] = channel[kJSONBuffer] + chunks[0];\n      for (let i = 0; i < numCompleteChunks; i++)\n        yield JSONParse(chunks[i]);\n      channel[kJSONBuffer] = incompleteChunk;\n    }\n    channel.buffering = channel[kJSONBuffer].length !== 0;\n  },\n  writeChannelMessage(channel, req, message, handle) {\n    const string = JSONStringify(message) + \"\\n\";\n    return channel.writeUtf8String(req, string, handle);\n  }\n};\nmodule.exports = { advanced, json };\n}"],["internal/cluster/child.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  FunctionPrototype,\n  ObjectAssign,\n  ReflectApply,\n  SafeMap,\n  SafeSet\n} = primordials;\nconst assert = require(\"internal/assert\");\nconst path = require(\"path\");\nconst EventEmitter = require(\"events\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst Worker = require(\"internal/cluster/worker\");\nconst { internal, sendHelper } = require(\"internal/cluster/utils\");\nconst cluster = new EventEmitter();\nconst handles = new SafeMap();\nconst indexes = new SafeMap();\nconst noop = FunctionPrototype;\nmodule.exports = cluster;\ncluster.isWorker = true;\ncluster.isMaster = false;\ncluster.isPrimary = false;\ncluster.worker = null;\ncluster.Worker = Worker;\ncluster._setupWorker = function() {\n  const worker = new Worker({\n    id: +process.env.NODE_UNIQUE_ID | 0,\n    process,\n    state: \"online\"\n  });\n  cluster.worker = worker;\n  process.once(\"disconnect\", () => {\n    worker.emit(\"disconnect\");\n    if (!worker.exitedAfterDisconnect) {\n      process.exit(0);\n    }\n  });\n  process.on(\"internalMessage\", internal(worker, onmessage));\n  send({ act: \"online\" });\n  function onmessage(message, handle) {\n    if (message.act === \"newconn\")\n      onconnection(message, handle);\n    else if (message.act === \"disconnect\")\n      ReflectApply(_disconnect, worker, [true]);\n  }\n};\ncluster._getServer = function(obj, options, cb) {\n  let address = options.address;\n  if (options.port < 0 && typeof address === \"string\" && process.platform !== \"win32\")\n    address = path.resolve(address);\n  const indexesKey = ArrayPrototypeJoin([\n    address,\n    options.port,\n    options.addressType,\n    options.fd\n  ], \":\");\n  let indexSet = indexes.get(indexesKey);\n  if (indexSet === void 0) {\n    indexSet = { nextIndex: 0, set: new SafeSet() };\n    indexes.set(indexesKey, indexSet);\n  }\n  const index = indexSet.nextIndex++;\n  indexSet.set.add(index);\n  const message = {\n    act: \"queryServer\",\n    index,\n    data: null,\n    ...options\n  };\n  message.address = address;\n  if (obj._getServerData)\n    message.data = obj._getServerData();\n  send(message, (reply, handle) => {\n    if (typeof obj._setServerData === \"function\")\n      obj._setServerData(reply.data);\n    if (handle) {\n      shared(reply, { handle, indexesKey, index }, cb);\n    } else {\n      rr(reply, { indexesKey, index }, cb);\n    }\n  });\n  obj.once(\"listening\", () => {\n    cluster.worker.state = \"listening\";\n    const address2 = obj.address();\n    message.act = \"listening\";\n    message.port = address2 && address2.port || options.port;\n    send(message);\n  });\n};\nfunction removeIndexesKey(indexesKey, index) {\n  const indexSet = indexes.get(indexesKey);\n  if (!indexSet) {\n    return;\n  }\n  indexSet.set.delete(index);\n  if (indexSet.set.size === 0) {\n    indexes.delete(indexesKey);\n  }\n}\nfunction shared(message, { handle, indexesKey, index }, cb) {\n  const key = message.key;\n  const close = handle.close;\n  handle.close = function() {\n    send({ act: \"close\", key });\n    handles.delete(key);\n    removeIndexesKey(indexesKey, index);\n    return ReflectApply(close, handle, arguments);\n  };\n  assert(handles.has(key) === false);\n  handles.set(key, handle);\n  cb(message.errno, handle);\n}\nfunction rr(message, { indexesKey, index }, cb) {\n  if (message.errno)\n    return cb(message.errno, null);\n  let key = message.key;\n  function listen(backlog) {\n    return 0;\n  }\n  function close() {\n    if (key === void 0)\n      return;\n    send({ act: \"close\", key });\n    handles.delete(key);\n    removeIndexesKey(indexesKey, index);\n    key = void 0;\n  }\n  function getsockname(out) {\n    if (key)\n      ObjectAssign(out, message.sockname);\n    return 0;\n  }\n  const handle = { close, listen, ref: noop, unref: noop };\n  if (message.sockname) {\n    handle.getsockname = getsockname;\n  }\n  assert(handles.has(key) === false);\n  handles.set(key, handle);\n  cb(0, handle);\n}\nfunction onconnection(message, handle) {\n  const key = message.key;\n  const server = handles.get(key);\n  const accepted = server !== void 0;\n  send({ ack: message.seq, accepted });\n  if (accepted)\n    server.onconnection(0, handle);\n}\nfunction send(message, cb) {\n  return sendHelper(process, message, null, cb);\n}\nfunction _disconnect(primaryInitiated) {\n  this.exitedAfterDisconnect = true;\n  let waitingCount = 1;\n  function checkWaitingCount() {\n    waitingCount--;\n    if (waitingCount === 0) {\n      if (primaryInitiated) {\n        process.disconnect();\n      } else {\n        send({ act: \"exitedAfterDisconnect\" }, () => process.disconnect());\n      }\n    }\n  }\n  handles.forEach((handle) => {\n    waitingCount++;\n    if (handle[owner_symbol])\n      handle[owner_symbol].close(checkWaitingCount);\n    else\n      handle.close(checkWaitingCount);\n  });\n  handles.clear();\n  checkWaitingCount();\n}\nWorker.prototype.disconnect = function() {\n  if (this.state !== \"disconnecting\" && this.state !== \"destroying\") {\n    this.state = \"disconnecting\";\n    ReflectApply(_disconnect, this, []);\n  }\n  return this;\n};\nWorker.prototype.destroy = function() {\n  if (this.state === \"destroying\")\n    return;\n  this.exitedAfterDisconnect = true;\n  if (!this.isConnected()) {\n    process.exit(0);\n  } else {\n    this.state = \"destroying\";\n    send({ act: \"exitedAfterDisconnect\" }, () => process.disconnect());\n    process.once(\"disconnect\", () => process.exit(0));\n  }\n};\n}"],["internal/cluster/primary.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSome,\n  ObjectKeys,\n  ObjectValues,\n  RegExpPrototypeTest,\n  SafeMap,\n  StringPrototypeStartsWith\n} = primordials;\nconst assert = require(\"internal/assert\");\nconst { fork } = require(\"child_process\");\nconst path = require(\"path\");\nconst EventEmitter = require(\"events\");\nconst RoundRobinHandle = require(\"internal/cluster/round_robin_handle\");\nconst SharedHandle = require(\"internal/cluster/shared_handle\");\nconst Worker = require(\"internal/cluster/worker\");\nconst { internal, sendHelper } = require(\"internal/cluster/utils\");\nconst cluster = new EventEmitter();\nconst intercom = new EventEmitter();\nconst SCHED_NONE = 1;\nconst SCHED_RR = 2;\nconst minPort = 1024;\nconst maxPort = 65535;\nconst { validatePort } = require(\"internal/validators\");\nmodule.exports = cluster;\nconst handles = new SafeMap();\ncluster.isWorker = false;\ncluster.isMaster = true;\ncluster.isPrimary = true;\ncluster.Worker = Worker;\ncluster.workers = {};\ncluster.settings = {};\ncluster.SCHED_NONE = SCHED_NONE;\ncluster.SCHED_RR = SCHED_RR;\nlet ids = 0;\nlet debugPortOffset = 1;\nlet initialized = false;\nlet schedulingPolicy = process.env.NODE_CLUSTER_SCHED_POLICY;\nif (schedulingPolicy === \"rr\")\n  schedulingPolicy = SCHED_RR;\nelse if (schedulingPolicy === \"none\")\n  schedulingPolicy = SCHED_NONE;\nelse if (process.platform === \"win32\") {\n  schedulingPolicy = SCHED_NONE;\n} else\n  schedulingPolicy = SCHED_RR;\ncluster.schedulingPolicy = schedulingPolicy;\ncluster.setupPrimary = function(options) {\n  const settings = {\n    args: ArrayPrototypeSlice(process.argv, 2),\n    exec: process.argv[1],\n    execArgv: process.execArgv,\n    silent: false,\n    ...cluster.settings,\n    ...options\n  };\n  if (ArrayPrototypeSome(settings.execArgv, (s) => StringPrototypeStartsWith(s, \"--prof\")) && !ArrayPrototypeSome(settings.execArgv, (s) => StringPrototypeStartsWith(s, \"--logfile=\"))) {\n    settings.execArgv = [...settings.execArgv, \"--logfile=v8-%p.log\"];\n  }\n  cluster.settings = settings;\n  if (initialized === true)\n    return process.nextTick(setupSettingsNT, settings);\n  initialized = true;\n  schedulingPolicy = cluster.schedulingPolicy;\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR, `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\n  process.nextTick(setupSettingsNT, settings);\n  process.on(\"internalMessage\", (message) => {\n    if (message.cmd !== \"NODE_DEBUG_ENABLED\")\n      return;\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.state === \"online\" || worker.state === \"listening\") {\n        process._debugProcess(worker.process.pid);\n      } else {\n        worker.once(\"online\", function() {\n          process._debugProcess(this.process.pid);\n        });\n      }\n    }\n  });\n};\ncluster.setupMaster = cluster.setupPrimary;\nfunction setupSettingsNT(settings) {\n  cluster.emit(\"setup\", settings);\n}\nfunction createWorkerProcess(id, env) {\n  const workerEnv = { ...process.env, ...env, NODE_UNIQUE_ID: `${id}` };\n  const execArgv = [...cluster.settings.execArgv];\n  const debugArgRegex = /--inspect(?:-brk|-port)?|--debug-port/;\n  const nodeOptions = process.env.NODE_OPTIONS || \"\";\n  if (ArrayPrototypeSome(execArgv, (arg) => RegExpPrototypeTest(debugArgRegex, arg)) || RegExpPrototypeTest(debugArgRegex, nodeOptions)) {\n    let inspectPort;\n    if (\"inspectPort\" in cluster.settings) {\n      if (typeof cluster.settings.inspectPort === \"function\")\n        inspectPort = cluster.settings.inspectPort();\n      else\n        inspectPort = cluster.settings.inspectPort;\n      validatePort(inspectPort);\n    } else {\n      inspectPort = process.debugPort + debugPortOffset;\n      if (inspectPort > maxPort)\n        inspectPort = inspectPort - maxPort + minPort - 1;\n      debugPortOffset++;\n    }\n    ArrayPrototypePush(execArgv, `--inspect-port=${inspectPort}`);\n  }\n  return fork(cluster.settings.exec, cluster.settings.args, {\n    cwd: cluster.settings.cwd,\n    env: workerEnv,\n    serialization: cluster.settings.serialization,\n    silent: cluster.settings.silent,\n    windowsHide: cluster.settings.windowsHide,\n    execArgv,\n    stdio: cluster.settings.stdio,\n    gid: cluster.settings.gid,\n    uid: cluster.settings.uid\n  });\n}\nfunction removeWorker(worker) {\n  assert(worker);\n  delete cluster.workers[worker.id];\n  if (ObjectKeys(cluster.workers).length === 0) {\n    assert(handles.size === 0, \"Resource leak detected.\");\n    intercom.emit(\"disconnect\");\n  }\n}\nfunction removeHandlesForWorker(worker) {\n  assert(worker);\n  handles.forEach((handle, key) => {\n    if (handle.remove(worker))\n      handles.delete(key);\n  });\n}\ncluster.fork = function(env) {\n  cluster.setupPrimary();\n  const id = ++ids;\n  const workerProcess = createWorkerProcess(id, env);\n  const worker = new Worker({\n    id,\n    process: workerProcess\n  });\n  worker.on(\"message\", function(message, handle) {\n    cluster.emit(\"message\", this, message, handle);\n  });\n  worker.process.once(\"exit\", (exitCode, signalCode) => {\n    if (!worker.isConnected()) {\n      removeHandlesForWorker(worker);\n      removeWorker(worker);\n    }\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = \"dead\";\n    worker.emit(\"exit\", exitCode, signalCode);\n    cluster.emit(\"exit\", worker, exitCode, signalCode);\n  });\n  worker.process.once(\"disconnect\", () => {\n    removeHandlesForWorker(worker);\n    if (worker.isDead())\n      removeWorker(worker);\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = \"disconnected\";\n    worker.emit(\"disconnect\");\n    cluster.emit(\"disconnect\", worker);\n  });\n  worker.process.on(\"internalMessage\", internal(worker, onmessage));\n  process.nextTick(emitForkNT, worker);\n  cluster.workers[worker.id] = worker;\n  return worker;\n};\nfunction emitForkNT(worker) {\n  cluster.emit(\"fork\", worker);\n}\ncluster.disconnect = function(cb) {\n  const workers = ObjectKeys(cluster.workers);\n  if (workers.length === 0) {\n    process.nextTick(() => intercom.emit(\"disconnect\"));\n  } else {\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.isConnected()) {\n        worker.disconnect();\n      }\n    }\n  }\n  if (typeof cb === \"function\")\n    intercom.once(\"disconnect\", cb);\n};\nconst methodMessageMapping = {\n  close,\n  exitedAfterDisconnect,\n  listening,\n  online,\n  queryServer\n};\nfunction onmessage(message, handle) {\n  const worker = this;\n  const fn = methodMessageMapping[message.act];\n  if (typeof fn === \"function\")\n    fn(worker, message);\n}\nfunction online(worker) {\n  worker.state = \"online\";\n  worker.emit(\"online\");\n  cluster.emit(\"online\", worker);\n}\nfunction exitedAfterDisconnect(worker, message) {\n  worker.exitedAfterDisconnect = true;\n  send(worker, { ack: message.seq });\n}\nfunction queryServer(worker, message) {\n  if (worker.exitedAfterDisconnect)\n    return;\n  const key = `${message.address}:${message.port}:${message.addressType}:${message.fd}:${message.index}`;\n  let handle = handles.get(key);\n  if (handle === void 0) {\n    let address = message.address;\n    if (message.port < 0 && typeof address === \"string\" && process.platform !== \"win32\") {\n      address = path.relative(process.cwd(), address);\n      if (message.address.length < address.length)\n        address = message.address;\n    }\n    if (schedulingPolicy !== SCHED_RR || message.addressType === \"udp4\" || message.addressType === \"udp6\") {\n      handle = new SharedHandle(key, address, message);\n    } else {\n      handle = new RoundRobinHandle(key, address, message);\n    }\n    handles.set(key, handle);\n  }\n  if (!handle.data)\n    handle.data = message.data;\n  handle.add(worker, (errno, reply, handle2) => {\n    const { data } = handles.get(key);\n    if (errno)\n      handles.delete(key);\n    send(worker, {\n      errno,\n      key,\n      ack: message.seq,\n      data,\n      ...reply\n    }, handle2);\n  });\n}\nfunction listening(worker, message) {\n  const info = {\n    addressType: message.addressType,\n    address: message.address,\n    port: message.port,\n    fd: message.fd\n  };\n  worker.state = \"listening\";\n  worker.emit(\"listening\", info);\n  cluster.emit(\"listening\", worker, info);\n}\nfunction close(worker, message) {\n  const key = message.key;\n  const handle = handles.get(key);\n  if (handle && handle.remove(worker))\n    handles.delete(key);\n}\nfunction send(worker, message, handle, cb) {\n  return sendHelper(worker.process, message, handle, cb);\n}\nWorker.prototype.disconnect = function() {\n  this.exitedAfterDisconnect = true;\n  send(this, { act: \"disconnect\" });\n  removeHandlesForWorker(this);\n  removeWorker(this);\n  return this;\n};\nWorker.prototype.destroy = function(signo) {\n  const proc = this.process;\n  signo = signo || \"SIGTERM\";\n  if (this.isConnected()) {\n    this.once(\"disconnect\", () => proc.kill(signo));\n    this.disconnect();\n    return;\n  }\n  proc.kill(signo);\n};\n}"],["internal/cluster/round_robin_handle.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  Boolean,\n  SafeMap\n} = primordials;\nconst assert = require(\"internal/assert\");\nconst net = require(\"net\");\nconst { sendHelper } = require(\"internal/cluster/utils\");\nconst { constants } = internalBinding(\"tcp_wrap\");\nmodule.exports = RoundRobinHandle;\nfunction RoundRobinHandle(key, address, { port, fd, flags }) {\n  this.key = key;\n  this.all = new SafeMap();\n  this.free = new SafeMap();\n  this.handles = [];\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n  if (fd >= 0)\n    this.server.listen({ fd });\n  else if (port >= 0) {\n    this.server.listen({\n      port,\n      host: address,\n      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY)\n    });\n  } else\n    this.server.listen(address);\n  this.server.once(\"listening\", () => {\n    this.handle = this.server._handle;\n    this.handle.onconnection = (err, handle) => this.distribute(err, handle);\n    this.server._handle = null;\n    this.server = null;\n  });\n}\nRoundRobinHandle.prototype.add = function(worker, send) {\n  assert(this.all.has(worker.id) === false);\n  this.all.set(worker.id, worker);\n  const done = () => {\n    if (this.handle.getsockname) {\n      const out = {};\n      this.handle.getsockname(out);\n      send(null, { sockname: out }, null);\n    } else {\n      send(null, null, null);\n    }\n    this.handoff(worker);\n  };\n  if (this.server === null)\n    return done();\n  this.server.once(\"listening\", done);\n  this.server.once(\"error\", (err) => {\n    send(err.errno, null);\n  });\n};\nRoundRobinHandle.prototype.remove = function(worker) {\n  const existed = this.all.delete(worker.id);\n  if (!existed)\n    return false;\n  this.free.delete(worker.id);\n  if (this.all.size !== 0)\n    return false;\n  for (const handle of this.handles) {\n    handle.close();\n  }\n  this.handles = [];\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\nRoundRobinHandle.prototype.distribute = function(err, handle) {\n  ArrayPrototypePush(this.handles, handle);\n  const [workerEntry] = this.free;\n  if (ArrayIsArray(workerEntry)) {\n    const { 0: workerId, 1: worker } = workerEntry;\n    this.free.delete(workerId);\n    this.handoff(worker);\n  }\n};\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (!this.all.has(worker.id)) {\n    return;\n  }\n  const handle = ArrayPrototypeShift(this.handles);\n  if (handle === void 0) {\n    this.free.set(worker.id, worker);\n    return;\n  }\n  const message = { act: \"newconn\", key: this.key };\n  sendHelper(worker.process, message, handle, (reply) => {\n    if (reply.accepted)\n      handle.close();\n    else\n      this.distribute(0, handle);\n    this.handoff(worker);\n  });\n};\n}"],["internal/cluster/shared_handle.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { SafeMap } = primordials;\nconst assert = require(\"internal/assert\");\nconst dgram = require(\"internal/dgram\");\nconst net = require(\"net\");\nmodule.exports = SharedHandle;\nfunction SharedHandle(key, address, { port, addressType, fd, flags }) {\n  this.key = key;\n  this.workers = new SafeMap();\n  this.handle = null;\n  this.errno = 0;\n  let rval;\n  if (addressType === \"udp4\" || addressType === \"udp6\")\n    rval = dgram._createSocketHandle(address, port, addressType, fd, flags);\n  else\n    rval = net._createServerHandle(address, port, addressType, fd, flags);\n  if (typeof rval === \"number\")\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\nSharedHandle.prototype.add = function(worker, send) {\n  assert(!this.workers.has(worker.id));\n  this.workers.set(worker.id, worker);\n  send(this.errno, null, this.handle);\n};\nSharedHandle.prototype.remove = function(worker) {\n  if (!this.workers.has(worker.id))\n    return false;\n  this.workers.delete(worker.id);\n  if (this.workers.size !== 0)\n    return false;\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n}"],["internal/cluster/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ReflectApply,\n  SafeMap\n} = primordials;\nmodule.exports = {\n  sendHelper,\n  internal\n};\nconst callbacks = new SafeMap();\nlet seq = 0;\nfunction sendHelper(proc, message, handle, cb) {\n  if (!proc.connected)\n    return false;\n  message = { cmd: \"NODE_CLUSTER\", ...message, seq };\n  if (typeof cb === \"function\")\n    callbacks.set(seq, cb);\n  seq += 1;\n  return proc.send(message, handle);\n}\nfunction internal(worker, cb) {\n  return function onInternalMessage(message, handle) {\n    if (message.cmd !== \"NODE_CLUSTER\")\n      return;\n    let fn = cb;\n    if (message.ack !== void 0) {\n      const callback = callbacks.get(message.ack);\n      if (callback !== void 0) {\n        fn = callback;\n        callbacks.delete(message.ack);\n      }\n    }\n    ReflectApply(fn, worker, arguments);\n  };\n}\n}"],["internal/cluster/worker.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  ReflectApply\n} = primordials;\nconst EventEmitter = require(\"events\");\nmodule.exports = Worker;\nfunction Worker(options) {\n  if (!(this instanceof Worker))\n    return new Worker(options);\n  ReflectApply(EventEmitter, this, []);\n  if (options === null || typeof options !== \"object\")\n    options = {};\n  this.exitedAfterDisconnect = void 0;\n  this.state = options.state || \"none\";\n  this.id = options.id | 0;\n  if (options.process) {\n    this.process = options.process;\n    this.process.on(\"error\", (code, signal) => this.emit(\"error\", code, signal));\n    this.process.on(\"message\", (message, handle) => this.emit(\"message\", message, handle));\n  }\n}\nObjectSetPrototypeOf(Worker.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(Worker, EventEmitter);\nWorker.prototype.kill = function() {\n  ReflectApply(this.destroy, this, arguments);\n};\nWorker.prototype.send = function() {\n  return ReflectApply(this.process.send, this.process, arguments);\n};\nWorker.prototype.isDead = function() {\n  return this.process.exitCode != null || this.process.signalCode != null;\n};\nWorker.prototype.isConnected = function() {\n  return this.process.connected;\n};\n}"],["internal/console/constructor.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  ArrayPrototypeUnshift,\n  Boolean,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  MathFloor,\n  Number,\n  NumberPrototypeToFixed,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectValues,\n  ReflectApply,\n  ReflectConstruct,\n  ReflectOwnKeys,\n  SafeArrayIterator,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeIncludes,\n  StringPrototypePadStart,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolHasInstance,\n  SymbolToStringTag\n} = primordials;\nconst { trace } = internalBinding(\"trace_events\");\nconst {\n  isStackOverflowError,\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INCOMPATIBLE_OPTION_PAIR\n  }\n} = require(\"internal/errors\");\nconst { validateInteger } = require(\"internal/validators\");\nconst { previewEntries } = internalBinding(\"util\");\nconst { Buffer: { isBuffer } } = require(\"buffer\");\nconst {\n  inspect,\n  formatWithOptions\n} = require(\"internal/util/inspect\");\nconst {\n  isTypedArray,\n  isSet,\n  isMap,\n  isSetIterator,\n  isMapIterator\n} = require(\"internal/util/types\");\nconst {\n  CHAR_LOWERCASE_B,\n  CHAR_LOWERCASE_E,\n  CHAR_LOWERCASE_N,\n  CHAR_UPPERCASE_C\n} = require(\"internal/constants\");\nconst kCounts = Symbol(\"counts\");\nconst kTraceConsoleCategory = \"node,node.console\";\nconst kTraceCount = CHAR_UPPERCASE_C;\nconst kTraceBegin = CHAR_LOWERCASE_B;\nconst kTraceEnd = CHAR_LOWERCASE_E;\nconst kTraceInstant = CHAR_LOWERCASE_N;\nconst kSecond = 1e3;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1e3;\nlet cliTable;\nconst kGroupIndent = Symbol(\"kGroupIndent\");\nconst kGroupIndentationWidth = Symbol(\"kGroupIndentWidth\");\nconst kFormatForStderr = Symbol(\"kFormatForStderr\");\nconst kFormatForStdout = Symbol(\"kFormatForStdout\");\nconst kGetInspectOptions = Symbol(\"kGetInspectOptions\");\nconst kColorMode = Symbol(\"kColorMode\");\nconst kIsConsole = Symbol(\"kIsConsole\");\nconst kWriteToConsole = Symbol(\"kWriteToConsole\");\nconst kBindProperties = Symbol(\"kBindProperties\");\nconst kBindStreamsEager = Symbol(\"kBindStreamsEager\");\nconst kBindStreamsLazy = Symbol(\"kBindStreamsLazy\");\nconst kUseStdout = Symbol(\"kUseStdout\");\nconst kUseStderr = Symbol(\"kUseStderr\");\nconst optionsMap = new SafeWeakMap();\nfunction Console(options) {\n  if (!new.target) {\n    return ReflectConstruct(Console, arguments);\n  }\n  if (!options || typeof options.write === \"function\") {\n    options = {\n      stdout: options,\n      stderr: arguments[1],\n      ignoreErrors: arguments[2]\n    };\n  }\n  const {\n    stdout,\n    stderr = stdout,\n    ignoreErrors = true,\n    colorMode = \"auto\",\n    inspectOptions,\n    groupIndentation\n  } = options;\n  if (!stdout || typeof stdout.write !== \"function\") {\n    throw new ERR_CONSOLE_WRITABLE_STREAM(\"stdout\");\n  }\n  if (!stderr || typeof stderr.write !== \"function\") {\n    throw new ERR_CONSOLE_WRITABLE_STREAM(\"stderr\");\n  }\n  if (typeof colorMode !== \"boolean\" && colorMode !== \"auto\")\n    throw new ERR_INVALID_ARG_VALUE(\"colorMode\", colorMode);\n  if (groupIndentation !== void 0) {\n    validateInteger(groupIndentation, \"groupIndentation\", 0, kMaxGroupIndentation);\n  }\n  if (typeof inspectOptions === \"object\" && inspectOptions !== null) {\n    if (inspectOptions.colors !== void 0 && options.colorMode !== void 0) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\"options.inspectOptions.color\", \"colorMode\");\n    }\n    optionsMap.set(this, inspectOptions);\n  } else if (inspectOptions !== void 0) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.inspectOptions\", \"object\", inspectOptions);\n  }\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype), (key) => {\n    this[key] = FunctionPrototypeBind(this[key], this);\n    ObjectDefineProperty(this[key], \"name\", {\n      value: key\n    });\n  });\n  this[kBindStreamsEager](stdout, stderr);\n  this[kBindProperties](ignoreErrors, colorMode, groupIndentation);\n}\nconst consolePropAttributes = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\nObjectDefineProperty(Console, SymbolHasInstance, {\n  value(instance) {\n    return instance[kIsConsole];\n  }\n});\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\nObjectDefineProperties(Console.prototype, {\n  [kBindStreamsEager]: {\n    ...consolePropAttributes,\n    value: function(stdout, stderr) {\n      ObjectDefineProperties(this, {\n        \"_stdout\": { ...consolePropAttributes, value: stdout },\n        \"_stderr\": { ...consolePropAttributes, value: stderr }\n      });\n    }\n  },\n  [kBindStreamsLazy]: {\n    ...consolePropAttributes,\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this, {\n        \"_stdout\": {\n          enumerable: false,\n          configurable: true,\n          get() {\n            if (!stdout)\n              stdout = object.stdout;\n            return stdout;\n          },\n          set(value) {\n            stdout = value;\n          }\n        },\n        \"_stderr\": {\n          enumerable: false,\n          configurable: true,\n          get() {\n            if (!stderr) {\n              stderr = object.stderr;\n            }\n            return stderr;\n          },\n          set(value) {\n            stderr = value;\n          }\n        }\n      });\n    }\n  },\n  [kBindProperties]: {\n    ...consolePropAttributes,\n    value: function(ignoreErrors, colorMode, groupIndentation = 2) {\n      ObjectDefineProperties(this, {\n        \"_stdoutErrorHandler\": {\n          ...consolePropAttributes,\n          value: createWriteErrorHandler(this, kUseStdout)\n        },\n        \"_stderrErrorHandler\": {\n          ...consolePropAttributes,\n          value: createWriteErrorHandler(this, kUseStderr)\n        },\n        \"_ignoreErrors\": {\n          ...consolePropAttributes,\n          value: Boolean(ignoreErrors)\n        },\n        \"_times\": { ...consolePropAttributes, value: new SafeMap() },\n        [kCounts]: { ...consolePropAttributes, value: new SafeMap() },\n        [kColorMode]: { ...consolePropAttributes, value: colorMode },\n        [kIsConsole]: { ...consolePropAttributes, value: true },\n        [kGroupIndent]: { ...consolePropAttributes, value: \"\" },\n        [kGroupIndentationWidth]: {\n          ...consolePropAttributes,\n          value: groupIndentation\n        },\n        [SymbolToStringTag]: {\n          writable: false,\n          enumerable: false,\n          configurable: true,\n          value: \"console\"\n        }\n      });\n    }\n  },\n  [kWriteToConsole]: {\n    ...consolePropAttributes,\n    value: function(streamSymbol, string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ? this._stdoutErrorHandler : this._stderrErrorHandler;\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string, \"\\n\")) {\n          string = StringPrototypeReplace(string, /\\n/g, `\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += \"\\n\";\n      if (ignoreErrors === false)\n        return stream.write(string);\n      try {\n        if (stream.listenerCount(\"error\") === 0)\n          stream.once(\"error\", noop);\n        stream.write(string, errorHandler);\n      } catch (e) {\n        if (isStackOverflowError(e))\n          throw e;\n      } finally {\n        stream.removeListener(\"error\", noop);\n      }\n    }\n  },\n  [kGetInspectOptions]: {\n    ...consolePropAttributes,\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === \"auto\") {\n        color = stream.isTTY && (typeof stream.getColorDepth === \"function\" ? stream.getColorDepth() > 2 : true);\n      }\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === void 0) {\n          options.colors = color;\n        }\n        return options;\n      }\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\n  },\n  [kFormatForStdout]: {\n    ...consolePropAttributes,\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args, opts);\n      return ReflectApply(formatWithOptions, null, args);\n    }\n  },\n  [kFormatForStderr]: {\n    ...consolePropAttributes,\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args, opts);\n      return ReflectApply(formatWithOptions, null, args);\n    }\n  }\n});\nfunction createWriteErrorHandler(instance, streamSymbol) {\n  return (err) => {\n    const stream = streamSymbol === kUseStdout ? instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      if (stream.listenerCount(\"error\") === 0) {\n        stream.once(\"error\", noop);\n      }\n    }\n  };\n}\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout, this[kFormatForStdout](args));\n  },\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr, this[kFormatForStderr](args));\n  },\n  dir(object, options) {\n    this[kWriteToConsole](kUseStdout, inspect(object, {\n      customInspect: false,\n      ...this[kGetInspectOptions](this._stdout),\n      ...options\n    }));\n  },\n  time(label = \"default\") {\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin, kTraceConsoleCategory, `time::${label}`, 0);\n    this._times.set(label, process.hrtime());\n  },\n  timeEnd(label = \"default\") {\n    label = `${label}`;\n    const found = timeLogImpl(this, \"timeEnd\", label);\n    trace(kTraceEnd, kTraceConsoleCategory, `time::${label}`, 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  },\n  timeLog(label = \"default\", ...data) {\n    label = `${label}`;\n    timeLogImpl(this, \"timeLog\", label, data);\n    trace(kTraceInstant, kTraceConsoleCategory, `time::${label}`, 0);\n  },\n  trace: function trace2(...args) {\n    const err = {\n      name: \"Trace\",\n      message: this[kFormatForStderr](args)\n    };\n    ErrorCaptureStackTrace(err, trace2);\n    this.error(err.stack);\n  },\n  assert(expression, ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? \"\" : `: ${args[0]}`}`;\n      ReflectApply(this.warn, this, args);\n    }\n  },\n  clear() {\n    if (this._stdout.isTTY && process.env.TERM !== \"dumb\") {\n      const {\n        cursorTo,\n        clearScreenDown\n      } = require(\"internal/readline/callbacks\");\n      cursorTo(this._stdout, 0, 0);\n      clearScreenDown(this._stdout);\n    }\n  },\n  count(label = \"default\") {\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === void 0)\n      count = 1;\n    else\n      count++;\n    counts.set(label, count);\n    trace(kTraceCount, kTraceConsoleCategory, `count::${label}`, 0, count);\n    this.log(`${label}: ${count}`);\n  },\n  countReset(label = \"default\") {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount, kTraceConsoleCategory, `count::${label}`, 0, 0);\n    counts.delete(`${label}`);\n  },\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log, this, data);\n    }\n    this[kGroupIndent] += StringPrototypeRepeat(\" \", this[kGroupIndentationWidth]);\n  },\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(this[kGroupIndent], 0, this[kGroupIndent].length - this[kGroupIndentationWidth]);\n  },\n  table(tabularData, properties) {\n    if (properties !== void 0 && !ArrayIsArray(properties))\n      throw new ERR_INVALID_ARG_TYPE(\"properties\", \"Array\", properties);\n    if (tabularData === null || typeof tabularData !== \"object\")\n      return this.log(tabularData);\n    if (cliTable === void 0)\n      cliTable = require(\"internal/cli_table\");\n    const final = (k, v) => this.log(cliTable(k, v));\n    const _inspect = (v) => {\n      const depth = v !== null && typeof v === \"object\" && !isArray(v) && ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth,\n        maxArrayLength: 3,\n        breakLength: Infinity,\n        ...this[kGetInspectOptions](this._stdout)\n      };\n      return inspect(v, opt);\n    };\n    const getIndexArray = (length) => ArrayFrom({ length }, (_, i2) => _inspect(i2));\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData, true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n    if (isKeyValue || isMap(tabularData)) {\n      const keys2 = [];\n      const values2 = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys2, _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values2, _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k, 1: v } of tabularData) {\n          ArrayPrototypePush(keys2, _inspect(k));\n          ArrayPrototypePush(values2, _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey,\n        keyKey,\n        valuesKey\n      ], [\n        getIndexArray(length),\n        keys2,\n        values2\n      ]);\n    }\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values2 = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values2, _inspect(v));\n        length++;\n      }\n      return final([iterKey, valuesKey], [getIndexArray(length), values2]);\n    }\n    const map = {};\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null || typeof item !== \"function\" && typeof item !== \"object\";\n      if (properties === void 0 && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys2 = properties || ObjectKeys(item);\n        for (const key of keys2) {\n          if (map[key] === void 0)\n            map[key] = [];\n          if (primitive && properties || !ObjectPrototypeHasOwnProperty(item, key))\n            map[key][i] = \"\";\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys, valuesKey);\n      ArrayPrototypePush(values, valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys, indexKey);\n    ArrayPrototypeUnshift(values, indexKeyArray);\n    return final(keys, values);\n  }\n};\nfunction timeLogImpl(self, name, label, data) {\n  const time = self._times.get(label);\n  if (time === void 0) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1e3 + duration[1] / 1e6;\n  const formatted = formatTime(ms);\n  if (data === void 0) {\n    self.log(\"%s: %s\", label, formatted);\n  } else {\n    self.log(\"%s: %s\", label, formatted, ...new SafeArrayIterator(data));\n  }\n  return true;\n}\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`, 2, \"0\");\n}\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds, 1: ms } = StringPrototypeSplit(NumberPrototypeToFixed(seconds, 3), \".\"));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? \"h:m\" : \"\"}m:ss.mmm)`;\n  }\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds, 3)}s`;\n  }\n  return `${Number(NumberPrototypeToFixed(ms, 3))}ms`;\n}\nconst keyKey = \"Key\";\nconst valuesKey = \"Values\";\nconst indexKey = \"(index)\";\nconst iterKey = \"(iteration index)\";\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\nfunction noop() {\n}\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\nmodule.exports = {\n  Console,\n  kBindStreamsLazy,\n  kBindProperties,\n  formatTime\n};\n}"],["internal/console/global.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  ObjectCreate,\n  ReflectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys\n} = primordials;\nconst {\n  Console,\n  kBindStreamsLazy,\n  kBindProperties\n} = require(\"internal/console/constructor\");\nconst globalConsole = ObjectCreate({});\nfor (const prop of ReflectOwnKeys(Console.prototype)) {\n  if (prop === \"constructor\") {\n    continue;\n  }\n  const desc = ReflectGetOwnPropertyDescriptor(Console.prototype, prop);\n  if (typeof desc.value === \"function\") {\n    const name = desc.value.name;\n    desc.value = FunctionPrototypeBind(desc.value, globalConsole);\n    ReflectDefineProperty(desc.value, \"name\", { value: name });\n  }\n  ReflectDefineProperty(globalConsole, prop, desc);\n}\nglobalConsole[kBindStreamsLazy](process);\nglobalConsole[kBindProperties](true, \"auto\");\nglobalConsole.Console = Console;\nmodule.exports = globalConsole;\n}"],["internal/crypto/aes.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBufferIsView,\n  ArrayBufferPrototypeSlice,\n  ArrayFrom,\n  ArrayPrototypeIncludes,\n  ArrayPrototypePush,\n  MathFloor,\n  Promise,\n  SafeSet,\n  TypedArrayPrototypeSlice\n} = primordials;\nconst {\n  AESCipherJob,\n  KeyObjectHandle,\n  kCryptoJobAsync,\n  kKeyVariantAES_CTR_128,\n  kKeyVariantAES_CBC_128,\n  kKeyVariantAES_GCM_128,\n  kKeyVariantAES_KW_128,\n  kKeyVariantAES_CTR_192,\n  kKeyVariantAES_CBC_192,\n  kKeyVariantAES_GCM_192,\n  kKeyVariantAES_KW_192,\n  kKeyVariantAES_CTR_256,\n  kKeyVariantAES_CBC_256,\n  kKeyVariantAES_GCM_256,\n  kKeyVariantAES_KW_256,\n  kWebCryptoCipherDecrypt,\n  kWebCryptoCipherEncrypt\n} = internalBinding(\"crypto\");\nconst {\n  getArrayBufferOrView,\n  hasAnyNotIn,\n  jobPromise,\n  validateByteLength,\n  validateKeyOps,\n  validateMaxBufferLength,\n  kAesKeyLengths,\n  kHandle,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst { PromiseReject } = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  InternalCryptoKey,\n  SecretKeyObject,\n  createSecretKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  generateKey\n} = require(\"internal/crypto/keygen\");\nconst {\n  validateInteger,\n  validateOneOf\n} = require(\"internal/validators\");\nconst kMaxCounterLength = 128;\nconst kTagLengths = [32, 64, 96, 104, 112, 120, 128];\nfunction getAlgorithmName(name, length) {\n  switch (name) {\n    case \"AES-CBC\":\n      return `A${length}CBC`;\n    case \"AES-CTR\":\n      return `A${length}CTR`;\n    case \"AES-GCM\":\n      return `A${length}GCM`;\n    case \"AES-KW\":\n      return `A${length}KW`;\n  }\n}\nfunction validateKeyLength(length) {\n  if (length !== 128 && length !== 192 && length !== 256)\n    throw lazyDOMException(\"Invalid key length\", \"DataError\");\n}\nfunction getVariant(name, length) {\n  switch (name) {\n    case \"AES-CBC\":\n      switch (length) {\n        case 128:\n          return kKeyVariantAES_CBC_128;\n        case 192:\n          return kKeyVariantAES_CBC_192;\n        case 256:\n          return kKeyVariantAES_CBC_256;\n      }\n      break;\n    case \"AES-CTR\":\n      switch (length) {\n        case 128:\n          return kKeyVariantAES_CTR_128;\n        case 192:\n          return kKeyVariantAES_CTR_192;\n        case 256:\n          return kKeyVariantAES_CTR_256;\n      }\n      break;\n    case \"AES-GCM\":\n      switch (length) {\n        case 128:\n          return kKeyVariantAES_GCM_128;\n        case 192:\n          return kKeyVariantAES_GCM_192;\n        case 256:\n          return kKeyVariantAES_GCM_256;\n      }\n      break;\n    case \"AES-KW\":\n      switch (length) {\n        case 128:\n          return kKeyVariantAES_KW_128;\n        case 192:\n          return kKeyVariantAES_KW_192;\n        case 256:\n          return kKeyVariantAES_KW_256;\n      }\n      break;\n  }\n}\nfunction asyncAesCtrCipher(mode, key, data, { counter, length }) {\n  counter = getArrayBufferOrView(counter, \"algorithm.counter\");\n  validateByteLength(counter, \"algorithm.counter\", 16);\n  if (typeof length !== \"number\" || length <= 0 || length > kMaxCounterLength) {\n    throw lazyDOMException(\"AES-CTR algorithm.length must be between 1 and 128\", \"OperationError\");\n  }\n  return jobPromise(new AESCipherJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], data, getVariant(\"AES-CTR\", key.algorithm.length), counter, length));\n}\nfunction asyncAesCbcCipher(mode, key, data, { iv }) {\n  iv = getArrayBufferOrView(iv, \"algorithm.iv\");\n  validateByteLength(iv, \"algorithm.iv\", 16);\n  return jobPromise(new AESCipherJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], data, getVariant(\"AES-CBC\", key.algorithm.length), iv));\n}\nfunction asyncAesKwCipher(mode, key, data) {\n  return jobPromise(new AESCipherJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], data, getVariant(\"AES-KW\", key.algorithm.length)));\n}\nfunction asyncAesGcmCipher(mode, key, data, { iv, additionalData, tagLength = 128 }) {\n  if (!ArrayPrototypeIncludes(kTagLengths, tagLength)) {\n    return PromiseReject(lazyDOMException(`${tagLength} is not a valid AES-GCM tag length`, \"OperationError\"));\n  }\n  iv = getArrayBufferOrView(iv, \"algorithm.iv\");\n  validateMaxBufferLength(iv, \"algorithm.iv\");\n  if (additionalData !== void 0) {\n    additionalData = getArrayBufferOrView(additionalData, \"algorithm.additionalData\");\n    validateMaxBufferLength(additionalData, \"algorithm.additionalData\");\n  }\n  const tagByteLength = MathFloor(tagLength / 8);\n  let tag;\n  switch (mode) {\n    case kWebCryptoCipherDecrypt:\n      const slice = ArrayBufferIsView(data) ? TypedArrayPrototypeSlice : ArrayBufferPrototypeSlice;\n      tag = slice(data, -tagByteLength);\n      if (tagByteLength > tag.byteLength) {\n        return PromiseReject(lazyDOMException(\"The provided data is too small.\", \"OperationError\"));\n      }\n      data = slice(data, 0, -tagByteLength);\n      break;\n    case kWebCryptoCipherEncrypt:\n      tag = tagByteLength;\n      break;\n  }\n  return jobPromise(new AESCipherJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], data, getVariant(\"AES-GCM\", key.algorithm.length), iv, tag, additionalData));\n}\nfunction aesCipher(mode, key, data, algorithm) {\n  switch (algorithm.name) {\n    case \"AES-CTR\":\n      return asyncAesCtrCipher(mode, key, data, algorithm);\n    case \"AES-CBC\":\n      return asyncAesCbcCipher(mode, key, data, algorithm);\n    case \"AES-GCM\":\n      return asyncAesGcmCipher(mode, key, data, algorithm);\n    case \"AES-KW\":\n      return asyncAesKwCipher(mode, key, data);\n  }\n}\nasync function aesGenerateKey(algorithm, extractable, keyUsages) {\n  const { name, length } = algorithm;\n  validateInteger(length, \"algorithm.length\");\n  validateOneOf(length, \"algorithm.length\", kAesKeyLengths);\n  const usageSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usageSet, [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"])) {\n    throw lazyDOMException(\"Unsupported key usage for an AES key\", \"SyntaxError\");\n  }\n  return new Promise((resolve, reject) => {\n    generateKey(\"aes\", { length }, (err, key) => {\n      if (err) {\n        return reject(lazyDOMException(`The operation failed for an operation-specific reason [${err.message}]`, \"OperationError\"));\n      }\n      resolve(new InternalCryptoKey(key, { name, length }, ArrayFrom(usageSet), extractable));\n    });\n  });\n}\nasync function aesImportKey(algorithm, format, keyData, extractable, keyUsages) {\n  const { name } = algorithm;\n  const checkUsages = [\"wrapKey\", \"unwrapKey\"];\n  if (name !== \"AES-KW\")\n    ArrayPrototypePush(checkUsages, \"encrypt\", \"decrypt\");\n  const usagesSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usagesSet, checkUsages)) {\n    throw lazyDOMException(\"Unsupported key usage for an AES key\", \"SyntaxError\");\n  }\n  let keyObject;\n  let length;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type !== \"secret\") {\n        throw lazyDOMException(`Unable to import AES key with format ${format}`, \"NotSupportedError\");\n      }\n      keyObject = keyData;\n      break;\n    }\n    case \"raw\": {\n      validateKeyLength(keyData.byteLength * 8);\n      keyObject = createSecretKey(keyData);\n      break;\n    }\n    case \"jwk\": {\n      if (keyData == null || typeof keyData !== \"object\")\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      if (keyData.kty !== \"oct\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      if (usagesSet.size > 0 && keyData.use !== void 0 && keyData.use !== \"enc\") {\n        throw lazyDOMException(\"Invalid use type\", \"DataError\");\n      }\n      validateKeyOps(keyData.key_ops, usagesSet);\n      if (keyData.ext !== void 0 && keyData.ext === false && extractable === true) {\n        throw lazyDOMException(\"JWK is not extractable\", \"DataError\");\n      }\n      const handle = new KeyObjectHandle();\n      handle.initJwk(keyData);\n      ({ length } = handle.keyDetail({}));\n      validateKeyLength(length);\n      if (keyData.alg !== void 0) {\n        if (typeof keyData.alg !== \"string\")\n          throw lazyDOMException(\"Invalid alg\", \"DataError\");\n        if (keyData.alg !== getAlgorithmName(algorithm.name, length))\n          throw lazyDOMException(\"Algorithm mismatch\", \"DataError\");\n      }\n      keyObject = new SecretKeyObject(handle);\n      break;\n    }\n    default:\n      throw lazyDOMException(`Unable to import AES key with format ${format}`, \"NotSupportedError\");\n  }\n  if (length === void 0) {\n    ({ length } = keyObject[kHandle].keyDetail({}));\n    validateKeyLength(length);\n  }\n  return new InternalCryptoKey(keyObject, { name, length }, keyUsages, extractable);\n}\nmodule.exports = {\n  aesCipher,\n  aesGenerateKey,\n  aesImportKey,\n  getAlgorithmName\n};\n}"],["internal/crypto/certificate.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  certExportChallenge,\n  certExportPublicKey,\n  certVerifySpkac\n} = internalBinding(\"crypto\");\nconst {\n  getArrayBufferOrView\n} = require(\"internal/crypto/util\");\nfunction verifySpkac(spkac, encoding) {\n  return certVerifySpkac(getArrayBufferOrView(spkac, \"spkac\", encoding));\n}\nfunction exportPublicKey(spkac, encoding) {\n  return certExportPublicKey(getArrayBufferOrView(spkac, \"spkac\", encoding));\n}\nfunction exportChallenge(spkac, encoding) {\n  return certExportChallenge(getArrayBufferOrView(spkac, \"spkac\", encoding));\n}\nfunction Certificate() {\n  if (!(this instanceof Certificate))\n    return new Certificate();\n}\nCertificate.prototype.verifySpkac = verifySpkac;\nCertificate.prototype.exportPublicKey = exportPublicKey;\nCertificate.prototype.exportChallenge = exportChallenge;\nCertificate.exportChallenge = exportChallenge;\nCertificate.exportPublicKey = exportPublicKey;\nCertificate.verifySpkac = verifySpkac;\nmodule.exports = Certificate;\n}"],["internal/crypto/cipher.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  StringPrototypeToLowerCase\n} = primordials;\nconst {\n  CipherBase,\n  privateDecrypt: _privateDecrypt,\n  privateEncrypt: _privateEncrypt,\n  publicDecrypt: _publicDecrypt,\n  publicEncrypt: _publicEncrypt,\n  getCipherInfo: _getCipherInfo\n} = internalBinding(\"crypto\");\nconst {\n  crypto: {\n    RSA_PKCS1_OAEP_PADDING,\n    RSA_PKCS1_PADDING\n  }\n} = internalBinding(\"constants\");\nconst {\n  codes: {\n    ERR_CRYPTO_INVALID_STATE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateEncoding,\n  validateInt32,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  preparePrivateKey,\n  preparePublicOrPrivateKey,\n  prepareSecretKey\n} = require(\"internal/crypto/keys\");\nconst {\n  getDefaultEncoding,\n  getArrayBufferOrView,\n  getStringOption,\n  kHandle\n} = require(\"internal/crypto/util\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst assert = require(\"internal/assert\");\nconst LazyTransform = require(\"internal/streams/lazy_transform\");\nconst { normalizeEncoding } = require(\"internal/util\");\nconst { StringDecoder } = require(\"string_decoder\");\nfunction rsaFunctionFor(method, defaultPadding, keyType) {\n  return (options, buffer) => {\n    const { format, type, data, passphrase } = keyType === \"private\" ? preparePrivateKey(options) : preparePublicOrPrivateKey(options);\n    const padding = options.padding || defaultPadding;\n    const { oaepHash, encoding } = options;\n    let { oaepLabel } = options;\n    if (oaepHash !== void 0)\n      validateString(oaepHash, \"key.oaepHash\");\n    if (oaepLabel !== void 0)\n      oaepLabel = getArrayBufferOrView(oaepLabel, \"key.oaepLabel\", encoding);\n    buffer = getArrayBufferOrView(buffer, \"buffer\", encoding);\n    return method(data, format, type, passphrase, buffer, padding, oaepHash, oaepLabel);\n  };\n}\nconst publicEncrypt = rsaFunctionFor(_publicEncrypt, RSA_PKCS1_OAEP_PADDING, \"public\");\nconst publicDecrypt = rsaFunctionFor(_publicDecrypt, RSA_PKCS1_PADDING, \"public\");\nconst privateEncrypt = rsaFunctionFor(_privateEncrypt, RSA_PKCS1_PADDING, \"private\");\nconst privateDecrypt = rsaFunctionFor(_privateDecrypt, RSA_PKCS1_OAEP_PADDING, \"private\");\nfunction getDecoder(decoder, encoding) {\n  encoding = normalizeEncoding(encoding);\n  decoder = decoder || new StringDecoder(encoding);\n  assert(decoder.encoding === encoding, \"Cannot change encoding\");\n  return decoder;\n}\nfunction getUIntOption(options, key) {\n  let value;\n  if (options && (value = options[key]) != null) {\n    if (value >>> 0 !== value)\n      throw new ERR_INVALID_ARG_VALUE(`options.${key}`, value);\n    return value;\n  }\n  return -1;\n}\nfunction createCipherBase(cipher, credential, options, decipher, iv) {\n  const authTagLength = getUIntOption(options, \"authTagLength\");\n  this[kHandle] = new CipherBase(decipher);\n  if (iv === void 0) {\n    this[kHandle].init(cipher, credential, authTagLength);\n  } else {\n    this[kHandle].initiv(cipher, credential, iv, authTagLength);\n  }\n  this._decoder = null;\n  ReflectApply(LazyTransform, this, [options]);\n}\nfunction createCipher(cipher, password, options, decipher) {\n  validateString(cipher, \"cipher\");\n  password = getArrayBufferOrView(password, \"password\");\n  ReflectApply(createCipherBase, this, [cipher, password, options, decipher]);\n}\nfunction createCipherWithIV(cipher, key, options, decipher, iv) {\n  validateString(cipher, \"cipher\");\n  const encoding = getStringOption(options, \"encoding\");\n  key = prepareSecretKey(key, encoding);\n  iv = iv === null ? null : getArrayBufferOrView(iv, \"iv\");\n  ReflectApply(createCipherBase, this, [cipher, key, options, decipher, iv]);\n}\nfunction Cipher(cipher, password, options) {\n  if (!(this instanceof Cipher))\n    return new Cipher(cipher, password, options);\n  ReflectApply(createCipher, this, [cipher, password, options, true]);\n}\nObjectSetPrototypeOf(Cipher.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Cipher, LazyTransform);\nCipher.prototype._transform = function _transform(chunk, encoding, callback) {\n  this.push(this[kHandle].update(chunk, encoding));\n  callback();\n};\nCipher.prototype._flush = function _flush(callback) {\n  try {\n    this.push(this[kHandle].final());\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  callback();\n};\nCipher.prototype.update = function update(data, inputEncoding, outputEncoding) {\n  const encoding = getDefaultEncoding();\n  inputEncoding = inputEncoding || encoding;\n  outputEncoding = outputEncoding || encoding;\n  if (typeof data === \"string\") {\n    validateEncoding(data, inputEncoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\"data\", [\"string\", \"Buffer\", \"TypedArray\", \"DataView\"], data);\n  }\n  const ret = this[kHandle].update(data, inputEncoding);\n  if (outputEncoding && outputEncoding !== \"buffer\") {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    return this._decoder.write(ret);\n  }\n  return ret;\n};\nCipher.prototype.final = function final(outputEncoding) {\n  outputEncoding = outputEncoding || getDefaultEncoding();\n  const ret = this[kHandle].final();\n  if (outputEncoding && outputEncoding !== \"buffer\") {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    return this._decoder.end(ret);\n  }\n  return ret;\n};\nCipher.prototype.setAutoPadding = function setAutoPadding(ap) {\n  if (!this[kHandle].setAutoPadding(!!ap))\n    throw new ERR_CRYPTO_INVALID_STATE(\"setAutoPadding\");\n  return this;\n};\nCipher.prototype.getAuthTag = function getAuthTag() {\n  const ret = this[kHandle].getAuthTag();\n  if (ret === void 0)\n    throw new ERR_CRYPTO_INVALID_STATE(\"getAuthTag\");\n  return ret;\n};\nfunction setAuthTag(tagbuf, encoding) {\n  tagbuf = getArrayBufferOrView(tagbuf, \"buffer\", encoding);\n  if (!this[kHandle].setAuthTag(tagbuf))\n    throw new ERR_CRYPTO_INVALID_STATE(\"setAuthTag\");\n  return this;\n}\nCipher.prototype.setAAD = function setAAD(aadbuf, options) {\n  const encoding = getStringOption(options, \"encoding\");\n  const plaintextLength = getUIntOption(options, \"plaintextLength\");\n  aadbuf = getArrayBufferOrView(aadbuf, \"aadbuf\", encoding);\n  if (!this[kHandle].setAAD(aadbuf, plaintextLength))\n    throw new ERR_CRYPTO_INVALID_STATE(\"setAAD\");\n  return this;\n};\nfunction Cipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Cipheriv))\n    return new Cipheriv(cipher, key, iv, options);\n  ReflectApply(createCipherWithIV, this, [cipher, key, options, true, iv]);\n}\nfunction addCipherPrototypeFunctions(constructor) {\n  constructor.prototype._transform = Cipher.prototype._transform;\n  constructor.prototype._flush = Cipher.prototype._flush;\n  constructor.prototype.update = Cipher.prototype.update;\n  constructor.prototype.final = Cipher.prototype.final;\n  constructor.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\n  if (constructor === Cipheriv) {\n    constructor.prototype.getAuthTag = Cipher.prototype.getAuthTag;\n  } else {\n    constructor.prototype.setAuthTag = setAuthTag;\n  }\n  constructor.prototype.setAAD = Cipher.prototype.setAAD;\n}\nObjectSetPrototypeOf(Cipheriv.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Cipheriv, LazyTransform);\naddCipherPrototypeFunctions(Cipheriv);\nfunction Decipher(cipher, password, options) {\n  if (!(this instanceof Decipher))\n    return new Decipher(cipher, password, options);\n  ReflectApply(createCipher, this, [cipher, password, options, false]);\n}\nObjectSetPrototypeOf(Decipher.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Decipher, LazyTransform);\naddCipherPrototypeFunctions(Decipher);\nfunction Decipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Decipheriv))\n    return new Decipheriv(cipher, key, iv, options);\n  ReflectApply(createCipherWithIV, this, [cipher, key, options, false, iv]);\n}\nObjectSetPrototypeOf(Decipheriv.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Decipheriv, LazyTransform);\naddCipherPrototypeFunctions(Decipheriv);\nfunction getCipherInfo(nameOrNid, options) {\n  if (typeof nameOrNid !== \"string\" && typeof nameOrNid !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(\"nameOrNid\", [\"string\", \"number\"], nameOrNid);\n  }\n  if (typeof nameOrNid === \"number\")\n    validateInt32(nameOrNid, \"nameOrNid\");\n  let keyLength, ivLength;\n  if (options !== void 0) {\n    validateObject(options, \"options\");\n    ({ keyLength, ivLength } = options);\n    if (keyLength !== void 0)\n      validateInt32(keyLength, \"options.keyLength\");\n    if (ivLength !== void 0)\n      validateInt32(ivLength, \"options.ivLength\");\n  }\n  const ret = _getCipherInfo({}, nameOrNid, keyLength, ivLength);\n  if (ret !== void 0) {\n    if (ret.name)\n      ret.name = StringPrototypeToLowerCase(ret.name);\n    if (ret.type)\n      ret.type = StringPrototypeToLowerCase(ret.type);\n  }\n  return ret;\n}\nmodule.exports = {\n  Cipher,\n  Cipheriv,\n  Decipher,\n  Decipheriv,\n  privateDecrypt,\n  privateEncrypt,\n  publicDecrypt,\n  publicEncrypt,\n  getCipherInfo\n};\n}"],["internal/crypto/diffiehellman.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBufferPrototypeSlice,\n  FunctionPrototypeCall,\n  MathFloor,\n  ObjectDefineProperty,\n  Promise,\n  SafeSet\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  DHBitsJob,\n  DHKeyExportJob,\n  DiffieHellman: _DiffieHellman,\n  DiffieHellmanGroup: _DiffieHellmanGroup,\n  ECDH: _ECDH,\n  ECDHBitsJob,\n  ECDHConvertKey: _ECDHConvertKey,\n  statelessDH,\n  kCryptoJobAsync\n} = internalBinding(\"crypto\");\nconst {\n  codes: {\n    ERR_CRYPTO_ECDH_INVALID_FORMAT,\n    ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY,\n    ERR_CRYPTO_INCOMPATIBLE_KEY,\n    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateCallback,\n  validateInt32,\n  validateObject,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  isArrayBufferView,\n  isAnyArrayBuffer\n} = require(\"internal/util/types\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  KeyObject,\n  InternalCryptoKey,\n  createPrivateKey,\n  createPublicKey,\n  isCryptoKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  generateKeyPair\n} = require(\"internal/crypto/keygen\");\nconst {\n  getArrayBufferOrView,\n  getDefaultEncoding,\n  getUsagesUnion,\n  hasAnyNotIn,\n  jobPromise,\n  toBuf,\n  kHandle,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  crypto: {\n    POINT_CONVERSION_COMPRESSED,\n    POINT_CONVERSION_HYBRID,\n    POINT_CONVERSION_UNCOMPRESSED\n  }\n} = internalBinding(\"constants\");\nconst DH_GENERATOR = 2;\nfunction DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {\n  if (!(this instanceof DiffieHellman))\n    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);\n  if (typeof sizeOrKey !== \"number\" && typeof sizeOrKey !== \"string\" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer(sizeOrKey)) {\n    throw new ERR_INVALID_ARG_TYPE(\"sizeOrKey\", [\"number\", \"string\", \"ArrayBuffer\", \"Buffer\", \"TypedArray\", \"DataView\"], sizeOrKey);\n  }\n  if (typeof sizeOrKey === \"number\")\n    validateInt32(sizeOrKey, \"sizeOrKey\");\n  if (keyEncoding && !Buffer.isEncoding(keyEncoding) && keyEncoding !== \"buffer\") {\n    genEncoding = generator;\n    generator = keyEncoding;\n    keyEncoding = false;\n  }\n  const encoding = getDefaultEncoding();\n  keyEncoding = keyEncoding || encoding;\n  genEncoding = genEncoding || encoding;\n  if (typeof sizeOrKey !== \"number\")\n    sizeOrKey = toBuf(sizeOrKey, keyEncoding);\n  if (!generator) {\n    generator = DH_GENERATOR;\n  } else if (typeof generator === \"number\") {\n    validateInt32(generator, \"generator\");\n  } else if (typeof generator === \"string\") {\n    generator = toBuf(generator, genEncoding);\n  } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer(generator)) {\n    throw new ERR_INVALID_ARG_TYPE(\"generator\", [\"number\", \"string\", \"ArrayBuffer\", \"Buffer\", \"TypedArray\", \"DataView\"], generator);\n  }\n  this[kHandle] = new _DiffieHellman(sizeOrKey, generator);\n  ObjectDefineProperty(this, \"verifyError\", {\n    enumerable: true,\n    value: this[kHandle].verifyError,\n    writable: false\n  });\n}\nfunction DiffieHellmanGroup(name) {\n  if (!(this instanceof DiffieHellmanGroup))\n    return new DiffieHellmanGroup(name);\n  this[kHandle] = new _DiffieHellmanGroup(name);\n  ObjectDefineProperty(this, \"verifyError\", {\n    enumerable: true,\n    value: this[kHandle].verifyError,\n    writable: false\n  });\n}\nDiffieHellmanGroup.prototype.generateKeys = DiffieHellman.prototype.generateKeys = dhGenerateKeys;\nfunction dhGenerateKeys(encoding) {\n  const keys = this[kHandle].generateKeys();\n  encoding = encoding || getDefaultEncoding();\n  return encode(keys, encoding);\n}\nDiffieHellmanGroup.prototype.computeSecret = DiffieHellman.prototype.computeSecret = dhComputeSecret;\nfunction dhComputeSecret(key, inEnc, outEnc) {\n  const encoding = getDefaultEncoding();\n  inEnc = inEnc || encoding;\n  outEnc = outEnc || encoding;\n  key = getArrayBufferOrView(key, \"key\", inEnc);\n  const ret = this[kHandle].computeSecret(key);\n  if (typeof ret === \"string\")\n    throw new ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY();\n  return encode(ret, outEnc);\n}\nDiffieHellmanGroup.prototype.getPrime = DiffieHellman.prototype.getPrime = dhGetPrime;\nfunction dhGetPrime(encoding) {\n  const prime = this[kHandle].getPrime();\n  encoding = encoding || getDefaultEncoding();\n  return encode(prime, encoding);\n}\nDiffieHellmanGroup.prototype.getGenerator = DiffieHellman.prototype.getGenerator = dhGetGenerator;\nfunction dhGetGenerator(encoding) {\n  const generator = this[kHandle].getGenerator();\n  encoding = encoding || getDefaultEncoding();\n  return encode(generator, encoding);\n}\nDiffieHellmanGroup.prototype.getPublicKey = DiffieHellman.prototype.getPublicKey = dhGetPublicKey;\nfunction dhGetPublicKey(encoding) {\n  const key = this[kHandle].getPublicKey();\n  encoding = encoding || getDefaultEncoding();\n  return encode(key, encoding);\n}\nDiffieHellmanGroup.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey = dhGetPrivateKey;\nfunction dhGetPrivateKey(encoding) {\n  const key = this[kHandle].getPrivateKey();\n  encoding = encoding || getDefaultEncoding();\n  return encode(key, encoding);\n}\nDiffieHellman.prototype.setPublicKey = function setPublicKey(key, encoding) {\n  encoding = encoding || getDefaultEncoding();\n  key = getArrayBufferOrView(key, \"key\", encoding);\n  this[kHandle].setPublicKey(key);\n  return this;\n};\nDiffieHellman.prototype.setPrivateKey = function setPrivateKey(key, encoding) {\n  encoding = encoding || getDefaultEncoding();\n  key = getArrayBufferOrView(key, \"key\", encoding);\n  this[kHandle].setPrivateKey(key);\n  return this;\n};\nfunction ECDH(curve) {\n  if (!(this instanceof ECDH))\n    return new ECDH(curve);\n  validateString(curve, \"curve\");\n  this[kHandle] = new _ECDH(curve);\n}\nECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;\nECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;\nECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;\nECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;\nECDH.prototype.generateKeys = function generateKeys(encoding, format) {\n  this[kHandle].generateKeys();\n  return this.getPublicKey(encoding, format);\n};\nECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {\n  const f = getFormat(format);\n  const key = this[kHandle].getPublicKey(f);\n  encoding = encoding || getDefaultEncoding();\n  return encode(key, encoding);\n};\nECDH.convertKey = function convertKey(key, curve, inEnc, outEnc, format) {\n  validateString(curve, \"curve\");\n  const encoding = inEnc || getDefaultEncoding();\n  key = getArrayBufferOrView(key, \"key\", encoding);\n  outEnc = outEnc || encoding;\n  const f = getFormat(format);\n  const convertedKey = _ECDHConvertKey(key, curve, f);\n  return encode(convertedKey, outEnc);\n};\nfunction encode(buffer, encoding) {\n  if (encoding && encoding !== \"buffer\")\n    buffer = buffer.toString(encoding);\n  return buffer;\n}\nfunction getFormat(format) {\n  if (format) {\n    if (format === \"compressed\")\n      return POINT_CONVERSION_COMPRESSED;\n    if (format === \"hybrid\")\n      return POINT_CONVERSION_HYBRID;\n    if (format !== \"uncompressed\")\n      throw new ERR_CRYPTO_ECDH_INVALID_FORMAT(format);\n  }\n  return POINT_CONVERSION_UNCOMPRESSED;\n}\nconst dhEnabledKeyTypes = new SafeSet([\"dh\", \"ec\", \"x448\", \"x25519\"]);\nfunction diffieHellman(options) {\n  validateObject(options, \"options\");\n  const { privateKey, publicKey } = options;\n  if (!(privateKey instanceof KeyObject))\n    throw new ERR_INVALID_ARG_VALUE(\"options.privateKey\", privateKey);\n  if (!(publicKey instanceof KeyObject))\n    throw new ERR_INVALID_ARG_VALUE(\"options.publicKey\", publicKey);\n  if (privateKey.type !== \"private\")\n    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(privateKey.type, \"private\");\n  if (publicKey.type !== \"public\" && publicKey.type !== \"private\") {\n    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(publicKey.type, \"private or public\");\n  }\n  const privateType = privateKey.asymmetricKeyType;\n  const publicType = publicKey.asymmetricKeyType;\n  if (privateType !== publicType || !dhEnabledKeyTypes.has(privateType)) {\n    throw new ERR_CRYPTO_INCOMPATIBLE_KEY(\"key types for Diffie-Hellman\", `${privateType} and ${publicType}`);\n  }\n  return statelessDH(privateKey[kHandle], publicKey[kHandle]);\n}\nfunction deriveBitsECDH(name, publicKey, privateKey, callback) {\n  validateString(name, \"name\");\n  validateObject(publicKey, \"publicKey\");\n  validateObject(privateKey, \"privateKey\");\n  validateCallback(callback);\n  const job = new ECDHBitsJob(kCryptoJobAsync, name, publicKey, privateKey);\n  job.ondone = (error, bits) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, bits);\n  };\n  job.run();\n}\nfunction deriveBitsDH(publicKey, privateKey, callback) {\n  validateObject(publicKey, \"publicKey\");\n  validateObject(privateKey, \"privateKey\");\n  validateCallback(callback);\n  const job = new DHBitsJob(kCryptoJobAsync, publicKey, privateKey);\n  job.ondone = (error, bits) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, bits);\n  };\n  job.run();\n}\nfunction verifyAcceptableDhKeyUse(name, type, usages) {\n  let checkSet;\n  switch (type) {\n    case \"private\":\n      checkSet = [\"deriveBits\", \"deriveKey\"];\n      break;\n    case \"public\":\n      checkSet = [];\n      break;\n  }\n  if (hasAnyNotIn(usages, checkSet)) {\n    throw lazyDOMException(`Unsupported key usage for an ${name} key`, \"SyntaxError\");\n  }\n}\nasync function dhGenerateKey(algorithm, extractable, keyUsages) {\n  const usageSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usageSet, [\"deriveKey\", \"deriveBits\"])) {\n    throw lazyDOMException(\"Unsupported key usage for a DH key\", \"SyntaxError\");\n  }\n  const {\n    name,\n    primeLength,\n    generator,\n    group\n  } = algorithm;\n  let { prime } = algorithm;\n  if (prime !== void 0)\n    prime = getArrayBufferOrView(prime);\n  return new Promise((resolve, reject) => {\n    generateKeyPair(\"dh\", {\n      prime,\n      primeLength,\n      generator,\n      group\n    }, (err, pubKey, privKey) => {\n      if (err) {\n        return reject(lazyDOMException(\"The operation failed for an operation-specific reason\", \"OperationError\"));\n      }\n      const algorithm2 = { name, prime, primeLength, generator, group };\n      const publicKey = new InternalCryptoKey(pubKey, algorithm2, [], true);\n      const privateKey = new InternalCryptoKey(privKey, algorithm2, getUsagesUnion(usageSet, \"deriveBits\", \"deriveKey\"), extractable);\n      resolve({ publicKey, privateKey });\n    });\n  });\n}\nasync function asyncDeriveBitsECDH(algorithm, baseKey, length) {\n  const { \"public\": key } = algorithm;\n  if (length !== null)\n    validateUint32(length, \"length\");\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE(\"algorithm.public\", \"CryptoKey\", key);\n  if (key.type !== \"public\") {\n    throw lazyDOMException(\"algorithm.public must be a public key\", \"InvalidAccessError\");\n  }\n  if (baseKey.type !== \"private\") {\n    throw lazyDOMException(\"baseKey must be a private key\", \"InvalidAccessError\");\n  }\n  if (key.algorithm.name !== \"ECDH\") {\n    throw lazyDOMException(\"Keys must be ECDH keys\", \"InvalidAccessError\");\n  }\n  if (key.algorithm.name !== baseKey.algorithm.name) {\n    throw lazyDOMException(\"The public and private keys must be of the same type\", \"InvalidAccessError\");\n  }\n  if (key.algorithm.namedCurve !== baseKey.algorithm.namedCurve)\n    throw lazyDOMException(\"Named curve mismatch\", \"InvalidAccessError\");\n  const bits = await new Promise((resolve, reject) => {\n    deriveBitsECDH(baseKey.algorithm.namedCurve, key[kKeyObject][kHandle], baseKey[kKeyObject][kHandle], (err, bits2) => {\n      if (err)\n        return reject(err);\n      resolve(bits2);\n    });\n  });\n  if (length === null)\n    return bits;\n  length = MathFloor(length / 8);\n  const { byteLength } = bits;\n  if (byteLength < length)\n    throw lazyDOMException(\"derived bit length is too small\", \"OperationError\");\n  return length === byteLength ? bits : ArrayBufferPrototypeSlice(bits, 0, length);\n}\nasync function asyncDeriveBitsDH(algorithm, baseKey, length) {\n  const { \"public\": key } = algorithm;\n  if (length !== null)\n    validateUint32(length, \"length\");\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE(\"algorithm.public\", \"CryptoKey\", key);\n  if (key.type !== \"public\") {\n    throw lazyDOMException(\"algorithm.public must be a public key\", \"InvalidAccessError\");\n  }\n  if (baseKey.type !== \"private\") {\n    throw lazyDOMException(\"baseKey must be a private key\", \"InvalidAccessError\");\n  }\n  if (key.algorithm.name !== \"NODE-DH\")\n    throw lazyDOMException(\"Keys must be DH keys\", \"InvalidAccessError\");\n  if (key.algorithm.name !== baseKey.algorithm.name) {\n    throw lazyDOMException(\"The public and private keys must be of the same type\", \"InvalidAccessError\");\n  }\n  const bits = await new Promise((resolve, reject) => {\n    deriveBitsDH(key[kKeyObject][kHandle], baseKey[kKeyObject][kHandle], (err, bits2) => {\n      if (err)\n        return reject(err);\n      resolve(bits2);\n    });\n  });\n  if (length === null)\n    return bits;\n  length = MathFloor(length / 8);\n  const { byteLength } = bits;\n  if (byteLength < length)\n    throw lazyDOMException(\"derived bit length is too small\", \"OperationError\");\n  return length === byteLength ? bits : ArrayBufferPrototypeSlice(bits, 0, length);\n}\nfunction dhExportKey(key, format) {\n  return jobPromise(new DHKeyExportJob(kCryptoJobAsync, format, key[kKeyObject][kHandle]));\n}\nasync function dhImportKey(format, keyData, algorithm, extractable, keyUsages) {\n  const usagesSet = new SafeSet(keyUsages);\n  let keyObject;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type === \"secret\")\n        throw lazyDOMException(\"Invalid key type\", \"InvalidAccessException\");\n      verifyAcceptableDhKeyUse(algorithm.name, keyData.type, usagesSet);\n      keyObject = keyData;\n      break;\n    }\n    case \"spki\": {\n      verifyAcceptableDhKeyUse(algorithm.name, \"public\", usagesSet);\n      keyObject = createPublicKey({\n        key: keyData,\n        format: \"der\",\n        type: \"spki\"\n      });\n      break;\n    }\n    case \"pkcs8\": {\n      verifyAcceptableDhKeyUse(algorithm.name, \"private\", usagesSet);\n      keyObject = createPrivateKey({\n        key: keyData,\n        format: \"der\",\n        type: \"pkcs8\"\n      });\n      break;\n    }\n    default:\n      throw lazyDOMException(`Unable to import DH key with format ${format}`, \"NotSupportedError\");\n  }\n  const {\n    prime,\n    primeLength,\n    generator,\n    group\n  } = keyObject[kHandle].keyDetail({});\n  return new InternalCryptoKey(keyObject, {\n    name: algorithm.name,\n    prime,\n    primeLength,\n    generator,\n    group\n  }, keyUsages, extractable);\n}\nmodule.exports = {\n  DiffieHellman,\n  DiffieHellmanGroup,\n  ECDH,\n  diffieHellman,\n  deriveBitsECDH,\n  deriveBitsDH,\n  dhGenerateKey,\n  asyncDeriveBitsECDH,\n  asyncDeriveBitsDH,\n  dhExportKey,\n  dhImportKey\n};\n}"],["internal/crypto/dsa.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Promise,\n  SafeSet\n} = primordials;\nconst {\n  DSAKeyExportJob,\n  KeyObjectHandle,\n  SignJob,\n  kCryptoJobAsync,\n  kSigEncDER,\n  kKeyTypePrivate,\n  kSignJobModeSign,\n  kSignJobModeVerify\n} = internalBinding(\"crypto\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_OPTION\n  }\n} = require(\"internal/errors\");\nconst {\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  InternalCryptoKey,\n  PrivateKeyObject,\n  PublicKeyObject,\n  createPrivateKey,\n  createPublicKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  generateKeyPair\n} = require(\"internal/crypto/keygen\");\nconst {\n  getUsagesUnion,\n  hasAnyNotIn,\n  jobPromise,\n  normalizeHashName,\n  validateKeyOps,\n  kKeyObject,\n  kHandle\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nfunction verifyAcceptableDsaKeyUse(name, type, usages) {\n  let checkSet;\n  switch (type) {\n    case \"private\":\n      checkSet = [\"sign\"];\n      break;\n    case \"public\":\n      checkSet = [\"verify\"];\n      break;\n  }\n  if (hasAnyNotIn(usages, checkSet)) {\n    throw lazyDOMException(`Unsupported key usage for an ${name} key`, \"SyntaxError\");\n  }\n}\nasync function dsaGenerateKey(algorithm, extractable, keyUsages) {\n  const {\n    name,\n    modulusLength,\n    divisorLength,\n    hash\n  } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  validateUint32(modulusLength, \"algorithm.modulusLength\");\n  const usageSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usageSet, [\"sign\", \"verify\"])) {\n    throw lazyDOMException(\"Unsupported key usage for a DSA key\", \"SyntaxError\");\n  }\n  return new Promise((resolve, reject) => {\n    generateKeyPair(\"dsa\", {\n      modulusLength,\n      divisorLength\n    }, (err, pubKey, privKey) => {\n      if (err) {\n        return reject(lazyDOMException(\"The operation failed for an operation-specific reason\", \"OperationError\"));\n      }\n      const algorithm2 = {\n        name,\n        modulusLength,\n        divisorLength,\n        hash: { name: hash.name }\n      };\n      const publicKey = new InternalCryptoKey(pubKey, algorithm2, getUsagesUnion(usageSet, \"verify\"), true);\n      const privateKey = new InternalCryptoKey(privKey, algorithm2, getUsagesUnion(usageSet, \"sign\"), extractable);\n      resolve({ publicKey, privateKey });\n    });\n  });\n}\nfunction dsaExportKey(key, format) {\n  return jobPromise(new DSAKeyExportJob(kCryptoJobAsync, format, key[kKeyObject][kHandle]));\n}\nasync function dsaImportKey(format, keyData, algorithm, extractable, keyUsages) {\n  const { hash } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  const usagesSet = new SafeSet(keyUsages);\n  let keyObject;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type === \"secret\")\n        throw lazyDOMException(\"Invalid key type\", \"InvalidAccessException\");\n      verifyAcceptableDsaKeyUse(algorithm.name, keyData.type, usagesSet);\n      keyObject = keyData;\n      break;\n    }\n    case \"spki\": {\n      verifyAcceptableDsaKeyUse(algorithm.name, \"public\", usagesSet);\n      keyObject = createPublicKey({\n        key: keyData,\n        format: \"der\",\n        type: \"spki\"\n      });\n      break;\n    }\n    case \"pkcs8\": {\n      verifyAcceptableDsaKeyUse(algorithm.name, \"private\", usagesSet);\n      keyObject = createPrivateKey({\n        key: keyData,\n        format: \"der\",\n        type: \"pkcs8\"\n      });\n      break;\n    }\n    case \"jwk\": {\n      if (keyData == null || typeof keyData !== \"object\")\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      verifyAcceptableDsaKeyUse(algorithm.name, keyData.x !== void 0 ? \"private\" : \"public\", usagesSet);\n      if (keyData.kty !== \"DSA\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      if (usagesSet.size > 0 && keyData.use !== void 0 && keyData.use !== \"sig\") {\n        throw lazyDOMException(\"Invalid use type\", \"DataError\");\n      }\n      validateKeyOps(keyData.key_ops, usagesSet);\n      if (keyData.ext !== void 0 && keyData.ext === false && extractable === true) {\n        throw lazyDOMException(\"JWK is not extractable\", \"DataError\");\n      }\n      if (keyData.alg !== void 0) {\n        if (typeof keyData.alg !== \"string\")\n          throw lazyDOMException(\"Invalid alg\", \"DataError\");\n        const hash2 = normalizeHashName(keyData.alg, normalizeHashName.kContextWebCrypto);\n        if (hash2 !== algorithm.hash.name)\n          throw lazyDOMException(\"Hash mismatch\", \"DataError\");\n      }\n      const handle = new KeyObjectHandle();\n      const type = handle.initJwk(keyData);\n      if (type === void 0)\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      keyObject = type === kKeyTypePrivate ? new PrivateKeyObject(handle) : new PublicKeyObject(handle);\n      break;\n    }\n    default:\n      throw lazyDOMException(`Unable to import DSA key with format ${format}`, \"NotSupportedError\");\n  }\n  if (keyObject.asymmetricKeyType !== \"dsa\")\n    throw lazyDOMException(\"Invalid key type\", \"DataError\");\n  const {\n    modulusLength,\n    divisorLength\n  } = keyObject[kHandle].keyDetail({});\n  return new InternalCryptoKey(keyObject, {\n    name: algorithm.name,\n    modulusLength,\n    divisorLength,\n    hash: algorithm.hash\n  }, keyUsages, extractable);\n}\nfunction dsaSignVerify(key, data, algorithm, signature) {\n  const mode = signature === void 0 ? kSignJobModeSign : kSignJobModeVerify;\n  const type = mode === kSignJobModeSign ? \"private\" : \"public\";\n  if (key.type !== type)\n    throw lazyDOMException(`Key must be a ${type} key`, \"InvalidAccessError\");\n  return jobPromise(new SignJob(kCryptoJobAsync, signature === void 0 ? kSignJobModeSign : kSignJobModeVerify, key[kKeyObject][kHandle], void 0, void 0, void 0, data, normalizeHashName(key.algorithm.hash.name), void 0, void 0, kSigEncDER, signature));\n}\nmodule.exports = {\n  dsaExportKey,\n  dsaGenerateKey,\n  dsaImportKey,\n  dsaSignVerify\n};\n}"],["internal/crypto/ec.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectKeys,\n  Promise,\n  SafeSet\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  ECKeyExportJob,\n  KeyObjectHandle,\n  SignJob,\n  kCryptoJobAsync,\n  kKeyTypePrivate,\n  kKeyTypePublic,\n  kSignJobModeSign,\n  kSignJobModeVerify,\n  kSigEncP1363\n} = internalBinding(\"crypto\");\nconst {\n  validateBoolean,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_OPTION\n  }\n} = require(\"internal/errors\");\nconst {\n  getArrayBufferOrView,\n  getUsagesUnion,\n  hasAnyNotIn,\n  jobPromise,\n  normalizeHashName,\n  validateKeyOps,\n  kHandle,\n  kKeyObject,\n  kNamedCurveAliases\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  generateKeyPair\n} = require(\"internal/crypto/keygen\");\nconst {\n  InternalCryptoKey,\n  PrivateKeyObject,\n  PublicKeyObject,\n  createPrivateKey,\n  createPublicKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nfunction verifyAcceptableEcKeyUse(name, type, usages) {\n  let checkSet;\n  switch (name) {\n    case \"ECDH\":\n      checkSet = [\"deriveKey\", \"deriveBits\"];\n      break;\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n      switch (type) {\n        case \"private\":\n          checkSet = [\"sign\"];\n          break;\n        case \"public\":\n          checkSet = [\"verify\"];\n          break;\n      }\n  }\n  if (hasAnyNotIn(usages, checkSet)) {\n    throw lazyDOMException(`Unsupported key usage for a ${name} key`, \"SyntaxError\");\n  }\n}\nfunction createECPublicKeyRaw(namedCurve, keyData) {\n  const handle = new KeyObjectHandle();\n  keyData = getArrayBufferOrView(keyData, \"keyData\");\n  if (handle.initECRaw(kNamedCurveAliases[namedCurve], keyData))\n    return new PublicKeyObject(handle);\n}\nfunction createECRawKey(namedCurve, keyData, isPublic) {\n  const handle = new KeyObjectHandle();\n  keyData = getArrayBufferOrView(keyData, \"keyData\");\n  switch (namedCurve) {\n    case \"NODE-ED25519\":\n    case \"NODE-X25519\":\n      if (keyData.byteLength !== 32) {\n        throw lazyDOMException(`${namedCurve} raw keys must be exactly 32-bytes`);\n      }\n      break;\n    case \"NODE-ED448\":\n      if (keyData.byteLength !== 57) {\n        throw lazyDOMException(`${namedCurve} raw keys must be exactly 57-bytes`);\n      }\n      break;\n    case \"NODE-X448\":\n      if (keyData.byteLength !== 56) {\n        throw lazyDOMException(`${namedCurve} raw keys must be exactly 56-bytes`);\n      }\n      break;\n  }\n  if (isPublic) {\n    handle.initEDRaw(namedCurve, keyData, kKeyTypePublic);\n    return new PublicKeyObject(handle);\n  }\n  handle.initEDRaw(namedCurve, keyData, kKeyTypePrivate);\n  return new PrivateKeyObject(handle);\n}\nasync function ecGenerateKey(algorithm, extractable, keyUsages) {\n  const { name, namedCurve } = algorithm;\n  validateString(namedCurve, \"algorithm.namedCurve\");\n  validateOneOf(namedCurve, \"algorithm.namedCurve\", ObjectKeys(kNamedCurveAliases));\n  const usageSet = new SafeSet(keyUsages);\n  switch (name) {\n    case \"ECDSA\":\n      if (namedCurve === \"NODE-ED25519\" || namedCurve === \"NODE-ED448\" || namedCurve === \"NODE-X25519\" || namedCurve === \"NODE-X448\") {\n        throw lazyDOMException(\"Unsupported named curves for ECDSA\");\n      }\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n      if (hasAnyNotIn(usageSet, [\"sign\", \"verify\"])) {\n        throw lazyDOMException(\"Unsupported key usage for an ECDSA key\", \"SyntaxError\");\n      }\n      break;\n    case \"ECDH\":\n      if (hasAnyNotIn(usageSet, [\"deriveKey\", \"deriveBits\"])) {\n        throw lazyDOMException(\"Unsupported key usage for an ECDH key\", \"SyntaxError\");\n      }\n      if (namedCurve === \"NODE-ED25519\" || namedCurve === \"NODE-ED448\") {\n        throw lazyDOMException(\"Unsupported named curves for ECDH\");\n      }\n  }\n  return new Promise((resolve, reject) => {\n    let genKeyType;\n    let genOpts;\n    switch (namedCurve) {\n      case \"NODE-ED25519\":\n        genKeyType = \"ed25519\";\n        break;\n      case \"NODE-ED448\":\n        genKeyType = \"ed448\";\n        break;\n      case \"NODE-X25519\":\n        genKeyType = \"x25519\";\n        break;\n      case \"NODE-X448\":\n        genKeyType = \"x448\";\n        break;\n      default:\n        genKeyType = \"ec\";\n        genOpts = { namedCurve };\n        break;\n    }\n    generateKeyPair(genKeyType, genOpts, (err, pubKey, privKey) => {\n      if (err) {\n        return reject(lazyDOMException(\"The operation failed for an operation-specific reason\", \"OperationError\"));\n      }\n      const algorithm2 = { name, namedCurve };\n      let publicUsages;\n      let privateUsages;\n      switch (name) {\n        case \"NODE-ED25519\":\n        case \"NODE-ED448\":\n        case \"ECDSA\":\n          publicUsages = getUsagesUnion(usageSet, \"verify\");\n          privateUsages = getUsagesUnion(usageSet, \"sign\");\n          break;\n        case \"ECDH\":\n          publicUsages = [];\n          privateUsages = getUsagesUnion(usageSet, \"deriveKey\", \"deriveBits\");\n          break;\n      }\n      const publicKey = new InternalCryptoKey(pubKey, algorithm2, publicUsages, true);\n      const privateKey = new InternalCryptoKey(privKey, algorithm2, privateUsages, extractable);\n      resolve({ publicKey, privateKey });\n    });\n  });\n}\nfunction ecExportKey(key, format) {\n  return jobPromise(new ECKeyExportJob(kCryptoJobAsync, format, key[kKeyObject][kHandle]));\n}\nasync function ecImportKey(format, keyData, algorithm, extractable, keyUsages) {\n  const { name, namedCurve } = algorithm;\n  validateString(namedCurve, \"algorithm.namedCurve\");\n  validateOneOf(namedCurve, \"algorithm.namedCurve\", ObjectKeys(kNamedCurveAliases));\n  let keyObject;\n  const usagesSet = new SafeSet(keyUsages);\n  let checkNamedCurve = true;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type === \"secret\")\n        throw lazyDOMException(\"Invalid key type\", \"InvalidAccessException\");\n      switch (namedCurve) {\n        case \"NODE-X25519\":\n        case \"NODE-X448\":\n          if (algorithm.name !== \"ECDH\")\n            throw lazyDOMException(\"Invalid algorithm name.\", \"DataError\");\n          break;\n        case \"NODE-ED25519\":\n        case \"NODE-ED448\":\n          if (algorithm.name !== namedCurve)\n            throw lazyDOMException(\"Invalid algorithm name.\", \"DataError\");\n          break;\n      }\n      verifyAcceptableEcKeyUse(name, keyData.type, usagesSet);\n      keyObject = keyData;\n      break;\n    }\n    case \"spki\": {\n      verifyAcceptableEcKeyUse(name, \"public\", usagesSet);\n      keyObject = createPublicKey({\n        key: keyData,\n        format: \"der\",\n        type: \"spki\"\n      });\n      break;\n    }\n    case \"pkcs8\": {\n      verifyAcceptableEcKeyUse(name, \"private\", usagesSet);\n      keyObject = createPrivateKey({\n        key: keyData,\n        format: \"der\",\n        type: \"pkcs8\"\n      });\n      break;\n    }\n    case \"jwk\": {\n      let curve;\n      if (keyData == null || typeof keyData !== \"object\")\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      switch (keyData.kty) {\n        case \"OKP\": {\n          const isPublic = keyData.d === void 0;\n          let type;\n          switch (namedCurve) {\n            case \"NODE-ED25519\":\n            case \"NODE-ED448\":\n              type = `NODE-${keyData.crv.toUpperCase()}`;\n              break;\n            case \"NODE-X25519\":\n            case \"NODE-X448\":\n              type = \"ECDH\";\n              break;\n          }\n          if (algorithm.name !== type)\n            throw lazyDOMException(\"Invalid algorithm name.\", \"DataError\");\n          verifyAcceptableEcKeyUse(type, isPublic ? \"public\" : \"private\", usagesSet);\n          keyObject = createECRawKey(namedCurve, Buffer.from(isPublic ? keyData.x : keyData.d, \"base64\"), isPublic);\n          break;\n        }\n        default: {\n          if (keyData.kty !== \"EC\")\n            throw lazyDOMException(\"Invalid key type\", \"DataError\");\n          if (keyData.d !== void 0) {\n            verifyAcceptableEcKeyUse(name, \"private\", usagesSet);\n          } else {\n            verifyAcceptableEcKeyUse(name, \"public\", usagesSet);\n          }\n          if (usagesSet.size > 0 && keyData.use !== void 0) {\n            if (algorithm.name === \"ECDSA\" && keyData.use !== \"sig\")\n              throw lazyDOMException(\"Invalid use type\", \"DataError\");\n            if (algorithm.name === \"ECDH\" && keyData.use !== \"enc\")\n              throw lazyDOMException(\"Invalid use type\", \"DataError\");\n          }\n          validateKeyOps(keyData.key_ops, usagesSet);\n          if (keyData.ext !== void 0 && keyData.ext === false && extractable === true) {\n            throw lazyDOMException(\"JWK is not extractable\", \"DataError\");\n          }\n          if (algorithm.name === \"ECDSA\" && keyData.alg !== void 0) {\n            if (typeof keyData.alg !== \"string\")\n              throw lazyDOMException(\"Invalid alg\", \"DataError\");\n            switch (keyData.alg) {\n              case \"ES256\":\n                curve = \"P-256\";\n                break;\n              case \"ES384\":\n                curve = \"P-384\";\n                break;\n              case \"ES512\":\n                curve = \"P-521\";\n                break;\n            }\n            if (curve !== namedCurve)\n              throw lazyDOMException(\"Named curve mismatch\", \"DataError\");\n          }\n          const handle = new KeyObjectHandle();\n          const type = handle.initJwk(keyData, namedCurve);\n          if (type === void 0)\n            throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n          keyObject = type === kKeyTypePrivate ? new PrivateKeyObject(handle) : new PublicKeyObject(handle);\n        }\n      }\n      break;\n    }\n    case \"raw\": {\n      switch (namedCurve) {\n        case \"NODE-X25519\":\n        case \"NODE-X448\":\n          if (algorithm.public !== void 0)\n            validateBoolean(algorithm.public, \"algorithm.public\");\n          if (algorithm.name !== \"ECDH\")\n            throw lazyDOMException(\"Invalid algorithm name.\", \"DataError\");\n          verifyAcceptableEcKeyUse(algorithm.name, algorithm.public === true ? \"public\" : \"private\", usagesSet);\n          keyObject = createECRawKey(namedCurve, keyData, algorithm.public);\n          break;\n        case \"NODE-ED25519\":\n        case \"NODE-ED448\":\n          if (algorithm.public !== void 0)\n            validateBoolean(algorithm.public, \"algorithm.public\");\n          if (algorithm.name !== namedCurve)\n            throw lazyDOMException(\"Invalid algorithm name.\", \"DataError\");\n          verifyAcceptableEcKeyUse(algorithm.name, algorithm.public === true ? \"public\" : \"private\", usagesSet);\n          keyObject = createECRawKey(namedCurve, keyData, algorithm.public);\n          break;\n        default:\n          verifyAcceptableEcKeyUse(name, \"public\", usagesSet);\n          keyObject = createECPublicKeyRaw(namedCurve, keyData);\n      }\n      if (keyObject === void 0)\n        throw lazyDOMException(\"Unable to import EC key\", \"OperationError\");\n      break;\n    }\n  }\n  switch (algorithm.name) {\n    case \"ECDSA\":\n      if (keyObject.asymmetricKeyType !== \"ec\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      break;\n    case \"ECDH\":\n      if (algorithm.namedCurve === \"NODE-X25519\") {\n        if (keyObject.asymmetricKeyType !== \"x25519\")\n          throw lazyDOMException(\"Invalid key type\", \"DataError\");\n        checkNamedCurve = false;\n      } else if (algorithm.namedCurve === \"NODE-X448\") {\n        if (keyObject.asymmetricKeyType !== \"x448\")\n          throw lazyDOMException(\"Invalid key type\", \"DataError\");\n        checkNamedCurve = false;\n      } else if (keyObject.asymmetricKeyType !== \"ec\") {\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      }\n      break;\n    case \"NODE-ED25519\":\n      if (keyObject.asymmetricKeyType !== \"ed25519\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      checkNamedCurve = false;\n      break;\n    case \"NODE-ED448\":\n      if (keyObject.asymmetricKeyType !== \"ed448\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      checkNamedCurve = false;\n      break;\n  }\n  if (checkNamedCurve) {\n    const {\n      namedCurve: checkNamedCurve2\n    } = keyObject[kHandle].keyDetail({});\n    if (kNamedCurveAliases[namedCurve] !== checkNamedCurve2)\n      throw lazyDOMException(\"Named curve mismatch\", \"DataError\");\n  }\n  return new InternalCryptoKey(keyObject, { name, namedCurve }, keyUsages, extractable);\n}\nfunction ecdsaSignVerify(key, data, { name, hash }, signature) {\n  const mode = signature === void 0 ? kSignJobModeSign : kSignJobModeVerify;\n  const type = mode === kSignJobModeSign ? \"private\" : \"public\";\n  if (key.type !== type)\n    throw lazyDOMException(`Key must be a ${type} key`, \"InvalidAccessError\");\n  let hashname;\n  switch (name) {\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n      if (hash !== void 0)\n        throw new lazyDOMException(`Hash is not permitted for ${name}`);\n      break;\n    default:\n      if (hash === void 0)\n        throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n      hashname = normalizeHashName(hash.name);\n  }\n  return jobPromise(new SignJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], void 0, void 0, void 0, data, hashname, void 0, void 0, kSigEncP1363, signature));\n}\nmodule.exports = {\n  ecExportKey,\n  ecImportKey,\n  ecGenerateKey,\n  ecdsaSignVerify\n};\n}"],["internal/crypto/hash.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  Symbol\n} = primordials;\nconst {\n  Hash: _Hash,\n  HashJob,\n  Hmac: _Hmac,\n  kCryptoJobAsync\n} = internalBinding(\"crypto\");\nconst {\n  getArrayBufferOrView,\n  getDefaultEncoding,\n  getStringOption,\n  jobPromise,\n  normalizeAlgorithm,\n  normalizeHashName,\n  validateMaxBufferLength,\n  kHandle\n} = require(\"internal/crypto/util\");\nconst {\n  prepareSecretKey\n} = require(\"internal/crypto/keys\");\nconst {\n  Buffer\n} = require(\"buffer\");\nconst {\n  codes: {\n    ERR_CRYPTO_HASH_FINALIZED,\n    ERR_CRYPTO_HASH_UPDATE_FAILED,\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateEncoding,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst LazyTransform = require(\"internal/streams/lazy_transform\");\nconst kState = Symbol(\"kState\");\nconst kFinalized = Symbol(\"kFinalized\");\nfunction Hash(algorithm, options) {\n  if (!(this instanceof Hash))\n    return new Hash(algorithm, options);\n  if (!(algorithm instanceof _Hash))\n    validateString(algorithm, \"algorithm\");\n  const xofLen = typeof options === \"object\" && options !== null ? options.outputLength : void 0;\n  if (xofLen !== void 0)\n    validateUint32(xofLen, \"options.outputLength\");\n  this[kHandle] = new _Hash(algorithm, xofLen);\n  this[kState] = {\n    [kFinalized]: false\n  };\n  ReflectApply(LazyTransform, this, [options]);\n}\nObjectSetPrototypeOf(Hash.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Hash, LazyTransform);\nHash.prototype.copy = function copy(options) {\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n  return new Hash(this[kHandle], options);\n};\nHash.prototype._transform = function _transform(chunk, encoding, callback) {\n  this[kHandle].update(chunk, encoding);\n  callback();\n};\nHash.prototype._flush = function _flush(callback) {\n  this.push(this[kHandle].digest());\n  callback();\n};\nHash.prototype.update = function update(data, encoding) {\n  encoding = encoding || getDefaultEncoding();\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n  if (typeof data === \"string\") {\n    validateEncoding(data, encoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\"data\", [\"string\", \"Buffer\", \"TypedArray\", \"DataView\"], data);\n  }\n  if (!this[kHandle].update(data, encoding))\n    throw new ERR_CRYPTO_HASH_UPDATE_FAILED();\n  return this;\n};\nHash.prototype.digest = function digest(outputEncoding) {\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n  outputEncoding = outputEncoding || getDefaultEncoding();\n  const ret = this[kHandle].digest(`${outputEncoding}`);\n  state[kFinalized] = true;\n  return ret;\n};\nfunction Hmac(hmac, key, options) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hmac, key, options);\n  validateString(hmac, \"hmac\");\n  const encoding = getStringOption(options, \"encoding\");\n  key = prepareSecretKey(key, encoding);\n  this[kHandle] = new _Hmac();\n  this[kHandle].init(hmac, key);\n  this[kState] = {\n    [kFinalized]: false\n  };\n  ReflectApply(LazyTransform, this, [options]);\n}\nObjectSetPrototypeOf(Hmac.prototype, LazyTransform.prototype);\nObjectSetPrototypeOf(Hmac, LazyTransform);\nHmac.prototype.update = Hash.prototype.update;\nHmac.prototype.digest = function digest2(outputEncoding) {\n  const state = this[kState];\n  outputEncoding = outputEncoding || getDefaultEncoding();\n  if (state[kFinalized]) {\n    const buf = Buffer.from(\"\");\n    return outputEncoding === \"buffer\" ? buf : buf.toString(outputEncoding);\n  }\n  const ret = this[kHandle].digest(`${outputEncoding}`);\n  state[kFinalized] = true;\n  return ret;\n};\nHmac.prototype._flush = Hash.prototype._flush;\nHmac.prototype._transform = Hash.prototype._transform;\nasync function asyncDigest(algorithm, data) {\n  algorithm = normalizeAlgorithm(algorithm);\n  data = getArrayBufferOrView(data, \"data\");\n  validateMaxBufferLength(data, \"data\");\n  if (algorithm.length !== void 0)\n    validateUint32(algorithm.length, \"algorithm.length\");\n  return jobPromise(new HashJob(kCryptoJobAsync, normalizeHashName(algorithm.name), data, algorithm.length));\n}\nmodule.exports = {\n  Hash,\n  Hmac,\n  asyncDigest\n};\n}"],["internal/crypto/hashnames.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectKeys,\n  StringPrototypeToLowerCase\n} = primordials;\nconst kHashContextNode = 1;\nconst kHashContextWebCrypto = 2;\nconst kHashContextJwkRsa = 3;\nconst kHashContextJwkRsaPss = 4;\nconst kHashContextJwkRsaOaep = 5;\nconst kHashContextJwkHmac = 6;\nconst kHashContextJwkDsa = 7;\nconst kHashNames = {\n  sha1: {\n    [kHashContextNode]: \"sha1\",\n    [kHashContextWebCrypto]: \"SHA-1\",\n    [kHashContextJwkRsa]: \"RS1\",\n    [kHashContextJwkRsaPss]: \"PS1\",\n    [kHashContextJwkRsaOaep]: \"RSA-OAEP\",\n    [kHashContextJwkHmac]: \"HS1\",\n    [kHashContextJwkDsa]: \"NODE-DSA-SHA-1\"\n  },\n  sha256: {\n    [kHashContextNode]: \"sha256\",\n    [kHashContextWebCrypto]: \"SHA-256\",\n    [kHashContextJwkRsa]: \"RS256\",\n    [kHashContextJwkRsaPss]: \"PS256\",\n    [kHashContextJwkRsaOaep]: \"RSA-OAEP-256\",\n    [kHashContextJwkHmac]: \"HS256\",\n    [kHashContextJwkDsa]: \"NODE-DSA-SHA-256\"\n  },\n  sha384: {\n    [kHashContextNode]: \"sha384\",\n    [kHashContextWebCrypto]: \"SHA-384\",\n    [kHashContextJwkRsa]: \"RS384\",\n    [kHashContextJwkRsaPss]: \"PS384\",\n    [kHashContextJwkRsaOaep]: \"RSA-OAEP-384\",\n    [kHashContextJwkHmac]: \"HS384\",\n    [kHashContextJwkDsa]: \"NODE-DSA-SHA-384\"\n  },\n  sha512: {\n    [kHashContextNode]: \"sha512\",\n    [kHashContextWebCrypto]: \"SHA-512\",\n    [kHashContextJwkRsa]: \"RS512\",\n    [kHashContextJwkRsaPss]: \"PS512\",\n    [kHashContextJwkRsaOaep]: \"RSA-OAEP-512\",\n    [kHashContextJwkHmac]: \"HS512\",\n    [kHashContextJwkDsa]: \"NODE-DSA-SHA-512\"\n  }\n};\n{\n  const keys = ObjectKeys(kHashNames);\n  for (let n = 0; n < keys.length; n++) {\n    const contexts = ObjectKeys(kHashNames[keys[n]]);\n    for (let i = 0; i < contexts.length; i++) {\n      const alias = StringPrototypeToLowerCase(kHashNames[keys[n]][contexts[i]]);\n      if (kHashNames[alias] === void 0)\n        kHashNames[alias] = kHashNames[keys[n]];\n    }\n  }\n}\nfunction normalizeHashName(name, context = kHashContextNode) {\n  if (typeof name !== \"string\")\n    return name;\n  name = StringPrototypeToLowerCase(name);\n  const alias = kHashNames[name] && kHashNames[name][context];\n  return alias || name;\n}\nnormalizeHashName.kContextNode = kHashContextNode;\nnormalizeHashName.kContextWebCrypto = kHashContextWebCrypto;\nnormalizeHashName.kContextJwkRsa = kHashContextJwkRsa;\nnormalizeHashName.kContextJwkRsaPss = kHashContextJwkRsaPss;\nnormalizeHashName.kContextJwkRsaOaep = kHashContextJwkRsaOaep;\nnormalizeHashName.kContextJwkHmac = kHashContextJwkHmac;\nnormalizeHashName.kContextJwkDsa = kHashContextJwkDsa;\nmodule.exports = normalizeHashName;\n}"],["internal/crypto/hkdf.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  Promise,\n  Uint8Array\n} = primordials;\nconst {\n  HKDFJob,\n  kCryptoJobAsync,\n  kCryptoJobSync\n} = internalBinding(\"crypto\");\nconst {\n  validateCallback,\n  validateInteger,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst { kMaxLength } = require(\"buffer\");\nconst {\n  getArrayBufferOrView,\n  normalizeHashName,\n  toBuf,\n  validateByteSource,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  createSecretKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE,\n    ERR_MISSING_OPTION\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst validateParameters = hideStackFrames((hash, key, salt, info, length) => {\n  key = prepareKey(key);\n  salt = toBuf(salt);\n  info = toBuf(info);\n  validateString(hash, \"digest\");\n  validateByteSource(salt, \"salt\");\n  validateByteSource(info, \"info\");\n  validateInteger(length, \"length\", 0, kMaxLength);\n  if (info.byteLength > 1024) {\n    throw ERR_OUT_OF_RANGE(\"info\", \"must not contain more than 1024 bytes\", info.byteLength);\n  }\n  return {\n    hash,\n    key,\n    salt,\n    info,\n    length\n  };\n});\nfunction prepareKey(key) {\n  if (isKeyObject(key))\n    return key;\n  if (isAnyArrayBuffer(key))\n    return createSecretKey(new Uint8Array(key));\n  key = toBuf(key);\n  if (!isArrayBufferView(key)) {\n    throw new ERR_INVALID_ARG_TYPE(\"ikm\", [\n      \"string\",\n      \"SecretKeyObject\",\n      \"ArrayBuffer\",\n      \"TypedArray\",\n      \"DataView\",\n      \"Buffer\"\n    ], key);\n  }\n  return createSecretKey(key);\n}\nfunction hkdf(hash, key, salt, info, length, callback) {\n  ({\n    hash,\n    key,\n    salt,\n    info,\n    length\n  } = validateParameters(hash, key, salt, info, length));\n  validateCallback(callback);\n  const job = new HKDFJob(kCryptoJobAsync, hash, key, salt, info, length);\n  job.ondone = (error, bits) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, bits);\n  };\n  job.run();\n}\nfunction hkdfSync(hash, key, salt, info, length) {\n  ({\n    hash,\n    key,\n    salt,\n    info,\n    length\n  } = validateParameters(hash, key, salt, info, length));\n  const job = new HKDFJob(kCryptoJobSync, hash, key, salt, info, length);\n  const { 0: err, 1: bits } = job.run();\n  if (err !== void 0)\n    throw err;\n  return bits;\n}\nasync function hkdfDeriveBits(algorithm, baseKey, length) {\n  validateUint32(length, \"length\");\n  const { hash } = algorithm;\n  const salt = getArrayBufferOrView(algorithm.salt, \"algorithm.salt\");\n  const info = getArrayBufferOrView(algorithm.info, \"algorithm.info\");\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  let byteLength = 512 / 8;\n  if (length !== void 0) {\n    if (length === 0)\n      throw lazyDOMException(\"length cannot be zero\", \"OperationError\");\n    if (length % 8) {\n      throw lazyDOMException(\"length must be a multiple of 8\", \"OperationError\");\n    }\n    byteLength = length / 8;\n  }\n  return new Promise((resolve, reject) => {\n    hkdf(normalizeHashName(hash.name), baseKey[kKeyObject], salt, info, byteLength, (err, bits) => {\n      if (err)\n        return reject(err);\n      resolve(bits);\n    });\n  });\n}\nmodule.exports = {\n  hkdf,\n  hkdfSync,\n  hkdfDeriveBits\n};\n}"],["internal/crypto/keygen.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  SafeArrayIterator\n} = primordials;\nconst {\n  DhKeyPairGenJob,\n  DsaKeyPairGenJob,\n  EcKeyPairGenJob,\n  NidKeyPairGenJob,\n  RsaKeyPairGenJob,\n  SecretKeyGenJob,\n  kCryptoJobAsync,\n  kCryptoJobSync,\n  kKeyVariantRSA_PSS,\n  kKeyVariantRSA_SSA_PKCS1_v1_5,\n  EVP_PKEY_ED25519,\n  EVP_PKEY_ED448,\n  EVP_PKEY_X25519,\n  EVP_PKEY_X448,\n  OPENSSL_EC_NAMED_CURVE,\n  OPENSSL_EC_EXPLICIT_CURVE\n} = internalBinding(\"crypto\");\nconst {\n  PublicKeyObject,\n  PrivateKeyObject,\n  SecretKeyObject,\n  parsePublicKeyEncoding,\n  parsePrivateKeyEncoding,\n  isJwk\n} = require(\"internal/crypto/keys\");\nconst {\n  kAesKeyLengths\n} = require(\"internal/crypto/util\");\nconst { customPromisifyArgs } = require(\"internal/util\");\nconst {\n  isInt32,\n  isUint32,\n  validateCallback,\n  validateString,\n  validateInteger,\n  validateObject,\n  validateOneOf\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_INCOMPATIBLE_OPTION_PAIR,\n    ERR_INVALID_ARG_VALUE,\n    ERR_MISSING_OPTION\n  }\n} = require(\"internal/errors\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst { getOptionValue } = require(\"internal/options\");\nconst pendingDeprecation = getOptionValue(\"--pending-deprecation\");\nfunction wrapKey(key, ctor) {\n  if (typeof key === \"string\" || isArrayBufferView(key) || isJwk(key))\n    return key;\n  return new ctor(key);\n}\nfunction generateKeyPair(type, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  validateCallback(callback);\n  const job = createJob(kCryptoJobAsync, type, options);\n  job.ondone = (error, result) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    let { 0: pubkey, 1: privkey } = result;\n    pubkey = wrapKey(pubkey, PublicKeyObject);\n    privkey = wrapKey(privkey, PrivateKeyObject);\n    FunctionPrototypeCall(callback, job, null, pubkey, privkey);\n  };\n  job.run();\n}\nObjectDefineProperty(generateKeyPair, customPromisifyArgs, {\n  value: [\"publicKey\", \"privateKey\"],\n  enumerable: false\n});\nfunction generateKeyPairSync(type, options) {\n  return handleError(createJob(kCryptoJobSync, type, options).run());\n}\nfunction handleError(ret) {\n  if (ret == null)\n    return;\n  const { 0: err, 1: keys } = ret;\n  if (err !== void 0)\n    throw err;\n  const { 0: publicKey, 1: privateKey } = keys;\n  return {\n    publicKey: wrapKey(publicKey, PublicKeyObject),\n    privateKey: wrapKey(privateKey, PrivateKeyObject)\n  };\n}\nfunction parseKeyEncoding(keyType, options = {}) {\n  const { publicKeyEncoding, privateKeyEncoding } = options;\n  let publicFormat, publicType;\n  if (publicKeyEncoding == null) {\n    publicFormat = publicType = void 0;\n  } else if (typeof publicKeyEncoding === \"object\") {\n    ({\n      format: publicFormat,\n      type: publicType\n    } = parsePublicKeyEncoding(publicKeyEncoding, keyType, \"publicKeyEncoding\"));\n  } else {\n    throw new ERR_INVALID_ARG_VALUE(\"options.publicKeyEncoding\", publicKeyEncoding);\n  }\n  let privateFormat, privateType, cipher, passphrase;\n  if (privateKeyEncoding == null) {\n    privateFormat = privateType = void 0;\n  } else if (typeof privateKeyEncoding === \"object\") {\n    ({\n      format: privateFormat,\n      type: privateType,\n      cipher,\n      passphrase\n    } = parsePrivateKeyEncoding(privateKeyEncoding, keyType, \"privateKeyEncoding\"));\n  } else {\n    throw new ERR_INVALID_ARG_VALUE(\"options.privateKeyEncoding\", privateKeyEncoding);\n  }\n  return [\n    publicFormat,\n    publicType,\n    privateFormat,\n    privateType,\n    cipher,\n    passphrase\n  ];\n}\nfunction createJob(mode, type, options) {\n  validateString(type, \"type\");\n  const encoding = new SafeArrayIterator(parseKeyEncoding(type, options));\n  if (options !== void 0)\n    validateObject(options, \"options\");\n  switch (type) {\n    case \"rsa\":\n    case \"rsa-pss\": {\n      validateObject(options, \"options\");\n      const { modulusLength } = options;\n      if (!isUint32(modulusLength))\n        throw new ERR_INVALID_ARG_VALUE(\"options.modulusLength\", modulusLength);\n      let { publicExponent } = options;\n      if (publicExponent == null) {\n        publicExponent = 65537;\n      } else if (!isUint32(publicExponent)) {\n        throw new ERR_INVALID_ARG_VALUE(\"options.publicExponent\", publicExponent);\n      }\n      if (type === \"rsa\") {\n        return new RsaKeyPairGenJob(mode, kKeyVariantRSA_SSA_PKCS1_v1_5, modulusLength, publicExponent, ...encoding);\n      }\n      const {\n        hash,\n        mgf1Hash,\n        hashAlgorithm,\n        mgf1HashAlgorithm,\n        saltLength\n      } = options;\n      if (saltLength !== void 0 && (!isInt32(saltLength) || saltLength < 0))\n        throw new ERR_INVALID_ARG_VALUE(\"options.saltLength\", saltLength);\n      if (hashAlgorithm !== void 0 && typeof hashAlgorithm !== \"string\")\n        throw new ERR_INVALID_ARG_VALUE(\"options.hashAlgorithm\", hashAlgorithm);\n      if (mgf1HashAlgorithm !== void 0 && typeof mgf1HashAlgorithm !== \"string\")\n        throw new ERR_INVALID_ARG_VALUE(\"options.mgf1HashAlgorithm\", mgf1HashAlgorithm);\n      if (hash !== void 0) {\n        pendingDeprecation && process.emitWarning('\"options.hash\" is deprecated, use \"options.hashAlgorithm\" instead.', \"DeprecationWarning\", \"DEP0154\");\n        if (typeof hash !== \"string\" || hashAlgorithm && hash !== hashAlgorithm) {\n          throw new ERR_INVALID_ARG_VALUE(\"options.hash\", hash);\n        }\n      }\n      if (mgf1Hash !== void 0) {\n        pendingDeprecation && process.emitWarning('\"options.mgf1Hash\" is deprecated, use \"options.mgf1HashAlgorithm\" instead.', \"DeprecationWarning\", \"DEP0154\");\n        if (typeof mgf1Hash !== \"string\" || mgf1HashAlgorithm && mgf1Hash !== mgf1HashAlgorithm) {\n          throw new ERR_INVALID_ARG_VALUE(\"options.mgf1Hash\", mgf1Hash);\n        }\n      }\n      return new RsaKeyPairGenJob(mode, kKeyVariantRSA_PSS, modulusLength, publicExponent, hashAlgorithm || hash, mgf1HashAlgorithm || mgf1Hash, saltLength, ...encoding);\n    }\n    case \"dsa\": {\n      validateObject(options, \"options\");\n      const { modulusLength } = options;\n      if (!isUint32(modulusLength))\n        throw new ERR_INVALID_ARG_VALUE(\"options.modulusLength\", modulusLength);\n      let { divisorLength } = options;\n      if (divisorLength == null) {\n        divisorLength = -1;\n      } else if (!isInt32(divisorLength) || divisorLength < 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"options.divisorLength\", divisorLength);\n      }\n      return new DsaKeyPairGenJob(mode, modulusLength, divisorLength, ...encoding);\n    }\n    case \"ec\": {\n      validateObject(options, \"options\");\n      const { namedCurve } = options;\n      if (typeof namedCurve !== \"string\")\n        throw new ERR_INVALID_ARG_VALUE(\"options.namedCurve\", namedCurve);\n      let { paramEncoding } = options;\n      if (paramEncoding == null || paramEncoding === \"named\")\n        paramEncoding = OPENSSL_EC_NAMED_CURVE;\n      else if (paramEncoding === \"explicit\")\n        paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;\n      else\n        throw new ERR_INVALID_ARG_VALUE(\"options.paramEncoding\", paramEncoding);\n      return new EcKeyPairGenJob(mode, namedCurve, paramEncoding, ...encoding);\n    }\n    case \"ed25519\":\n    case \"ed448\":\n    case \"x25519\":\n    case \"x448\": {\n      let id;\n      switch (type) {\n        case \"ed25519\":\n          id = EVP_PKEY_ED25519;\n          break;\n        case \"ed448\":\n          id = EVP_PKEY_ED448;\n          break;\n        case \"x25519\":\n          id = EVP_PKEY_X25519;\n          break;\n        case \"x448\":\n          id = EVP_PKEY_X448;\n          break;\n      }\n      return new NidKeyPairGenJob(mode, id, ...encoding);\n    }\n    case \"dh\": {\n      validateObject(options, \"options\");\n      const { group, primeLength, prime, generator } = options;\n      if (group != null) {\n        if (prime != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR(\"group\", \"prime\");\n        if (primeLength != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR(\"group\", \"primeLength\");\n        if (generator != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR(\"group\", \"generator\");\n        if (typeof group !== \"string\")\n          throw new ERR_INVALID_ARG_VALUE(\"options.group\", group);\n        return new DhKeyPairGenJob(mode, group, ...encoding);\n      }\n      if (prime != null) {\n        if (primeLength != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR(\"prime\", \"primeLength\");\n        if (!isArrayBufferView(prime))\n          throw new ERR_INVALID_ARG_VALUE(\"options.prime\", prime);\n      } else if (primeLength != null) {\n        if (!isInt32(primeLength) || primeLength < 0)\n          throw new ERR_INVALID_ARG_VALUE(\"options.primeLength\", primeLength);\n      } else {\n        throw new ERR_MISSING_OPTION(\"At least one of the group, prime, or primeLength options\");\n      }\n      if (generator != null) {\n        if (!isInt32(generator) || generator < 0)\n          throw new ERR_INVALID_ARG_VALUE(\"options.generator\", generator);\n      }\n      return new DhKeyPairGenJob(mode, prime != null ? prime : primeLength, generator == null ? 2 : generator, ...encoding);\n    }\n    default:\n  }\n  throw new ERR_INVALID_ARG_VALUE(\"type\", type, \"must be a supported key type\");\n}\nfunction generateKeyJob(mode, keyType, options) {\n  validateString(keyType, \"type\");\n  validateObject(options, \"options\");\n  const { length } = options;\n  switch (keyType) {\n    case \"hmac\":\n      validateInteger(length, \"options.length\", 1, 2 ** 31 - 1);\n      break;\n    case \"aes\":\n      validateOneOf(length, \"options.length\", kAesKeyLengths);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"type\", keyType, \"must be a supported key type\");\n  }\n  return new SecretKeyGenJob(mode, length);\n}\nfunction handleGenerateKeyError(ret) {\n  if (ret === void 0)\n    return;\n  const { 0: err, 1: key } = ret;\n  if (err !== void 0)\n    throw err;\n  return wrapKey(key, SecretKeyObject);\n}\nfunction generateKey(type, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  validateCallback(callback);\n  const job = generateKeyJob(kCryptoJobAsync, type, options);\n  job.ondone = (error, key) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, wrapKey(key, SecretKeyObject));\n  };\n  handleGenerateKeyError(job.run());\n}\nfunction generateKeySync(type, options) {\n  return handleGenerateKeyError(generateKeyJob(kCryptoJobSync, type, options).run());\n}\nmodule.exports = {\n  generateKeyPair,\n  generateKeyPairSync,\n  generateKey,\n  generateKeySync\n};\n}"],["internal/crypto/keys.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayPrototypeSlice,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  Symbol,\n  Uint8Array\n} = primordials;\nconst {\n  KeyObjectHandle,\n  createNativeKeyObjectClass,\n  kKeyTypeSecret,\n  kKeyTypePublic,\n  kKeyTypePrivate,\n  kKeyFormatPEM,\n  kKeyFormatDER,\n  kKeyFormatJWK,\n  kKeyEncodingPKCS1,\n  kKeyEncodingPKCS8,\n  kKeyEncodingSPKI,\n  kKeyEncodingSEC1\n} = internalBinding(\"crypto\");\nconst {\n  validateObject,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,\n    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,\n    ERR_CRYPTO_INVALID_JWK,\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE\n  }\n} = require(\"internal/errors\");\nconst {\n  kHandle,\n  kKeyObject,\n  getArrayBufferOrView,\n  bigIntArrayToUnsignedBigInt\n} = require(\"internal/crypto/util\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  JSTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst { Buffer } = require(\"buffer\");\nconst kAlgorithm = Symbol(\"kAlgorithm\");\nconst kExtractable = Symbol(\"kExtractable\");\nconst kKeyType = Symbol(\"kKeyType\");\nconst kKeyUsages = Symbol(\"kKeyUsages\");\nconst kConsumePublic = 0;\nconst kConsumePrivate = 1;\nconst kCreatePublic = 2;\nconst kCreatePrivate = 3;\nconst encodingNames = [];\nfor (const m of [\n  [kKeyEncodingPKCS1, \"pkcs1\"],\n  [kKeyEncodingPKCS8, \"pkcs8\"],\n  [kKeyEncodingSPKI, \"spki\"],\n  [kKeyEncodingSEC1, \"sec1\"]\n])\n  encodingNames[m[0]] = m[1];\nconst {\n  0: KeyObject,\n  1: SecretKeyObject,\n  2: PublicKeyObject,\n  3: PrivateKeyObject\n} = createNativeKeyObjectClass((NativeKeyObject) => {\n  class KeyObject2 extends NativeKeyObject {\n    constructor(type, handle) {\n      if (type !== \"secret\" && type !== \"public\" && type !== \"private\")\n        throw new ERR_INVALID_ARG_VALUE(\"type\", type);\n      if (typeof handle !== \"object\" || !(handle instanceof KeyObjectHandle))\n        throw new ERR_INVALID_ARG_TYPE(\"handle\", \"object\", handle);\n      super(handle);\n      this[kKeyType] = type;\n      ObjectDefineProperty(this, kHandle, {\n        value: handle,\n        enumerable: false,\n        configurable: false,\n        writable: false\n      });\n    }\n    get type() {\n      return this[kKeyType];\n    }\n    static from(key) {\n      if (!isCryptoKey(key))\n        throw new ERR_INVALID_ARG_TYPE(\"key\", \"CryptoKey\", key);\n      return key[kKeyObject];\n    }\n  }\n  class SecretKeyObject2 extends KeyObject2 {\n    constructor(handle) {\n      super(\"secret\", handle);\n    }\n    get symmetricKeySize() {\n      return this[kHandle].getSymmetricKeySize();\n    }\n    export(options) {\n      if (options !== void 0) {\n        validateObject(options, \"options\");\n        validateOneOf(options.format, \"options.format\", [void 0, \"buffer\", \"jwk\"]);\n        if (options.format === \"jwk\") {\n          return this[kHandle].exportJwk({}, false);\n        }\n      }\n      return this[kHandle].export();\n    }\n  }\n  const kAsymmetricKeyType = Symbol(\"kAsymmetricKeyType\");\n  const kAsymmetricKeyDetails = Symbol(\"kAsymmetricKeyDetails\");\n  function normalizeKeyDetails(details = {}) {\n    if (details.publicExponent !== void 0) {\n      return {\n        ...details,\n        publicExponent: bigIntArrayToUnsignedBigInt(new Uint8Array(details.publicExponent))\n      };\n    }\n    return details;\n  }\n  class AsymmetricKeyObject extends KeyObject2 {\n    constructor(type, handle) {\n      super(type, handle);\n    }\n    get asymmetricKeyType() {\n      return this[kAsymmetricKeyType] || (this[kAsymmetricKeyType] = this[kHandle].getAsymmetricKeyType());\n    }\n    get asymmetricKeyDetails() {\n      switch (this.asymmetricKeyType) {\n        case \"rsa\":\n        case \"rsa-pss\":\n        case \"dsa\":\n        case \"ec\":\n          return this[kAsymmetricKeyDetails] || (this[kAsymmetricKeyDetails] = normalizeKeyDetails(this[kHandle].keyDetail({})));\n        default:\n          return {};\n      }\n    }\n  }\n  class PublicKeyObject2 extends AsymmetricKeyObject {\n    constructor(handle) {\n      super(\"public\", handle);\n    }\n    export(options) {\n      if (options && options.format === \"jwk\") {\n        return this[kHandle].exportJwk({}, false);\n      }\n      const {\n        format,\n        type\n      } = parsePublicKeyEncoding(options, this.asymmetricKeyType);\n      return this[kHandle].export(format, type);\n    }\n  }\n  class PrivateKeyObject2 extends AsymmetricKeyObject {\n    constructor(handle) {\n      super(\"private\", handle);\n    }\n    export(options) {\n      if (options && options.format === \"jwk\") {\n        if (options.passphrase !== void 0) {\n          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\"jwk\", \"does not support encryption\");\n        }\n        return this[kHandle].exportJwk({}, false);\n      }\n      const {\n        format,\n        type,\n        cipher,\n        passphrase\n      } = parsePrivateKeyEncoding(options, this.asymmetricKeyType);\n      return this[kHandle].export(format, type, cipher, passphrase);\n    }\n  }\n  return [KeyObject2, SecretKeyObject2, PublicKeyObject2, PrivateKeyObject2];\n});\nfunction parseKeyFormat(formatStr, defaultFormat, optionName) {\n  if (formatStr === void 0 && defaultFormat !== void 0)\n    return defaultFormat;\n  else if (formatStr === \"pem\")\n    return kKeyFormatPEM;\n  else if (formatStr === \"der\")\n    return kKeyFormatDER;\n  else if (formatStr === \"jwk\")\n    return kKeyFormatJWK;\n  throw new ERR_INVALID_ARG_VALUE(optionName, formatStr);\n}\nfunction parseKeyType(typeStr, required, keyType, isPublic, optionName) {\n  if (typeStr === void 0 && !required) {\n    return void 0;\n  } else if (typeStr === \"pkcs1\") {\n    if (keyType !== void 0 && keyType !== \"rsa\") {\n      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(typeStr, \"can only be used for RSA keys\");\n    }\n    return kKeyEncodingPKCS1;\n  } else if (typeStr === \"spki\" && isPublic !== false) {\n    return kKeyEncodingSPKI;\n  } else if (typeStr === \"pkcs8\" && isPublic !== true) {\n    return kKeyEncodingPKCS8;\n  } else if (typeStr === \"sec1\" && isPublic !== true) {\n    if (keyType !== void 0 && keyType !== \"ec\") {\n      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(typeStr, \"can only be used for EC keys\");\n    }\n    return kKeyEncodingSEC1;\n  }\n  throw new ERR_INVALID_ARG_VALUE(optionName, typeStr);\n}\nfunction option(name, objName) {\n  return objName === void 0 ? `options.${name}` : `options.${objName}.${name}`;\n}\nfunction parseKeyFormatAndType(enc, keyType, isPublic, objName) {\n  const { format: formatStr, type: typeStr } = enc;\n  const isInput = keyType === void 0;\n  const format = parseKeyFormat(formatStr, isInput ? kKeyFormatPEM : void 0, option(\"format\", objName));\n  const isRequired = (!isInput || format === kKeyFormatDER) && format !== kKeyFormatJWK;\n  const type = parseKeyType(typeStr, isRequired, keyType, isPublic, option(\"type\", objName));\n  return { format, type };\n}\nfunction isStringOrBuffer(val) {\n  return typeof val === \"string\" || isArrayBufferView(val) || isAnyArrayBuffer(val);\n}\nfunction parseKeyEncoding(enc, keyType, isPublic, objName) {\n  validateObject(enc, \"options\");\n  const isInput = keyType === void 0;\n  const {\n    format,\n    type\n  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);\n  let cipher, passphrase, encoding;\n  if (isPublic !== true) {\n    ({ cipher, passphrase, encoding } = enc);\n    if (!isInput) {\n      if (cipher != null) {\n        if (typeof cipher !== \"string\")\n          throw new ERR_INVALID_ARG_VALUE(option(\"cipher\", objName), cipher);\n        if (format === kKeyFormatDER && (type === kKeyEncodingPKCS1 || type === kKeyEncodingSEC1)) {\n          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(encodingNames[type], \"does not support encryption\");\n        }\n      } else if (passphrase !== void 0) {\n        throw new ERR_INVALID_ARG_VALUE(option(\"cipher\", objName), cipher);\n      }\n    }\n    if (isInput && passphrase !== void 0 && !isStringOrBuffer(passphrase) || !isInput && cipher != null && !isStringOrBuffer(passphrase)) {\n      throw new ERR_INVALID_ARG_VALUE(option(\"passphrase\", objName), passphrase);\n    }\n  }\n  if (passphrase !== void 0)\n    passphrase = getArrayBufferOrView(passphrase, \"key.passphrase\", encoding);\n  return { format, type, cipher, passphrase };\n}\nfunction parsePublicKeyEncoding(enc, keyType, objName) {\n  return parseKeyEncoding(enc, keyType, keyType ? true : void 0, objName);\n}\nfunction parsePrivateKeyEncoding(enc, keyType, objName) {\n  return parseKeyEncoding(enc, keyType, false, objName);\n}\nfunction getKeyObjectHandle(key, ctx) {\n  if (ctx === kCreatePrivate) {\n    throw new ERR_INVALID_ARG_TYPE(\"key\", [\"string\", \"ArrayBuffer\", \"Buffer\", \"TypedArray\", \"DataView\"], key);\n  }\n  if (key.type !== \"private\") {\n    if (ctx === kConsumePrivate || ctx === kCreatePublic)\n      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, \"private\");\n    if (key.type !== \"public\") {\n      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, \"private or public\");\n    }\n  }\n  return key[kHandle];\n}\nfunction getKeyTypes(allowKeyObject, bufferOnly = false) {\n  const types = [\n    \"ArrayBuffer\",\n    \"Buffer\",\n    \"TypedArray\",\n    \"DataView\",\n    \"string\",\n    \"KeyObject\",\n    \"CryptoKey\"\n  ];\n  if (bufferOnly) {\n    return ArrayPrototypeSlice(types, 0, 4);\n  } else if (!allowKeyObject) {\n    return ArrayPrototypeSlice(types, 0, 5);\n  }\n  return types;\n}\nfunction getKeyObjectHandleFromJwk(key, ctx) {\n  validateObject(key, \"key\");\n  validateOneOf(key.kty, \"key.kty\", [\"RSA\", \"EC\", \"OKP\"]);\n  const isPublic = ctx === kConsumePublic || ctx === kCreatePublic;\n  if (key.kty === \"OKP\") {\n    validateString(key.crv, \"key.crv\");\n    validateOneOf(key.crv, \"key.crv\", [\"Ed25519\", \"Ed448\", \"X25519\", \"X448\"]);\n    validateString(key.x, \"key.x\");\n    if (!isPublic)\n      validateString(key.d, \"key.d\");\n    let keyData;\n    if (isPublic)\n      keyData = Buffer.from(key.x, \"base64\");\n    else\n      keyData = Buffer.from(key.d, \"base64\");\n    switch (key.crv) {\n      case \"Ed25519\":\n      case \"X25519\":\n        if (keyData.byteLength !== 32) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n      case \"Ed448\":\n        if (keyData.byteLength !== 57) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n      case \"X448\":\n        if (keyData.byteLength !== 56) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n    }\n    const handle2 = new KeyObjectHandle();\n    if (isPublic) {\n      handle2.initEDRaw(`NODE-${key.crv.toUpperCase()}`, keyData, kKeyTypePublic);\n    } else {\n      handle2.initEDRaw(`NODE-${key.crv.toUpperCase()}`, keyData, kKeyTypePrivate);\n    }\n    return handle2;\n  }\n  if (key.kty === \"EC\") {\n    validateString(key.crv, \"key.crv\");\n    validateOneOf(key.crv, \"key.crv\", [\"P-256\", \"secp256k1\", \"P-384\", \"P-521\"]);\n    validateString(key.x, \"key.x\");\n    validateString(key.y, \"key.y\");\n    const jwk2 = {\n      kty: key.kty,\n      crv: key.crv,\n      x: key.x,\n      y: key.y\n    };\n    if (!isPublic) {\n      validateString(key.d, \"key.d\");\n      jwk2.d = key.d;\n    }\n    const handle2 = new KeyObjectHandle();\n    const type2 = handle2.initJwk(jwk2, jwk2.crv);\n    if (type2 === void 0)\n      throw new ERR_CRYPTO_INVALID_JWK();\n    return handle2;\n  }\n  validateString(key.n, \"key.n\");\n  validateString(key.e, \"key.e\");\n  const jwk = {\n    kty: key.kty,\n    n: key.n,\n    e: key.e\n  };\n  if (!isPublic) {\n    validateString(key.d, \"key.d\");\n    validateString(key.p, \"key.p\");\n    validateString(key.q, \"key.q\");\n    validateString(key.dp, \"key.dp\");\n    validateString(key.dq, \"key.dq\");\n    validateString(key.qi, \"key.qi\");\n    jwk.d = key.d;\n    jwk.p = key.p;\n    jwk.q = key.q;\n    jwk.dp = key.dp;\n    jwk.dq = key.dq;\n    jwk.qi = key.qi;\n  }\n  const handle = new KeyObjectHandle();\n  const type = handle.initJwk(jwk);\n  if (type === void 0)\n    throw new ERR_CRYPTO_INVALID_JWK();\n  return handle;\n}\nfunction prepareAsymmetricKey(key, ctx) {\n  if (isKeyObject(key)) {\n    return { data: getKeyObjectHandle(key, ctx) };\n  } else if (isCryptoKey(key)) {\n    return { data: getKeyObjectHandle(key[kKeyObject], ctx) };\n  } else if (isStringOrBuffer(key)) {\n    return { format: kKeyFormatPEM, data: getArrayBufferOrView(key, \"key\") };\n  } else if (typeof key === \"object\") {\n    const { key: data, encoding, format } = key;\n    if (isKeyObject(data))\n      return { data: getKeyObjectHandle(data, ctx) };\n    else if (isCryptoKey(data))\n      return { data: getKeyObjectHandle(data[kKeyObject], ctx) };\n    else if (isJwk(data) && format === \"jwk\")\n      return { data: getKeyObjectHandleFromJwk(data, ctx), format: \"jwk\" };\n    if (!isStringOrBuffer(data)) {\n      throw new ERR_INVALID_ARG_TYPE(\"key.key\", getKeyTypes(ctx !== kCreatePrivate), data);\n    }\n    const isPublic = ctx === kConsumePrivate || ctx === kCreatePrivate ? false : void 0;\n    return {\n      data: getArrayBufferOrView(data, \"key\", encoding),\n      ...parseKeyEncoding(key, void 0, isPublic)\n    };\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"key\", getKeyTypes(ctx !== kCreatePrivate), key);\n}\nfunction preparePrivateKey(key) {\n  return prepareAsymmetricKey(key, kConsumePrivate);\n}\nfunction preparePublicOrPrivateKey(key) {\n  return prepareAsymmetricKey(key, kConsumePublic);\n}\nfunction prepareSecretKey(key, encoding, bufferOnly = false) {\n  if (!bufferOnly) {\n    if (isKeyObject(key)) {\n      if (key.type !== \"secret\")\n        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, \"secret\");\n      return key[kHandle];\n    } else if (isCryptoKey(key)) {\n      if (key.type !== \"secret\")\n        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, \"secret\");\n      return key[kKeyObject][kHandle];\n    }\n  }\n  if (typeof key !== \"string\" && !isArrayBufferView(key) && !isAnyArrayBuffer(key)) {\n    throw new ERR_INVALID_ARG_TYPE(\"key\", getKeyTypes(!bufferOnly, bufferOnly), key);\n  }\n  return getArrayBufferOrView(key, \"key\", encoding);\n}\nfunction createSecretKey(key, encoding) {\n  key = prepareSecretKey(key, encoding, true);\n  if (key.byteLength === 0)\n    throw new ERR_OUT_OF_RANGE(\"key.byteLength\", \"> 0\", key.byteLength);\n  const handle = new KeyObjectHandle();\n  handle.init(kKeyTypeSecret, key);\n  return new SecretKeyObject(handle);\n}\nfunction createPublicKey(key) {\n  const { format, type, data, passphrase } = prepareAsymmetricKey(key, kCreatePublic);\n  let handle;\n  if (format === \"jwk\") {\n    handle = data;\n  } else {\n    handle = new KeyObjectHandle();\n    handle.init(kKeyTypePublic, data, format, type, passphrase);\n  }\n  return new PublicKeyObject(handle);\n}\nfunction createPrivateKey(key) {\n  const { format, type, data, passphrase } = prepareAsymmetricKey(key, kCreatePrivate);\n  let handle;\n  if (format === \"jwk\") {\n    handle = data;\n  } else {\n    handle = new KeyObjectHandle();\n    handle.init(kKeyTypePrivate, data, format, type, passphrase);\n  }\n  return new PrivateKeyObject(handle);\n}\nfunction isKeyObject(obj) {\n  return obj != null && obj[kKeyType] !== void 0;\n}\nclass CryptoKey extends JSTransferable {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `CryptoKey ${inspect({\n      type: this.type,\n      extractable: this.extractable,\n      algorithm: this.algorithm,\n      usages: this.usages\n    }, opts)}`;\n  }\n  get type() {\n    return this[kKeyObject].type;\n  }\n  get extractable() {\n    return this[kExtractable];\n  }\n  get algorithm() {\n    return this[kAlgorithm];\n  }\n  get usages() {\n    return ArrayFrom(this[kKeyUsages]);\n  }\n  [kClone]() {\n    const keyObject = this[kKeyObject];\n    const algorithm = this.algorithm;\n    const extractable = this.extractable;\n    const usages = this.usages;\n    return {\n      data: {\n        keyObject,\n        algorithm,\n        usages,\n        extractable\n      },\n      deserializeInfo: \"internal/crypto/keys:InternalCryptoKey\"\n    };\n  }\n  [kDeserialize]({ keyObject, algorithm, usages, extractable }) {\n    this[kKeyObject] = keyObject;\n    this[kAlgorithm] = algorithm;\n    this[kKeyUsages] = usages;\n    this[kExtractable] = extractable;\n  }\n}\nclass InternalCryptoKey extends JSTransferable {\n  constructor(keyObject, algorithm, keyUsages, extractable) {\n    super();\n    this[kKeyObject] = keyObject;\n    this[kAlgorithm] = algorithm;\n    this[kExtractable] = extractable;\n    this[kKeyUsages] = keyUsages;\n  }\n}\nInternalCryptoKey.prototype.constructor = CryptoKey;\nObjectSetPrototypeOf(InternalCryptoKey.prototype, CryptoKey.prototype);\nfunction isCryptoKey(obj) {\n  return obj != null && obj[kKeyObject] !== void 0;\n}\nfunction isJwk(obj) {\n  return obj != null && obj.kty !== void 0;\n}\nmodule.exports = {\n  createSecretKey,\n  createPublicKey,\n  createPrivateKey,\n  KeyObject,\n  CryptoKey,\n  InternalCryptoKey,\n  parsePublicKeyEncoding,\n  parsePrivateKeyEncoding,\n  parseKeyEncoding,\n  preparePrivateKey,\n  preparePublicOrPrivateKey,\n  prepareSecretKey,\n  SecretKeyObject,\n  PublicKeyObject,\n  PrivateKeyObject,\n  isKeyObject,\n  isCryptoKey,\n  isJwk\n};\n}"],["internal/crypto/mac.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  Promise,\n  SafeSet\n} = primordials;\nconst {\n  HmacJob,\n  KeyObjectHandle,\n  kCryptoJobAsync,\n  kSignJobModeSign,\n  kSignJobModeVerify\n} = internalBinding(\"crypto\");\nconst {\n  getHashLength,\n  hasAnyNotIn,\n  jobPromise,\n  normalizeHashName,\n  validateBitLength,\n  validateKeyOps,\n  kHandle,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  codes: {\n    ERR_MISSING_OPTION,\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  generateKey\n} = require(\"internal/crypto/keygen\");\nconst {\n  InternalCryptoKey,\n  SecretKeyObject,\n  createSecretKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nasync function hmacGenerateKey(algorithm, extractable, keyUsages) {\n  const { hash, name } = algorithm;\n  let { length } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  if (length === void 0)\n    length = getHashLength(hash.name);\n  validateBitLength(length, \"algorithm.length\", true);\n  const usageSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usageSet, [\"sign\", \"verify\"])) {\n    throw lazyDOMException(\"Unsupported key usage for an HMAC key\", \"SyntaxError\");\n  }\n  return new Promise((resolve, reject) => {\n    generateKey(\"hmac\", { length }, (err, key) => {\n      if (err) {\n        return reject(lazyDOMException(\"The operation failed for an operation-specific reason\", \"OperationError\"));\n      }\n      resolve(new InternalCryptoKey(key, { name, length, hash: { name: hash.name } }, ArrayFrom(usageSet), extractable));\n    });\n  });\n}\nasync function hmacImportKey(format, keyData, algorithm, extractable, keyUsages) {\n  const { hash } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  const usagesSet = new SafeSet(keyUsages);\n  if (hasAnyNotIn(usagesSet, [\"sign\", \"verify\"])) {\n    throw lazyDOMException(\"Unsupported key usage for an HMAC key\", \"SyntaxError\");\n  }\n  let keyObject;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type !== \"secret\") {\n        throw lazyDOMException(`Unable to import HMAC key with format ${format}`);\n      }\n      keyObject = keyData;\n      break;\n    }\n    case \"raw\": {\n      const checkLength = keyData.byteLength * 8;\n      if (checkLength === 0 || algorithm.length === 0)\n        throw lazyDOMException(\"Zero-length key is not supported\", \"DataError\");\n      if (algorithm.length !== void 0 && algorithm.length !== checkLength) {\n        throw lazyDOMException(\"Invalid key length\", \"DataError\");\n      }\n      keyObject = createSecretKey(keyData);\n      break;\n    }\n    case \"jwk\": {\n      if (keyData == null || typeof keyData !== \"object\")\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      if (keyData.kty !== \"oct\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      if (usagesSet.size > 0 && keyData.use !== void 0 && keyData.use !== \"sig\") {\n        throw lazyDOMException(\"Invalid use type\", \"DataError\");\n      }\n      validateKeyOps(keyData.key_ops, usagesSet);\n      if (keyData.ext !== void 0 && keyData.ext === false && extractable === true) {\n        throw lazyDOMException(\"JWK is not extractable\", \"DataError\");\n      }\n      if (keyData.alg !== void 0) {\n        if (typeof keyData.alg !== \"string\")\n          throw lazyDOMException(\"Invalid alg\", \"DataError\");\n        switch (keyData.alg) {\n          case \"HS1\":\n            if (algorithm.hash.name !== \"SHA-1\")\n              throw lazyDOMException(\"Digest algorithm mismatch\", \"DataError\");\n            break;\n          case \"HS256\":\n            if (algorithm.hash.name !== \"SHA-256\")\n              throw lazyDOMException(\"Digest algorithm mismatch\", \"DataError\");\n            break;\n          case \"HS384\":\n            if (algorithm.hash.name !== \"SHA-384\")\n              throw lazyDOMException(\"Digest algorithm mismatch\", \"DataError\");\n            break;\n          case \"HS512\":\n            if (algorithm.hash.name !== \"SHA-512\")\n              throw lazyDOMException(\"Digest algorithm mismatch\", \"DataError\");\n            break;\n          default:\n            throw lazyDOMException(\"Unsupported digest algorithm\", \"DataError\");\n        }\n      }\n      const handle = new KeyObjectHandle();\n      handle.initJwk(keyData);\n      keyObject = new SecretKeyObject(handle);\n      break;\n    }\n    default:\n      throw lazyDOMException(`Unable to import HMAC key with format ${format}`);\n  }\n  const { length } = keyObject[kHandle].keyDetail({});\n  return new InternalCryptoKey(keyObject, {\n    name: \"HMAC\",\n    hash: algorithm.hash,\n    length\n  }, keyUsages, extractable);\n}\nfunction hmacSignVerify(key, data, algorithm, signature) {\n  const mode = signature === void 0 ? kSignJobModeSign : kSignJobModeVerify;\n  return jobPromise(new HmacJob(kCryptoJobAsync, mode, normalizeHashName(key.algorithm.hash.name), key[kKeyObject][kHandle], data, signature));\n}\nmodule.exports = {\n  hmacImportKey,\n  hmacGenerateKey,\n  hmacSignVerify\n};\n}"],["internal/crypto/pbkdf2.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  Promise\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  PBKDF2Job,\n  kCryptoJobAsync,\n  kCryptoJobSync\n} = internalBinding(\"crypto\");\nconst {\n  validateCallback,\n  validateInteger,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst { ERR_MISSING_OPTION } = require(\"internal/errors\").codes;\nconst {\n  getArrayBufferOrView,\n  getDefaultEncoding,\n  normalizeHashName,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nfunction pbkdf2(password, salt, iterations, keylen, digest, callback) {\n  if (typeof digest === \"function\") {\n    callback = digest;\n    digest = void 0;\n  }\n  ({ password, salt, iterations, keylen, digest } = check(password, salt, iterations, keylen, digest));\n  validateCallback(callback);\n  const job = new PBKDF2Job(kCryptoJobAsync, password, salt, iterations, keylen, digest);\n  const encoding = getDefaultEncoding();\n  job.ondone = (err, result) => {\n    if (err !== void 0)\n      return FunctionPrototypeCall(callback, job, err);\n    const buf = Buffer.from(result);\n    if (encoding === \"buffer\")\n      return FunctionPrototypeCall(callback, job, null, buf);\n    FunctionPrototypeCall(callback, job, null, buf.toString(encoding));\n  };\n  job.run();\n}\nfunction pbkdf2Sync(password, salt, iterations, keylen, digest) {\n  ({ password, salt, iterations, keylen, digest } = check(password, salt, iterations, keylen, digest));\n  const job = new PBKDF2Job(kCryptoJobSync, password, salt, iterations, keylen, digest);\n  const { 0: err, 1: result } = job.run();\n  if (err !== void 0)\n    throw err;\n  const buf = Buffer.from(result);\n  const encoding = getDefaultEncoding();\n  return encoding === \"buffer\" ? buf : buf.toString(encoding);\n}\nfunction check(password, salt, iterations, keylen, digest) {\n  validateString(digest, \"digest\");\n  password = getArrayBufferOrView(password, \"password\");\n  salt = getArrayBufferOrView(salt, \"salt\");\n  validateUint32(iterations, \"iterations\", true);\n  validateUint32(keylen, \"keylen\");\n  return { password, salt, iterations, keylen, digest };\n}\nasync function pbkdf2DeriveBits(algorithm, baseKey, length) {\n  validateUint32(length, \"length\");\n  const { iterations } = algorithm;\n  let { hash } = algorithm;\n  const salt = getArrayBufferOrView(algorithm.salt, \"algorithm.salt\");\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  validateInteger(iterations, \"algorithm.iterations\", 1);\n  hash = normalizeHashName(hash.name);\n  const raw = baseKey[kKeyObject].export();\n  let byteLength = 64;\n  if (length !== void 0) {\n    if (length === 0)\n      throw lazyDOMException(\"length cannot be zero\", \"OperationError\");\n    if (length % 8) {\n      throw lazyDOMException(\"length must be a multiple of 8\", \"OperationError\");\n    }\n    byteLength = length / 8;\n  }\n  return new Promise((resolve, reject) => {\n    pbkdf2(raw, salt, iterations, byteLength, hash, (err, result) => {\n      if (err)\n        return reject(err);\n      resolve(result.buffer);\n    });\n  });\n}\nmodule.exports = {\n  pbkdf2,\n  pbkdf2Sync,\n  pbkdf2DeriveBits\n};\n}"],["internal/crypto/random.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  ArrayPrototypeSplice,\n  BigInt,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  MathMin,\n  NumberIsNaN,\n  NumberIsSafeInteger,\n  NumberPrototypeToString,\n  StringPrototypePadStart\n} = primordials;\nconst {\n  RandomBytesJob,\n  RandomPrimeJob,\n  CheckPrimeJob,\n  kCryptoJobAsync,\n  kCryptoJobSync,\n  secureBuffer\n} = internalBinding(\"crypto\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst { Buffer, kMaxLength } = require(\"buffer\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE,\n    ERR_OPERATION_FAILED\n  }\n} = require(\"internal/errors\");\nconst {\n  validateNumber,\n  validateBoolean,\n  validateCallback,\n  validateObject,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  isArrayBufferView,\n  isAnyArrayBuffer,\n  isFloat32Array,\n  isFloat64Array\n} = require(\"internal/util/types\");\nconst { FastBuffer } = require(\"internal/buffer\");\nconst kMaxInt32 = 2 ** 31 - 1;\nconst kMaxPossibleLength = MathMin(kMaxLength, kMaxInt32);\nfunction assertOffset(offset, elementSize, length) {\n  validateNumber(offset, \"offset\");\n  offset *= elementSize;\n  const maxLength = MathMin(length, kMaxPossibleLength);\n  if (NumberIsNaN(offset) || offset > maxLength || offset < 0) {\n    throw new ERR_OUT_OF_RANGE(\"offset\", `>= 0 && <= ${maxLength}`, offset);\n  }\n  return offset >>> 0;\n}\nfunction assertSize(size, elementSize, offset, length) {\n  validateNumber(size, \"size\");\n  size *= elementSize;\n  if (NumberIsNaN(size) || size > kMaxPossibleLength || size < 0) {\n    throw new ERR_OUT_OF_RANGE(\"size\", `>= 0 && <= ${kMaxPossibleLength}`, size);\n  }\n  if (size + offset > length) {\n    throw new ERR_OUT_OF_RANGE(\"size + offset\", `<= ${length}`, size + offset);\n  }\n  return size >>> 0;\n}\nfunction randomBytes(size, callback) {\n  size = assertSize(size, 1, 0, Infinity);\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  const buf = new FastBuffer(size);\n  if (callback === void 0) {\n    randomFillSync(buf.buffer, 0, size);\n    return buf;\n  }\n  randomFill(buf.buffer, 0, size, function(error) {\n    if (error)\n      return FunctionPrototypeCall(callback, this, error);\n    FunctionPrototypeCall(callback, this, null, buf);\n  });\n}\nfunction randomFillSync(buf, offset = 0, size) {\n  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {\n    throw new ERR_INVALID_ARG_TYPE(\"buf\", [\"ArrayBuffer\", \"ArrayBufferView\"], buf);\n  }\n  const elementSize = buf.BYTES_PER_ELEMENT || 1;\n  offset = assertOffset(offset, elementSize, buf.byteLength);\n  if (size === void 0) {\n    size = buf.byteLength - offset;\n  } else {\n    size = assertSize(size, elementSize, offset, buf.byteLength);\n  }\n  if (size === 0)\n    return buf;\n  const job = new RandomBytesJob(kCryptoJobSync, buf, offset, size);\n  const err = job.run()[0];\n  if (err)\n    throw err;\n  return buf;\n}\nfunction randomFill(buf, offset, size, callback) {\n  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {\n    throw new ERR_INVALID_ARG_TYPE(\"buf\", [\"ArrayBuffer\", \"ArrayBufferView\"], buf);\n  }\n  const elementSize = buf.BYTES_PER_ELEMENT || 1;\n  if (typeof offset === \"function\") {\n    callback = offset;\n    offset = 0;\n    size = buf.length;\n  } else if (typeof size === \"function\") {\n    callback = size;\n    size = buf.length - offset;\n  } else {\n    validateCallback(callback);\n  }\n  offset = assertOffset(offset, elementSize, buf.byteLength);\n  if (size === void 0) {\n    size = buf.byteLength - offset;\n  } else {\n    size = assertSize(size, elementSize, offset, buf.byteLength);\n  }\n  if (size === 0) {\n    callback(null, buf);\n    return;\n  }\n  const job = new RandomBytesJob(kCryptoJobAsync, buf, offset, size);\n  job.ondone = FunctionPrototypeBind(onJobDone, job, buf, callback);\n  job.run();\n}\nconst RAND_MAX = 281474976710655;\nconst randomCache = new FastBuffer(6 * 1024);\nlet randomCacheOffset = randomCache.length;\nlet asyncCacheFillInProgress = false;\nconst asyncCachePendingTasks = [];\nfunction randomInt(min, max, callback) {\n  const minNotSpecified = typeof max === \"undefined\" || typeof max === \"function\";\n  if (minNotSpecified) {\n    callback = max;\n    max = min;\n    min = 0;\n  }\n  const isSync = typeof callback === \"undefined\";\n  if (!isSync) {\n    validateCallback(callback);\n  }\n  if (!NumberIsSafeInteger(min)) {\n    throw new ERR_INVALID_ARG_TYPE(\"min\", \"a safe integer\", min);\n  }\n  if (!NumberIsSafeInteger(max)) {\n    throw new ERR_INVALID_ARG_TYPE(\"max\", \"a safe integer\", max);\n  }\n  if (max <= min) {\n    throw new ERR_OUT_OF_RANGE(\"max\", `greater than the value of \"min\" (${min})`, max);\n  }\n  const range = max - min;\n  if (!(range <= RAND_MAX)) {\n    throw new ERR_OUT_OF_RANGE(`max${minNotSpecified ? \"\" : \" - min\"}`, `<= ${RAND_MAX}`, range);\n  }\n  const randLimit = RAND_MAX - RAND_MAX % range;\n  while (isSync || randomCacheOffset < randomCache.length) {\n    if (randomCacheOffset === randomCache.length) {\n      randomFillSync(randomCache);\n      randomCacheOffset = 0;\n    }\n    const x = randomCache.readUIntBE(randomCacheOffset, 6);\n    randomCacheOffset += 6;\n    if (x < randLimit) {\n      const n = x % range + min;\n      if (isSync)\n        return n;\n      process.nextTick(callback, void 0, n);\n      return;\n    }\n  }\n  ArrayPrototypePush(asyncCachePendingTasks, { min, max, callback });\n  asyncRefillRandomIntCache();\n}\nfunction asyncRefillRandomIntCache() {\n  if (asyncCacheFillInProgress)\n    return;\n  asyncCacheFillInProgress = true;\n  randomFill(randomCache, (err) => {\n    asyncCacheFillInProgress = false;\n    const tasks = asyncCachePendingTasks;\n    const errorReceiver = err && ArrayPrototypeShift(tasks);\n    if (!err)\n      randomCacheOffset = 0;\n    ArrayPrototypeForEach(ArrayPrototypeSplice(tasks, 0), (task) => {\n      randomInt(task.min, task.max, task.callback);\n    });\n    if (errorReceiver)\n      errorReceiver.callback(err);\n  });\n}\nfunction onJobDone(buf, callback, error) {\n  if (error)\n    return FunctionPrototypeCall(callback, this, error);\n  FunctionPrototypeCall(callback, this, null, buf);\n}\nfunction getRandomValues(data) {\n  if (!isArrayBufferView(data) || isFloat32Array(data) || isFloat64Array(data)) {\n    throw lazyDOMException(\"The data argument must be an integer-type TypedArray\", \"TypeMismatchError\");\n  }\n  if (data.byteLength > 65536) {\n    throw lazyDOMException(\"The requested length exceeds 65,536 bytes\", \"QuotaExceededError\");\n  }\n  randomFillSync(data, 0);\n  return data;\n}\nconst kBatchSize = 128;\nlet uuidData;\nlet uuidNotBuffered;\nlet uuidBatch = 0;\nlet hexBytesCache;\nfunction getHexBytes() {\n  if (hexBytesCache === void 0) {\n    hexBytesCache = new Array(256);\n    for (let i = 0; i < hexBytesCache.length; i++) {\n      const hex = NumberPrototypeToString(i, 16);\n      hexBytesCache[i] = StringPrototypePadStart(hex, 2, \"0\");\n    }\n  }\n  return hexBytesCache;\n}\nfunction serializeUUID(buf, offset = 0) {\n  const kHexBytes = getHexBytes();\n  return kHexBytes[buf[offset]] + kHexBytes[buf[offset + 1]] + kHexBytes[buf[offset + 2]] + kHexBytes[buf[offset + 3]] + \"-\" + kHexBytes[buf[offset + 4]] + kHexBytes[buf[offset + 5]] + \"-\" + kHexBytes[buf[offset + 6] & 15 | 64] + kHexBytes[buf[offset + 7]] + \"-\" + kHexBytes[buf[offset + 8] & 63 | 128] + kHexBytes[buf[offset + 9]] + \"-\" + kHexBytes[buf[offset + 10]] + kHexBytes[buf[offset + 11]] + kHexBytes[buf[offset + 12]] + kHexBytes[buf[offset + 13]] + kHexBytes[buf[offset + 14]] + kHexBytes[buf[offset + 15]];\n}\nfunction getBufferedUUID() {\n  uuidData ??= secureBuffer(16 * kBatchSize);\n  if (uuidData === void 0)\n    throw new ERR_OPERATION_FAILED(\"Out of memory\");\n  if (uuidBatch === 0)\n    randomFillSync(uuidData);\n  uuidBatch = (uuidBatch + 1) % kBatchSize;\n  return serializeUUID(uuidData, uuidBatch * 16);\n}\nfunction getUnbufferedUUID() {\n  uuidNotBuffered ??= secureBuffer(16);\n  if (uuidNotBuffered === void 0)\n    throw new ERR_OPERATION_FAILED(\"Out of memory\");\n  randomFillSync(uuidNotBuffered);\n  return serializeUUID(uuidNotBuffered);\n}\nfunction randomUUID(options) {\n  if (options !== void 0)\n    validateObject(options, \"options\");\n  const {\n    disableEntropyCache = false\n  } = options || {};\n  validateBoolean(disableEntropyCache, \"options.disableEntropyCache\");\n  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();\n}\nfunction createRandomPrimeJob(type, size, options) {\n  validateObject(options, \"options\");\n  const {\n    safe = false,\n    bigint = false\n  } = options;\n  let {\n    add,\n    rem\n  } = options;\n  validateBoolean(safe, \"options.safe\");\n  validateBoolean(bigint, \"options.bigint\");\n  if (add !== void 0) {\n    if (typeof add === \"bigint\") {\n      add = unsignedBigIntToBuffer(add, \"options.add\");\n    } else if (!isAnyArrayBuffer(add) && !isArrayBufferView(add)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.add\", [\n        \"ArrayBuffer\",\n        \"TypedArray\",\n        \"Buffer\",\n        \"DataView\",\n        \"bigint\"\n      ], add);\n    }\n  }\n  if (rem !== void 0) {\n    if (typeof rem === \"bigint\") {\n      rem = unsignedBigIntToBuffer(rem, \"options.rem\");\n    } else if (!isAnyArrayBuffer(rem) && !isArrayBufferView(rem)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.rem\", [\n        \"ArrayBuffer\",\n        \"TypedArray\",\n        \"Buffer\",\n        \"DataView\",\n        \"bigint\"\n      ], rem);\n    }\n  }\n  const job = new RandomPrimeJob(type, size, safe, add, rem);\n  job.result = bigint ? arrayBufferToUnsignedBigInt : (p) => p;\n  return job;\n}\nfunction generatePrime(size, options, callback) {\n  validateUint32(size, \"size\", true);\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  validateCallback(callback);\n  const job = createRandomPrimeJob(kCryptoJobAsync, size, options);\n  job.ondone = (err, prime) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    callback(void 0, job.result(prime));\n  };\n  job.run();\n}\nfunction generatePrimeSync(size, options = {}) {\n  validateUint32(size, \"size\", true);\n  const job = createRandomPrimeJob(kCryptoJobSync, size, options);\n  const { 0: err, 1: prime } = job.run();\n  if (err)\n    throw err;\n  return job.result(prime);\n}\nfunction arrayBufferToUnsignedBigInt(arrayBuffer) {\n  return BigInt(`0x${Buffer.from(arrayBuffer).toString(\"hex\")}`);\n}\nfunction unsignedBigIntToBuffer(bigint, name) {\n  if (bigint < 0) {\n    throw new ERR_OUT_OF_RANGE(name, \">= 0\", bigint);\n  }\n  const hex = bigint.toString(16);\n  const padded = hex.padStart(hex.length + hex.length % 2, 0);\n  return Buffer.from(padded, \"hex\");\n}\nfunction checkPrime(candidate, options = {}, callback) {\n  if (typeof candidate === \"bigint\")\n    candidate = unsignedBigIntToBuffer(candidate, \"candidate\");\n  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {\n    throw new ERR_INVALID_ARG_TYPE(\"candidate\", [\n      \"ArrayBuffer\",\n      \"TypedArray\",\n      \"Buffer\",\n      \"DataView\",\n      \"bigint\"\n    ], candidate);\n  }\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  validateCallback(callback);\n  validateObject(options, \"options\");\n  const {\n    checks = 0\n  } = options;\n  validateUint32(checks, \"options.checks\");\n  const job = new CheckPrimeJob(kCryptoJobAsync, candidate, checks);\n  job.ondone = callback;\n  job.run();\n}\nfunction checkPrimeSync(candidate, options = {}) {\n  if (typeof candidate === \"bigint\")\n    candidate = unsignedBigIntToBuffer(candidate, \"candidate\");\n  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {\n    throw new ERR_INVALID_ARG_TYPE(\"candidate\", [\n      \"ArrayBuffer\",\n      \"TypedArray\",\n      \"Buffer\",\n      \"DataView\",\n      \"bigint\"\n    ], candidate);\n  }\n  validateObject(options, \"options\");\n  const {\n    checks = 0\n  } = options;\n  validateUint32(checks, \"options.checks\");\n  const job = new CheckPrimeJob(kCryptoJobSync, candidate, checks);\n  const { 0: err, 1: result } = job.run();\n  if (err)\n    throw err;\n  return result;\n}\nmodule.exports = {\n  checkPrime,\n  checkPrimeSync,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  randomInt,\n  getRandomValues,\n  randomUUID,\n  generatePrime,\n  generatePrimeSync\n};\n}"],["internal/crypto/rsa.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Promise,\n  SafeSet,\n  Uint8Array\n} = primordials;\nconst {\n  KeyObjectHandle,\n  RSACipherJob,\n  RSAKeyExportJob,\n  SignJob,\n  kCryptoJobAsync,\n  kSignJobModeSign,\n  kSignJobModeVerify,\n  kKeyVariantRSA_SSA_PKCS1_v1_5,\n  kKeyVariantRSA_PSS,\n  kKeyVariantRSA_OAEP,\n  kKeyTypePrivate,\n  kWebCryptoCipherEncrypt,\n  RSA_PKCS1_PSS_PADDING\n} = internalBinding(\"crypto\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_OPTION\n  }\n} = require(\"internal/errors\");\nconst {\n  validateInt32,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  bigIntArrayToUnsignedInt,\n  getArrayBufferOrView,\n  getUsagesUnion,\n  hasAnyNotIn,\n  jobPromise,\n  normalizeHashName,\n  validateKeyOps,\n  validateMaxBufferLength,\n  kHandle,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  isUint8Array\n} = require(\"internal/util/types\");\nconst {\n  InternalCryptoKey,\n  PrivateKeyObject,\n  PublicKeyObject,\n  createPublicKey,\n  createPrivateKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  generateKeyPair\n} = require(\"internal/crypto/keygen\");\nconst kRsaVariants = {\n  \"RSASSA-PKCS1-v1_5\": kKeyVariantRSA_SSA_PKCS1_v1_5,\n  \"RSA-PSS\": kKeyVariantRSA_PSS,\n  \"RSA-OAEP\": kKeyVariantRSA_OAEP\n};\nfunction verifyAcceptableRsaKeyUse(name, type, usages) {\n  let checkSet;\n  switch (name) {\n    case \"RSA-OAEP\":\n      switch (type) {\n        case \"private\":\n          checkSet = [\"decrypt\", \"unwrapKey\"];\n          break;\n        case \"public\":\n          checkSet = [\"encrypt\", \"wrapKey\"];\n          break;\n      }\n      break;\n    default:\n      switch (type) {\n        case \"private\":\n          checkSet = [\"sign\"];\n          break;\n        case \"public\":\n          checkSet = [\"verify\"];\n          break;\n      }\n  }\n  if (hasAnyNotIn(usages, checkSet)) {\n    throw lazyDOMException(`Unsupported key usage for an ${name} key`, \"SyntaxError\");\n  }\n}\nfunction rsaOaepCipher(mode, key, data, { label }) {\n  const type = mode === kWebCryptoCipherEncrypt ? \"public\" : \"private\";\n  if (key.type !== type) {\n    throw lazyDOMException(\"The requested operation is not valid for the provided key\", \"InvalidAccessError\");\n  }\n  if (label !== void 0) {\n    label = getArrayBufferOrView(label, \"algorithm.label\");\n    validateMaxBufferLength(label, \"algorithm.label\");\n  }\n  return jobPromise(new RSACipherJob(kCryptoJobAsync, mode, key[kKeyObject][kHandle], data, kKeyVariantRSA_OAEP, normalizeHashName(key.algorithm.hash.name), label));\n}\nasync function rsaKeyGenerate(algorithm, extractable, keyUsages) {\n  const {\n    name,\n    modulusLength,\n    publicExponent,\n    hash\n  } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  validateUint32(modulusLength, \"algorithm.modulusLength\");\n  if (!isUint8Array(publicExponent)) {\n    throw new ERR_INVALID_ARG_TYPE(\"algorithm.publicExponent\", \"Uint8Array\", publicExponent);\n  }\n  const usageSet = new SafeSet(keyUsages);\n  const publicExponentConverted = bigIntArrayToUnsignedInt(publicExponent);\n  if (publicExponentConverted === void 0) {\n    throw lazyDOMException(\"The publicExponent must be equivalent to an unsigned 32-bit value\", \"OperationError\");\n  }\n  switch (name) {\n    case \"RSA-OAEP\":\n      if (hasAnyNotIn(usageSet, [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"])) {\n        throw lazyDOMException(\"Unsupported key usage for a RSA key\", \"SyntaxError\");\n      }\n      break;\n    default:\n      if (hasAnyNotIn(usageSet, [\"sign\", \"verify\"])) {\n        throw lazyDOMException(\"Unsupported key usage for a RSA key\", \"SyntaxError\");\n      }\n  }\n  return new Promise((resolve, reject) => {\n    generateKeyPair(\"rsa\", {\n      modulusLength,\n      publicExponentConverted\n    }, (err, pubKey, privKey) => {\n      if (err) {\n        return reject(lazyDOMException(\"The operation failed for an operation-specific reason\", \"OperationError\"));\n      }\n      const algorithm2 = {\n        name,\n        modulusLength,\n        publicExponent,\n        hash: { name: hash.name }\n      };\n      let publicUsages;\n      let privateUsages;\n      switch (name) {\n        case \"RSA-OAEP\": {\n          publicUsages = getUsagesUnion(usageSet, \"encrypt\", \"wrapKey\");\n          privateUsages = getUsagesUnion(usageSet, \"decrypt\", \"unwrapKey\");\n          break;\n        }\n        default: {\n          publicUsages = getUsagesUnion(usageSet, \"verify\");\n          privateUsages = getUsagesUnion(usageSet, \"sign\");\n          break;\n        }\n      }\n      const publicKey = new InternalCryptoKey(pubKey, algorithm2, publicUsages, true);\n      const privateKey = new InternalCryptoKey(privKey, algorithm2, privateUsages, extractable);\n      resolve({ publicKey, privateKey });\n    });\n  });\n}\nfunction rsaExportKey(key, format) {\n  return jobPromise(new RSAKeyExportJob(kCryptoJobAsync, format, key[kKeyObject][kHandle], kRsaVariants[key.algorithm.name]));\n}\nasync function rsaImportKey(format, keyData, algorithm, extractable, keyUsages) {\n  const { hash } = algorithm;\n  if (hash === void 0)\n    throw new ERR_MISSING_OPTION(\"algorithm.hash\");\n  const usagesSet = new SafeSet(keyUsages);\n  let keyObject;\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type === \"secret\")\n        throw lazyDOMException(\"Invalid key type\", \"InvalidAccessException\");\n      verifyAcceptableRsaKeyUse(algorithm.name, keyData.type, usagesSet);\n      keyObject = keyData;\n      break;\n    }\n    case \"spki\": {\n      verifyAcceptableRsaKeyUse(algorithm.name, \"public\", usagesSet);\n      keyObject = createPublicKey({\n        key: keyData,\n        format: \"der\",\n        type: \"spki\"\n      });\n      break;\n    }\n    case \"pkcs8\": {\n      verifyAcceptableRsaKeyUse(algorithm.name, \"private\", usagesSet);\n      keyObject = createPrivateKey({\n        key: keyData,\n        format: \"der\",\n        type: \"pkcs8\"\n      });\n      break;\n    }\n    case \"jwk\": {\n      if (keyData == null || typeof keyData !== \"object\")\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      verifyAcceptableRsaKeyUse(algorithm.name, keyData.d !== void 0 ? \"private\" : \"public\", usagesSet);\n      if (keyData.kty !== \"RSA\")\n        throw lazyDOMException(\"Invalid key type\", \"DataError\");\n      if (usagesSet.size > 0 && keyData.use !== void 0) {\n        const checkUse = algorithm.name === \"RSA-OAEP\" ? \"enc\" : \"sig\";\n        if (keyData.use !== checkUse)\n          throw lazyDOMException(\"Invalid use type\", \"DataError\");\n      }\n      validateKeyOps(keyData.key_ops, usagesSet);\n      if (keyData.ext !== void 0 && keyData.ext === false && extractable === true) {\n        throw lazyDOMException(\"JWK is not extractable\", \"DataError\");\n      }\n      if (keyData.alg !== void 0) {\n        if (typeof keyData.alg !== \"string\")\n          throw lazyDOMException(\"Invalid alg\", \"DataError\");\n        const hash2 = normalizeHashName(keyData.alg, normalizeHashName.kContextWebCrypto);\n        if (hash2 !== algorithm.hash.name)\n          throw lazyDOMException(\"Hash mismatch\", \"DataError\");\n      }\n      const handle = new KeyObjectHandle();\n      const type = handle.initJwk(keyData);\n      if (type === void 0)\n        throw lazyDOMException(\"Invalid JWK keyData\", \"DataError\");\n      keyObject = type === kKeyTypePrivate ? new PrivateKeyObject(handle) : new PublicKeyObject(handle);\n      break;\n    }\n    default:\n      throw lazyDOMException(`Unable to import RSA key with format ${format}`, \"NotSupportedError\");\n  }\n  if (algorithm.name === \"RSA-PSS\") {\n    if (keyObject.asymmetricKeyType !== \"rsa\" && keyObject.asymmetricKeyType !== \"rsa-pss\") {\n      throw lazyDOMException(\"Invalid key type\", \"DataError\");\n    }\n  } else if (keyObject.asymmetricKeyType !== \"rsa\") {\n    throw lazyDOMException(\"Invalid key type\", \"DataError\");\n  }\n  const {\n    modulusLength,\n    publicExponent\n  } = keyObject[kHandle].keyDetail({});\n  return new InternalCryptoKey(keyObject, {\n    name: algorithm.name,\n    modulusLength,\n    publicExponent: new Uint8Array(publicExponent),\n    hash: algorithm.hash\n  }, keyUsages, extractable);\n}\nfunction rsaSignVerify(key, data, { saltLength }, signature) {\n  let padding;\n  if (key.algorithm.name === \"RSA-PSS\") {\n    padding = RSA_PKCS1_PSS_PADDING;\n    validateInt32(saltLength, \"algorithm.saltLength\", -2);\n  }\n  const mode = signature === void 0 ? kSignJobModeSign : kSignJobModeVerify;\n  const type = mode === kSignJobModeSign ? \"private\" : \"public\";\n  if (key.type !== type)\n    throw lazyDOMException(`Key must be a ${type} key`, \"InvalidAccessError\");\n  return jobPromise(new SignJob(kCryptoJobAsync, signature === void 0 ? kSignJobModeSign : kSignJobModeVerify, key[kKeyObject][kHandle], void 0, void 0, void 0, data, normalizeHashName(key.algorithm.hash.name), saltLength, padding, void 0, signature));\n}\nmodule.exports = {\n  rsaCipher: rsaOaepCipher,\n  rsaExportKey,\n  rsaImportKey,\n  rsaKeyGenerate,\n  rsaSignVerify\n};\n}"],["internal/crypto/scrypt.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  Promise\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  ScryptJob,\n  kCryptoJobAsync,\n  kCryptoJobSync\n} = internalBinding(\"crypto\");\nconst {\n  validateCallback,\n  validateInteger,\n  validateInt32,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,\n    ERR_CRYPTO_SCRYPT_NOT_SUPPORTED\n  }\n} = require(\"internal/errors\");\nconst {\n  getArrayBufferOrView,\n  getDefaultEncoding,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst defaults = {\n  N: 16384,\n  r: 8,\n  p: 1,\n  maxmem: 32 << 20\n};\nfunction scrypt(password, salt, keylen, options, callback = defaults) {\n  if (callback === defaults) {\n    callback = options;\n    options = defaults;\n  }\n  options = check(password, salt, keylen, options);\n  const { N, r, p, maxmem } = options;\n  ({ password, salt, keylen } = options);\n  validateCallback(callback);\n  const job = new ScryptJob(kCryptoJobAsync, password, salt, N, r, p, maxmem, keylen);\n  const encoding = getDefaultEncoding();\n  job.ondone = (error, result) => {\n    if (error !== void 0)\n      return FunctionPrototypeCall(callback, job, error);\n    const buf = Buffer.from(result);\n    if (encoding === \"buffer\")\n      return FunctionPrototypeCall(callback, job, null, buf);\n    FunctionPrototypeCall(callback, job, null, buf.toString(encoding));\n  };\n  job.run();\n}\nfunction scryptSync(password, salt, keylen, options = defaults) {\n  options = check(password, salt, keylen, options);\n  const { N, r, p, maxmem } = options;\n  ({ password, salt, keylen } = options);\n  const job = new ScryptJob(kCryptoJobSync, password, salt, N, r, p, maxmem, keylen);\n  const { 0: err, 1: result } = job.run();\n  if (err !== void 0)\n    throw err;\n  const buf = Buffer.from(result);\n  const encoding = getDefaultEncoding();\n  return encoding === \"buffer\" ? buf : buf.toString(encoding);\n}\nfunction check(password, salt, keylen, options) {\n  if (ScryptJob === void 0)\n    throw new ERR_CRYPTO_SCRYPT_NOT_SUPPORTED();\n  password = getArrayBufferOrView(password, \"password\");\n  salt = getArrayBufferOrView(salt, \"salt\");\n  validateInt32(keylen, \"keylen\", 0);\n  let { N, r, p, maxmem } = defaults;\n  if (options && options !== defaults) {\n    let has_N, has_r, has_p;\n    if (has_N = options.N !== void 0) {\n      N = options.N;\n      validateUint32(N, \"N\");\n    }\n    if (options.cost !== void 0) {\n      if (has_N)\n        throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      N = options.cost;\n      validateUint32(N, \"cost\");\n    }\n    if (has_r = options.r !== void 0) {\n      r = options.r;\n      validateUint32(r, \"r\");\n    }\n    if (options.blockSize !== void 0) {\n      if (has_r)\n        throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      r = options.blockSize;\n      validateUint32(r, \"blockSize\");\n    }\n    if (has_p = options.p !== void 0) {\n      p = options.p;\n      validateUint32(p, \"p\");\n    }\n    if (options.parallelization !== void 0) {\n      if (has_p)\n        throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      p = options.parallelization;\n      validateUint32(p, \"parallelization\");\n    }\n    if (options.maxmem !== void 0) {\n      maxmem = options.maxmem;\n      validateInteger(maxmem, \"maxmem\", 0);\n    }\n    if (N === 0)\n      N = defaults.N;\n    if (r === 0)\n      r = defaults.r;\n    if (p === 0)\n      p = defaults.p;\n    if (maxmem === 0)\n      maxmem = defaults.maxmem;\n  }\n  return { password, salt, keylen, N, r, p, maxmem };\n}\nasync function scryptDeriveBits(algorithm, baseKey, length) {\n  validateUint32(length, \"length\");\n  const {\n    N = 16384,\n    r = 8,\n    p = 1,\n    maxmem = 32 * 1024 * 1024,\n    encoding\n  } = algorithm;\n  validateUint32(N, \"algorithm.N\");\n  validateUint32(r, \"algorithm.r\");\n  validateUint32(p, \"algorithm.p\");\n  validateUint32(maxmem, \"algorithm.maxmem\");\n  const salt = getArrayBufferOrView(algorithm.salt, \"algorithm.salt\", encoding);\n  const raw = baseKey[kKeyObject].export();\n  let byteLength = 64;\n  if (length !== void 0) {\n    if (length === 0)\n      throw lazyDOMException(\"length cannot be zero\", \"OperationError\");\n    if (length % 8) {\n      throw lazyDOMException(\"length must be a multiple of 8\", \"OperationError\");\n    }\n    byteLength = length / 8;\n  }\n  return new Promise((resolve, reject) => {\n    scrypt(raw, salt, byteLength, { N, r, p, maxmem }, (err, result) => {\n      if (err)\n        return reject(err);\n      resolve(result.buffer);\n    });\n  });\n}\nmodule.exports = {\n  scrypt,\n  scryptSync,\n  scryptDeriveBits\n};\n}"],["internal/crypto/sig.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  ObjectSetPrototypeOf,\n  ReflectApply\n} = primordials;\nconst {\n  codes: {\n    ERR_CRYPTO_SIGN_KEY_REQUIRED,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateCallback,\n  validateEncoding,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  Sign: _Sign,\n  SignJob,\n  Verify: _Verify,\n  kCryptoJobAsync,\n  kCryptoJobSync,\n  kSigEncDER,\n  kSigEncP1363,\n  kSignJobModeSign,\n  kSignJobModeVerify\n} = internalBinding(\"crypto\");\nconst {\n  getArrayBufferOrView,\n  getDefaultEncoding,\n  kHandle\n} = require(\"internal/crypto/util\");\nconst {\n  preparePrivateKey,\n  preparePublicOrPrivateKey\n} = require(\"internal/crypto/keys\");\nconst { Writable } = require(\"stream\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nfunction Sign(algorithm, options) {\n  if (!(this instanceof Sign))\n    return new Sign(algorithm, options);\n  validateString(algorithm, \"algorithm\");\n  this[kHandle] = new _Sign();\n  this[kHandle].init(algorithm);\n  ReflectApply(Writable, this, [options]);\n}\nObjectSetPrototypeOf(Sign.prototype, Writable.prototype);\nObjectSetPrototypeOf(Sign, Writable);\nSign.prototype._write = function _write(chunk, encoding, callback) {\n  this.update(chunk, encoding);\n  callback();\n};\nSign.prototype.update = function update(data, encoding) {\n  encoding = encoding || getDefaultEncoding();\n  if (typeof data === \"string\") {\n    validateEncoding(data, encoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\"data\", [\"string\", \"Buffer\", \"TypedArray\", \"DataView\"], data);\n  }\n  this[kHandle].update(data, encoding);\n  return this;\n};\nfunction getPadding(options) {\n  return getIntOption(\"padding\", options);\n}\nfunction getSaltLength(options) {\n  return getIntOption(\"saltLength\", options);\n}\nfunction getDSASignatureEncoding(options) {\n  if (typeof options === \"object\") {\n    const { dsaEncoding = \"der\" } = options;\n    if (dsaEncoding === \"der\")\n      return kSigEncDER;\n    else if (dsaEncoding === \"ieee-p1363\")\n      return kSigEncP1363;\n    throw new ERR_INVALID_ARG_VALUE(\"options.dsaEncoding\", dsaEncoding);\n  }\n  return kSigEncDER;\n}\nfunction getIntOption(name, options) {\n  const value = options[name];\n  if (value !== void 0) {\n    if (value === value >> 0) {\n      return value;\n    }\n    throw new ERR_INVALID_ARG_VALUE(`options.${name}`, value);\n  }\n  return void 0;\n}\nSign.prototype.sign = function sign(options, encoding) {\n  if (!options)\n    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();\n  const { data, format, type, passphrase } = preparePrivateKey(options, true);\n  const rsaPadding = getPadding(options);\n  const pssSaltLength = getSaltLength(options);\n  const dsaSigEnc = getDSASignatureEncoding(options);\n  const ret = this[kHandle].sign(data, format, type, passphrase, rsaPadding, pssSaltLength, dsaSigEnc);\n  encoding = encoding || getDefaultEncoding();\n  if (encoding && encoding !== \"buffer\")\n    return ret.toString(encoding);\n  return ret;\n};\nfunction signOneShot(algorithm, data, key, callback) {\n  if (algorithm != null)\n    validateString(algorithm, \"algorithm\");\n  if (callback !== void 0)\n    validateCallback(callback);\n  data = getArrayBufferOrView(data, \"data\");\n  if (!key)\n    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();\n  const rsaPadding = getPadding(key);\n  const pssSaltLength = getSaltLength(key);\n  const dsaSigEnc = getDSASignatureEncoding(key);\n  const {\n    data: keyData,\n    format: keyFormat,\n    type: keyType,\n    passphrase: keyPassphrase\n  } = preparePrivateKey(key);\n  const job = new SignJob(callback ? kCryptoJobAsync : kCryptoJobSync, kSignJobModeSign, keyData, keyFormat, keyType, keyPassphrase, data, algorithm, pssSaltLength, rsaPadding, dsaSigEnc);\n  if (!callback) {\n    const { 0: err, 1: signature } = job.run();\n    if (err !== void 0)\n      throw err;\n    return Buffer.from(signature);\n  }\n  job.ondone = (error, signature) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, Buffer.from(signature));\n  };\n  job.run();\n}\nfunction Verify(algorithm, options) {\n  if (!(this instanceof Verify))\n    return new Verify(algorithm, options);\n  validateString(algorithm, \"algorithm\");\n  this[kHandle] = new _Verify();\n  this[kHandle].init(algorithm);\n  ReflectApply(Writable, this, [options]);\n}\nObjectSetPrototypeOf(Verify.prototype, Writable.prototype);\nObjectSetPrototypeOf(Verify, Writable);\nVerify.prototype._write = Sign.prototype._write;\nVerify.prototype.update = Sign.prototype.update;\nVerify.prototype.verify = function verify(options, signature, sigEncoding) {\n  const {\n    data,\n    format,\n    type,\n    passphrase\n  } = preparePublicOrPrivateKey(options, true);\n  sigEncoding = sigEncoding || getDefaultEncoding();\n  const rsaPadding = getPadding(options);\n  const pssSaltLength = getSaltLength(options);\n  const dsaSigEnc = getDSASignatureEncoding(options);\n  signature = getArrayBufferOrView(signature, \"signature\", sigEncoding);\n  return this[kHandle].verify(data, format, type, passphrase, signature, rsaPadding, pssSaltLength, dsaSigEnc);\n};\nfunction verifyOneShot(algorithm, data, key, signature, callback) {\n  if (algorithm != null)\n    validateString(algorithm, \"algorithm\");\n  if (callback !== void 0)\n    validateCallback(callback);\n  data = getArrayBufferOrView(data, \"data\");\n  if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\"data\", [\"Buffer\", \"TypedArray\", \"DataView\"], data);\n  }\n  const rsaPadding = getPadding(key);\n  const pssSaltLength = getSaltLength(key);\n  const dsaSigEnc = getDSASignatureEncoding(key);\n  if (!isArrayBufferView(signature)) {\n    throw new ERR_INVALID_ARG_TYPE(\"signature\", [\"Buffer\", \"TypedArray\", \"DataView\"], signature);\n  }\n  const {\n    data: keyData,\n    format: keyFormat,\n    type: keyType,\n    passphrase: keyPassphrase\n  } = preparePublicOrPrivateKey(key);\n  const job = new SignJob(callback ? kCryptoJobAsync : kCryptoJobSync, kSignJobModeVerify, keyData, keyFormat, keyType, keyPassphrase, data, algorithm, pssSaltLength, rsaPadding, dsaSigEnc, signature);\n  if (!callback) {\n    const { 0: err, 1: result } = job.run();\n    if (err !== void 0)\n      throw err;\n    return result;\n  }\n  job.ondone = (error, result) => {\n    if (error)\n      return FunctionPrototypeCall(callback, job, error);\n    FunctionPrototypeCall(callback, job, null, result);\n  };\n  job.run();\n}\nmodule.exports = {\n  Sign,\n  signOneShot,\n  Verify,\n  verifyOneShot\n};\n}"],["internal/crypto/util.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIncludes,\n  ArrayPrototypePush,\n  BigInt,\n  FunctionPrototypeBind,\n  Number,\n  ObjectKeys,\n  Promise,\n  StringPrototypeToLowerCase,\n  Symbol\n} = primordials;\nconst {\n  getCiphers: _getCiphers,\n  getCurves: _getCurves,\n  getHashes: _getHashes,\n  setEngine: _setEngine,\n  secureHeapUsed: _secureHeapUsed\n} = internalBinding(\"crypto\");\nconst { getOptionValue } = require(\"internal/options\");\nconst {\n  crypto: {\n    ENGINE_METHOD_ALL\n  }\n} = internalBinding(\"constants\");\nconst normalizeHashName = require(\"internal/crypto/hashnames\");\nconst {\n  hideStackFrames,\n  codes: {\n    ERR_CRYPTO_ENGINE_UNKNOWN,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateArray,\n  validateNumber,\n  validateString\n} = require(\"internal/validators\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  cachedResult,\n  filterDuplicateStrings,\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  isArrayBufferView,\n  isAnyArrayBuffer\n} = require(\"internal/util/types\");\nconst kHandle = Symbol(\"kHandle\");\nconst kKeyObject = Symbol(\"kKeyObject\");\nconst lazyRequireCache = {};\nfunction lazyRequire(name) {\n  let ret = lazyRequireCache[name];\n  if (ret === void 0)\n    ret = lazyRequireCache[name] = require(name);\n  return ret;\n}\nvar defaultEncoding = \"buffer\";\nfunction setDefaultEncoding(val) {\n  defaultEncoding = val;\n}\nfunction getDefaultEncoding() {\n  return defaultEncoding;\n}\nfunction toBuf(val, encoding) {\n  if (typeof val === \"string\") {\n    if (encoding === \"buffer\")\n      encoding = \"utf8\";\n    return Buffer.from(val, encoding);\n  }\n  return val;\n}\nconst getCiphers = cachedResult(() => filterDuplicateStrings(_getCiphers()));\nconst getHashes = cachedResult(() => filterDuplicateStrings(_getHashes()));\nconst getCurves = cachedResult(() => filterDuplicateStrings(_getCurves()));\nfunction setEngine(id, flags) {\n  validateString(id, \"id\");\n  if (flags)\n    validateNumber(flags, \"flags\");\n  flags = flags >>> 0;\n  if (flags === 0)\n    flags = ENGINE_METHOD_ALL;\n  if (!_setEngine(id, flags))\n    throw new ERR_CRYPTO_ENGINE_UNKNOWN(id);\n}\nconst getArrayBufferOrView = hideStackFrames((buffer, name, encoding) => {\n  if (isAnyArrayBuffer(buffer))\n    return buffer;\n  if (typeof buffer === \"string\") {\n    if (encoding === \"buffer\")\n      encoding = \"utf8\";\n    return Buffer.from(buffer, encoding);\n  }\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name, [\n      \"string\",\n      \"ArrayBuffer\",\n      \"Buffer\",\n      \"TypedArray\",\n      \"DataView\"\n    ], buffer);\n  }\n  return buffer;\n});\nconst kMaxBufferLength = 2 ** 31 - 1;\nconst kNamedCurveAliases = {\n  \"P-256\": \"prime256v1\",\n  \"P-384\": \"secp384r1\",\n  \"P-521\": \"secp521r1\",\n  \"NODE-ED25519\": \"ed25519\",\n  \"NODE-ED448\": \"ed448\",\n  \"NODE-X25519\": \"x25519\",\n  \"NODE-X448\": \"x448\"\n};\nconst kAesKeyLengths = [128, 192, 256];\nconst kAlgorithms = {\n  \"rsassa-pkcs1-v1_5\": \"RSASSA-PKCS1-v1_5\",\n  \"rsa-pss\": \"RSA-PSS\",\n  \"rsa-oaep\": \"RSA-OAEP\",\n  \"ecdsa\": \"ECDSA\",\n  \"ecdh\": \"ECDH\",\n  \"aes-ctr\": \"AES-CTR\",\n  \"aes-cbc\": \"AES-CBC\",\n  \"aes-gcm\": \"AES-GCM\",\n  \"aes-kw\": \"AES-KW\",\n  \"hmac\": \"HMAC\",\n  \"sha-1\": \"SHA-1\",\n  \"sha-256\": \"SHA-256\",\n  \"sha-384\": \"SHA-384\",\n  \"sha-512\": \"SHA-512\",\n  \"hkdf\": \"HKDF\",\n  \"pbkdf2\": \"PBKDF2\",\n  \"node-dsa\": \"NODE-DSA\",\n  \"node-dh\": \"NODE-DH\",\n  \"node-scrypt\": \"NODE-SCRYPT\",\n  \"node-ed25519\": \"NODE-ED25519\",\n  \"node-ed448\": \"NODE-ED448\"\n};\nconst kAlgorithmsKeys = ObjectKeys(kAlgorithms);\nconst kExportFormats = [\n  \"raw\",\n  \"pkcs8\",\n  \"spki\",\n  \"jwk\",\n  \"node.keyObject\"\n];\nconst kHashTypes = [\n  \"SHA-1\",\n  \"SHA-256\",\n  \"SHA-384\",\n  \"SHA-512\"\n];\nfunction validateMaxBufferLength(data, name) {\n  if (data.byteLength > kMaxBufferLength) {\n    throw lazyDOMException(`${name} must be less than ${kMaxBufferLength + 1} bits`, \"OperationError\");\n  }\n}\nfunction normalizeAlgorithm(algorithm, label = \"algorithm\") {\n  if (algorithm != null) {\n    if (typeof algorithm === \"string\")\n      algorithm = { name: algorithm };\n    if (typeof algorithm === \"object\") {\n      const { name } = algorithm;\n      let hash;\n      if (typeof name !== \"string\" || !ArrayPrototypeIncludes(kAlgorithmsKeys, StringPrototypeToLowerCase(name))) {\n        throw lazyDOMException(\"Unrecognized name.\", \"NotSupportedError\");\n      }\n      if (algorithm.hash !== void 0) {\n        hash = normalizeAlgorithm(algorithm.hash, \"algorithm.hash\");\n        if (!ArrayPrototypeIncludes(kHashTypes, hash.name))\n          throw lazyDOMException(\"Unrecognized name.\", \"NotSupportedError\");\n      }\n      return {\n        ...algorithm,\n        name: kAlgorithms[StringPrototypeToLowerCase(name)],\n        hash\n      };\n    }\n  }\n  throw lazyDOMException(\"Unrecognized name.\", \"NotSupportedError\");\n}\nfunction hasAnyNotIn(set, checks) {\n  for (const s of set)\n    if (!ArrayPrototypeIncludes(checks, s))\n      return true;\n  return false;\n}\nfunction validateBitLength(length, name, required = false) {\n  if (length !== void 0 || required) {\n    validateNumber(length, name);\n    if (length < 0)\n      throw new ERR_OUT_OF_RANGE(name, \"> 0\");\n    if (length % 8) {\n      throw new ERR_INVALID_ARG_VALUE(name, length, \"must be a multiple of 8\");\n    }\n  }\n}\nfunction validateByteLength(buf, name, target) {\n  if (buf.byteLength !== target) {\n    throw lazyDOMException(`${name} must contain exactly ${target} bytes`, \"OperationError\");\n  }\n}\nconst validateByteSource = hideStackFrames((val, name) => {\n  val = toBuf(val);\n  if (isAnyArrayBuffer(val) || isArrayBufferView(val))\n    return;\n  throw new ERR_INVALID_ARG_TYPE(name, [\n    \"string\",\n    \"ArrayBuffer\",\n    \"TypedArray\",\n    \"DataView\",\n    \"Buffer\"\n  ], val);\n});\nfunction onDone(resolve, reject, err, result) {\n  if (err)\n    return reject(err);\n  resolve(result);\n}\nfunction jobPromise(job) {\n  return new Promise((resolve, reject) => {\n    job.ondone = FunctionPrototypeBind(onDone, job, resolve, reject);\n    job.run();\n  });\n}\nfunction bigIntArrayToUnsignedInt(input) {\n  let result = 0;\n  for (let n = 0; n < input.length; ++n) {\n    const n_reversed = input.length - n - 1;\n    if (n_reversed >= 4 && input[n])\n      return;\n    result |= input[n] << 8 * n_reversed;\n  }\n  return result;\n}\nfunction bigIntArrayToUnsignedBigInt(input) {\n  let result = 0n;\n  for (let n = 0; n < input.length; ++n) {\n    const n_reversed = input.length - n - 1;\n    result |= BigInt(input[n]) << 8n * BigInt(n_reversed);\n  }\n  return result;\n}\nfunction getStringOption(options, key) {\n  let value;\n  if (options && (value = options[key]) != null)\n    validateString(value, `options.${key}`);\n  return value;\n}\nfunction getUsagesUnion(usageSet, ...usages) {\n  const newset = [];\n  for (let n = 0; n < usages.length; n++) {\n    if (usageSet.has(usages[n]))\n      ArrayPrototypePush(newset, usages[n]);\n  }\n  return newset;\n}\nfunction getHashLength(name) {\n  switch (name) {\n    case \"SHA-1\":\n      return 160;\n    case \"SHA-256\":\n      return 256;\n    case \"SHA-384\":\n      return 384;\n    case \"SHA-512\":\n      return 512;\n  }\n}\nconst kKeyOps = {\n  sign: 1,\n  verify: 2,\n  encrypt: 3,\n  decrypt: 4,\n  wrapKey: 5,\n  unwrapKey: 6,\n  deriveKey: 7,\n  deriveBits: 8\n};\nfunction validateKeyOps(keyOps, usagesSet) {\n  if (keyOps === void 0)\n    return;\n  validateArray(keyOps, \"keyData.key_ops\");\n  let flags = 0;\n  for (let n = 0; n < keyOps.length; n++) {\n    const op = keyOps[n];\n    const op_flag = kKeyOps[op];\n    if (op_flag === void 0)\n      continue;\n    if (flags & 1 << op_flag)\n      throw lazyDOMException(\"Duplicate key operation\", \"DataError\");\n    flags |= 1 << op_flag;\n  }\n  if (usagesSet !== void 0) {\n    for (const use of usagesSet) {\n      if (!ArrayPrototypeIncludes(keyOps, use)) {\n        throw lazyDOMException(\"Key operations and usage mismatch\", \"DataError\");\n      }\n    }\n  }\n}\nfunction secureHeapUsed() {\n  const val = _secureHeapUsed();\n  if (val === void 0)\n    return { total: 0, used: 0, utilization: 0, min: 0 };\n  const used = Number(_secureHeapUsed());\n  const total = Number(getOptionValue(\"--secure-heap\"));\n  const min = Number(getOptionValue(\"--secure-heap-min\"));\n  const utilization = used / total;\n  return { total, used, utilization, min };\n}\nmodule.exports = {\n  getArrayBufferOrView,\n  getCiphers,\n  getCurves,\n  getDefaultEncoding,\n  getHashes,\n  kHandle,\n  kKeyObject,\n  setDefaultEncoding,\n  setEngine,\n  toBuf,\n  kHashTypes,\n  kNamedCurveAliases,\n  kAesKeyLengths,\n  kExportFormats,\n  normalizeAlgorithm,\n  normalizeHashName,\n  hasAnyNotIn,\n  validateBitLength,\n  validateByteLength,\n  validateByteSource,\n  validateKeyOps,\n  jobPromise,\n  lazyRequire,\n  validateMaxBufferLength,\n  bigIntArrayToUnsignedBigInt,\n  bigIntArrayToUnsignedInt,\n  getStringOption,\n  getUsagesUnion,\n  getHashLength,\n  secureHeapUsed\n};\n}"],["internal/crypto/webcrypto.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIncludes,\n  JSONParse,\n  JSONStringify,\n  ObjectDefineProperties,\n  SafeSet,\n  SymbolToStringTag,\n  StringPrototypeRepeat\n} = primordials;\nconst {\n  kWebCryptoKeyFormatRaw,\n  kWebCryptoKeyFormatPKCS8,\n  kWebCryptoKeyFormatSPKI,\n  kWebCryptoCipherEncrypt,\n  kWebCryptoCipherDecrypt\n} = internalBinding(\"crypto\");\nconst {\n  validateArray,\n  validateBoolean,\n  validateObject,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst { TextDecoder, TextEncoder } = require(\"internal/encoding\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  CryptoKey,\n  InternalCryptoKey,\n  createSecretKey,\n  isCryptoKey,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  asyncDigest\n} = require(\"internal/crypto/hash\");\nconst {\n  getArrayBufferOrView,\n  hasAnyNotIn,\n  lazyRequire,\n  normalizeAlgorithm,\n  normalizeHashName,\n  validateMaxBufferLength,\n  kExportFormats,\n  kHandle,\n  kKeyObject\n} = require(\"internal/crypto/util\");\nconst {\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  getRandomValues,\n  randomUUID: _randomUUID\n} = require(\"internal/crypto/random\");\nconst randomUUID = () => _randomUUID();\nasync function generateKey(algorithm, extractable, keyUsages) {\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable, \"extractable\");\n  validateArray(keyUsages, \"keyUsages\");\n  switch (algorithm.name) {\n    case \"RSASSA-PKCS1-v1_5\":\n    case \"RSA-PSS\":\n    case \"RSA-OAEP\":\n      return lazyRequire(\"internal/crypto/rsa\").rsaKeyGenerate(algorithm, extractable, keyUsages);\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n    case \"ECDH\":\n      return lazyRequire(\"internal/crypto/ec\").ecGenerateKey(algorithm, extractable, keyUsages);\n    case \"HMAC\":\n      return lazyRequire(\"internal/crypto/mac\").hmacGenerateKey(algorithm, extractable, keyUsages);\n    case \"AES-CTR\":\n    case \"AES-CBC\":\n    case \"AES-GCM\":\n    case \"AES-KW\":\n      return lazyRequire(\"internal/crypto/aes\").aesGenerateKey(algorithm, extractable, keyUsages);\n    case \"NODE-DSA\":\n      return lazyRequire(\"internal/crypto/dsa\").dsaGenerateKey(algorithm, extractable, keyUsages);\n    case \"NODE-DH\":\n      return lazyRequire(\"internal/crypto/diffiehellman\").dhGenerateKey(algorithm, extractable, keyUsages);\n    default:\n      throw lazyDOMException(\"Unrecognized name.\");\n  }\n}\nasync function deriveBits(algorithm, baseKey, length) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE(\"baseKey\", \"CryptoKey\", baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages, \"deriveBits\")) {\n    throw lazyDOMException(\"baseKey does not have deriveBits usage\", \"InvalidAccessError\");\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException(\"Key algorithm mismatch\", \"InvalidAccessError\");\n  switch (algorithm.name) {\n    case \"ECDH\":\n      return lazyRequire(\"internal/crypto/diffiehellman\").asyncDeriveBitsECDH(algorithm, baseKey, length);\n    case \"HKDF\":\n      return lazyRequire(\"internal/crypto/hkdf\").hkdfDeriveBits(algorithm, baseKey, length);\n    case \"PBKDF2\":\n      return lazyRequire(\"internal/crypto/pbkdf2\").pbkdf2DeriveBits(algorithm, baseKey, length);\n    case \"NODE-SCRYPT\":\n      return lazyRequire(\"internal/crypto/scrypt\").scryptDeriveBits(algorithm, baseKey, length);\n    case \"NODE-DH\":\n      return lazyRequire(\"internal/crypto/diffiehellman\").asyncDeriveBitsDH(algorithm, baseKey, length);\n  }\n  throw lazyDOMException(\"Unrecognized name.\");\n}\nasync function deriveKey(algorithm, baseKey, derivedKeyAlgorithm, extractable, keyUsages) {\n  algorithm = normalizeAlgorithm(algorithm);\n  derivedKeyAlgorithm = normalizeAlgorithm(derivedKeyAlgorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE(\"baseKey\", \"CryptoKey\", baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages, \"deriveKey\")) {\n    throw lazyDOMException(\"baseKey does not have deriveKey usage\", \"InvalidAccessError\");\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException(\"Key algorithm mismatch\", \"InvalidAccessError\");\n  validateObject(derivedKeyAlgorithm, \"derivedKeyAlgorithm\", {\n    allowArray: true,\n    allowFunction: true\n  });\n  validateBoolean(extractable, \"extractable\");\n  validateArray(keyUsages, \"keyUsages\");\n  const { length } = derivedKeyAlgorithm;\n  let bits;\n  switch (algorithm.name) {\n    case \"ECDH\":\n      bits = await lazyRequire(\"internal/crypto/diffiehellman\").asyncDeriveBitsECDH(algorithm, baseKey, length);\n      break;\n    case \"HKDF\":\n      bits = await lazyRequire(\"internal/crypto/hkdf\").hkdfDeriveBits(algorithm, baseKey, length);\n      break;\n    case \"PBKDF2\":\n      bits = await lazyRequire(\"internal/crypto/pbkdf2\").pbkdf2DeriveBits(algorithm, baseKey, length);\n      break;\n    case \"NODE-SCRYPT\":\n      bits = await lazyRequire(\"internal/crypto/scrypt\").scryptDeriveBits(algorithm, baseKey, length);\n      break;\n    case \"NODE-DH\":\n      bits = await lazyRequire(\"internal/crypto/diffiehellman\").asyncDeriveBitsDH(algorithm, baseKey, length);\n      break;\n    default:\n      throw lazyDOMException(\"Unrecognized name.\");\n  }\n  return importKey(\"raw\", bits, derivedKeyAlgorithm, extractable, keyUsages);\n}\nasync function exportKeySpki(key) {\n  switch (key.algorithm.name) {\n    case \"RSASSA-PKCS1-v1_5\":\n    case \"RSA-PSS\":\n    case \"RSA-OAEP\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/rsa\").rsaExportKey(key, kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n    case \"ECDH\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/ec\").ecExportKey(key, kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case \"NODE-DSA\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/dsa\").dsaExportKey(key, kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case \"NODE-DH\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/diffiehellman\").dhExportKey(key, kWebCryptoKeyFormatSPKI);\n      }\n      break;\n  }\n  throw lazyDOMException(`Unable to export a raw ${key.algorithm.name} ${key.type} key`, \"InvalidAccessError\");\n}\nasync function exportKeyPkcs8(key) {\n  switch (key.algorithm.name) {\n    case \"RSASSA-PKCS1-v1_5\":\n    case \"RSA-PSS\":\n    case \"RSA-OAEP\":\n      if (key.type === \"private\") {\n        return lazyRequire(\"internal/crypto/rsa\").rsaExportKey(key, kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n    case \"ECDH\":\n      if (key.type === \"private\") {\n        return lazyRequire(\"internal/crypto/ec\").ecExportKey(key, kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case \"NODE-DSA\":\n      if (key.type === \"private\") {\n        return lazyRequire(\"internal/crypto/dsa\").dsaExportKey(key, kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case \"NODE-DH\":\n      if (key.type === \"private\") {\n        return lazyRequire(\"internal/crypto/diffiehellman\").dhExportKey(key, kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n  }\n  throw lazyDOMException(`Unable to export a pkcs8 ${key.algorithm.name} ${key.type} key`, \"InvalidAccessError\");\n}\nasync function exportKeyRaw(key) {\n  switch (key.algorithm.name) {\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/ec\").ecExportKey(key, kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case \"ECDSA\":\n    case \"ECDH\":\n      if (key.type === \"public\") {\n        return lazyRequire(\"internal/crypto/ec\").ecExportKey(key, kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case \"AES-CTR\":\n    case \"AES-CBC\":\n    case \"AES-GCM\":\n    case \"AES-KW\":\n    case \"HMAC\":\n      return key[kKeyObject].export().buffer;\n  }\n  throw lazyDOMException(`Unable to export a raw ${key.algorithm.name} ${key.type} key`, \"InvalidAccessError\");\n}\nasync function exportKeyJWK(key) {\n  const jwk = key[kKeyObject][kHandle].exportJwk({\n    key_ops: key.usages,\n    ext: key.extractable\n  }, true);\n  switch (key.algorithm.name) {\n    case \"RSASSA-PKCS1-v1_5\":\n      jwk.alg = normalizeHashName(key.algorithm.hash.name, normalizeHashName.kContextJwkRsa);\n      return jwk;\n    case \"RSA-PSS\":\n      jwk.alg = normalizeHashName(key.algorithm.hash.name, normalizeHashName.kContextJwkRsaPss);\n      return jwk;\n    case \"RSA-OAEP\":\n      jwk.alg = normalizeHashName(key.algorithm.hash.name, normalizeHashName.kContextJwkRsaOaep);\n      return jwk;\n    case \"ECDSA\":\n    case \"ECDH\":\n      jwk.crv ||= key.algorithm.namedCurve;\n      return jwk;\n    case \"AES-CTR\":\n    case \"AES-CBC\":\n    case \"AES-GCM\":\n    case \"AES-KW\":\n      jwk.alg = lazyRequire(\"internal/crypto/aes\").getAlgorithmName(key.algorithm.name, key.algorithm.length);\n      return jwk;\n    case \"HMAC\":\n      jwk.alg = normalizeHashName(key.algorithm.hash.name, normalizeHashName.kContextJwkHmac);\n      return jwk;\n    case \"NODE-DSA\":\n      jwk.alg = normalizeHashName(key.algorithm.hash.name, normalizeHashName.kContextJwkDsa);\n      return jwk;\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n      return jwk;\n    default:\n  }\n  throw lazyDOMException(\"Not yet supported\", \"NotSupportedError\");\n}\nasync function exportKey(format, key) {\n  validateString(format, \"format\");\n  validateOneOf(format, \"format\", kExportFormats);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE(\"key\", \"CryptoKey\", key);\n  if (!key.extractable)\n    throw lazyDOMException(\"key is not extractable\", \"InvalidAccessException\");\n  switch (format) {\n    case \"node.keyObject\":\n      return key[kKeyObject];\n    case \"spki\":\n      return exportKeySpki(key);\n    case \"pkcs8\":\n      return exportKeyPkcs8(key);\n    case \"jwk\":\n      return exportKeyJWK(key);\n    case \"raw\":\n      return exportKeyRaw(key);\n  }\n  throw lazyDOMException(\"Export format is unsupported\", \"NotSupportedError\");\n}\nasync function importGenericSecretKey({ name, length }, format, keyData, extractable, keyUsages) {\n  const usagesSet = new SafeSet(keyUsages);\n  if (extractable)\n    throw lazyDOMException(`${name} keys are not extractable`, \"SyntaxError\");\n  if (hasAnyNotIn(usagesSet, [\"deriveKey\", \"deriveBits\"])) {\n    throw lazyDOMException(`Unsupported key usage for a ${name} key`, \"SyntaxError\");\n  }\n  switch (format) {\n    case \"node.keyObject\": {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE(\"keyData\", \"KeyObject\", keyData);\n      if (keyData.type === \"secret\")\n        return new InternalCryptoKey(keyData, { name }, keyUsages, extractable);\n      break;\n    }\n    case \"raw\":\n      if (hasAnyNotIn(usagesSet, [\"deriveKey\", \"deriveBits\"])) {\n        throw lazyDOMException(`Unsupported key usage for a ${name} key`, \"SyntaxError\");\n      }\n      const checkLength = keyData.byteLength * 8;\n      if (checkLength === 0 || length === 0)\n        throw lazyDOMException(\"Zero-length key is not supported\", \"DataError\");\n      if (length !== void 0 && length !== checkLength) {\n        throw lazyDOMException(\"Invalid key length\", \"DataError\");\n      }\n      const keyObject = createSecretKey(keyData);\n      return new InternalCryptoKey(keyObject, { name }, keyUsages, false);\n  }\n  throw lazyDOMException(`Unable to import ${name} key with format ${format}`, \"NotSupportedError\");\n}\nasync function importKey(format, keyData, algorithm, extractable, keyUsages) {\n  validateString(format, \"format\");\n  validateOneOf(format, \"format\", kExportFormats);\n  if (format !== \"node.keyObject\" && format !== \"jwk\")\n    keyData = getArrayBufferOrView(keyData, \"keyData\");\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable, \"extractable\");\n  validateArray(keyUsages, \"keyUsages\");\n  switch (algorithm.name) {\n    case \"RSASSA-PKCS1-v1_5\":\n    case \"RSA-PSS\":\n    case \"RSA-OAEP\":\n      return lazyRequire(\"internal/crypto/rsa\").rsaImportKey(format, keyData, algorithm, extractable, keyUsages);\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n    case \"ECDH\":\n      return lazyRequire(\"internal/crypto/ec\").ecImportKey(format, keyData, algorithm, extractable, keyUsages);\n    case \"HMAC\":\n      return lazyRequire(\"internal/crypto/mac\").hmacImportKey(format, keyData, algorithm, extractable, keyUsages);\n    case \"AES-CTR\":\n    case \"AES-CBC\":\n    case \"AES-GCM\":\n    case \"AES-KW\":\n      return lazyRequire(\"internal/crypto/aes\").aesImportKey(algorithm, format, keyData, extractable, keyUsages);\n    case \"HKDF\":\n    case \"NODE-SCRYPT\":\n    case \"PBKDF2\":\n      return importGenericSecretKey(algorithm, format, keyData, extractable, keyUsages);\n    case \"NODE-DSA\":\n      return lazyRequire(\"internal/crypto/dsa\").dsaImportKey(format, keyData, algorithm, extractable, keyUsages);\n    case \"NODE-DH\":\n      return lazyRequire(\"internal/crypto/diffiehellman\").dhImportKey(format, keyData, algorithm, extractable, keyUsages);\n  }\n  throw lazyDOMException(\"Unrecognized name.\", \"NotSupportedError\");\n}\nasync function wrapKey(format, key, wrappingKey, algorithm) {\n  algorithm = normalizeAlgorithm(algorithm);\n  let keyData = await exportKey(format, key);\n  if (format === \"jwk\") {\n    if (keyData == null || typeof keyData !== \"object\")\n      throw lazyDOMException(\"Invalid exported JWK key\", \"DataError\");\n    const ec = new TextEncoder();\n    const raw = JSONStringify(keyData);\n    keyData = ec.encode(raw + StringPrototypeRepeat(\" \", 8 - raw.length % 8));\n  }\n  return cipherOrWrap(kWebCryptoCipherEncrypt, algorithm, wrappingKey, keyData, \"wrapKey\");\n}\nasync function unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgo, unwrappedKeyAlgo, extractable, keyUsages) {\n  wrappedKey = getArrayBufferOrView(wrappedKey, \"wrappedKey\");\n  let keyData = await cipherOrWrap(kWebCryptoCipherDecrypt, normalizeAlgorithm(unwrapAlgo), unwrappingKey, wrappedKey, \"unwrapKey\");\n  if (format === \"jwk\") {\n    const options = process.versions.icu !== void 0 ? { fatal: true } : void 0;\n    const dec = new TextDecoder(\"utf-8\", options);\n    try {\n      keyData = JSONParse(dec.decode(keyData));\n    } catch {\n      throw lazyDOMException(\"Invalid imported JWK key\", \"DataError\");\n    }\n  }\n  return importKey(format, keyData, unwrappedKeyAlgo, extractable, keyUsages);\n}\nfunction signVerify(algorithm, key, data, signature) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE(\"key\", \"CryptoKey\", key);\n  data = getArrayBufferOrView(data, \"data\");\n  let usage = \"sign\";\n  if (signature !== void 0) {\n    signature = getArrayBufferOrView(signature, \"signature\");\n    usage = \"verify\";\n  }\n  if (!ArrayPrototypeIncludes(key.usages, usage) || algorithm.name !== key.algorithm.name) {\n    throw lazyDOMException(`Unable to use this key to ${usage}`, \"InvalidAccessError\");\n  }\n  switch (algorithm.name) {\n    case \"RSA-PSS\":\n    case \"RSASSA-PKCS1-v1_5\":\n      return lazyRequire(\"internal/crypto/rsa\").rsaSignVerify(key, data, algorithm, signature);\n    case \"NODE-ED25519\":\n    case \"NODE-ED448\":\n    case \"ECDSA\":\n      return lazyRequire(\"internal/crypto/ec\").ecdsaSignVerify(key, data, algorithm, signature);\n    case \"HMAC\":\n      return lazyRequire(\"internal/crypto/mac\").hmacSignVerify(key, data, algorithm, signature);\n    case \"NODE-DSA\":\n      return lazyRequire(\"internal/crypto/dsa\").dsaSignVerify(key, data, algorithm, signature);\n  }\n  throw lazyDOMException(\"Unrecognized named.\", \"NotSupportedError\");\n}\nasync function sign(algorithm, key, data) {\n  return signVerify(algorithm, key, data);\n}\nasync function verify(algorithm, key, signature, data) {\n  return signVerify(algorithm, key, data, signature);\n}\nasync function cipherOrWrap(mode, algorithm, key, data, op) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE(\"key\", \"CryptoKey\", key);\n  if (key.algorithm.name !== algorithm.name || !ArrayPrototypeIncludes(key.usages, op)) {\n    throw lazyDOMException(\"The requested operation is not valid for the provided key\", \"InvalidAccessError\");\n  }\n  data = getArrayBufferOrView(data, \"data\");\n  validateMaxBufferLength(data, \"data\");\n  switch (algorithm.name) {\n    case \"RSA-OAEP\":\n      return lazyRequire(\"internal/crypto/rsa\").rsaCipher(mode, key, data, algorithm);\n    case \"AES-CTR\":\n    case \"AES-CBC\":\n    case \"AES-GCM\":\n      return lazyRequire(\"internal/crypto/aes\").aesCipher(mode, key, data, algorithm);\n    case \"AES-KW\":\n      if (op === \"wrapKey\" || op === \"unwrapKey\") {\n        return lazyRequire(\"internal/crypto/aes\").aesCipher(mode, key, data, algorithm);\n      }\n  }\n  throw lazyDOMException(\"Unrecognized name.\", \"NotSupportedError\");\n}\nasync function encrypt(algorithm, key, data) {\n  return cipherOrWrap(kWebCryptoCipherEncrypt, algorithm, key, data, \"encrypt\");\n}\nasync function decrypt(algorithm, key, data) {\n  return cipherOrWrap(kWebCryptoCipherDecrypt, algorithm, key, data, \"decrypt\");\n}\nclass SubtleCrypto {\n}\nconst subtle = new SubtleCrypto();\nclass Crypto {\n}\nconst crypto = new Crypto();\nObjectDefineProperties(Crypto.prototype, {\n  [SymbolToStringTag]: {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: \"Crypto\"\n  },\n  subtle: {\n    enumerable: true,\n    configurable: false,\n    value: subtle\n  },\n  getRandomValues: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: getRandomValues\n  },\n  randomUUID: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: randomUUID\n  },\n  CryptoKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: CryptoKey\n  }\n});\nObjectDefineProperties(SubtleCrypto.prototype, {\n  [SymbolToStringTag]: {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: \"SubtleCrypto\"\n  },\n  encrypt: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: encrypt\n  },\n  decrypt: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: decrypt\n  },\n  sign: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: sign\n  },\n  verify: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: verify\n  },\n  digest: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: asyncDigest\n  },\n  generateKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: generateKey\n  },\n  deriveKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: deriveKey\n  },\n  deriveBits: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: deriveBits\n  },\n  importKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: importKey\n  },\n  exportKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: exportKey\n  },\n  wrapKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: wrapKey\n  },\n  unwrapKey: {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: unwrapKey\n  }\n});\nmodule.exports = {\n  Crypto,\n  SubtleCrypto,\n  crypto\n};\n}"],["internal/crypto/x509.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  SafeMap,\n  Symbol\n} = primordials;\nconst {\n  parseX509,\n  X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT,\n  X509_CHECK_FLAG_NEVER_CHECK_SUBJECT,\n  X509_CHECK_FLAG_NO_WILDCARDS,\n  X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS,\n  X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS,\n  X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS\n} = internalBinding(\"crypto\");\nconst {\n  PublicKeyObject,\n  isKeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  validateBoolean,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  JSTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nconst {\n  kHandle\n} = require(\"internal/crypto/util\");\nconst kInternalState = Symbol(\"kInternalState\");\nfunction isX509Certificate(value) {\n  return value[kInternalState] !== void 0;\n}\nfunction getFlags(options = {}) {\n  validateObject(options, \"options\");\n  const {\n    subject = \"always\",\n    wildcards = true,\n    partialWildcards = true,\n    multiLabelWildcards = false,\n    singleLabelSubdomains = false\n  } = { ...options };\n  let flags = 0;\n  validateString(subject, \"options.subject\");\n  validateBoolean(wildcards, \"options.wildcards\");\n  validateBoolean(partialWildcards, \"options.partialWildcards\");\n  validateBoolean(multiLabelWildcards, \"options.multiLabelWildcards\");\n  validateBoolean(singleLabelSubdomains, \"options.singleLabelSubdomains\");\n  switch (subject) {\n    case \"always\":\n      flags |= X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT;\n      break;\n    case \"never\":\n      flags |= X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\"options.subject\", subject);\n  }\n  if (!wildcards)\n    flags |= X509_CHECK_FLAG_NO_WILDCARDS;\n  if (!partialWildcards)\n    flags |= X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\n  if (multiLabelWildcards)\n    flags |= X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;\n  if (singleLabelSubdomains)\n    flags |= X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;\n  return flags;\n}\nclass InternalX509Certificate extends JSTransferable {\n  [kInternalState] = new SafeMap();\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\nclass X509Certificate extends JSTransferable {\n  [kInternalState] = new SafeMap();\n  constructor(buffer) {\n    if (typeof buffer === \"string\")\n      buffer = Buffer.from(buffer);\n    if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE(\"buffer\", [\"string\", \"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n    }\n    super();\n    this[kHandle] = parseX509(buffer);\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `X509Certificate ${inspect({\n      subject: this.subject,\n      subjectAltName: this.subjectAltName,\n      issuer: this.issuer,\n      infoAccess: this.infoAccess,\n      validFrom: this.validFrom,\n      validTo: this.validTo,\n      fingerprint: this.fingerprint,\n      fingerprint256: this.fingerprint256,\n      keyUsage: this.keyUsage,\n      serialNumber: this.serialNumber\n    }, opts)}`;\n  }\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/crypto/x509:InternalX509Certificate\"\n    };\n  }\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n  }\n  get subject() {\n    let value = this[kInternalState].get(\"subject\");\n    if (value === void 0) {\n      value = this[kHandle].subject();\n      this[kInternalState].set(\"subject\", value);\n    }\n    return value;\n  }\n  get subjectAltName() {\n    let value = this[kInternalState].get(\"subjectAltName\");\n    if (value === void 0) {\n      value = this[kHandle].subjectAltName();\n      this[kInternalState].set(\"subjectAltName\", value);\n    }\n    return value;\n  }\n  get issuer() {\n    let value = this[kInternalState].get(\"issuer\");\n    if (value === void 0) {\n      value = this[kHandle].issuer();\n      this[kInternalState].set(\"issuer\", value);\n    }\n    return value;\n  }\n  get issuerCertificate() {\n    let value = this[kInternalState].get(\"issuerCertificate\");\n    if (value === void 0) {\n      const cert = this[kHandle].getIssuerCert();\n      if (cert)\n        value = new InternalX509Certificate(this[kHandle].getIssuerCert());\n      this[kInternalState].set(\"issuerCertificate\", value);\n    }\n    return value;\n  }\n  get infoAccess() {\n    let value = this[kInternalState].get(\"infoAccess\");\n    if (value === void 0) {\n      value = this[kHandle].infoAccess();\n      this[kInternalState].set(\"infoAccess\", value);\n    }\n    return value;\n  }\n  get validFrom() {\n    let value = this[kInternalState].get(\"validFrom\");\n    if (value === void 0) {\n      value = this[kHandle].validFrom();\n      this[kInternalState].set(\"validFrom\", value);\n    }\n    return value;\n  }\n  get validTo() {\n    let value = this[kInternalState].get(\"validTo\");\n    if (value === void 0) {\n      value = this[kHandle].validTo();\n      this[kInternalState].set(\"validTo\", value);\n    }\n    return value;\n  }\n  get fingerprint() {\n    let value = this[kInternalState].get(\"fingerprint\");\n    if (value === void 0) {\n      value = this[kHandle].fingerprint();\n      this[kInternalState].set(\"fingerprint\", value);\n    }\n    return value;\n  }\n  get fingerprint256() {\n    let value = this[kInternalState].get(\"fingerprint256\");\n    if (value === void 0) {\n      value = this[kHandle].fingerprint256();\n      this[kInternalState].set(\"fingerprint256\", value);\n    }\n    return value;\n  }\n  get keyUsage() {\n    let value = this[kInternalState].get(\"keyUsage\");\n    if (value === void 0) {\n      value = this[kHandle].keyUsage();\n      this[kInternalState].set(\"keyUsage\", value);\n    }\n    return value;\n  }\n  get serialNumber() {\n    let value = this[kInternalState].get(\"serialNumber\");\n    if (value === void 0) {\n      value = this[kHandle].serialNumber();\n      this[kInternalState].set(\"serialNumber\", value);\n    }\n    return value;\n  }\n  get raw() {\n    let value = this[kInternalState].get(\"raw\");\n    if (value === void 0) {\n      value = this[kHandle].raw();\n      this[kInternalState].set(\"raw\", value);\n    }\n    return value;\n  }\n  get publicKey() {\n    let value = this[kInternalState].get(\"publicKey\");\n    if (value === void 0) {\n      value = new PublicKeyObject(this[kHandle].publicKey());\n      this[kInternalState].set(\"publicKey\", value);\n    }\n    return value;\n  }\n  toString() {\n    let value = this[kInternalState].get(\"pem\");\n    if (value === void 0) {\n      value = this[kHandle].pem();\n      this[kInternalState].set(\"pem\", value);\n    }\n    return value;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  get ca() {\n    let value = this[kInternalState].get(\"ca\");\n    if (value === void 0) {\n      value = this[kHandle].checkCA();\n      this[kInternalState].set(\"ca\", value);\n    }\n    return value;\n  }\n  checkHost(name, options) {\n    validateString(name, \"name\");\n    return this[kHandle].checkHost(name, getFlags(options));\n  }\n  checkEmail(email, options) {\n    validateString(email, \"email\");\n    return this[kHandle].checkEmail(email, getFlags(options));\n  }\n  checkIP(ip, options) {\n    validateString(ip, \"ip\");\n    return this[kHandle].checkIP(ip, getFlags(options));\n  }\n  checkIssued(otherCert) {\n    if (!isX509Certificate(otherCert))\n      throw new ERR_INVALID_ARG_TYPE(\"otherCert\", \"X509Certificate\", otherCert);\n    return this[kHandle].checkIssued(otherCert[kHandle]);\n  }\n  checkPrivateKey(pkey) {\n    if (!isKeyObject(pkey))\n      throw new ERR_INVALID_ARG_TYPE(\"pkey\", \"KeyObject\", pkey);\n    if (pkey.type !== \"private\")\n      throw new ERR_INVALID_ARG_VALUE(\"pkey\", pkey);\n    return this[kHandle].checkPrivateKey(pkey[kHandle]);\n  }\n  verify(pkey) {\n    if (!isKeyObject(pkey))\n      throw new ERR_INVALID_ARG_TYPE(\"pkey\", \"KeyObject\", pkey);\n    if (pkey.type !== \"public\")\n      throw new ERR_INVALID_ARG_VALUE(\"pkey\", pkey);\n    return this[kHandle].verify(pkey[kHandle]);\n  }\n  toLegacyObject() {\n    return this[kHandle].toLegacy();\n  }\n}\nInternalX509Certificate.prototype.constructor = X509Certificate;\nObjectSetPrototypeOf(InternalX509Certificate.prototype, X509Certificate.prototype);\nmodule.exports = {\n  X509Certificate,\n  InternalX509Certificate,\n  isX509Certificate\n};\n}"],["internal/debugger/inspect.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeConcat,\n  ArrayPrototypeForEach,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  FunctionPrototypeBind,\n  Number,\n  Promise,\n  PromisePrototypeCatch,\n  PromisePrototypeThen,\n  PromiseResolve,\n  Proxy,\n  RegExpPrototypeSymbolMatch,\n  RegExpPrototypeSymbolSplit,\n  RegExpPrototypeTest,\n  StringPrototypeEndsWith,\n  StringPrototypeSplit\n} = primordials;\nconst { spawn } = require(\"child_process\");\nconst { EventEmitter } = require(\"events\");\nconst net = require(\"net\");\nconst util = require(\"util\");\nconst {\n  setInterval: pSetInterval,\n  setTimeout: pSetTimeout\n} = require(\"timers/promises\");\nconst {\n  AbortController\n} = require(\"internal/abort_controller\");\nconst console = require(\"internal/console/global\");\nconst { 0: InspectClient, 1: createRepl } = [\n  require(\"internal/debugger/inspect_client\"),\n  require(\"internal/debugger/inspect_repl\")\n];\nconst debuglog = util.debuglog(\"inspect\");\nconst { ERR_DEBUGGER_STARTUP_ERROR } = require(\"internal/errors\").codes;\nasync function portIsFree(host, port, timeout = 9999) {\n  if (port === 0)\n    return;\n  const retryDelay = 150;\n  const ac = new AbortController();\n  const { signal } = ac;\n  pSetTimeout(timeout).then(() => ac.abort());\n  const asyncIterator = pSetInterval(retryDelay);\n  while (true) {\n    await asyncIterator.next();\n    if (signal.aborted) {\n      throw new ERR_DEBUGGER_STARTUP_ERROR(`Timeout (${timeout}) waiting for ${host}:${port} to be free`);\n    }\n    const error = await new Promise((resolve) => {\n      const socket = net.connect(port, host);\n      socket.on(\"error\", resolve);\n      socket.on(\"connect\", resolve);\n    });\n    if (error?.code === \"ECONNREFUSED\") {\n      return;\n    }\n  }\n}\nconst debugRegex = /Debugger listening on ws:\\/\\/\\[?(.+?)\\]?:(\\d+)\\//;\nasync function runScript(script, scriptArgs, inspectHost, inspectPort, childPrint) {\n  await portIsFree(inspectHost, inspectPort);\n  const args = ArrayPrototypeConcat([`--inspect-brk=${inspectPort}`, script], scriptArgs);\n  const child = spawn(process.execPath, args);\n  child.stdout.setEncoding(\"utf8\");\n  child.stderr.setEncoding(\"utf8\");\n  child.stdout.on(\"data\", (chunk) => childPrint(chunk, \"stdout\"));\n  child.stderr.on(\"data\", (chunk) => childPrint(chunk, \"stderr\"));\n  let output = \"\";\n  return new Promise((resolve) => {\n    function waitForListenHint(text) {\n      output += text;\n      const debug = RegExpPrototypeSymbolMatch(debugRegex, output);\n      if (debug) {\n        const host = debug[1];\n        const port = Number(debug[2]);\n        child.stderr.removeListener(\"data\", waitForListenHint);\n        resolve([child, port, host]);\n      }\n    }\n    child.stderr.on(\"data\", waitForListenHint);\n  });\n}\nfunction createAgentProxy(domain, client) {\n  const agent = new EventEmitter();\n  agent.then = (then, _catch) => {\n    const descriptor = {\n      [util.inspect.custom](depth, { stylize }) {\n        return stylize(`[Agent ${domain}]`, \"special\");\n      }\n    };\n    return PromisePrototypeThen(PromiseResolve(descriptor), then, _catch);\n  };\n  return new Proxy(agent, {\n    get(target, name) {\n      if (name in target)\n        return target[name];\n      return function callVirtualMethod(params) {\n        return client.callMethod(`${domain}.${name}`, params);\n      };\n    }\n  });\n}\nclass NodeInspector {\n  constructor(options, stdin, stdout) {\n    this.options = options;\n    this.stdin = stdin;\n    this.stdout = stdout;\n    this.paused = true;\n    this.child = null;\n    if (options.script) {\n      this._runScript = FunctionPrototypeBind(runScript, null, options.script, options.scriptArgs, options.host, options.port, FunctionPrototypeBind(this.childPrint, this));\n    } else {\n      this._runScript = () => PromiseResolve([null, options.port, options.host]);\n    }\n    this.client = new InspectClient();\n    this.domainNames = [\"Debugger\", \"HeapProfiler\", \"Profiler\", \"Runtime\"];\n    ArrayPrototypeForEach(this.domainNames, (domain) => {\n      this[domain] = createAgentProxy(domain, this.client);\n    });\n    this.handleDebugEvent = (fullName, params) => {\n      const { 0: domain, 1: name } = StringPrototypeSplit(fullName, \".\");\n      if (domain in this) {\n        this[domain].emit(name, params);\n      }\n    };\n    this.client.on(\"debugEvent\", this.handleDebugEvent);\n    const startRepl = createRepl(this);\n    process.on(\"exit\", () => this.killChild());\n    const exitCodeZero = () => process.exit(0);\n    process.once(\"SIGTERM\", exitCodeZero);\n    process.once(\"SIGHUP\", exitCodeZero);\n    PromisePrototypeCatch(PromisePrototypeThen(this.run(), async () => {\n      const repl = await startRepl();\n      this.repl = repl;\n      this.repl.on(\"exit\", exitCodeZero);\n      this.paused = false;\n    }), (error) => process.nextTick(() => {\n      throw error;\n    }));\n  }\n  suspendReplWhile(fn) {\n    if (this.repl) {\n      this.repl.pause();\n    }\n    this.stdin.pause();\n    this.paused = true;\n    return PromisePrototypeCatch(PromisePrototypeThen(new Promise((resolve) => {\n      resolve(fn());\n    }), () => {\n      this.paused = false;\n      if (this.repl) {\n        this.repl.resume();\n        this.repl.displayPrompt();\n      }\n      this.stdin.resume();\n    }), (error) => process.nextTick(() => {\n      throw error;\n    }));\n  }\n  killChild() {\n    this.client.reset();\n    if (this.child) {\n      this.child.kill();\n      this.child = null;\n    }\n  }\n  async run() {\n    this.killChild();\n    const { 0: child, 1: port, 2: host } = await this._runScript();\n    this.child = child;\n    this.print(`connecting to ${host}:${port} ..`, false);\n    for (let attempt = 0; attempt < 5; attempt++) {\n      debuglog(\"connection attempt #%d\", attempt);\n      this.stdout.write(\".\");\n      try {\n        await this.client.connect(port, host);\n        debuglog(\"connection established\");\n        this.stdout.write(\" ok\\n\");\n        return;\n      } catch (error) {\n        debuglog(\"connect failed\", error);\n        await pSetTimeout(1e3);\n      }\n    }\n    this.stdout.write(\" failed to connect, please retry\\n\");\n    process.exit(1);\n  }\n  clearLine() {\n    if (this.stdout.isTTY) {\n      this.stdout.cursorTo(0);\n      this.stdout.clearLine(1);\n    } else {\n      this.stdout.write(\"\\b\");\n    }\n  }\n  print(text, appendNewline = false) {\n    this.clearLine();\n    this.stdout.write(appendNewline ? `${text}\n` : text);\n  }\n  #stdioBuffers = { stdout: \"\", stderr: \"\" };\n  childPrint(text, which) {\n    const lines = RegExpPrototypeSymbolSplit(/\\r\\n|\\r|\\n/g, this.#stdioBuffers[which] + text);\n    this.#stdioBuffers[which] = \"\";\n    if (lines[lines.length - 1] !== \"\") {\n      this.#stdioBuffers[which] = ArrayPrototypePop(lines);\n    }\n    const textToPrint = ArrayPrototypeJoin(ArrayPrototypeMap(lines, (chunk) => `< ${chunk}`), \"\\n\");\n    if (lines.length) {\n      this.print(textToPrint, true);\n      if (!this.paused) {\n        this.repl.displayPrompt(true);\n      }\n    }\n    if (StringPrototypeEndsWith(textToPrint, \"Waiting for the debugger to disconnect...\\n\")) {\n      this.killChild();\n    }\n  }\n}\nfunction parseArgv(args) {\n  const target = ArrayPrototypeShift(args);\n  let host = \"127.0.0.1\";\n  let port = 9229;\n  let isRemote = false;\n  let script = target;\n  let scriptArgs = args;\n  const hostMatch = RegExpPrototypeSymbolMatch(/^([^:]+):(\\d+)$/, target);\n  const portMatch = RegExpPrototypeSymbolMatch(/^--port=(\\d+)$/, target);\n  if (hostMatch) {\n    host = hostMatch[1];\n    port = Number(hostMatch[2]);\n    isRemote = true;\n    script = null;\n  } else if (portMatch) {\n    port = Number(portMatch[1]);\n    script = args[0];\n    scriptArgs = ArrayPrototypeSlice(args, 1);\n  } else if (args.length === 1 && RegExpPrototypeTest(/^\\d+$/, args[0]) && target === \"-p\") {\n    const pid = Number(args[0]);\n    try {\n      process._debugProcess(pid);\n    } catch (e) {\n      if (e.code === \"ESRCH\") {\n        console.error(`Target process: ${pid} doesn't exist.`);\n        process.exit(1);\n      }\n      throw e;\n    }\n    script = null;\n    isRemote = true;\n  }\n  return {\n    host,\n    port,\n    isRemote,\n    script,\n    scriptArgs\n  };\n}\nfunction startInspect(argv = ArrayPrototypeSlice(process.argv, 2), stdin = process.stdin, stdout = process.stdout) {\n  if (argv.length < 1) {\n    const invokedAs = `${process.argv0} ${process.argv[1]}`;\n    console.error(`Usage: ${invokedAs} script.js`);\n    console.error(`       ${invokedAs} <host>:<port>`);\n    console.error(`       ${invokedAs} --port=<port>`);\n    console.error(`       ${invokedAs} -p <pid>`);\n    process.exit(1);\n  }\n  const options = parseArgv(argv);\n  const inspector = new NodeInspector(options, stdin, stdout);\n  stdin.resume();\n  function handleUnexpectedError(e) {\n    if (e.code !== \"ERR_DEBUGGER_STARTUP_ERROR\") {\n      console.error(\"There was an internal error in Node.js. Please report this bug.\");\n      console.error(e.message);\n      console.error(e.stack);\n    } else {\n      console.error(e.message);\n    }\n    if (inspector.child)\n      inspector.child.kill();\n    process.exit(1);\n  }\n  process.on(\"uncaughtException\", handleUnexpectedError);\n}\nexports.start = startInspect;\n}"],["internal/debugger/inspect_client.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  JSONParse,\n  JSONStringify,\n  ObjectKeys,\n  Promise\n} = primordials;\nconst Buffer = require(\"buffer\").Buffer;\nconst crypto = require(\"crypto\");\nconst { ERR_DEBUGGER_ERROR } = require(\"internal/errors\").codes;\nconst { EventEmitter } = require(\"events\");\nconst http = require(\"http\");\nconst URL = require(\"url\");\nconst debuglog = require(\"internal/util/debuglog\").debuglog(\"inspect\");\nconst kOpCodeText = 1;\nconst kOpCodeClose = 8;\nconst kFinalBit = 128;\nconst kReserved1Bit = 64;\nconst kReserved2Bit = 32;\nconst kReserved3Bit = 16;\nconst kOpCodeMask = 15;\nconst kMaskBit = 128;\nconst kPayloadLengthMask = 127;\nconst kMaxSingleBytePayloadLength = 125;\nconst kMaxTwoBytePayloadLength = 65535;\nconst kTwoBytePayloadLengthField = 126;\nconst kEightBytePayloadLengthField = 127;\nconst kMaskingKeyWidthInBytes = 4;\nconst WEBSOCKET_HANDSHAKE_GUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\nfunction unpackError({ code, message }) {\n  const err = new ERR_DEBUGGER_ERROR(`${message}`);\n  err.code = code;\n  ErrorCaptureStackTrace(err, unpackError);\n  return err;\n}\nfunction validateHandshake(requestKey, responseKey) {\n  const expectedResponseKeyBase = requestKey + WEBSOCKET_HANDSHAKE_GUID;\n  const shasum = crypto.createHash(\"sha1\");\n  shasum.update(expectedResponseKeyBase);\n  const shabuf = shasum.digest();\n  if (shabuf.toString(\"base64\") !== responseKey) {\n    throw new ERR_DEBUGGER_ERROR(`WebSocket secret mismatch: ${requestKey} did not match ${responseKey}`);\n  }\n}\nfunction encodeFrameHybi17(payload) {\n  var i;\n  const dataLength = payload.length;\n  let singleByteLength;\n  let additionalLength;\n  if (dataLength > kMaxTwoBytePayloadLength) {\n    singleByteLength = kEightBytePayloadLengthField;\n    additionalLength = Buffer.alloc(8);\n    let remaining = dataLength;\n    for (i = 0; i < 8; ++i) {\n      additionalLength[7 - i] = remaining & 255;\n      remaining >>= 8;\n    }\n  } else if (dataLength > kMaxSingleBytePayloadLength) {\n    singleByteLength = kTwoBytePayloadLengthField;\n    additionalLength = Buffer.alloc(2);\n    additionalLength[0] = (dataLength & 65280) >> 8;\n    additionalLength[1] = dataLength & 255;\n  } else {\n    additionalLength = Buffer.alloc(0);\n    singleByteLength = dataLength;\n  }\n  const header = Buffer.from([\n    kFinalBit | kOpCodeText,\n    kMaskBit | singleByteLength\n  ]);\n  const mask = Buffer.alloc(4);\n  const masked = Buffer.alloc(dataLength);\n  for (i = 0; i < dataLength; ++i) {\n    masked[i] = payload[i] ^ mask[i % kMaskingKeyWidthInBytes];\n  }\n  return Buffer.concat([header, additionalLength, mask, masked]);\n}\nfunction decodeFrameHybi17(data) {\n  const dataAvailable = data.length;\n  const notComplete = { closed: false, payload: null, rest: data };\n  let payloadOffset = 2;\n  if (dataAvailable - payloadOffset < 0)\n    return notComplete;\n  const firstByte = data[0];\n  const secondByte = data[1];\n  const final = (firstByte & kFinalBit) !== 0;\n  const reserved1 = (firstByte & kReserved1Bit) !== 0;\n  const reserved2 = (firstByte & kReserved2Bit) !== 0;\n  const reserved3 = (firstByte & kReserved3Bit) !== 0;\n  const opCode = firstByte & kOpCodeMask;\n  const masked = (secondByte & kMaskBit) !== 0;\n  const compressed = reserved1;\n  if (compressed) {\n    throw new ERR_DEBUGGER_ERROR(\"Compressed frames not supported\");\n  }\n  if (!final || reserved2 || reserved3) {\n    throw new ERR_DEBUGGER_ERROR(\"Only compression extension is supported\");\n  }\n  if (masked) {\n    throw new ERR_DEBUGGER_ERROR(\"Masked server frame - not supported\");\n  }\n  let closed = false;\n  switch (opCode) {\n    case kOpCodeClose:\n      closed = true;\n      break;\n    case kOpCodeText:\n      break;\n    default:\n      throw new ERR_DEBUGGER_ERROR(`Unsupported op code ${opCode}`);\n  }\n  let payloadLength = secondByte & kPayloadLengthMask;\n  switch (payloadLength) {\n    case kTwoBytePayloadLengthField:\n      payloadOffset += 2;\n      payloadLength = (data[2] << 8) + data[3];\n      break;\n    case kEightBytePayloadLengthField:\n      payloadOffset += 8;\n      payloadLength = 0;\n      for (var i = 0; i < 8; ++i) {\n        payloadLength <<= 8;\n        payloadLength |= data[2 + i];\n      }\n      break;\n    default:\n  }\n  if (dataAvailable - payloadOffset - payloadLength < 0)\n    return notComplete;\n  const payloadEnd = payloadOffset + payloadLength;\n  return {\n    payload: data.slice(payloadOffset, payloadEnd),\n    rest: data.slice(payloadEnd),\n    closed\n  };\n}\nclass Client extends EventEmitter {\n  constructor() {\n    super();\n    this.handleChunk = FunctionPrototypeBind(this._handleChunk, this);\n    this._port = void 0;\n    this._host = void 0;\n    this.reset();\n  }\n  _handleChunk(chunk) {\n    this._unprocessed = Buffer.concat([this._unprocessed, chunk]);\n    while (this._unprocessed.length > 2) {\n      const {\n        closed,\n        payload: payloadBuffer,\n        rest\n      } = decodeFrameHybi17(this._unprocessed);\n      this._unprocessed = rest;\n      if (closed) {\n        this.reset();\n        return;\n      }\n      if (payloadBuffer === null || payloadBuffer.length === 0)\n        break;\n      const payloadStr = payloadBuffer.toString();\n      debuglog(\"< %s\", payloadStr);\n      const lastChar = payloadStr[payloadStr.length - 1];\n      if (payloadStr[0] !== \"{\" || lastChar !== \"}\") {\n        throw new ERR_DEBUGGER_ERROR(`Payload does not look like JSON: ${payloadStr}`);\n      }\n      let payload;\n      try {\n        payload = JSONParse(payloadStr);\n      } catch (parseError) {\n        parseError.string = payloadStr;\n        throw parseError;\n      }\n      const { id, method, params, result, error } = payload;\n      if (id) {\n        const handler = this._pending[id];\n        if (handler) {\n          delete this._pending[id];\n          handler(error, result);\n        }\n      } else if (method) {\n        this.emit(\"debugEvent\", method, params);\n        this.emit(method, params);\n      } else {\n        throw new ERR_DEBUGGER_ERROR(`Unsupported response: ${payloadStr}`);\n      }\n    }\n  }\n  reset() {\n    if (this._http) {\n      this._http.destroy();\n    }\n    if (this._socket) {\n      this._socket.destroy();\n    }\n    this._http = null;\n    this._lastId = 0;\n    this._socket = null;\n    this._pending = {};\n    this._unprocessed = Buffer.alloc(0);\n  }\n  callMethod(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this._socket) {\n        reject(new ERR_DEBUGGER_ERROR(\"Use `run` to start the app again.\"));\n        return;\n      }\n      const data = { id: ++this._lastId, method, params };\n      this._pending[data.id] = (error, result) => {\n        if (error)\n          reject(unpackError(error));\n        else\n          resolve(ObjectKeys(result).length ? result : void 0);\n      };\n      const json = JSONStringify(data);\n      debuglog(\"> %s\", json);\n      this._socket.write(encodeFrameHybi17(Buffer.from(json)));\n    });\n  }\n  _fetchJSON(urlPath) {\n    return new Promise((resolve, reject) => {\n      const httpReq = http.get({\n        host: this._host,\n        port: this._port,\n        path: urlPath\n      });\n      const chunks = [];\n      function onResponse(httpRes) {\n        function parseChunks() {\n          const resBody = Buffer.concat(chunks).toString();\n          if (httpRes.statusCode !== 200) {\n            reject(new ERR_DEBUGGER_ERROR(`Unexpected ${httpRes.statusCode}: ${resBody}`));\n            return;\n          }\n          try {\n            resolve(JSONParse(resBody));\n          } catch {\n            reject(new ERR_DEBUGGER_ERROR(`Response didn't contain JSON: ${resBody}`));\n          }\n        }\n        httpRes.on(\"error\", reject);\n        httpRes.on(\"data\", (chunk) => ArrayPrototypePush(chunks, chunk));\n        httpRes.on(\"end\", parseChunks);\n      }\n      httpReq.on(\"error\", reject);\n      httpReq.on(\"response\", onResponse);\n    });\n  }\n  async connect(port, host) {\n    this._port = port;\n    this._host = host;\n    const urlPath = await this._discoverWebsocketPath();\n    return this._connectWebsocket(urlPath);\n  }\n  async _discoverWebsocketPath() {\n    const { 0: { webSocketDebuggerUrl } } = await this._fetchJSON(\"/json\");\n    return URL.parse(webSocketDebuggerUrl).path;\n  }\n  _connectWebsocket(urlPath) {\n    this.reset();\n    const requestKey = crypto.randomBytes(16).toString(\"base64\");\n    debuglog(\"request WebSocket\", requestKey);\n    const httpReq = this._http = http.request({\n      host: this._host,\n      port: this._port,\n      path: urlPath,\n      headers: {\n        \"Connection\": \"Upgrade\",\n        \"Upgrade\": \"websocket\",\n        \"Sec-WebSocket-Key\": requestKey,\n        \"Sec-WebSocket-Version\": \"13\"\n      }\n    });\n    httpReq.on(\"error\", (e) => {\n      this.emit(\"error\", e);\n    });\n    httpReq.on(\"response\", (httpRes) => {\n      if (httpRes.statusCode >= 400) {\n        process.stderr.write(`Unexpected HTTP code: ${httpRes.statusCode}\n`);\n        httpRes.pipe(process.stderr);\n      } else {\n        httpRes.pipe(process.stderr);\n      }\n    });\n    const handshakeListener = (res, socket) => {\n      validateHandshake(requestKey, res.headers[\"sec-websocket-accept\"]);\n      debuglog(\"websocket upgrade\");\n      this._socket = socket;\n      socket.on(\"data\", this.handleChunk);\n      socket.on(\"close\", () => {\n        this.emit(\"close\");\n      });\n      this.emit(\"ready\");\n    };\n    return new Promise((resolve, reject) => {\n      this.once(\"error\", reject);\n      this.once(\"ready\", resolve);\n      httpReq.on(\"upgrade\", handshakeListener);\n      httpReq.end();\n    });\n  }\n}\nmodule.exports = Client;\n}"],["internal/debugger/inspect_repl.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayFrom,\n  ArrayPrototypeFilter,\n  ArrayPrototypeFind,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSome,\n  ArrayPrototypeSplice,\n  Date,\n  FunctionPrototypeCall,\n  JSONStringify,\n  MathMax,\n  ObjectAssign,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectValues,\n  Promise,\n  PromiseAll,\n  PromisePrototypeCatch,\n  PromisePrototypeThen,\n  PromiseResolve,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  RegExpPrototypeSymbolMatch,\n  RegExpPrototypeSymbolReplace,\n  SafeArrayIterator,\n  SafeMap,\n  String,\n  StringFromCharCode,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeRepeat,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeToUpperCase,\n  StringPrototypeTrim\n} = primordials;\nconst { ERR_DEBUGGER_ERROR } = require(\"internal/errors\").codes;\nconst { validateString } = require(\"internal/validators\");\nconst FS = require(\"fs\");\nconst Path = require(\"path\");\nconst Repl = require(\"repl\");\nconst vm = require(\"vm\");\nconst { fileURLToPath } = require(\"internal/url\");\nconst { customInspectSymbol } = require(\"internal/util\");\nconst { inspect: utilInspect } = require(\"internal/util/inspect\");\nconst debuglog = require(\"internal/util/debuglog\").debuglog(\"inspect\");\nconst SHORTCUTS = {\n  cont: \"c\",\n  next: \"n\",\n  step: \"s\",\n  out: \"o\",\n  backtrace: \"bt\",\n  setBreakpoint: \"sb\",\n  clearBreakpoint: \"cb\",\n  run: \"r\"\n};\nconst HELP = StringPrototypeTrim(`\nrun, restart, r       Run the application or reconnect\nkill                  Kill a running application or disconnect\n\ncont, c               Resume execution\nnext, n               Continue to next line in current file\nstep, s               Step into, potentially entering a function\nout, o                Step out, leaving the current function\nbacktrace, bt         Print the current backtrace\nlist                  Print the source around the current line where execution\n                      is currently paused\n\nsetBreakpoint, sb     Set a breakpoint\nclearBreakpoint, cb   Clear a breakpoint\nbreakpoints           List all known breakpoints\nbreakOnException      Pause execution whenever an exception is thrown\nbreakOnUncaught       Pause execution whenever an exception isn't caught\nbreakOnNone           Don't pause on exceptions (this is the default)\n\nwatch(expr)           Start watching the given expression\nunwatch(expr)         Stop watching an expression\nwatchers              Print all watched expressions and their current values\n\nexec(expr)            Evaluate the expression and print the value\nrepl                  Enter a debug repl that works like exec\n\nscripts               List application scripts that are currently loaded\nscripts(true)         List all scripts (including node-internals)\n\nprofile               Start CPU profiling session.\nprofileEnd            Stop current CPU profiling session.\nprofiles              Array of completed CPU profiling sessions.\nprofiles[n].save(filepath = 'node.cpuprofile')\n                      Save CPU profiling session to disk as JSON.\n\ntakeHeapSnapshot(filepath = 'node.heapsnapshot')\n                      Take a heap snapshot and save to disk as JSON.\n`);\nconst FUNCTION_NAME_PATTERN = /^(?:function\\*? )?([^(\\s]+)\\(/;\nfunction extractFunctionName(description) {\n  const fnNameMatch = RegExpPrototypeSymbolMatch(FUNCTION_NAME_PATTERN, description);\n  return fnNameMatch ? `: ${fnNameMatch[1]}` : \"\";\n}\nconst {\n  moduleIds: PUBLIC_BUILTINS\n} = internalBinding(\"native_module\");\nconst NATIVES = internalBinding(\"natives\");\nfunction isNativeUrl(url) {\n  url = RegExpPrototypeSymbolReplace(/\\.js$/, url, \"\");\n  return StringPrototypeStartsWith(url, \"node:internal/\") || ArrayPrototypeIncludes(PUBLIC_BUILTINS, url) || url in NATIVES || url === \"bootstrap_node\";\n}\nfunction getRelativePath(filenameOrURL) {\n  const dir = StringPrototypeSlice(Path.join(Path.resolve(), \"x\"), 0, -1);\n  const filename = StringPrototypeStartsWith(filenameOrURL, \"file://\") ? fileURLToPath(filenameOrURL) : filenameOrURL;\n  if (StringPrototypeStartsWith(filename, dir)) {\n    return StringPrototypeSlice(filename, dir.length);\n  }\n  return filename;\n}\nfunction leftPad(n, prefix, maxN) {\n  const s = n.toString();\n  const nchars = MathMax(2, String(maxN).length);\n  const nspaces = nchars - s.length;\n  return prefix + StringPrototypeRepeat(\" \", nspaces) + s;\n}\nfunction markSourceColumn(sourceText, position, useColors) {\n  if (!sourceText)\n    return \"\";\n  const head = StringPrototypeSlice(sourceText, 0, position);\n  let tail = StringPrototypeSlice(sourceText, position);\n  if (useColors) {\n    tail = RegExpPrototypeSymbolReplace(/(.+?)([^\\w]|$)/, tail, \"\u001b[32m$1\u001b[39m$2\");\n  }\n  return head + tail;\n}\nfunction extractErrorMessage(stack) {\n  if (!stack)\n    return \"<unknown>\";\n  const m = RegExpPrototypeSymbolMatch(/^\\w+: ([^\\n]+)/, stack);\n  return m?.[1] ?? stack;\n}\nfunction convertResultToError(result) {\n  const { className, description } = result;\n  const err = new ERR_DEBUGGER_ERROR(extractErrorMessage(description));\n  err.stack = description;\n  ObjectDefineProperty(err, \"name\", { value: className });\n  return err;\n}\nclass RemoteObject {\n  constructor(attributes) {\n    ObjectAssign(this, attributes);\n    if (this.type === \"number\") {\n      this.value = this.unserializableValue ? +this.unserializableValue : +this.value;\n    }\n  }\n  [customInspectSymbol](depth, opts) {\n    function formatProperty(prop) {\n      switch (prop.type) {\n        case \"string\":\n        case \"undefined\":\n          return utilInspect(prop.value, opts);\n        case \"number\":\n        case \"boolean\":\n          return opts.stylize(prop.value, prop.type);\n        case \"object\":\n        case \"symbol\":\n          if (prop.subtype === \"date\") {\n            return utilInspect(new Date(prop.value), opts);\n          }\n          if (prop.subtype === \"array\") {\n            return opts.stylize(prop.value, \"special\");\n          }\n          return opts.stylize(prop.value, prop.subtype || \"special\");\n        default:\n          return prop.value;\n      }\n    }\n    switch (this.type) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n      case \"undefined\":\n        return utilInspect(this.value, opts);\n      case \"symbol\":\n        return opts.stylize(this.description, \"special\");\n      case \"function\": {\n        const fnName = extractFunctionName(this.description);\n        const formatted = `[${this.className}${fnName}]`;\n        return opts.stylize(formatted, \"special\");\n      }\n      case \"object\":\n        switch (this.subtype) {\n          case \"date\":\n            return utilInspect(new Date(this.description), opts);\n          case \"null\":\n            return utilInspect(null, opts);\n          case \"regexp\":\n            return opts.stylize(this.description, \"regexp\");\n          default:\n            break;\n        }\n        if (this.preview) {\n          const props = ArrayPrototypeMap(this.preview.properties, (prop, idx) => {\n            const value = formatProperty(prop);\n            if (prop.name === `${idx}`)\n              return value;\n            return `${prop.name}: ${value}`;\n          });\n          if (this.preview.overflow) {\n            ArrayPrototypePush(props, \"...\");\n          }\n          const singleLine = ArrayPrototypeJoin(props, \", \");\n          const propString = singleLine.length > 60 ? ArrayPrototypeJoin(props, \",\\n  \") : singleLine;\n          return this.subtype === \"array\" ? `[ ${propString} ]` : `{ ${propString} }`;\n        }\n        return this.description;\n      default:\n        return this.description;\n    }\n  }\n  static fromEvalResult({ result, wasThrown }) {\n    if (wasThrown)\n      return convertResultToError(result);\n    return new RemoteObject(result);\n  }\n}\nclass ScopeSnapshot {\n  constructor(scope, properties) {\n    ObjectAssign(this, scope);\n    this.properties = new SafeMap();\n    this.completionGroup = ArrayPrototypeMap(properties, (prop) => {\n      const value = new RemoteObject(prop.value);\n      this.properties.set(prop.name, value);\n      return prop.name;\n    });\n  }\n  [customInspectSymbol](depth, opts) {\n    const type = StringPrototypeToUpperCase(this.type[0]) + StringPrototypeSlice(this.type, 1);\n    const name = this.name ? `<${this.name}>` : \"\";\n    const prefix = `${type}${name} `;\n    return RegExpPrototypeSymbolReplace(/^Map /, utilInspect(this.properties, opts), prefix);\n  }\n}\nfunction copyOwnProperties(target, source) {\n  ArrayPrototypeForEach(ReflectOwnKeys(source), (prop) => {\n    const desc = ReflectGetOwnPropertyDescriptor(source, prop);\n    ObjectDefineProperty(target, prop, desc);\n  });\n}\nfunction aliasProperties(target, mapping) {\n  ArrayPrototypeForEach(ObjectKeys(mapping), (key) => {\n    const desc = ReflectGetOwnPropertyDescriptor(target, key);\n    ObjectDefineProperty(target, mapping[key], desc);\n  });\n}\nfunction createRepl(inspector) {\n  const { Debugger, HeapProfiler, Profiler, Runtime } = inspector;\n  let repl;\n  const history = { control: [], debug: [] };\n  const watchedExpressions = [];\n  const knownBreakpoints = [];\n  let heapSnapshotPromise = null;\n  let pauseOnExceptionState = \"none\";\n  let lastCommand;\n  let knownScripts;\n  let currentBacktrace;\n  let selectedFrame;\n  let exitDebugRepl;\n  function resetOnStart() {\n    knownScripts = {};\n    currentBacktrace = null;\n    selectedFrame = null;\n    if (exitDebugRepl)\n      exitDebugRepl();\n    exitDebugRepl = null;\n  }\n  resetOnStart();\n  const INSPECT_OPTIONS = { colors: inspector.stdout.isTTY };\n  function inspect(value) {\n    return utilInspect(value, INSPECT_OPTIONS);\n  }\n  function print(value, addNewline = true) {\n    const text = typeof value === \"string\" ? value : inspect(value);\n    return inspector.print(text, addNewline);\n  }\n  function getCurrentLocation() {\n    if (!selectedFrame) {\n      throw new ERR_DEBUGGER_ERROR(\"Requires execution to be paused\");\n    }\n    return selectedFrame.location;\n  }\n  function isCurrentScript(script) {\n    return selectedFrame && getCurrentLocation().scriptId === script.scriptId;\n  }\n  function formatScripts(displayNatives = false) {\n    function isVisible(script) {\n      if (displayNatives)\n        return true;\n      return !script.isNative || isCurrentScript(script);\n    }\n    return ArrayPrototypeJoin(ArrayPrototypeMap(ArrayPrototypeFilter(ObjectValues(knownScripts), isVisible), (script) => {\n      const isCurrent = isCurrentScript(script);\n      const { isNative, url } = script;\n      const name = `${getRelativePath(url)}${isNative ? \" <native>\" : \"\"}`;\n      return `${isCurrent ? \"*\" : \" \"} ${script.scriptId}: ${name}`;\n    }), \"\\n\");\n  }\n  function listScripts(displayNatives = false) {\n    print(formatScripts(displayNatives));\n  }\n  listScripts[customInspectSymbol] = function listWithoutInternal() {\n    return formatScripts();\n  };\n  const profiles = [];\n  class Profile {\n    constructor(data) {\n      this.data = data;\n    }\n    static createAndRegister({ profile }) {\n      const p = new Profile(profile);\n      ArrayPrototypePush(profiles, p);\n      return p;\n    }\n    [customInspectSymbol](depth, { stylize }) {\n      const { startTime, endTime } = this.data;\n      const MU = StringFromCharCode(956);\n      return stylize(`[Profile ${endTime - startTime}${MU}s]`, \"special\");\n    }\n    save(filename = \"node.cpuprofile\") {\n      const absoluteFile = Path.resolve(filename);\n      const json = JSONStringify(this.data);\n      FS.writeFileSync(absoluteFile, json);\n      print(\"Saved profile to \" + absoluteFile);\n    }\n  }\n  class SourceSnippet {\n    constructor(location, delta, scriptSource) {\n      ObjectAssign(this, location);\n      this.scriptSource = scriptSource;\n      this.delta = delta;\n    }\n    [customInspectSymbol](depth, options) {\n      const { scriptId, lineNumber, columnNumber, delta, scriptSource } = this;\n      const start = MathMax(1, lineNumber - delta + 1);\n      const end = lineNumber + delta + 1;\n      const lines = StringPrototypeSplit(scriptSource, \"\\n\");\n      return ArrayPrototypeJoin(ArrayPrototypeMap(ArrayPrototypeSlice(lines, start - 1, end), (lineText, offset) => {\n        const i = start + offset;\n        const isCurrent = i === lineNumber + 1;\n        const markedLine = isCurrent ? markSourceColumn(lineText, columnNumber, options.colors) : lineText;\n        let isBreakpoint = false;\n        ArrayPrototypeForEach(knownBreakpoints, ({ location }) => {\n          if (!location)\n            return;\n          if (scriptId === location.scriptId && i === location.lineNumber + 1) {\n            isBreakpoint = true;\n          }\n        });\n        let prefixChar = \" \";\n        if (isCurrent) {\n          prefixChar = \">\";\n        } else if (isBreakpoint) {\n          prefixChar = \"*\";\n        }\n        return `${leftPad(i, prefixChar, end)} ${markedLine}`;\n      }), \"\\n\");\n    }\n  }\n  async function getSourceSnippet(location, delta = 5) {\n    const { scriptId } = location;\n    const { scriptSource } = await Debugger.getScriptSource({ scriptId });\n    return new SourceSnippet(location, delta, scriptSource);\n  }\n  class CallFrame {\n    constructor(callFrame) {\n      ObjectAssign(this, callFrame);\n    }\n    loadScopes() {\n      return PromiseAll(new SafeArrayIterator(ArrayPrototypeMap(ArrayPrototypeFilter(this.scopeChain, (scope) => scope.type !== \"global\"), async (scope) => {\n        const { objectId } = scope.object;\n        const { result } = await Runtime.getProperties({\n          objectId,\n          generatePreview: true\n        });\n        return new ScopeSnapshot(scope, result);\n      })));\n    }\n    list(delta = 5) {\n      return getSourceSnippet(this.location, delta);\n    }\n  }\n  class Backtrace extends Array {\n    [customInspectSymbol]() {\n      return ArrayPrototypeJoin(ArrayPrototypeMap(this, (callFrame, idx) => {\n        const {\n          location: { scriptId, lineNumber, columnNumber },\n          functionName\n        } = callFrame;\n        const name = functionName || \"(anonymous)\";\n        const script = knownScripts[scriptId];\n        const relativeUrl = script && getRelativePath(script.url) || \"<unknown>\";\n        const frameLocation = `${relativeUrl}:${lineNumber + 1}:${columnNumber}`;\n        return `#${idx} ${name} ${frameLocation}`;\n      }), \"\\n\");\n    }\n    static from(callFrames) {\n      return FunctionPrototypeCall(ArrayFrom, this, callFrames, (callFrame) => callFrame instanceof CallFrame ? callFrame : new CallFrame(callFrame));\n    }\n  }\n  function prepareControlCode(input) {\n    if (input === \"\\n\")\n      return lastCommand;\n    const match = RegExpPrototypeSymbolMatch(/^\\s*exec\\s+([^\\n]*)/, input);\n    if (match) {\n      lastCommand = `exec(${JSONStringify(match[1])})`;\n    } else {\n      lastCommand = input;\n    }\n    return lastCommand;\n  }\n  async function evalInCurrentContext(code) {\n    if (code === \".scope\") {\n      if (!selectedFrame) {\n        throw new ERR_DEBUGGER_ERROR(\"Requires execution to be paused\");\n      }\n      const scopes = await selectedFrame.loadScopes();\n      return ArrayPrototypeMap(scopes, (scope) => scope.completionGroup);\n    }\n    if (selectedFrame) {\n      return PromisePrototypeThen(Debugger.evaluateOnCallFrame({\n        callFrameId: selectedFrame.callFrameId,\n        expression: code,\n        objectGroup: \"node-inspect\",\n        generatePreview: true\n      }), RemoteObject.fromEvalResult);\n    }\n    return PromisePrototypeThen(Runtime.evaluate({\n      expression: code,\n      objectGroup: \"node-inspect\",\n      generatePreview: true\n    }), RemoteObject.fromEvalResult);\n  }\n  function controlEval(input, context, filename, callback) {\n    debuglog(\"eval:\", input);\n    function returnToCallback(error, result) {\n      debuglog(\"end-eval:\", input, error);\n      callback(error, result);\n    }\n    try {\n      const code = prepareControlCode(input);\n      const result = vm.runInContext(code, context, filename);\n      const then = result?.then;\n      if (typeof then === \"function\") {\n        FunctionPrototypeCall(then, result, (result2) => returnToCallback(null, result2), returnToCallback);\n      } else {\n        returnToCallback(null, result);\n      }\n    } catch (e) {\n      returnToCallback(e);\n    }\n  }\n  function debugEval(input, context, filename, callback) {\n    debuglog(\"eval:\", input);\n    function returnToCallback(error, result) {\n      debuglog(\"end-eval:\", input, error);\n      callback(error, result);\n    }\n    PromisePrototypeThen(evalInCurrentContext(input), (result) => returnToCallback(null, result), returnToCallback);\n  }\n  async function formatWatchers(verbose = false) {\n    if (!watchedExpressions.length) {\n      return \"\";\n    }\n    const inspectValue = (expr) => PromisePrototypeCatch(evalInCurrentContext(expr), (error) => `<${error.message}>`);\n    const lastIndex = watchedExpressions.length - 1;\n    const values = await PromiseAll(new SafeArrayIterator(ArrayPrototypeMap(watchedExpressions, inspectValue)));\n    const lines = ArrayPrototypeMap(watchedExpressions, (expr, idx) => {\n      const prefix = `${leftPad(idx, \" \", lastIndex)}: ${expr} =`;\n      const value = inspect(values[idx]);\n      if (!StringPrototypeIncludes(value, \"\\n\")) {\n        return `${prefix} ${value}`;\n      }\n      return `${prefix}\n    ${RegExpPrototypeSymbolReplace(/\\n/g, value, \"\\n    \")}`;\n    });\n    const valueList = ArrayPrototypeJoin(lines, \"\\n\");\n    return verbose ? `Watchers:\n${valueList}\n` : valueList;\n  }\n  function watchers(verbose = false) {\n    return PromisePrototypeThen(formatWatchers(verbose), print);\n  }\n  function list(delta = 5) {\n    return selectedFrame.list(delta).then(null, (error) => {\n      print(\"You can't list source code right now\");\n      throw error;\n    });\n  }\n  function handleBreakpointResolved({ breakpointId, location }) {\n    const script = knownScripts[location.scriptId];\n    const scriptUrl = script && script.url;\n    if (scriptUrl) {\n      ObjectAssign(location, { scriptUrl });\n    }\n    const isExisting = ArrayPrototypeSome(knownBreakpoints, (bp) => {\n      if (bp.breakpointId === breakpointId) {\n        ObjectAssign(bp, { location });\n        return true;\n      }\n      return false;\n    });\n    if (!isExisting) {\n      ArrayPrototypePush(knownBreakpoints, { breakpointId, location });\n    }\n  }\n  function listBreakpoints() {\n    if (!knownBreakpoints.length) {\n      print(\"No breakpoints yet\");\n      return;\n    }\n    function formatLocation(location) {\n      if (!location)\n        return \"<unknown location>\";\n      const script = knownScripts[location.scriptId];\n      const scriptUrl = script ? script.url : location.scriptUrl;\n      return `${getRelativePath(scriptUrl)}:${location.lineNumber + 1}`;\n    }\n    const breaklist = ArrayPrototypeJoin(ArrayPrototypeMap(knownBreakpoints, (bp, idx) => `#${idx} ${formatLocation(bp.location)}`), \"\\n\");\n    print(breaklist);\n  }\n  function setBreakpoint(script, line, condition, silent) {\n    function registerBreakpoint({ breakpointId, actualLocation }) {\n      handleBreakpointResolved({ breakpointId, location: actualLocation });\n      if (actualLocation && actualLocation.scriptId) {\n        if (!silent)\n          return getSourceSnippet(actualLocation, 5);\n      } else {\n        print(`Warning: script '${script}' was not loaded yet.`);\n      }\n      return void 0;\n    }\n    if (script === void 0) {\n      return PromisePrototypeThen(Debugger.setBreakpoint({ location: getCurrentLocation(), condition }), registerBreakpoint);\n    }\n    if (line === void 0 && typeof script === \"number\") {\n      const location = {\n        scriptId: getCurrentLocation().scriptId,\n        lineNumber: script - 1\n      };\n      return PromisePrototypeThen(Debugger.setBreakpoint({ location, condition }), registerBreakpoint);\n    }\n    validateString(script, \"script\");\n    if (StringPrototypeEndsWith(script, \"()\")) {\n      const debugExpr = `debug(${script.slice(0, -2)})`;\n      const debugCall = selectedFrame ? Debugger.evaluateOnCallFrame({\n        callFrameId: selectedFrame.callFrameId,\n        expression: debugExpr,\n        includeCommandLineAPI: true\n      }) : Runtime.evaluate({\n        expression: debugExpr,\n        includeCommandLineAPI: true\n      });\n      return PromisePrototypeThen(debugCall, ({ result, wasThrown }) => {\n        if (wasThrown)\n          return convertResultToError(result);\n        return void 0;\n      });\n    }\n    let scriptId = null;\n    let ambiguous = false;\n    if (knownScripts[script]) {\n      scriptId = script;\n    } else {\n      ArrayPrototypeForEach(ObjectKeys(knownScripts), (id) => {\n        const scriptUrl = knownScripts[id].url;\n        if (scriptUrl && StringPrototypeIncludes(scriptUrl, script)) {\n          if (scriptId !== null) {\n            ambiguous = true;\n          }\n          scriptId = id;\n        }\n      });\n    }\n    if (ambiguous) {\n      print(\"Script name is ambiguous\");\n      return void 0;\n    }\n    if (line <= 0) {\n      print(\"Line should be a positive value\");\n      return void 0;\n    }\n    if (scriptId !== null) {\n      const location = { scriptId, lineNumber: line - 1 };\n      return PromisePrototypeThen(Debugger.setBreakpoint({ location, condition }), registerBreakpoint);\n    }\n    const escapedPath = RegExpPrototypeSymbolReplace(/([/\\\\.?*()^${}|[\\]])/g, script, \"\\\\$1\");\n    const urlRegex = `^(.*[\\\\/\\\\\\\\])?${escapedPath}$`;\n    return PromisePrototypeThen(Debugger.setBreakpointByUrl({\n      urlRegex,\n      lineNumber: line - 1,\n      condition\n    }), (bp) => {\n      if (!bp.location) {\n        ObjectAssign(bp, {\n          actualLocation: {\n            scriptUrl: `.*/${script}$`,\n            lineNumber: line - 1\n          }\n        });\n      }\n      return registerBreakpoint(bp);\n    });\n  }\n  function clearBreakpoint(url, line) {\n    const breakpoint = ArrayPrototypeFind(knownBreakpoints, ({ location }) => {\n      if (!location)\n        return false;\n      const script = knownScripts[location.scriptId];\n      if (!script)\n        return false;\n      return StringPrototypeIncludes(script.url, url) && location.lineNumber + 1 === line;\n    });\n    if (!breakpoint) {\n      print(`Could not find breakpoint at ${url}:${line}`);\n      return PromiseResolve();\n    }\n    return PromisePrototypeThen(Debugger.removeBreakpoint({ breakpointId: breakpoint.breakpointId }), () => {\n      const idx = ArrayPrototypeIndexOf(knownBreakpoints, breakpoint);\n      ArrayPrototypeSplice(knownBreakpoints, idx, 1);\n    });\n  }\n  function restoreBreakpoints() {\n    const lastBreakpoints = ArrayPrototypeSplice(knownBreakpoints, 0);\n    const newBreakpoints = ArrayPrototypeMap(ArrayPrototypeFilter(lastBreakpoints, ({ location }) => !!location.scriptUrl), ({ location }) => setBreakpoint(location.scriptUrl, location.lineNumber + 1));\n    if (!newBreakpoints.length)\n      return PromiseResolve();\n    return PromisePrototypeThen(PromiseAll(new SafeArrayIterator(newBreakpoints)), (results) => {\n      print(`${results.length} breakpoints restored.`);\n    });\n  }\n  function setPauseOnExceptions(state) {\n    return PromisePrototypeThen(Debugger.setPauseOnExceptions({ state }), () => {\n      pauseOnExceptionState = state;\n    });\n  }\n  Debugger.on(\"paused\", ({ callFrames, reason }) => {\n    if (process.env.NODE_INSPECT_RESUME_ON_START === \"1\" && reason === \"Break on start\") {\n      debuglog(\"Paused on start, but NODE_INSPECT_RESUME_ON_START environment variable is set to 1, resuming\");\n      inspector.client.callMethod(\"Debugger.resume\");\n      return;\n    }\n    currentBacktrace = Backtrace.from(callFrames);\n    selectedFrame = currentBacktrace[0];\n    const { scriptId, lineNumber } = selectedFrame.location;\n    const breakType = reason === \"other\" ? \"break\" : reason;\n    const script = knownScripts[scriptId];\n    const scriptUrl = script ? getRelativePath(script.url) : \"[unknown]\";\n    const header = `${breakType} in ${scriptUrl}:${lineNumber + 1}`;\n    inspector.suspendReplWhile(() => PromisePrototypeThen(PromiseAll(new SafeArrayIterator([formatWatchers(true), selectedFrame.list(2)])), ({ 0: watcherList, 1: context }) => {\n      const breakContext = watcherList ? `${watcherList}\n${inspect(context)}` : inspect(context);\n      print(`${header}\n${breakContext}`);\n    }));\n  });\n  function handleResumed() {\n    currentBacktrace = null;\n    selectedFrame = null;\n  }\n  Debugger.on(\"resumed\", handleResumed);\n  Debugger.on(\"breakpointResolved\", handleBreakpointResolved);\n  Debugger.on(\"scriptParsed\", (script) => {\n    const { scriptId, url } = script;\n    if (url) {\n      knownScripts[scriptId] = { isNative: isNativeUrl(url), ...script };\n    }\n  });\n  Profiler.on(\"consoleProfileFinished\", ({ profile }) => {\n    Profile.createAndRegister({ profile });\n    print(`Captured new CPU profile.\nAccess it with profiles[${profiles.length - 1}]`);\n  });\n  function initializeContext(context) {\n    ArrayPrototypeForEach(inspector.domainNames, (domain) => {\n      ObjectDefineProperty(context, domain, {\n        value: inspector[domain],\n        enumerable: true,\n        configurable: true,\n        writeable: false\n      });\n    });\n    copyOwnProperties(context, {\n      get help() {\n        return print(HELP);\n      },\n      get run() {\n        return inspector.run();\n      },\n      get kill() {\n        return inspector.killChild();\n      },\n      get restart() {\n        return inspector.run();\n      },\n      get cont() {\n        handleResumed();\n        return Debugger.resume();\n      },\n      get next() {\n        handleResumed();\n        return Debugger.stepOver();\n      },\n      get step() {\n        handleResumed();\n        return Debugger.stepInto();\n      },\n      get out() {\n        handleResumed();\n        return Debugger.stepOut();\n      },\n      get pause() {\n        return Debugger.pause();\n      },\n      get backtrace() {\n        return currentBacktrace;\n      },\n      get breakpoints() {\n        return listBreakpoints();\n      },\n      exec(expr) {\n        return evalInCurrentContext(expr);\n      },\n      get profile() {\n        return Profiler.start();\n      },\n      get profileEnd() {\n        return PromisePrototypeThen(Profiler.stop(), Profile.createAndRegister);\n      },\n      get profiles() {\n        return profiles;\n      },\n      takeHeapSnapshot(filename = \"node.heapsnapshot\") {\n        if (heapSnapshotPromise) {\n          print(\"Cannot take heap snapshot because another snapshot is in progress.\");\n          return heapSnapshotPromise;\n        }\n        heapSnapshotPromise = new Promise((resolve, reject) => {\n          const absoluteFile = Path.resolve(filename);\n          const writer = FS.createWriteStream(absoluteFile);\n          let sizeWritten = 0;\n          function onProgress({ done, total, finished }) {\n            if (finished) {\n              print(\"Heap snaphost prepared.\");\n            } else {\n              print(`Heap snapshot: ${done}/${total}`, false);\n            }\n          }\n          function onChunk({ chunk }) {\n            sizeWritten += chunk.length;\n            writer.write(chunk);\n            print(`Writing snapshot: ${sizeWritten}`, false);\n          }\n          function onResolve() {\n            writer.end(() => {\n              teardown();\n              print(`Wrote snapshot: ${absoluteFile}`);\n              heapSnapshotPromise = null;\n              resolve();\n            });\n          }\n          function onReject(error) {\n            teardown();\n            reject(error);\n          }\n          function teardown() {\n            HeapProfiler.removeListener(\"reportHeapSnapshotProgress\", onProgress);\n            HeapProfiler.removeListener(\"addHeapSnapshotChunk\", onChunk);\n          }\n          HeapProfiler.on(\"reportHeapSnapshotProgress\", onProgress);\n          HeapProfiler.on(\"addHeapSnapshotChunk\", onChunk);\n          print(\"Heap snapshot: 0/0\", false);\n          PromisePrototypeThen(HeapProfiler.takeHeapSnapshot({ reportProgress: true }), onResolve, onReject);\n        });\n        return heapSnapshotPromise;\n      },\n      get watchers() {\n        return watchers();\n      },\n      watch(expr) {\n        ArrayPrototypePush(watchedExpressions, expr);\n      },\n      unwatch(expr) {\n        const index = ArrayPrototypeIndexOf(watchedExpressions, expr);\n        ArrayPrototypeSplice(watchedExpressions, index !== -1 ? index : +expr, 1);\n      },\n      get repl() {\n        const listeners = ArrayPrototypeSlice(repl.listeners(\"SIGINT\"));\n        repl.removeAllListeners(\"SIGINT\");\n        const oldContext = repl.context;\n        exitDebugRepl = () => {\n          process.nextTick(() => {\n            ArrayPrototypeForEach(listeners, (listener) => {\n              repl.on(\"SIGINT\", listener);\n            });\n          });\n          repl.eval = controlEval;\n          history.debug = repl.history;\n          repl.history = history.control;\n          repl.context = oldContext;\n          repl.setPrompt(\"debug> \");\n          repl.displayPrompt();\n          repl.removeListener(\"SIGINT\", exitDebugRepl);\n          repl.removeListener(\"exit\", exitDebugRepl);\n          exitDebugRepl = null;\n        };\n        repl.on(\"SIGINT\", exitDebugRepl);\n        repl.on(\"exit\", exitDebugRepl);\n        repl.eval = debugEval;\n        repl.context = {};\n        history.control = repl.history;\n        repl.history = history.debug;\n        repl.setPrompt(\"> \");\n        print(\"Press Ctrl+C to leave debug repl\");\n        return repl.displayPrompt();\n      },\n      get version() {\n        return PromisePrototypeThen(Runtime.evaluate({\n          expression: \"process.versions.v8\",\n          contextId: 1,\n          returnByValue: true\n        }), ({ result }) => {\n          print(result.value);\n        });\n      },\n      scripts: listScripts,\n      setBreakpoint,\n      clearBreakpoint,\n      setPauseOnExceptions,\n      get breakOnException() {\n        return setPauseOnExceptions(\"all\");\n      },\n      get breakOnUncaught() {\n        return setPauseOnExceptions(\"uncaught\");\n      },\n      get breakOnNone() {\n        return setPauseOnExceptions(\"none\");\n      },\n      list\n    });\n    aliasProperties(context, SHORTCUTS);\n  }\n  async function initAfterStart() {\n    await Runtime.enable();\n    await Profiler.enable();\n    await Profiler.setSamplingInterval({ interval: 100 });\n    await Debugger.enable();\n    await Debugger.setPauseOnExceptions({ state: \"none\" });\n    await Debugger.setAsyncCallStackDepth({ maxDepth: 0 });\n    await Debugger.setBlackboxPatterns({ patterns: [] });\n    await Debugger.setPauseOnExceptions({ state: pauseOnExceptionState });\n    await restoreBreakpoints();\n    return Runtime.runIfWaitingForDebugger();\n  }\n  return async function startRepl() {\n    inspector.client.on(\"close\", () => {\n      resetOnStart();\n    });\n    inspector.client.on(\"ready\", () => {\n      initAfterStart();\n    });\n    await initAfterStart();\n    const replOptions = {\n      prompt: \"debug> \",\n      input: inspector.stdin,\n      output: inspector.stdout,\n      eval: controlEval,\n      useGlobal: false,\n      ignoreUndefined: true\n    };\n    repl = Repl.start(replOptions);\n    initializeContext(repl.context);\n    repl.on(\"reset\", initializeContext);\n    repl.defineCommand(\"interrupt\", () => {\n      repl.emit(\"SIGINT\");\n    });\n    return repl;\n  };\n}\nmodule.exports = createRepl;\n}"],["internal/dns/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply\n} = primordials;\nconst {\n  bindDefaultResolver,\n  Resolver: CallbackResolver,\n  validateHints,\n  validateTimeout,\n  validateTries,\n  emitInvalidHostnameWarning,\n  emitTypeCoercionDeprecationWarning,\n  getDefaultVerbatim\n} = require(\"internal/dns/utils\");\nconst { codes, dnsException } = require(\"internal/errors\");\nconst { toASCII } = require(\"internal/idna\");\nconst { isIP } = require(\"internal/net\");\nconst {\n  getaddrinfo,\n  getnameinfo,\n  ChannelWrap,\n  GetAddrInfoReqWrap,\n  GetNameInfoReqWrap,\n  QueryReqWrap\n} = internalBinding(\"cares_wrap\");\nconst {\n  ERR_INVALID_ARG_VALUE,\n  ERR_MISSING_ARGS\n} = codes;\nconst {\n  validatePort,\n  validateString,\n  validateOneOf\n} = require(\"internal/validators\");\nfunction onlookup(err, addresses) {\n  if (err) {\n    this.reject(dnsException(err, \"getaddrinfo\", this.hostname));\n    return;\n  }\n  const family = this.family || isIP(addresses[0]);\n  this.resolve({ address: addresses[0], family });\n}\nfunction onlookupall(err, addresses) {\n  if (err) {\n    this.reject(dnsException(err, \"getaddrinfo\", this.hostname));\n    return;\n  }\n  const family = this.family;\n  for (var i = 0; i < addresses.length; i++) {\n    const address = addresses[i];\n    addresses[i] = {\n      address,\n      family: family || isIP(addresses[i])\n    };\n  }\n  this.resolve(addresses);\n}\nfunction createLookupPromise(family, hostname, all, hints, verbatim) {\n  return new Promise((resolve2, reject) => {\n    if (!hostname) {\n      emitInvalidHostnameWarning(hostname);\n      resolve2(all ? [] : { address: null, family: family === 6 ? 6 : 4 });\n      return;\n    }\n    const matchedFamily = isIP(hostname);\n    if (matchedFamily !== 0) {\n      const result = { address: hostname, family: matchedFamily };\n      resolve2(all ? [result] : result);\n      return;\n    }\n    const req = new GetAddrInfoReqWrap();\n    req.family = family;\n    req.hostname = hostname;\n    req.oncomplete = all ? onlookupall : onlookup;\n    req.resolve = resolve2;\n    req.reject = reject;\n    const err = getaddrinfo(req, toASCII(hostname), family, hints, verbatim);\n    if (err) {\n      reject(dnsException(err, \"getaddrinfo\", hostname));\n    }\n  });\n}\nfunction lookup(hostname, options) {\n  var hints = 0;\n  var family = -1;\n  var all = false;\n  var verbatim = getDefaultVerbatim();\n  if (hostname) {\n    validateString(hostname, \"hostname\");\n  }\n  if (options !== null && typeof options === \"object\") {\n    if (options.hints != null && typeof options.hints !== \"number\") {\n      emitTypeCoercionDeprecationWarning();\n    }\n    hints = options.hints >>> 0;\n    if (options.family != null && typeof options.family !== \"number\") {\n      emitTypeCoercionDeprecationWarning();\n    }\n    family = options.family >>> 0;\n    if (options.all != null && typeof options.all !== \"boolean\") {\n      emitTypeCoercionDeprecationWarning();\n    }\n    all = options.all === true;\n    if (typeof options.verbatim === \"boolean\") {\n      verbatim = options.verbatim === true;\n    } else if (options.verbatim != null) {\n      emitTypeCoercionDeprecationWarning();\n    }\n    validateHints(hints);\n  } else {\n    if (options != null && typeof options !== \"number\") {\n      emitTypeCoercionDeprecationWarning();\n    }\n    family = options >>> 0;\n  }\n  validateOneOf(family, \"family\", [0, 4, 6], true);\n  return createLookupPromise(family, hostname, all, hints, verbatim);\n}\nfunction onlookupservice(err, hostname, service) {\n  if (err) {\n    this.reject(dnsException(err, \"getnameinfo\", this.host));\n    return;\n  }\n  this.resolve({ hostname, service });\n}\nfunction createLookupServicePromise(hostname, port) {\n  return new Promise((resolve2, reject) => {\n    const req = new GetNameInfoReqWrap();\n    req.hostname = hostname;\n    req.port = port;\n    req.oncomplete = onlookupservice;\n    req.resolve = resolve2;\n    req.reject = reject;\n    const err = getnameinfo(req, hostname, port);\n    if (err)\n      reject(dnsException(err, \"getnameinfo\", hostname));\n  });\n}\nfunction lookupService(address, port) {\n  if (arguments.length !== 2)\n    throw new ERR_MISSING_ARGS(\"address\", \"port\");\n  if (isIP(address) === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"address\", address);\n  validatePort(port);\n  return createLookupServicePromise(address, +port);\n}\nfunction onresolve(err, result, ttls) {\n  if (err) {\n    this.reject(dnsException(err, this.bindingName, this.hostname));\n    return;\n  }\n  if (ttls && this.ttl)\n    result = ArrayPrototypeMap(result, (address, index) => ({ address, ttl: ttls[index] }));\n  this.resolve(result);\n}\nfunction createResolverPromise(resolver2, bindingName, hostname, ttl) {\n  return new Promise((resolve2, reject) => {\n    const req = new QueryReqWrap();\n    req.bindingName = bindingName;\n    req.hostname = hostname;\n    req.oncomplete = onresolve;\n    req.resolve = resolve2;\n    req.reject = reject;\n    req.ttl = ttl;\n    const err = resolver2._handle[bindingName](req, toASCII(hostname));\n    if (err)\n      reject(dnsException(err, bindingName, hostname));\n  });\n}\nfunction resolver(bindingName) {\n  function query(name, options) {\n    validateString(name, \"name\");\n    const ttl = !!(options && options.ttl);\n    return createResolverPromise(this, bindingName, name, ttl);\n  }\n  ObjectDefineProperty(query, \"name\", { value: bindingName });\n  return query;\n}\nconst resolveMap = ObjectCreate(null);\nclass Resolver {\n  constructor(options = void 0) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    this._handle = new ChannelWrap(timeout, tries);\n  }\n}\nResolver.prototype.getServers = CallbackResolver.prototype.getServers;\nResolver.prototype.setServers = CallbackResolver.prototype.setServers;\nResolver.prototype.cancel = CallbackResolver.prototype.cancel;\nResolver.prototype.setLocalAddress = CallbackResolver.prototype.setLocalAddress;\nResolver.prototype.resolveAny = resolveMap.ANY = resolver(\"queryAny\");\nResolver.prototype.resolve4 = resolveMap.A = resolver(\"queryA\");\nResolver.prototype.resolve6 = resolveMap.AAAA = resolver(\"queryAaaa\");\nResolver.prototype.resolveCaa = resolveMap.CAA = resolver(\"queryCaa\");\nResolver.prototype.resolveCname = resolveMap.CNAME = resolver(\"queryCname\");\nResolver.prototype.resolveMx = resolveMap.MX = resolver(\"queryMx\");\nResolver.prototype.resolveNs = resolveMap.NS = resolver(\"queryNs\");\nResolver.prototype.resolveTxt = resolveMap.TXT = resolver(\"queryTxt\");\nResolver.prototype.resolveSrv = resolveMap.SRV = resolver(\"querySrv\");\nResolver.prototype.resolvePtr = resolveMap.PTR = resolver(\"queryPtr\");\nResolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver(\"queryNaptr\");\nResolver.prototype.resolveSoa = resolveMap.SOA = resolver(\"querySoa\");\nResolver.prototype.reverse = resolver(\"getHostByAddr\");\nResolver.prototype.resolve = function resolve(hostname, rrtype) {\n  var resolver2;\n  if (rrtype !== void 0) {\n    validateString(rrtype, \"rrtype\");\n    resolver2 = resolveMap[rrtype];\n    if (typeof resolver2 !== \"function\")\n      throw new ERR_INVALID_ARG_VALUE(\"rrtype\", rrtype);\n  } else {\n    resolver2 = resolveMap.A;\n  }\n  return ReflectApply(resolver2, this, [hostname]);\n};\nmodule.exports = { lookup, lookupService, Resolver };\nbindDefaultResolver(module.exports, Resolver.prototype);\n}"],["internal/dns/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  FunctionPrototypeBind,\n  NumberParseInt,\n  StringPrototypeMatch,\n  StringPrototypeReplace\n} = primordials;\nconst errors = require(\"internal/errors\");\nconst { isIP } = require(\"internal/net\");\nconst { getOptionValue } = require(\"internal/options\");\nconst {\n  validateArray,\n  validateInt32,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  ChannelWrap,\n  strerror,\n  AI_ADDRCONFIG,\n  AI_ALL,\n  AI_V4MAPPED\n} = internalBinding(\"cares_wrap\");\nconst IANA_DNS_PORT = 53;\nconst IPv6RE = /^\\[([^[\\]]*)\\]/;\nconst addrSplitRE = /(^.+?)(?::(\\d+))?$/;\nconst {\n  ERR_DNS_SET_SERVERS_FAILED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_IP_ADDRESS\n} = errors.codes;\nfunction validateTimeout(options) {\n  const { timeout = -1 } = { ...options };\n  validateInt32(timeout, \"options.timeout\", -1, 2 ** 31 - 1);\n  return timeout;\n}\nfunction validateTries(options) {\n  const { tries = 4 } = { ...options };\n  validateInt32(tries, \"options.tries\", 1, 2 ** 31 - 1);\n  return tries;\n}\nclass Resolver {\n  constructor(options = void 0) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    this._handle = new ChannelWrap(timeout, tries);\n  }\n  cancel() {\n    this._handle.cancel();\n  }\n  getServers() {\n    return ArrayPrototypeMap(this._handle.getServers(), (val) => {\n      if (!val[1] || val[1] === IANA_DNS_PORT)\n        return val[0];\n      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n      return `${host}:${val[1]}`;\n    });\n  }\n  setServers(servers) {\n    validateArray(servers, \"servers\");\n    const orig = this._handle.getServers();\n    const newSet = [];\n    ArrayPrototypeForEach(servers, (serv, index) => {\n      validateString(serv, `servers[${index}]`);\n      let ipVersion = isIP(serv);\n      if (ipVersion !== 0)\n        return ArrayPrototypePush(newSet, [ipVersion, serv, IANA_DNS_PORT]);\n      const match = StringPrototypeMatch(serv, IPv6RE);\n      if (match) {\n        ipVersion = isIP(match[1]);\n        if (ipVersion !== 0) {\n          const port = NumberParseInt(StringPrototypeReplace(serv, addrSplitRE, \"$2\")) || IANA_DNS_PORT;\n          return ArrayPrototypePush(newSet, [ipVersion, match[1], port]);\n        }\n      }\n      const addrSplitMatch = StringPrototypeMatch(serv, addrSplitRE);\n      if (addrSplitMatch) {\n        const hostIP = addrSplitMatch[1];\n        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n        ipVersion = isIP(hostIP);\n        if (ipVersion !== 0) {\n          return ArrayPrototypePush(newSet, [ipVersion, hostIP, NumberParseInt(port)]);\n        }\n      }\n      throw new ERR_INVALID_IP_ADDRESS(serv);\n    });\n    const errorNumber = this._handle.setServers(newSet);\n    if (errorNumber !== 0) {\n      this._handle.setServers(ArrayPrototypeJoin(orig, \",\"));\n      const err = strerror(errorNumber);\n      throw new ERR_DNS_SET_SERVERS_FAILED(err, servers);\n    }\n  }\n  setLocalAddress(ipv4, ipv6) {\n    validateString(ipv4, \"ipv4\");\n    if (ipv6 !== void 0) {\n      validateString(ipv6, \"ipv6\");\n    }\n    this._handle.setLocalAddress(ipv4, ipv6);\n  }\n}\nlet defaultResolver = new Resolver();\nconst resolverKeys = [\n  \"getServers\",\n  \"resolve\",\n  \"resolve4\",\n  \"resolve6\",\n  \"resolveAny\",\n  \"resolveCaa\",\n  \"resolveCname\",\n  \"resolveMx\",\n  \"resolveNaptr\",\n  \"resolveNs\",\n  \"resolvePtr\",\n  \"resolveSoa\",\n  \"resolveSrv\",\n  \"resolveTxt\",\n  \"reverse\"\n];\nfunction getDefaultResolver() {\n  return defaultResolver;\n}\nfunction setDefaultResolver(resolver) {\n  defaultResolver = resolver;\n}\nfunction bindDefaultResolver(target, source) {\n  ArrayPrototypeForEach(resolverKeys, (key) => {\n    target[key] = FunctionPrototypeBind(source[key], defaultResolver);\n  });\n}\nfunction validateHints(hints) {\n  if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"hints\", hints);\n  }\n}\nlet invalidHostnameWarningEmitted = false;\nfunction emitInvalidHostnameWarning(hostname) {\n  if (invalidHostnameWarningEmitted) {\n    return;\n  }\n  invalidHostnameWarningEmitted = true;\n  process.emitWarning(`The provided hostname \"${hostname}\" is not a valid hostname, and is supported in the dns module solely for compatibility.`, \"DeprecationWarning\", \"DEP0118\");\n}\nlet typeCoercionWarningEmitted = false;\nfunction emitTypeCoercionDeprecationWarning() {\n  if (!typeCoercionWarningEmitted) {\n    process.emitWarning(\"Type coercion of dns.lookup options is deprecated\", \"DeprecationWarning\", \"DEP0153\");\n    typeCoercionWarningEmitted = true;\n  }\n}\nlet dnsOrder = getOptionValue(\"--dns-result-order\") || \"verbatim\";\nfunction getDefaultVerbatim() {\n  return dnsOrder !== \"ipv4first\";\n}\nfunction setDefaultResultOrder(value) {\n  validateOneOf(value, \"dnsOrder\", [\"verbatim\", \"ipv4first\"]);\n  dnsOrder = value;\n}\nmodule.exports = {\n  bindDefaultResolver,\n  getDefaultResolver,\n  setDefaultResolver,\n  validateHints,\n  validateTimeout,\n  validateTries,\n  Resolver,\n  emitInvalidHostnameWarning,\n  emitTypeCoercionDeprecationWarning,\n  getDefaultVerbatim,\n  setDefaultResultOrder\n};\n}"],["internal/fs/dir.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  FunctionPrototypeBind,\n  ObjectDefineProperty,\n  PromiseReject,\n  Symbol,\n  SymbolAsyncIterator\n} = primordials;\nconst pathModule = require(\"path\");\nconst binding = internalBinding(\"fs\");\nconst dirBinding = internalBinding(\"fs_dir\");\nconst {\n  codes: {\n    ERR_DIR_CLOSED,\n    ERR_DIR_CONCURRENT_OPERATION,\n    ERR_MISSING_ARGS\n  }\n} = require(\"internal/errors\");\nconst { FSReqCallback } = binding;\nconst internalUtil = require(\"internal/util\");\nconst {\n  getDirent,\n  getOptions,\n  getValidatedPath,\n  handleErrorFromBinding\n} = require(\"internal/fs/utils\");\nconst {\n  validateCallback,\n  validateUint32\n} = require(\"internal/validators\");\nconst kDirHandle = Symbol(\"kDirHandle\");\nconst kDirPath = Symbol(\"kDirPath\");\nconst kDirBufferedEntries = Symbol(\"kDirBufferedEntries\");\nconst kDirClosed = Symbol(\"kDirClosed\");\nconst kDirOptions = Symbol(\"kDirOptions\");\nconst kDirReadImpl = Symbol(\"kDirReadImpl\");\nconst kDirReadPromisified = Symbol(\"kDirReadPromisified\");\nconst kDirClosePromisified = Symbol(\"kDirClosePromisified\");\nconst kDirOperationQueue = Symbol(\"kDirOperationQueue\");\nclass Dir {\n  constructor(handle, path, options) {\n    if (handle == null)\n      throw new ERR_MISSING_ARGS(\"handle\");\n    this[kDirHandle] = handle;\n    this[kDirBufferedEntries] = [];\n    this[kDirPath] = path;\n    this[kDirClosed] = false;\n    this[kDirOperationQueue] = null;\n    this[kDirOptions] = {\n      bufferSize: 32,\n      ...getOptions(options, {\n        encoding: \"utf8\"\n      })\n    };\n    validateUint32(this[kDirOptions].bufferSize, \"options.bufferSize\", true);\n    this[kDirReadPromisified] = FunctionPrototypeBind(internalUtil.promisify(this[kDirReadImpl]), this, false);\n    this[kDirClosePromisified] = FunctionPrototypeBind(internalUtil.promisify(this.close), this);\n  }\n  get path() {\n    return this[kDirPath];\n  }\n  read(callback) {\n    return this[kDirReadImpl](true, callback);\n  }\n  [kDirReadImpl](maybeSync, callback) {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n    if (callback === void 0) {\n      return this[kDirReadPromisified]();\n    }\n    validateCallback(callback);\n    if (this[kDirOperationQueue] !== null) {\n      ArrayPrototypePush(this[kDirOperationQueue], () => {\n        this[kDirReadImpl](maybeSync, callback);\n      });\n      return;\n    }\n    if (this[kDirBufferedEntries].length > 0) {\n      const { 0: name, 1: type } = ArrayPrototypeSplice(this[kDirBufferedEntries], 0, 2);\n      if (maybeSync)\n        process.nextTick(getDirent, this[kDirPath], name, type, callback);\n      else\n        getDirent(this[kDirPath], name, type, callback);\n      return;\n    }\n    const req = new FSReqCallback();\n    req.oncomplete = (err, result) => {\n      process.nextTick(() => {\n        const queue = this[kDirOperationQueue];\n        this[kDirOperationQueue] = null;\n        for (const op of queue)\n          op();\n      });\n      if (err || result === null) {\n        return callback(err, result);\n      }\n      this[kDirBufferedEntries] = ArrayPrototypeSlice(result, 2);\n      getDirent(this[kDirPath], result[0], result[1], callback);\n    };\n    this[kDirOperationQueue] = [];\n    this[kDirHandle].read(this[kDirOptions].encoding, this[kDirOptions].bufferSize, req);\n  }\n  readSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n    if (this[kDirBufferedEntries].length > 0) {\n      const { 0: name, 1: type } = ArrayPrototypeSplice(this[kDirBufferedEntries], 0, 2);\n      return getDirent(this[kDirPath], name, type);\n    }\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].read(this[kDirOptions].encoding, this[kDirOptions].bufferSize, void 0, ctx);\n    handleErrorFromBinding(ctx);\n    if (result === null) {\n      return result;\n    }\n    this[kDirBufferedEntries] = ArrayPrototypeSlice(result, 2);\n    return getDirent(this[kDirPath], result[0], result[1]);\n  }\n  close(callback) {\n    if (callback === void 0) {\n      if (this[kDirClosed] === true) {\n        return PromiseReject(new ERR_DIR_CLOSED());\n      }\n      return this[kDirClosePromisified]();\n    }\n    validateCallback(callback);\n    if (this[kDirClosed] === true) {\n      process.nextTick(callback, new ERR_DIR_CLOSED());\n      return;\n    }\n    if (this[kDirOperationQueue] !== null) {\n      ArrayPrototypePush(this[kDirOperationQueue], () => {\n        this.close(callback);\n      });\n      return;\n    }\n    this[kDirClosed] = true;\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    this[kDirHandle].close(req);\n  }\n  closeSync() {\n    if (this[kDirClosed] === true) {\n      throw new ERR_DIR_CLOSED();\n    }\n    if (this[kDirOperationQueue] !== null) {\n      throw new ERR_DIR_CONCURRENT_OPERATION();\n    }\n    this[kDirClosed] = true;\n    const ctx = { path: this[kDirPath] };\n    const result = this[kDirHandle].close(void 0, ctx);\n    handleErrorFromBinding(ctx);\n    return result;\n  }\n  async *entries() {\n    try {\n      while (true) {\n        const result = await this[kDirReadPromisified]();\n        if (result === null) {\n          break;\n        }\n        yield result;\n      }\n    } finally {\n      await this[kDirClosePromisified]();\n    }\n  }\n}\nObjectDefineProperty(Dir.prototype, SymbolAsyncIterator, {\n  value: Dir.prototype.entries,\n  enumerable: false,\n  writable: true,\n  configurable: true\n});\nfunction opendir(path, options, callback) {\n  callback = typeof options === \"function\" ? options : callback;\n  validateCallback(callback);\n  path = getValidatedPath(path);\n  options = getOptions(options, {\n    encoding: \"utf8\"\n  });\n  function opendirCallback(error, handle) {\n    if (error) {\n      callback(error);\n    } else {\n      callback(null, new Dir(handle, path, options));\n    }\n  }\n  const req = new FSReqCallback();\n  req.oncomplete = opendirCallback;\n  dirBinding.opendir(pathModule.toNamespacedPath(path), options.encoding, req);\n}\nfunction opendirSync(path, options) {\n  path = getValidatedPath(path);\n  options = getOptions(options, {\n    encoding: \"utf8\"\n  });\n  const ctx = { path };\n  const handle = dirBinding.opendir(pathModule.toNamespacedPath(path), options.encoding, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return new Dir(handle, path, options);\n}\nmodule.exports = {\n  Dir,\n  opendir,\n  opendirSync\n};\n}"],["internal/fs/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  Error,\n  MathMax,\n  MathMin,\n  NumberIsSafeInteger,\n  Promise,\n  PromisePrototypeThen,\n  PromiseResolve,\n  PromiseReject,\n  SafeArrayIterator,\n  SafePromisePrototypeFinally,\n  Symbol,\n  Uint8Array\n} = primordials;\nconst {\n  F_OK,\n  O_SYMLINK,\n  O_WRONLY,\n  S_IFMT,\n  S_IFREG\n} = internalBinding(\"constants\").fs;\nconst binding = internalBinding(\"fs\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_STATE,\n    ERR_METHOD_NOT_IMPLEMENTED\n  },\n  AbortError,\n  aggregateTwoErrors\n} = require(\"internal/errors\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst { rimrafPromises } = require(\"internal/fs/rimraf\");\nconst {\n  constants: {\n    kIoMaxLength,\n    kMaxUserId,\n    kReadFileBufferLength,\n    kReadFileUnknownBufferLength,\n    kWriteFileMaxChunkSize\n  },\n  copyObject,\n  emitRecursiveRmdirWarning,\n  getDirents,\n  getOptions,\n  getStatsFromBinding,\n  getValidatedPath,\n  getValidMode,\n  nullCheck,\n  preprocessSymlinkDestination,\n  stringToFlags,\n  stringToSymlinkType,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateCpOptions,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validateRmOptions,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n} = require(\"internal/fs/utils\");\nconst { opendir } = require(\"internal/fs/dir\");\nconst {\n  parseFileMode,\n  validateAbortSignal,\n  validateBoolean,\n  validateBuffer,\n  validateEncoding,\n  validateInteger,\n  validateString\n} = require(\"internal/validators\");\nconst pathModule = require(\"path\");\nconst { lazyDOMException, promisify } = require(\"internal/util\");\nconst { EventEmitterMixin } = require(\"internal/event_target\");\nconst { watch } = require(\"internal/fs/watchers\");\nconst { isIterable } = require(\"internal/streams/utils\");\nconst assert = require(\"internal/assert\");\nconst kHandle = Symbol(\"kHandle\");\nconst kFd = Symbol(\"kFd\");\nconst kRefs = Symbol(\"kRefs\");\nconst kClosePromise = Symbol(\"kClosePromise\");\nconst kCloseResolve = Symbol(\"kCloseResolve\");\nconst kCloseReject = Symbol(\"kCloseReject\");\nconst kRef = Symbol(\"kRef\");\nconst kUnref = Symbol(\"kUnref\");\nconst kLocked = Symbol(\"kLocked\");\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable,\n  kDeserialize,\n  kTransfer,\n  kTransferList\n} = require(\"internal/worker/js_transferable\");\nconst {\n  newReadableStreamFromStreamBase\n} = require(\"internal/webstreams/adapters\");\nconst {\n  readableStreamCancel\n} = require(\"internal/webstreams/readablestream\");\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require(\"internal/fs/cp/cp\").cpFn;\n}\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n  get fd() {\n    return this[kFd];\n  }\n  appendFile(data, options) {\n    return fsCall(writeFile, this, data, options);\n  }\n  chmod(mode) {\n    return fsCall(fchmod, this, mode);\n  }\n  chown(uid, gid) {\n    return fsCall(fchown, this, uid, gid);\n  }\n  datasync() {\n    return fsCall(fdatasync, this);\n  }\n  sync() {\n    return fsCall(fsync, this);\n  }\n  read(buffer, offset, length, position) {\n    return fsCall(read, this, buffer, offset, length, position);\n  }\n  readv(buffers, position) {\n    return fsCall(readv, this, buffers, position);\n  }\n  readFile(options) {\n    return fsCall(readFile, this, options);\n  }\n  stat(options) {\n    return fsCall(fstat, this, options);\n  }\n  truncate(len = 0) {\n    return fsCall(ftruncate, this, len);\n  }\n  utimes(atime, mtime) {\n    return fsCall(futimes, this, atime, mtime);\n  }\n  write(buffer, offset, length, position) {\n    return fsCall(write, this, buffer, offset, length, position);\n  }\n  writev(buffers, position) {\n    return fsCall(writev, this, buffers, position);\n  }\n  writeFile(data, options) {\n    return fsCall(writeFile, this, data, options);\n  }\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(this[kHandle].close(), () => {\n        this[kClosePromise] = void 0;\n      });\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(new Promise((resolve, reject) => {\n        this[kCloseResolve] = resolve;\n        this[kCloseReject] = reject;\n      }), () => {\n        this[kClosePromise] = void 0;\n        this[kCloseReject] = void 0;\n        this[kCloseResolve] = void 0;\n      });\n    }\n    this.emit(\"close\");\n    return this[kClosePromise];\n  };\n  readableWebStream() {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE(\"The FileHandle is closed\");\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE(\"The FileHandle is closing\");\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE(\"The FileHandle is locked\");\n    this[kLocked] = true;\n    const readable = newReadableStreamFromStreamBase(this[kHandle], void 0, { ondone: () => this[kUnref]() });\n    this[kRef]();\n    this.once(\"close\", () => {\n      readableStreamCancel(readable);\n    });\n    return readable;\n  }\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException(\"Cannot transfer FileHandle while in use\", \"DataCloneError\");\n    }\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n    return {\n      data: { handle },\n      deserializeInfo: \"internal/fs/promises:FileHandle\"\n    };\n  }\n  [kTransferList]() {\n    return [this[kHandle]];\n  }\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n  [kRef]() {\n    this[kRefs]++;\n  }\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(this[kHandle].close(), this[kCloseResolve], this[kCloseReject]);\n    }\n  }\n}\nasync function handleFdClose(fileOpPromise, closeFunc) {\n  return PromisePrototypeThen(fileOpPromise, (result) => PromisePrototypeThen(closeFunc(), () => result), (opError) => PromisePrototypeThen(closeFunc(), () => PromiseReject(opError), (closeError) => PromiseReject(aggregateTwoErrors(closeError, opError))));\n}\nasync function fsCall(fn, handle, ...args) {\n  assert(handle[kRefs] !== void 0, \"handle must be an instance of FileHandle\");\n  if (handle.fd === -1) {\n    const err = new Error(\"file closed\");\n    err.code = \"EBADF\";\n    err.syscall = fn.name;\n    throw err;\n  }\n  try {\n    handle[kRef]();\n    return await fn(handle, ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError();\n}\nasync function writeFileHandle(filehandle, data, signal, encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite = isArrayBufferView(buf) ? buf : Buffer.from(buf, encoding || \"utf8\");\n      let remaining2 = toWrite.byteLength;\n      while (remaining2 > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize, remaining2);\n        const { bytesWritten } = await write(filehandle, toWrite, toWrite.byteLength - remaining2, writeSize);\n        remaining2 -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0)\n    return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } = await write(filehandle, data, 0, MathMin(kWriteFileMaxChunkSize, data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(data.buffer, data.byteOffset + bytesWritten, data.byteLength - bytesWritten);\n  } while (remaining > 0);\n}\nasync function readFileHandle(filehandle, options) {\n  const signal = options?.signal;\n  checkAborted(signal);\n  const statFields = await binding.fstat(filehandle.fd, false, kUsePromises);\n  checkAborted(signal);\n  let size;\n  if ((statFields[1] & S_IFMT) === S_IFREG) {\n    size = statFields[8];\n  } else {\n    size = 0;\n  }\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? void 0 : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead, kReadFileBufferLength);\n    }\n    const bytesRead = await binding.read(filehandle.fd, buffer, offset, length, -1, kUsePromises) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0, bytesRead);\n      ArrayPrototypePush(buffers, chunkBuffer);\n    }\n  } while (!endOfFile);\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0, totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers, totalRead);\n  }\n  return options.encoding ? result.toString(options.encoding) : result;\n}\nasync function access(path, mode = F_OK) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode, \"access\");\n  return binding.access(pathModule.toNamespacedPath(path), mode, kUsePromises);\n}\nasync function cp(src, dest, options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src, \"src\"));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest, \"dest\"));\n  return lazyLoadCpPromises()(src, dest, options);\n}\nasync function copyFile(src, dest, mode) {\n  src = getValidatedPath(src, \"src\");\n  dest = getValidatedPath(dest, \"dest\");\n  mode = getValidMode(mode, \"copyFile\");\n  return binding.copyFile(pathModule.toNamespacedPath(src), pathModule.toNamespacedPath(dest), mode, kUsePromises);\n}\nasync function open(path, flags, mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode, \"mode\", 438);\n  return new FileHandle(await binding.openFileHandle(pathModule.toNamespacedPath(path), flagsNumber, mode, kUsePromises));\n}\nasync function read(handle, bufferOrOptions, offset, length, position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions === void 0) {\n      bufferOrOptions = {};\n    }\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.byteLength;\n    position = bufferOrOptions.position || null;\n  }\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, \"offset\", 0);\n  }\n  length |= 0;\n  if (length === 0)\n    return { bytesRead: length, buffer };\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"buffer\", buffer, \"is empty and cannot be written\");\n  }\n  validateOffsetLengthRead(offset, length, buffer.byteLength);\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n  const bytesRead = await binding.read(handle.fd, buffer, offset, length, position, kUsePromises) || 0;\n  return { bytesRead, buffer };\n}\nasync function readv(handle, buffers, position) {\n  validateBufferArray(buffers);\n  if (typeof position !== \"number\")\n    position = null;\n  const bytesRead = await binding.readBuffers(handle.fd, buffers, position, kUsePromises) || 0;\n  return { bytesRead, buffers };\n}\nasync function write(handle, buffer, offset, length, position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0, buffer };\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset, \"offset\", 0);\n    }\n    if (typeof length !== \"number\")\n      length = buffer.byteLength - offset;\n    if (typeof position !== \"number\")\n      position = null;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    const bytesWritten2 = await binding.writeBuffer(handle.fd, buffer, offset, length, position, kUsePromises) || 0;\n    return { bytesWritten: bytesWritten2, buffer };\n  }\n  validateStringAfterArrayBufferView(buffer, \"buffer\");\n  validateEncoding(buffer, length);\n  const bytesWritten = await binding.writeString(handle.fd, buffer, offset, length, kUsePromises) || 0;\n  return { bytesWritten, buffer };\n}\nasync function writev(handle, buffers, position) {\n  validateBufferArray(buffers);\n  if (typeof position !== \"number\")\n    position = null;\n  const bytesWritten = await binding.writeBuffers(handle.fd, buffers, position, kUsePromises) || 0;\n  return { bytesWritten, buffers };\n}\nasync function rename(oldPath, newPath) {\n  oldPath = getValidatedPath(oldPath, \"oldPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  return binding.rename(pathModule.toNamespacedPath(oldPath), pathModule.toNamespacedPath(newPath), kUsePromises);\n}\nasync function truncate(path, len = 0) {\n  const fd = await open(path, \"r+\");\n  return handleFdClose(ftruncate(fd, len), fd.close);\n}\nasync function ftruncate(handle, len = 0) {\n  validateInteger(len, \"len\");\n  len = MathMax(0, len);\n  return binding.ftruncate(handle.fd, len, kUsePromises);\n}\nasync function rm(path, options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path, options, false);\n  return rimrafPromises(path, options);\n}\nasync function rmdir(path, options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path, options);\n    }\n  }\n  return binding.rmdir(path, kUsePromises);\n}\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd, kUsePromises);\n}\nasync function fsync(handle) {\n  return binding.fsync(handle.fd, kUsePromises);\n}\nasync function mkdir(path, options) {\n  if (typeof options === \"number\" || typeof options === \"string\") {\n    options = { mode: options };\n  }\n  const {\n    recursive = false,\n    mode = 511\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive, \"options.recursive\");\n  return binding.mkdir(pathModule.toNamespacedPath(path), parseFileMode(mode, \"mode\", 511), recursive, kUsePromises);\n}\nasync function readdir(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path), options.encoding, !!options.withFileTypes, kUsePromises);\n  return options.withFileTypes ? getDirectoryEntriesPromise(path, result) : result;\n}\nasync function readlink(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path, \"oldPath\");\n  return binding.readlink(pathModule.toNamespacedPath(path), options.encoding, kUsePromises);\n}\nasync function symlink(target, path, type_) {\n  const type = typeof type_ === \"string\" ? type_ : null;\n  target = getValidatedPath(target, \"target\");\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target, type, path), pathModule.toNamespacedPath(path), stringToSymlinkType(type), kUsePromises);\n}\nasync function fstat(handle, options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd, options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\nasync function lstat(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path), options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\nasync function stat(path, options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path), options.bigint, kUsePromises);\n  return getStatsFromBinding(result);\n}\nasync function link(existingPath, newPath) {\n  existingPath = getValidatedPath(existingPath, \"existingPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  return binding.link(pathModule.toNamespacedPath(existingPath), pathModule.toNamespacedPath(newPath), kUsePromises);\n}\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n}\nasync function fchmod(handle, mode) {\n  mode = parseFileMode(mode, \"mode\");\n  return binding.fchmod(handle.fd, mode, kUsePromises);\n}\nasync function chmod(path, mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, \"mode\");\n  return binding.chmod(pathModule.toNamespacedPath(path), mode, kUsePromises);\n}\nasync function lchmod(path, mode) {\n  if (O_SYMLINK === void 0)\n    throw new ERR_METHOD_NOT_IMPLEMENTED(\"lchmod()\");\n  const fd = await open(path, O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd, mode), fd.close);\n}\nasync function lchown(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path), uid, gid, kUsePromises);\n}\nasync function fchown(handle, uid, gid) {\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  return binding.fchown(handle.fd, uid, gid, kUsePromises);\n}\nasync function chown(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path), uid, gid, kUsePromises);\n}\nasync function utimes(path, atime, mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), kUsePromises);\n}\nasync function futimes(handle, atime, mtime) {\n  atime = toUnixTimestamp(atime, \"atime\");\n  mtime = toUnixTimestamp(mtime, \"mtime\");\n  return binding.futimes(handle.fd, atime, mtime, kUsePromises);\n}\nasync function lutimes(path, atime, mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), kUsePromises);\n}\nasync function realpath(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  return binding.realpath(path, options.encoding, kUsePromises);\n}\nasync function mkdtemp(prefix, options) {\n  options = getOptions(options, {});\n  validateString(prefix, \"prefix\");\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, kUsePromises);\n}\nasync function writeFile(path, data, options) {\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"w\" });\n  const flag = options.flag || \"w\";\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data, \"data\");\n    data = Buffer.from(data, options.encoding || \"utf8\");\n  }\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path, data, options.signal, options.encoding);\n  checkAborted(options.signal);\n  const fd = await open(path, flag, options.mode);\n  return handleFdClose(writeFileHandle(fd, data, options.signal, options.encoding), fd.close);\n}\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== \"string\";\n}\nasync function appendFile(path, data, options) {\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"a\" });\n  options = copyObject(options);\n  options.flag = options.flag || \"a\";\n  return writeFile(path, data, options);\n}\nasync function readFile(path, options) {\n  options = getOptions(options, { flag: \"r\" });\n  const flag = options.flag || \"r\";\n  if (path instanceof FileHandle)\n    return readFileHandle(path, options);\n  checkAborted(options.signal);\n  const fd = await open(path, flag, 438);\n  return handleFdClose(readFileHandle(fd, options), fd.close);\n}\nmodule.exports = {\n  exports: {\n    access,\n    copyFile,\n    cp,\n    open,\n    opendir: promisify(opendir),\n    rename,\n    truncate,\n    rm,\n    rmdir,\n    mkdir,\n    readdir,\n    readlink,\n    symlink,\n    lstat,\n    stat,\n    link,\n    unlink,\n    chmod,\n    lchmod,\n    lchown,\n    chown,\n    utimes,\n    lutimes,\n    realpath,\n    mkdtemp,\n    writeFile,\n    appendFile,\n    readFile,\n    watch\n  },\n  FileHandle,\n  kRef,\n  kUnref\n};\n}"],["internal/fs/read_file_context.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  MathMin,\n  ReflectApply\n} = primordials;\nconst {\n  constants: {\n    kReadFileBufferLength,\n    kReadFileUnknownBufferLength\n  }\n} = require(\"internal/fs/utils\");\nconst { Buffer } = require(\"buffer\");\nconst { FSReqCallback, close, read } = internalBinding(\"fs\");\nconst {\n  AbortError,\n  aggregateTwoErrors\n} = require(\"internal/errors\");\nfunction readFileAfterRead(err, bytesRead) {\n  const context = this.context;\n  if (err)\n    return context.close(err);\n  context.pos += bytesRead;\n  if (context.pos === context.size || bytesRead === 0) {\n    context.close();\n  } else {\n    if (context.size === 0) {\n      const buffer = bytesRead === kReadFileUnknownBufferLength ? context.buffer : context.buffer.slice(0, bytesRead);\n      ArrayPrototypePush(context.buffers, buffer);\n    }\n    context.read();\n  }\n}\nfunction readFileAfterClose(err) {\n  const context = this.context;\n  const callback = context.callback;\n  let buffer = null;\n  if (context.err || err)\n    return callback(aggregateTwoErrors(err, context.err));\n  try {\n    if (context.size === 0)\n      buffer = Buffer.concat(context.buffers, context.pos);\n    else if (context.pos < context.size)\n      buffer = context.buffer.slice(0, context.pos);\n    else\n      buffer = context.buffer;\n    if (context.encoding)\n      buffer = buffer.toString(context.encoding);\n  } catch (err2) {\n    return callback(err2);\n  }\n  callback(null, buffer);\n}\nclass ReadFileContext {\n  constructor(callback, encoding) {\n    this.fd = void 0;\n    this.isUserFd = void 0;\n    this.size = 0;\n    this.callback = callback;\n    this.buffers = null;\n    this.buffer = null;\n    this.pos = 0;\n    this.encoding = encoding;\n    this.err = null;\n    this.signal = void 0;\n  }\n  read() {\n    let buffer;\n    let offset;\n    let length;\n    if (this.signal?.aborted) {\n      return this.close(new AbortError());\n    }\n    if (this.size === 0) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n      this.buffer = buffer;\n    } else {\n      buffer = this.buffer;\n      offset = this.pos;\n      length = MathMin(kReadFileBufferLength, this.size - this.pos);\n    }\n    const req = new FSReqCallback();\n    req.oncomplete = readFileAfterRead;\n    req.context = this;\n    read(this.fd, buffer, offset, length, -1, req);\n  }\n  close(err) {\n    if (this.isUserFd) {\n      process.nextTick(function tick(context) {\n        ReflectApply(readFileAfterClose, { context }, [null]);\n      }, this);\n      return;\n    }\n    const req = new FSReqCallback();\n    req.oncomplete = readFileAfterClose;\n    req.context = this;\n    this.err = err;\n    close(this.fd, req);\n  }\n}\nmodule.exports = ReadFileContext;\n}"],["internal/fs/rimraf.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  Promise,\n  SafeSet\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst fs = require(\"fs\");\nconst {\n  chmod,\n  chmodSync,\n  lstat,\n  lstatSync,\n  readdir,\n  readdirSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  unlink,\n  unlinkSync\n} = fs;\nconst { sep } = require(\"path\");\nconst { setTimeout } = require(\"timers\");\nconst { sleep } = require(\"internal/util\");\nconst notEmptyErrorCodes = new SafeSet([\"ENOTEMPTY\", \"EEXIST\", \"EPERM\"]);\nconst retryErrorCodes = new SafeSet([\"EBUSY\", \"EMFILE\", \"ENFILE\", \"ENOTEMPTY\", \"EPERM\"]);\nconst isWindows = process.platform === \"win32\";\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = \"buffer\";\nconst separator = Buffer.from(sep);\nfunction rimraf(path, options, callback) {\n  let retries = 0;\n  _rimraf(path, options, function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf, delay, path, options, CB);\n      }\n      if (err.code === \"ENOENT\")\n        err = null;\n    }\n    callback(err);\n  });\n}\nfunction _rimraf(path, options, callback) {\n  lstat(path, (err, stats) => {\n    if (err) {\n      if (err.code === \"ENOENT\")\n        return callback(null);\n      if (isWindows && err.code === \"EPERM\")\n        return fixWinEPERM(path, options, err, callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path, options, err, callback);\n    }\n    unlink(path, (err2) => {\n      if (err2) {\n        if (err2.code === \"ENOENT\")\n          return callback(null);\n        if (err2.code === \"EISDIR\")\n          return _rmdir(path, options, err2, callback);\n        if (err2.code === \"EPERM\") {\n          return epermHandler(path, options, err2, callback);\n        }\n      }\n      return callback(err2);\n    });\n  });\n}\nfunction fixWinEPERM(path, options, originalErr, callback) {\n  chmod(path, 438, (err) => {\n    if (err)\n      return callback(err.code === \"ENOENT\" ? null : originalErr);\n    stat(path, (err2, stats) => {\n      if (err2)\n        return callback(err2.code === \"ENOENT\" ? null : originalErr);\n      if (stats.isDirectory())\n        _rmdir(path, options, originalErr, callback);\n      else\n        unlink(path, callback);\n    });\n  });\n}\nfunction _rmdir(path, options, originalErr, callback) {\n  rmdir(path, (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path, options, callback);\n      if (err.code === \"ENOTDIR\")\n        return callback(originalErr);\n    }\n    callback(err);\n  });\n}\nfunction _rmchildren(path, options, callback) {\n  const pathBuf = Buffer.from(path);\n  readdir(pathBuf, readdirEncoding, (err, files) => {\n    if (err)\n      return callback(err);\n    let numFiles = files.length;\n    if (numFiles === 0)\n      return rmdir(path, callback);\n    let done = false;\n    ArrayPrototypeForEach(files, (child) => {\n      const childPath = Buffer.concat([pathBuf, separator, child]);\n      rimraf(childPath, options, (err2) => {\n        if (done)\n          return;\n        if (err2) {\n          done = true;\n          return callback(err2);\n        }\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path, callback);\n      });\n    });\n  });\n}\nfunction rimrafPromises(path, options) {\n  return new Promise((resolve, reject) => {\n    rimraf(path, options, (err) => {\n      if (err)\n        return reject(err);\n      resolve();\n    });\n  });\n}\nfunction rimrafSync(path, options) {\n  let stats;\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    if (isWindows && err.code === \"EPERM\")\n      fixWinEPERMSync(path, options, err);\n  }\n  try {\n    if (stats?.isDirectory())\n      _rmdirSync(path, options, null);\n    else\n      _unlinkSync(path, options);\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    if (err.code === \"EPERM\")\n      return epermHandlerSync(path, options, err);\n    if (err.code !== \"EISDIR\")\n      throw err;\n    _rmdirSync(path, options, err);\n  }\n}\nfunction _unlinkSync(path, options) {\n  const tries = options.maxRetries + 1;\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      if (retryErrorCodes.has(err.code) && i < tries && options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === \"ENOENT\") {\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\nfunction _rmdirSync(path, options, originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    if (err.code === \"ENOTDIR\") {\n      throw originalErr || err;\n    }\n    if (notEmptyErrorCodes.has(err.code)) {\n      const pathBuf = Buffer.from(path);\n      ArrayPrototypeForEach(readdirSync(pathBuf, readdirEncoding), (child) => {\n        const childPath = Buffer.concat([pathBuf, separator, child]);\n        rimrafSync(childPath, options);\n      });\n      const tries = options.maxRetries + 1;\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err2) {\n          if (retryErrorCodes.has(err2.code) && i < tries && options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err2.code === \"ENOENT\") {\n            return;\n          } else if (i === tries) {\n            throw err2;\n          }\n        }\n      }\n    }\n    throw originalErr || err;\n  }\n}\nfunction fixWinEPERMSync(path, options, originalErr) {\n  try {\n    chmodSync(path, 438);\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    throw originalErr;\n  }\n  let stats;\n  try {\n    stats = statSync(path, { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n  if (stats === void 0)\n    return;\n  if (stats.isDirectory())\n    _rmdirSync(path, options, originalErr);\n  else\n    _unlinkSync(path, options);\n}\nmodule.exports = { rimraf, rimrafPromises, rimrafSync };\n}"],["internal/fs/streams.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  FunctionPrototypeBind,\n  MathMin,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  PromisePrototypeThen,\n  ReflectApply,\n  Symbol\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE,\n  ERR_METHOD_NOT_IMPLEMENTED\n} = require(\"internal/errors\").codes;\nconst { deprecate } = require(\"internal/util\");\nconst {\n  validateFunction,\n  validateInteger\n} = require(\"internal/validators\");\nconst { errorOrDestroy } = require(\"internal/streams/destroy\");\nconst fs = require(\"fs\");\nconst { kRef, kUnref, FileHandle } = require(\"internal/fs/promises\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  copyObject,\n  getOptions,\n  getValidatedFd,\n  validatePath\n} = require(\"internal/fs/utils\");\nconst { Readable, Writable, finished } = require(\"stream\");\nconst { toPathIfFileURL } = require(\"internal/url\");\nconst kIoDone = Symbol(\"kIoDone\");\nconst kIsPerformingIO = Symbol(\"kIsPerformingIO\");\nconst kFs = Symbol(\"kFs\");\nconst kHandle = Symbol(\"kHandle\");\nfunction _construct(callback) {\n  const stream = this;\n  if (typeof stream.fd === \"number\") {\n    callback();\n    return;\n  }\n  if (stream.open !== openWriteFs && stream.open !== openReadFs) {\n    const orgEmit = stream.emit;\n    stream.emit = function(...args) {\n      if (args[0] === \"open\") {\n        this.emit = orgEmit;\n        callback();\n        ReflectApply(orgEmit, this, args);\n      } else if (args[0] === \"error\") {\n        this.emit = orgEmit;\n        callback(args[1]);\n      } else {\n        ReflectApply(orgEmit, this, args);\n      }\n    };\n    stream.open();\n  } else {\n    stream[kFs].open(stream.path, stream.flags, stream.mode, (er, fd) => {\n      if (er) {\n        callback(er);\n      } else {\n        stream.fd = fd;\n        callback();\n        stream.emit(\"open\", stream.fd);\n        stream.emit(\"ready\");\n      }\n    });\n  }\n}\nconst FileHandleOperations = (handle) => {\n  return {\n    open: (path, flags, mode, cb) => {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"open()\");\n    },\n    close: (fd, cb) => {\n      handle[kUnref]();\n      PromisePrototypeThen(handle.close(), () => cb(), cb);\n    },\n    read: (fd, buf, offset, length, pos, cb) => {\n      PromisePrototypeThen(handle.read(buf, offset, length, pos), (r) => cb(null, r.bytesRead, r.buffer), (err) => cb(err, 0, buf));\n    },\n    write: (fd, buf, offset, length, pos, cb) => {\n      PromisePrototypeThen(handle.write(buf, offset, length, pos), (r) => cb(null, r.bytesWritten, r.buffer), (err) => cb(err, 0, buf));\n    },\n    writev: (fd, buffers, pos, cb) => {\n      PromisePrototypeThen(handle.writev(buffers, pos), (r) => cb(null, r.bytesWritten, r.buffers), (err) => cb(err, 0, buffers));\n    }\n  };\n};\nfunction close(stream, err, cb) {\n  if (!stream.fd) {\n    cb(err);\n  } else {\n    stream[kFs].close(stream.fd, (er) => {\n      stream.closed = true;\n      cb(er || err);\n    });\n    stream.fd = null;\n  }\n}\nfunction importFd(stream, options) {\n  if (typeof options.fd === \"number\") {\n    stream[kFs] = options.fs || fs;\n    return options.fd;\n  } else if (typeof options.fd === \"object\" && options.fd instanceof FileHandle) {\n    if (options.fs) {\n      throw new ERR_METHOD_NOT_IMPLEMENTED(\"FileHandle with fs\");\n    }\n    stream[kHandle] = options.fd;\n    stream[kFs] = FileHandleOperations(stream[kHandle]);\n    stream[kHandle][kRef]();\n    options.fd.on(\"close\", FunctionPrototypeBind(stream.close, stream));\n    return options.fd.fd;\n  }\n  throw ERR_INVALID_ARG_TYPE(\"options.fd\", [\"number\", \"FileHandle\"], options.fd);\n}\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n  options = copyObject(getOptions(options, {}));\n  if (options.highWaterMark === void 0)\n    options.highWaterMark = 64 * 1024;\n  if (options.autoDestroy === void 0) {\n    options.autoDestroy = false;\n  }\n  if (options.fd == null) {\n    this.fd = null;\n    this[kFs] = options.fs || fs;\n    validateFunction(this[kFs].open, \"options.fs.open\");\n    this.path = toPathIfFileURL(path);\n    this.flags = options.flags === void 0 ? \"r\" : options.flags;\n    this.mode = options.mode === void 0 ? 438 : options.mode;\n    validatePath(this.path);\n  } else {\n    this.fd = getValidatedFd(importFd(this, options));\n  }\n  options.autoDestroy = options.autoClose === void 0 ? true : options.autoClose;\n  validateFunction(this[kFs].read, \"options.fs.read\");\n  if (options.autoDestroy) {\n    validateFunction(this[kFs].close, \"options.fs.close\");\n  }\n  this.start = options.start;\n  this.end = options.end;\n  this.pos = void 0;\n  this.bytesRead = 0;\n  this.closed = false;\n  this[kIsPerformingIO] = false;\n  if (this.start !== void 0) {\n    validateInteger(this.start, \"start\", 0);\n    this.pos = this.start;\n  }\n  if (this.end === void 0) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    validateInteger(this.end, \"end\", 0);\n    if (this.start !== void 0 && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\"start\", `<= \"end\" (here: ${this.end})`, this.start);\n    }\n  }\n  ReflectApply(Readable, this, [options]);\n}\nObjectSetPrototypeOf(ReadStream.prototype, Readable.prototype);\nObjectSetPrototypeOf(ReadStream, Readable);\nObjectDefineProperty(ReadStream.prototype, \"autoClose\", {\n  get() {\n    return this._readableState.autoDestroy;\n  },\n  set(val) {\n    this._readableState.autoDestroy = val;\n  }\n});\nconst openReadFs = deprecate(function() {\n}, \"ReadStream.prototype.open() is deprecated\", \"DEP0135\");\nReadStream.prototype.open = openReadFs;\nReadStream.prototype._construct = _construct;\nReadStream.prototype._read = function(n) {\n  n = this.pos !== void 0 ? MathMin(this.end - this.pos + 1, n) : MathMin(this.end - this.bytesRead + 1, n);\n  if (n <= 0) {\n    this.push(null);\n    return;\n  }\n  const buf = Buffer.allocUnsafeSlow(n);\n  this[kIsPerformingIO] = true;\n  this[kFs].read(this.fd, buf, 0, n, this.pos, (er, bytesRead, buf2) => {\n    this[kIsPerformingIO] = false;\n    if (this.destroyed) {\n      this.emit(kIoDone, er);\n      return;\n    }\n    if (er) {\n      errorOrDestroy(this, er);\n    } else if (bytesRead > 0) {\n      if (this.pos !== void 0) {\n        this.pos += bytesRead;\n      }\n      this.bytesRead += bytesRead;\n      if (bytesRead !== buf2.length) {\n        const dst = Buffer.allocUnsafeSlow(bytesRead);\n        buf2.copy(dst, 0, 0, bytesRead);\n        buf2 = dst;\n      }\n      this.push(buf2);\n    } else {\n      this.push(null);\n    }\n  });\n};\nReadStream.prototype._destroy = function(err, cb) {\n  if (this[kIsPerformingIO]) {\n    this.once(kIoDone, (er) => close(this, err || er, cb));\n  } else {\n    close(this, err, cb);\n  }\n};\nReadStream.prototype.close = function(cb) {\n  if (typeof cb === \"function\")\n    finished(this, cb);\n  this.destroy();\n};\nObjectDefineProperty(ReadStream.prototype, \"pending\", {\n  get() {\n    return this.fd === null;\n  },\n  configurable: true\n});\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n  options = copyObject(getOptions(options, {}));\n  options.decodeStrings = true;\n  if (options.fd == null) {\n    this.fd = null;\n    this[kFs] = options.fs || fs;\n    validateFunction(this[kFs].open, \"options.fs.open\");\n    this.path = toPathIfFileURL(path);\n    this.flags = options.flags === void 0 ? \"w\" : options.flags;\n    this.mode = options.mode === void 0 ? 438 : options.mode;\n    validatePath(this.path);\n  } else {\n    this.fd = getValidatedFd(importFd(this, options));\n  }\n  options.autoDestroy = options.autoClose === void 0 ? true : options.autoClose;\n  if (!this[kFs].write && !this[kFs].writev) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.fs.write\", \"function\", this[kFs].write);\n  }\n  if (this[kFs].write) {\n    validateFunction(this[kFs].write, \"options.fs.write\");\n  }\n  if (this[kFs].writev) {\n    validateFunction(this[kFs].writev, \"options.fs.writev\");\n  }\n  if (options.autoDestroy) {\n    validateFunction(this[kFs].close, \"options.fs.close\");\n  }\n  if (!this[kFs].write) {\n    this._write = null;\n  }\n  if (!this[kFs].writev) {\n    this._writev = null;\n  }\n  this.start = options.start;\n  this.pos = void 0;\n  this.bytesWritten = 0;\n  this.closed = false;\n  this[kIsPerformingIO] = false;\n  if (this.start !== void 0) {\n    validateInteger(this.start, \"start\", 0);\n    this.pos = this.start;\n  }\n  ReflectApply(Writable, this, [options]);\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n}\nObjectSetPrototypeOf(WriteStream.prototype, Writable.prototype);\nObjectSetPrototypeOf(WriteStream, Writable);\nObjectDefineProperty(WriteStream.prototype, \"autoClose\", {\n  get() {\n    return this._writableState.autoDestroy;\n  },\n  set(val) {\n    this._writableState.autoDestroy = val;\n  }\n});\nconst openWriteFs = deprecate(function() {\n}, \"WriteStream.prototype.open() is deprecated\", \"DEP0135\");\nWriteStream.prototype.open = openWriteFs;\nWriteStream.prototype._construct = _construct;\nWriteStream.prototype._write = function(data, encoding, cb) {\n  this[kIsPerformingIO] = true;\n  this[kFs].write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {\n    this[kIsPerformingIO] = false;\n    if (this.destroyed) {\n      cb(er);\n      return this.emit(kIoDone, er);\n    }\n    if (er) {\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n  if (this.pos !== void 0)\n    this.pos += data.length;\n};\nWriteStream.prototype._writev = function(data, cb) {\n  const len = data.length;\n  const chunks = new Array(len);\n  let size = 0;\n  for (let i = 0; i < len; i++) {\n    const chunk = data[i].chunk;\n    chunks[i] = chunk;\n    size += chunk.length;\n  }\n  this[kIsPerformingIO] = true;\n  this[kFs].writev(this.fd, chunks, this.pos, (er, bytes) => {\n    this[kIsPerformingIO] = false;\n    if (this.destroyed) {\n      cb(er);\n      return this.emit(kIoDone, er);\n    }\n    if (er) {\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n  if (this.pos !== void 0)\n    this.pos += size;\n};\nWriteStream.prototype._destroy = function(err, cb) {\n  if (this[kIsPerformingIO]) {\n    this.once(kIoDone, (er) => close(this, err || er, cb));\n  } else {\n    close(this, err, cb);\n  }\n};\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on(\"close\", cb);\n  }\n  if (!this.autoClose) {\n    this.on(\"finish\", this.destroy);\n  }\n  this.end();\n};\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nObjectDefineProperty(WriteStream.prototype, \"pending\", {\n  get() {\n    return this.fd === null;\n  },\n  configurable: true\n});\nmodule.exports = {\n  ReadStream,\n  WriteStream\n};\n}"],["internal/fs/sync_write_stream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  ReflectApply\n} = primordials;\nconst { Writable } = require(\"stream\");\nconst { closeSync, writeSync } = require(\"fs\");\nfunction SyncWriteStream(fd, options) {\n  ReflectApply(Writable, this, [{ autoDestroy: true }]);\n  options = options || {};\n  this.fd = fd;\n  this.readable = false;\n  this.autoClose = options.autoClose === void 0 ? true : options.autoClose;\n}\nObjectSetPrototypeOf(SyncWriteStream.prototype, Writable.prototype);\nObjectSetPrototypeOf(SyncWriteStream, Writable);\nSyncWriteStream.prototype._write = function(chunk, encoding, cb) {\n  writeSync(this.fd, chunk, 0, chunk.length);\n  cb();\n  return true;\n};\nSyncWriteStream.prototype._destroy = function(err, cb) {\n  if (this.fd === null)\n    return cb(err);\n  if (this.autoClose)\n    closeSync(this.fd);\n  this.fd = null;\n  cb(err);\n};\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\nmodule.exports = SyncWriteStream;\n}"],["internal/fs/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  BigInt,\n  Date,\n  DateNow,\n  DatePrototypeGetTime,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeCall,\n  Number,\n  NumberIsFinite,\n  NumberIsInteger,\n  MathMin,\n  ObjectIs,\n  ObjectPrototypeHasOwnProperty,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  ReflectOwnKeys,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeReplace,\n  Symbol,\n  TypedArrayPrototypeIncludes\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  codes: {\n    ERR_FS_EISDIR,\n    ERR_FS_INVALID_SYMLINK_TYPE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE\n  },\n  hideStackFrames,\n  uvException\n} = require(\"internal/errors\");\nconst {\n  isArrayBufferView,\n  isUint8Array,\n  isDate,\n  isBigUint64Array\n} = require(\"internal/util/types\");\nconst { once } = require(\"internal/util\");\nconst { toPathIfFileURL } = require(\"internal/url\");\nconst {\n  validateAbortSignal,\n  validateBoolean,\n  validateFunction,\n  validateInt32,\n  validateInteger,\n  validateObject,\n  validateUint32\n} = require(\"internal/validators\");\nconst pathModule = require(\"path\");\nconst kType = Symbol(\"type\");\nconst kStats = Symbol(\"stats\");\nconst assert = require(\"internal/assert\");\nconst {\n  fs: {\n    F_OK = 0,\n    W_OK = 0,\n    R_OK = 0,\n    X_OK = 0,\n    COPYFILE_EXCL,\n    COPYFILE_FICLONE,\n    COPYFILE_FICLONE_FORCE,\n    O_APPEND,\n    O_CREAT,\n    O_EXCL,\n    O_RDONLY,\n    O_RDWR,\n    O_SYNC,\n    O_TRUNC,\n    O_WRONLY,\n    S_IFBLK,\n    S_IFCHR,\n    S_IFDIR,\n    S_IFIFO,\n    S_IFLNK,\n    S_IFMT,\n    S_IFREG,\n    S_IFSOCK,\n    UV_FS_SYMLINK_DIR,\n    UV_FS_SYMLINK_JUNCTION,\n    UV_DIRENT_UNKNOWN,\n    UV_DIRENT_FILE,\n    UV_DIRENT_DIR,\n    UV_DIRENT_LINK,\n    UV_DIRENT_FIFO,\n    UV_DIRENT_SOCKET,\n    UV_DIRENT_CHAR,\n    UV_DIRENT_BLOCK\n  },\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding(\"constants\");\nconst kMinimumAccessMode = MathMin(F_OK, W_OK, R_OK, X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\nconst kDefaultCopyMode = 0;\nconst kMinimumCopyMode = MathMin(kDefaultCopyMode, COPYFILE_EXCL, COPYFILE_FICLONE, COPYFILE_FICLONE_FORCE);\nconst kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;\nconst kIoMaxLength = 2 ** 31 - 1;\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\nconst kWriteFileMaxChunkSize = 512 * 1024;\nconst kMaxUserId = 2 ** 32 - 1;\nconst isWindows = process.platform === \"win32\";\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require(\"fs\");\n  }\n  return fs;\n}\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = \"is invalid encoding\";\n    throw new ERR_INVALID_ARG_VALUE(encoding, \"encoding\", reason);\n  }\n}\nclass Dirent {\n  constructor(name, type) {\n    this.name = name;\n    this[kType] = type;\n  }\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\nclass DirentFromStats extends Dirent {\n  constructor(name, stats) {\n    super(name, null);\n    this[kStats] = stats;\n  }\n}\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === \"constructor\") {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\nconst bufferSep = Buffer.from(pathModule.sep);\nfunction join(path, name) {\n  if ((typeof path === \"string\" || isUint8Array(path)) && name === void 0) {\n    return path;\n  }\n  if (typeof path === \"string\" && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path, pathModule.sep));\n    return Buffer.concat([pathBuffer, name]);\n  }\n  if (typeof path === \"string\" && typeof name === \"string\") {\n    return pathModule.join(path, name);\n  }\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path, bufferSep, name]);\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"path\", [\"string\", \"Buffer\"], path);\n}\nfunction getDirents(path, { 0: names, 1: types }, callback) {\n  let i;\n  if (typeof callback === \"function\") {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path, name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath, (err, stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name, stats);\n          if (--toFinish === 0) {\n            callback(null, names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i], types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null, names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path, names[i], types[i]);\n    }\n    return names;\n  }\n}\nfunction getDirent(path, name, type, callback) {\n  if (typeof callback === \"function\") {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path, name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath, (err, stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null, new DirentFromStats(name, stats));\n      });\n    } else {\n      callback(null, new Dirent(name, type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path, name));\n    return new DirentFromStats(name, stats);\n  } else {\n    return new Dirent(name, type);\n  }\n}\nfunction getOptions(options, defaultOptions) {\n  if (options === null || options === void 0 || typeof options === \"function\") {\n    return defaultOptions;\n  }\n  if (typeof options === \"string\") {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options\", [\"string\", \"Object\"], options);\n  }\n  if (options.encoding !== \"buffer\")\n    assertEncoding(options.encoding);\n  if (options.signal !== void 0) {\n    validateAbortSignal(options.signal, \"options.signal\");\n  }\n  return options;\n}\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== void 0) {\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err, handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== void 0) {\n    ErrorCaptureStackTrace(ctx.error, handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\nconst nullCheck = hideStackFrames((path, propName, throwError = true) => {\n  const pathIsString = typeof path === \"string\";\n  const pathIsUint8Array = isUint8Array(path);\n  if (!pathIsString && !pathIsUint8Array || pathIsString && !StringPrototypeIncludes(path, \"\\0\") || pathIsUint8Array && !TypedArrayPrototypeIncludes(path, 0)) {\n    return;\n  }\n  const err = new ERR_INVALID_ARG_VALUE(propName, path, \"must be a string or Uint8Array without null bytes\");\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\nfunction preprocessSymlinkDestination(path, type, linkPath) {\n  if (!isWindows) {\n    return path;\n  }\n  path = \"\" + path;\n  if (type === \"junction\") {\n    path = pathModule.resolve(linkPath, \"..\", path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    return pathModule.toNamespacedPath(path);\n  }\n  return StringPrototypeReplace(path, /\\//g, \"\\\\\");\n}\nfunction StatsBase(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec, nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\nfunction nsFromTimeSpecBigInt(sec, nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\nfunction BigIntStats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {\n  ReflectApply(StatsBase, this, [\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks\n  ]);\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\nObjectSetPrototypeOf(BigIntStats.prototype, StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats, StatsBase);\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {\n    return false;\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\nfunction Stats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\n  FunctionPrototypeCall(StatsBase, this, dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\nObjectSetPrototypeOf(Stats.prototype, StatsBase.prototype);\nObjectSetPrototypeOf(Stats, StatsBase);\nStats.prototype.isFile = StatsBase.prototype.isFile;\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {\n    return false;\n  }\n  return (this.mode & S_IFMT) === property;\n};\nfunction getStatsFromBinding(stats, offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]), nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]), nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]), nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]));\n  }\n  return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], msFromTimeSpec(stats[10 + offset], stats[11 + offset]), msFromTimeSpec(stats[12 + offset], stats[13 + offset]), msFromTimeSpec(stats[14 + offset], stats[15 + offset]), msFromTimeSpec(stats[16 + offset], stats[17 + offset]));\n}\nfunction stringToFlags(flags, name = \"flags\") {\n  if (typeof flags === \"number\") {\n    validateInt32(flags, name);\n    return flags;\n  }\n  if (flags == null) {\n    return O_RDONLY;\n  }\n  switch (flags) {\n    case \"r\":\n      return O_RDONLY;\n    case \"rs\":\n    case \"sr\":\n      return O_RDONLY | O_SYNC;\n    case \"r+\":\n      return O_RDWR;\n    case \"rs+\":\n    case \"sr+\":\n      return O_RDWR | O_SYNC;\n    case \"w\":\n      return O_TRUNC | O_CREAT | O_WRONLY;\n    case \"wx\":\n    case \"xw\":\n      return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n    case \"w+\":\n      return O_TRUNC | O_CREAT | O_RDWR;\n    case \"wx+\":\n    case \"xw+\":\n      return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n    case \"a\":\n      return O_APPEND | O_CREAT | O_WRONLY;\n    case \"ax\":\n    case \"xa\":\n      return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case \"as\":\n    case \"sa\":\n      return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n    case \"a+\":\n      return O_APPEND | O_CREAT | O_RDWR;\n    case \"ax+\":\n    case \"xa+\":\n      return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case \"as+\":\n    case \"sa+\":\n      return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n  throw new ERR_INVALID_ARG_VALUE(\"flags\", flags);\n}\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"dir\":\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case \"junction\":\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case \"file\":\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\nfunction toUnixTimestamp(time, name = \"time\") {\n  if (typeof time === \"string\" && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1e3;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    return DatePrototypeGetTime(time) / 1e3;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name, [\"Date\", \"Time in seconds\"], time);\n}\nconst validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength) => {\n  if (offset < 0) {\n    throw new ERR_OUT_OF_RANGE(\"offset\", \">= 0\", offset);\n  }\n  if (length < 0) {\n    throw new ERR_OUT_OF_RANGE(\"length\", \">= 0\", length);\n  }\n  if (offset + length > bufferLength) {\n    throw new ERR_OUT_OF_RANGE(\"length\", `<= ${bufferLength - offset}`, length);\n  }\n});\nconst validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength) => {\n  if (offset > byteLength) {\n    throw new ERR_OUT_OF_RANGE(\"offset\", `<= ${byteLength}`, offset);\n  }\n  if (length > byteLength - offset) {\n    throw new ERR_OUT_OF_RANGE(\"length\", `<= ${byteLength - offset}`, length);\n  }\n  if (length < 0) {\n    throw new ERR_OUT_OF_RANGE(\"length\", \">= 0\", length);\n  }\n  validateInt32(length, \"length\", 0);\n});\nconst validatePath = hideStackFrames((path, propName = \"path\") => {\n  if (typeof path !== \"string\" && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName, [\"string\", \"Buffer\", \"URL\"], path);\n  }\n  const err = nullCheck(path, propName, false);\n  if (err !== void 0) {\n    throw err;\n  }\n});\nconst getValidatedPath = hideStackFrames((fileURLOrPath, propName = \"path\") => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path, propName);\n  return path;\n});\nconst getValidatedFd = hideStackFrames((fd, propName = \"fd\") => {\n  if (ObjectIs(fd, -0)) {\n    return 0;\n  }\n  validateInt32(fd, propName, 0);\n  return fd;\n});\nconst validateBufferArray = hideStackFrames((buffers, propName = \"buffers\") => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName, \"ArrayBufferView[]\", buffers);\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName, \"ArrayBufferView[]\", buffers);\n  }\n  return buffers;\n});\nlet nonPortableTemplateWarn = true;\nfunction warnOnNonPortableTemplate(template) {\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template, \"X\")) {\n    process.emitWarning(\"mkdtemp() templates ending with X are not portable. For details see: https://nodejs.org/api/fs.html\");\n    nonPortableTemplateWarn = false;\n  }\n}\nconst defaultCpOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: void 0,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false\n};\nconst defaultRmOptions = {\n  recursive: false,\n  force: false,\n  retryDelay: 100,\n  maxRetries: 0\n};\nconst defaultRmdirOptions = {\n  retryDelay: 100,\n  maxRetries: 0,\n  recursive: false\n};\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === void 0)\n    return { ...defaultCpOptions };\n  validateObject(options, \"options\");\n  options = { ...defaultCpOptions, ...options };\n  validateBoolean(options.dereference, \"options.dereference\");\n  validateBoolean(options.errorOnExist, \"options.errorOnExist\");\n  validateBoolean(options.force, \"options.force\");\n  validateBoolean(options.preserveTimestamps, \"options.preserveTimestamps\");\n  validateBoolean(options.recursive, \"options.recursive\");\n  if (options.filter !== void 0) {\n    validateFunction(options.filter, \"options.filter\");\n  }\n  return options;\n});\nconst validateRmOptions = hideStackFrames((path, options, expectDir, cb) => {\n  options = validateRmdirOptions(options, defaultRmOptions);\n  validateBoolean(options.force, \"options.force\");\n  lazyLoadFs().stat(path, (err, stats) => {\n    if (err) {\n      if (options.force && err.code === \"ENOENT\") {\n        return cb(null, options);\n      }\n      return cb(err, options);\n    }\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: \"EISDIR\",\n        message: \"is a directory\",\n        path,\n        syscall: \"rm\",\n        errno: EISDIR\n      }));\n    }\n    return cb(null, options);\n  });\n});\nconst validateRmOptionsSync = hideStackFrames((path, options, expectDir) => {\n  options = validateRmdirOptions(options, defaultRmOptions);\n  validateBoolean(options.force, \"options.force\");\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs().statSync(path, { throwIfNoEntry: !options.force })?.isDirectory();\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: \"EISDIR\",\n        message: \"is a directory\",\n        path,\n        syscall: \"rm\",\n        errno: EISDIR\n      });\n    }\n  }\n  return options;\n});\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\"In future versions of Node.js, fs.rmdir(path, { recursive: true }) will be removed. Use fs.rm(path, { recursive: true }) instead\", \"DeprecationWarning\", \"DEP0147\");\n    recursiveRmdirWarned = true;\n  }\n}\nconst validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions) => {\n  if (options === void 0)\n    return defaults;\n  validateObject(options, \"options\");\n  options = { ...defaults, ...options };\n  validateBoolean(options.recursive, \"options.recursive\");\n  validateInt32(options.retryDelay, \"options.retryDelay\", 0);\n  validateUint32(options.maxRetries, \"options.maxRetries\");\n  return options;\n});\nconst getValidMode = hideStackFrames((mode, type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === \"copyFile\") {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === \"access\");\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== \"number\") {\n    throw new ERR_INVALID_ARG_TYPE(\"mode\", \"integer\", mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\"mode\", `an integer >= ${min} && <= ${max}`, mode);\n});\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer, name) => {\n  if (typeof buffer === \"string\") {\n    return;\n  }\n  if (typeof buffer === \"object\" && buffer !== null && typeof buffer.toString === \"function\" && ObjectPrototypeHasOwnProperty(buffer, \"toString\")) {\n    return;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name, [\"string\", \"Buffer\", \"TypedArray\", \"DataView\"], buffer);\n});\nconst validatePosition = hideStackFrames((position, name) => {\n  if (typeof position === \"number\") {\n    validateInteger(position, \"position\");\n  } else if (typeof position === \"bigint\") {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE(\"position\", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"position\", [\"integer\", \"bigint\"], position);\n  }\n});\nmodule.exports = {\n  constants: {\n    kIoMaxLength,\n    kMaxUserId,\n    kReadFileBufferLength,\n    kReadFileUnknownBufferLength,\n    kWriteFileMaxChunkSize\n  },\n  assertEncoding,\n  BigIntStats,\n  copyObject,\n  Dirent,\n  emitRecursiveRmdirWarning,\n  getDirent,\n  getDirents,\n  getOptions,\n  getValidatedFd,\n  getValidatedPath,\n  getValidMode,\n  handleErrorFromBinding,\n  nullCheck,\n  preprocessSymlinkDestination,\n  realpathCacheKey: Symbol(\"realpathCacheKey\"),\n  getStatsFromBinding,\n  stringToFlags,\n  stringToSymlinkType,\n  Stats,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateCpOptions,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validatePath,\n  validatePosition,\n  validateRmOptions,\n  validateRmOptionsSync,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n};\n}"],["internal/fs/watchers.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nconst {\n  AbortError,\n  uvException,\n  codes: {\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst { createDeferredPromise } = require(\"internal/util\");\nconst {\n  kFsStatsFieldsNumber,\n  StatWatcher: _StatWatcher\n} = internalBinding(\"fs\");\nconst { FSEvent } = internalBinding(\"fs_event_wrap\");\nconst { UV_ENOSPC } = internalBinding(\"uv\");\nconst { EventEmitter } = require(\"events\");\nconst {\n  getStatsFromBinding,\n  getValidatedPath\n} = require(\"internal/fs/utils\");\nconst {\n  defaultTriggerAsyncIdScope,\n  symbols: { owner_symbol }\n} = require(\"internal/async_hooks\");\nconst { toNamespacedPath } = require(\"path\");\nconst {\n  validateAbortSignal,\n  validateBoolean,\n  validateObject,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  Buffer: {\n    isEncoding\n  }\n} = require(\"buffer\");\nconst assert = require(\"internal/assert\");\nconst kOldStatus = Symbol(\"kOldStatus\");\nconst kUseBigint = Symbol(\"kUseBigint\");\nconst kFSWatchStart = Symbol(\"kFSWatchStart\");\nconst kFSStatWatcherStart = Symbol(\"kFSStatWatcherStart\");\nconst KFSStatWatcherRefCount = Symbol(\"KFSStatWatcherRefCount\");\nconst KFSStatWatcherMaxRefCount = Symbol(\"KFSStatWatcherMaxRefCount\");\nconst kFSStatWatcherAddOrCleanRef = Symbol(\"kFSStatWatcherAddOrCleanRef\");\nfunction emitStop(self) {\n  self.emit(\"stop\");\n}\nfunction StatWatcher(bigint) {\n  FunctionPrototypeCall(EventEmitter, this);\n  this._handle = null;\n  this[kOldStatus] = -1;\n  this[kUseBigint] = bigint;\n  this[KFSStatWatcherRefCount] = 1;\n  this[KFSStatWatcherMaxRefCount] = 1;\n}\nObjectSetPrototypeOf(StatWatcher.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(StatWatcher, EventEmitter);\nfunction onchange(newStatus, stats) {\n  const self = this[owner_symbol];\n  if (self[kOldStatus] === -1 && newStatus === -1 && stats[2] === stats[16]) {\n    return;\n  }\n  self[kOldStatus] = newStatus;\n  self.emit(\"change\", getStatsFromBinding(stats), getStatsFromBinding(stats, kFsStatsFieldsNumber));\n}\nStatWatcher.prototype[kFSStatWatcherStart] = function(filename, persistent, interval) {\n  if (this._handle !== null)\n    return;\n  this._handle = new _StatWatcher(this[kUseBigint]);\n  this._handle[owner_symbol] = this;\n  this._handle.onchange = onchange;\n  if (!persistent)\n    this.unref();\n  this[kOldStatus] = -1;\n  filename = getValidatedPath(filename, \"filename\");\n  validateUint32(interval, \"interval\");\n  const err = this._handle.start(toNamespacedPath(filename), interval);\n  if (err) {\n    const error = uvException({\n      errno: err,\n      syscall: \"watch\",\n      path: filename\n    });\n    error.filename = filename;\n    throw error;\n  }\n};\nStatWatcher.prototype.start = () => {\n};\nStatWatcher.prototype.stop = function() {\n  if (this._handle === null)\n    return;\n  defaultTriggerAsyncIdScope(this._handle.getAsyncId(), process.nextTick, emitStop, this);\n  this._handle.close();\n  this._handle = null;\n};\nStatWatcher.prototype[kFSStatWatcherAddOrCleanRef] = function(operate) {\n  if (operate === \"add\") {\n    this[KFSStatWatcherRefCount]++;\n    this[KFSStatWatcherMaxRefCount]++;\n  } else if (operate === \"clean\") {\n    this[KFSStatWatcherMaxRefCount]--;\n    this.unref();\n  } else if (operate === \"cleanAll\") {\n    this[KFSStatWatcherMaxRefCount] = 0;\n    this[KFSStatWatcherRefCount] = 0;\n    this._handle?.unref();\n  }\n};\nStatWatcher.prototype.ref = function() {\n  if (this[KFSStatWatcherRefCount] === this[KFSStatWatcherMaxRefCount])\n    return this;\n  if (this._handle && this[KFSStatWatcherRefCount]++ === 0)\n    this._handle.ref();\n  return this;\n};\nStatWatcher.prototype.unref = function() {\n  if (this[KFSStatWatcherRefCount] === 0)\n    return this;\n  if (this._handle && --this[KFSStatWatcherRefCount] === 0)\n    this._handle.unref();\n  return this;\n};\nfunction FSWatcher() {\n  FunctionPrototypeCall(EventEmitter, this);\n  this._handle = new FSEvent();\n  this._handle[owner_symbol] = this;\n  this._handle.onchange = (status, eventType, filename) => {\n    if (status < 0) {\n      if (this._handle !== null) {\n        this._handle.close();\n        this._handle = null;\n      }\n      const error = uvException({\n        errno: status,\n        syscall: \"watch\",\n        path: filename\n      });\n      error.filename = filename;\n      this.emit(\"error\", error);\n    } else {\n      this.emit(\"change\", eventType, filename);\n    }\n  };\n}\nObjectSetPrototypeOf(FSWatcher.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(FSWatcher, EventEmitter);\nFSWatcher.prototype[kFSWatchStart] = function(filename, persistent, recursive, encoding) {\n  if (this._handle === null) {\n    return;\n  }\n  assert(this._handle instanceof FSEvent, \"handle must be a FSEvent\");\n  if (this._handle.initialized) {\n    return;\n  }\n  filename = getValidatedPath(filename, \"filename\");\n  const err = this._handle.start(toNamespacedPath(filename), persistent, recursive, encoding);\n  if (err) {\n    const error = uvException({\n      errno: err,\n      syscall: \"watch\",\n      path: filename,\n      message: err === UV_ENOSPC ? \"System limit for number of file watchers reached\" : \"\"\n    });\n    error.filename = filename;\n    throw error;\n  }\n};\nFSWatcher.prototype.start = () => {\n};\nFSWatcher.prototype.close = function() {\n  if (this._handle === null) {\n    return;\n  }\n  assert(this._handle instanceof FSEvent, \"handle must be a FSEvent\");\n  if (!this._handle.initialized) {\n    return;\n  }\n  this._handle.close();\n  this._handle = null;\n  process.nextTick(emitCloseNT, this);\n};\nFSWatcher.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\nFSWatcher.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n  return this;\n};\nfunction emitCloseNT(self) {\n  self.emit(\"close\");\n}\nObjectDefineProperty(FSEvent.prototype, \"owner\", {\n  get() {\n    return this[owner_symbol];\n  },\n  set(v) {\n    return this[owner_symbol] = v;\n  }\n});\nasync function* watch(filename, options = {}) {\n  const path = toNamespacedPath(getValidatedPath(filename));\n  validateObject(options, \"options\");\n  const {\n    persistent = true,\n    recursive = false,\n    encoding = \"utf8\",\n    signal\n  } = options;\n  validateBoolean(persistent, \"options.persistent\");\n  validateBoolean(recursive, \"options.recursive\");\n  validateAbortSignal(signal, \"options.signal\");\n  if (encoding && !isEncoding(encoding)) {\n    const reason = \"is invalid encoding\";\n    throw new ERR_INVALID_ARG_VALUE(encoding, \"encoding\", reason);\n  }\n  if (signal?.aborted)\n    throw new AbortError();\n  const handle = new FSEvent();\n  let { promise, resolve, reject } = createDeferredPromise();\n  const oncancel = () => {\n    handle.close();\n    reject(new AbortError());\n  };\n  try {\n    signal?.addEventListener(\"abort\", oncancel, { once: true });\n    handle.onchange = (status, eventType, filename2) => {\n      if (status < 0) {\n        const error = uvException({\n          errno: status,\n          syscall: \"watch\",\n          path: filename2\n        });\n        error.filename = filename2;\n        handle.close();\n        reject(error);\n        return;\n      }\n      resolve({ eventType, filename: filename2 });\n    };\n    const err = handle.start(path, persistent, recursive, encoding);\n    if (err) {\n      const error = uvException({\n        errno: err,\n        syscall: \"watch\",\n        path: filename,\n        message: err === UV_ENOSPC ? \"System limit for number of file watchers reached\" : \"\"\n      });\n      error.filename = filename;\n      handle.close();\n      throw error;\n    }\n    while (!signal?.aborted) {\n      yield await promise;\n      ({ promise, resolve, reject } = createDeferredPromise());\n    }\n    throw new AbortError();\n  } finally {\n    handle.close();\n    signal?.removeEventListener(\"abort\", oncancel);\n  }\n}\nmodule.exports = {\n  FSWatcher,\n  StatWatcher,\n  kFSWatchStart,\n  kFSStatWatcherStart,\n  kFSStatWatcherAddOrCleanRef,\n  watch\n};\n}"],["internal/http2/compat.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypePush,\n  Boolean,\n  FunctionPrototypeBind,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  Proxy,\n  ReflectApply,\n  ReflectGetPrototypeOf,\n  StringPrototypeIncludes,\n  SafeArrayIterator,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  Symbol\n} = primordials;\nconst assert = require(\"internal/assert\");\nconst Stream = require(\"stream\");\nconst { Readable } = Stream;\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_CONNECTION,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_STATUS,\n    HTTP_STATUS_CONTINUE,\n    HTTP_STATUS_EXPECTATION_FAILED,\n    HTTP_STATUS_METHOD_NOT_ALLOWED,\n    HTTP_STATUS_OK\n  }\n} = internalBinding(\"http2\");\nconst {\n  codes: {\n    ERR_HTTP2_HEADERS_SENT,\n    ERR_HTTP2_INFO_STATUS_NOT_ALLOWED,\n    ERR_HTTP2_INVALID_HEADER_VALUE,\n    ERR_HTTP2_INVALID_STREAM,\n    ERR_HTTP2_NO_SOCKET_MANIPULATION,\n    ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED,\n    ERR_HTTP2_STATUS_INVALID,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_HTTP_TOKEN,\n    ERR_STREAM_WRITE_AFTER_END\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst {\n  validateCallback,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  kSocket,\n  kRequest,\n  kProxySocket,\n  assertValidPseudoHeader,\n  getAuthority\n} = require(\"internal/http2/util\");\nconst { _checkIsHttpToken: checkIsHttpToken } = require(\"_http_common\");\nconst kBeginSend = Symbol(\"begin-send\");\nconst kState = Symbol(\"state\");\nconst kStream = Symbol(\"stream\");\nconst kResponse = Symbol(\"response\");\nconst kHeaders = Symbol(\"headers\");\nconst kRawHeaders = Symbol(\"rawHeaders\");\nconst kTrailers = Symbol(\"trailers\");\nconst kRawTrailers = Symbol(\"rawTrailers\");\nconst kSetHeader = Symbol(\"setHeader\");\nconst kAborted = Symbol(\"aborted\");\nlet statusMessageWarned = false;\nlet statusConnectionHeaderWarned = false;\nconst assertValidHeader = hideStackFrames((name, value) => {\n  if (name === \"\" || typeof name !== \"string\" || StringPrototypeIncludes(name, \" \")) {\n    throw new ERR_INVALID_HTTP_TOKEN(\"Header name\", name);\n  }\n  if (isPseudoHeader(name)) {\n    throw new ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED();\n  }\n  if (value === void 0 || value === null) {\n    throw new ERR_HTTP2_INVALID_HEADER_VALUE(value, name);\n  }\n  if (!isConnectionHeaderAllowed(name, value)) {\n    connectionHeaderMessageWarn();\n  }\n});\nfunction isPseudoHeader(name) {\n  switch (name) {\n    case HTTP2_HEADER_STATUS:\n    case HTTP2_HEADER_METHOD:\n    case HTTP2_HEADER_PATH:\n    case HTTP2_HEADER_AUTHORITY:\n    case HTTP2_HEADER_SCHEME:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction statusMessageWarn() {\n  if (statusMessageWarned === false) {\n    process.emitWarning(\"Status message is not supported by HTTP/2 (RFC7540 8.1.2.4)\", \"UnsupportedWarning\");\n    statusMessageWarned = true;\n  }\n}\nfunction isConnectionHeaderAllowed(name, value) {\n  return name !== HTTP2_HEADER_CONNECTION || value === \"trailers\";\n}\nfunction connectionHeaderMessageWarn() {\n  if (statusConnectionHeaderWarned === false) {\n    process.emitWarning(\"The provided connection header is not valid, the value will be dropped from the header and will never be in use.\", \"UnsupportedWarning\");\n    statusConnectionHeaderWarned = true;\n  }\n}\nfunction onStreamData(chunk) {\n  const request = this[kRequest];\n  if (request !== void 0 && !request.push(chunk))\n    this.pause();\n}\nfunction onStreamTrailers(trailers, flags, rawTrailers) {\n  const request = this[kRequest];\n  if (request !== void 0) {\n    ObjectAssign(request[kTrailers], trailers);\n    ArrayPrototypePush(request[kRawTrailers], ...new SafeArrayIterator(rawTrailers));\n  }\n}\nfunction onStreamEnd() {\n  const request = this[kRequest];\n  if (request !== void 0)\n    this[kRequest].push(null);\n}\nfunction onStreamError(error) {\n}\nfunction onRequestPause() {\n  this[kStream].pause();\n}\nfunction onRequestResume() {\n  this[kStream].resume();\n}\nfunction onStreamDrain() {\n  const response = this[kResponse];\n  if (response !== void 0)\n    response.emit(\"drain\");\n}\nfunction onStreamAbortedRequest() {\n  const request = this[kRequest];\n  if (request !== void 0 && request[kState].closed === false) {\n    request[kAborted] = true;\n    request.emit(\"aborted\");\n  }\n}\nfunction onStreamAbortedResponse() {\n}\nfunction resumeStream(stream) {\n  stream.resume();\n}\nconst proxySocketHandler = {\n  has(stream, prop) {\n    const ref = stream.session !== void 0 ? stream.session[kSocket] : stream;\n    return prop in stream || prop in ref;\n  },\n  get(stream, prop) {\n    switch (prop) {\n      case \"on\":\n      case \"once\":\n      case \"end\":\n      case \"emit\":\n      case \"destroy\":\n        return FunctionPrototypeBind(stream[prop], stream);\n      case \"writable\":\n      case \"destroyed\":\n        return stream[prop];\n      case \"readable\":\n        if (stream.destroyed)\n          return false;\n        const request = stream[kRequest];\n        return request ? request.readable : stream.readable;\n      case \"setTimeout\":\n        const session = stream.session;\n        if (session !== void 0)\n          return FunctionPrototypeBind(session.setTimeout, session);\n        return FunctionPrototypeBind(stream.setTimeout, stream);\n      case \"write\":\n      case \"read\":\n      case \"pause\":\n      case \"resume\":\n        throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();\n      default:\n        const ref = stream.session !== void 0 ? stream.session[kSocket] : stream;\n        const value = ref[prop];\n        return typeof value === \"function\" ? FunctionPrototypeBind(value, ref) : value;\n    }\n  },\n  getPrototypeOf(stream) {\n    if (stream.session !== void 0)\n      return ReflectGetPrototypeOf(stream.session[kSocket]);\n    return ReflectGetPrototypeOf(stream);\n  },\n  set(stream, prop, value) {\n    switch (prop) {\n      case \"writable\":\n      case \"readable\":\n      case \"destroyed\":\n      case \"on\":\n      case \"once\":\n      case \"end\":\n      case \"emit\":\n      case \"destroy\":\n        stream[prop] = value;\n        return true;\n      case \"setTimeout\":\n        const session = stream.session;\n        if (session !== void 0)\n          session.setTimeout = value;\n        else\n          stream.setTimeout = value;\n        return true;\n      case \"write\":\n      case \"read\":\n      case \"pause\":\n      case \"resume\":\n        throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();\n      default:\n        const ref = stream.session !== void 0 ? stream.session[kSocket] : stream;\n        ref[prop] = value;\n        return true;\n    }\n  }\n};\nfunction onStreamCloseRequest() {\n  const req = this[kRequest];\n  if (req === void 0)\n    return;\n  const state = req[kState];\n  state.closed = true;\n  req.push(null);\n  if (!state.didRead && !req._readableState.resumeScheduled)\n    req.resume();\n  this[kProxySocket] = null;\n  this[kRequest] = void 0;\n  req.emit(\"close\");\n}\nfunction onStreamTimeout(kind) {\n  return function onStreamTimeout2() {\n    const obj = this[kind];\n    obj.emit(\"timeout\");\n  };\n}\nclass Http2ServerRequest extends Readable {\n  constructor(stream, headers, options, rawHeaders) {\n    super({ autoDestroy: false, ...options });\n    this[kState] = {\n      closed: false,\n      didRead: false\n    };\n    this[kHeaders] = headers;\n    this[kRawHeaders] = rawHeaders;\n    this[kTrailers] = {};\n    this[kRawTrailers] = [];\n    this[kStream] = stream;\n    this[kAborted] = false;\n    stream[kProxySocket] = null;\n    stream[kRequest] = this;\n    stream.on(\"trailers\", onStreamTrailers);\n    stream.on(\"end\", onStreamEnd);\n    stream.on(\"error\", onStreamError);\n    stream.on(\"aborted\", onStreamAbortedRequest);\n    stream.on(\"close\", onStreamCloseRequest);\n    stream.on(\"timeout\", onStreamTimeout(kRequest));\n    this.on(\"pause\", onRequestPause);\n    this.on(\"resume\", onRequestResume);\n  }\n  get aborted() {\n    return this[kAborted];\n  }\n  get complete() {\n    return this[kAborted] || this.readableEnded || this[kState].closed || this[kStream].destroyed;\n  }\n  get stream() {\n    return this[kStream];\n  }\n  get headers() {\n    return this[kHeaders];\n  }\n  get rawHeaders() {\n    return this[kRawHeaders];\n  }\n  get trailers() {\n    return this[kTrailers];\n  }\n  get rawTrailers() {\n    return this[kRawTrailers];\n  }\n  get httpVersionMajor() {\n    return 2;\n  }\n  get httpVersionMinor() {\n    return 0;\n  }\n  get httpVersion() {\n    return \"2.0\";\n  }\n  get socket() {\n    const stream = this[kStream];\n    const proxySocket = stream[kProxySocket];\n    if (proxySocket === null)\n      return stream[kProxySocket] = new Proxy(stream, proxySocketHandler);\n    return proxySocket;\n  }\n  get connection() {\n    return this.socket;\n  }\n  _read(nread) {\n    const state = this[kState];\n    assert(!state.closed);\n    if (!state.didRead) {\n      state.didRead = true;\n      this[kStream].on(\"data\", onStreamData);\n    } else {\n      process.nextTick(resumeStream, this[kStream]);\n    }\n  }\n  get method() {\n    return this[kHeaders][HTTP2_HEADER_METHOD];\n  }\n  set method(method) {\n    validateString(method, \"method\");\n    if (StringPrototypeTrim(method) === \"\")\n      throw new ERR_INVALID_ARG_VALUE(\"method\", method);\n    this[kHeaders][HTTP2_HEADER_METHOD] = method;\n  }\n  get authority() {\n    return getAuthority(this[kHeaders]);\n  }\n  get scheme() {\n    return this[kHeaders][HTTP2_HEADER_SCHEME];\n  }\n  get url() {\n    return this[kHeaders][HTTP2_HEADER_PATH];\n  }\n  set url(url) {\n    this[kHeaders][HTTP2_HEADER_PATH] = url;\n  }\n  setTimeout(msecs, callback) {\n    if (!this[kState].closed)\n      this[kStream].setTimeout(msecs, callback);\n    return this;\n  }\n}\nfunction onStreamTrailersReady() {\n  this.sendTrailers(this[kResponse][kTrailers]);\n}\nfunction onStreamCloseResponse() {\n  const res = this[kResponse];\n  if (res === void 0)\n    return;\n  const state = res[kState];\n  if (this.headRequest !== state.headRequest)\n    return;\n  state.closed = true;\n  this[kProxySocket] = null;\n  this.removeListener(\"wantTrailers\", onStreamTrailersReady);\n  this[kResponse] = void 0;\n  res.emit(\"finish\");\n  res.emit(\"close\");\n}\nclass Http2ServerResponse extends Stream {\n  constructor(stream, options) {\n    super(options);\n    this[kState] = {\n      closed: false,\n      ending: false,\n      destroyed: false,\n      headRequest: false,\n      sendDate: true,\n      statusCode: HTTP_STATUS_OK\n    };\n    this[kHeaders] = ObjectCreate(null);\n    this[kTrailers] = ObjectCreate(null);\n    this[kStream] = stream;\n    stream[kProxySocket] = null;\n    stream[kResponse] = this;\n    this.writable = true;\n    this.req = stream[kRequest];\n    stream.on(\"drain\", onStreamDrain);\n    stream.on(\"aborted\", onStreamAbortedResponse);\n    stream.on(\"close\", onStreamCloseResponse);\n    stream.on(\"wantTrailers\", onStreamTrailersReady);\n    stream.on(\"timeout\", onStreamTimeout(kResponse));\n  }\n  get _header() {\n    return this.headersSent;\n  }\n  get writableEnded() {\n    const state = this[kState];\n    return state.ending;\n  }\n  get finished() {\n    const state = this[kState];\n    return state.ending;\n  }\n  get socket() {\n    if (this[kState].closed)\n      return void 0;\n    const stream = this[kStream];\n    const proxySocket = stream[kProxySocket];\n    if (proxySocket === null)\n      return stream[kProxySocket] = new Proxy(stream, proxySocketHandler);\n    return proxySocket;\n  }\n  get connection() {\n    return this.socket;\n  }\n  get stream() {\n    return this[kStream];\n  }\n  get headersSent() {\n    return this[kStream].headersSent;\n  }\n  get sendDate() {\n    return this[kState].sendDate;\n  }\n  set sendDate(bool) {\n    this[kState].sendDate = Boolean(bool);\n  }\n  get statusCode() {\n    return this[kState].statusCode;\n  }\n  get writableCorked() {\n    return this[kStream].writableCorked;\n  }\n  get writableHighWaterMark() {\n    return this[kStream].writableHighWaterMark;\n  }\n  get writableFinished() {\n    return this[kStream].writableFinished;\n  }\n  get writableLength() {\n    return this[kStream].writableLength;\n  }\n  set statusCode(code) {\n    code |= 0;\n    if (code >= 100 && code < 200)\n      throw new ERR_HTTP2_INFO_STATUS_NOT_ALLOWED();\n    if (code < 100 || code > 599)\n      throw new ERR_HTTP2_STATUS_INVALID(code);\n    this[kState].statusCode = code;\n  }\n  setTrailer(name, value) {\n    validateString(name, \"name\");\n    name = StringPrototypeToLowerCase(StringPrototypeTrim(name));\n    assertValidHeader(name, value);\n    this[kTrailers][name] = value;\n  }\n  addTrailers(headers) {\n    const keys = ObjectKeys(headers);\n    let key = \"\";\n    for (let i = 0; i < keys.length; i++) {\n      key = keys[i];\n      this.setTrailer(key, headers[key]);\n    }\n  }\n  getHeader(name) {\n    validateString(name, \"name\");\n    name = StringPrototypeToLowerCase(StringPrototypeTrim(name));\n    return this[kHeaders][name];\n  }\n  getHeaderNames() {\n    return ObjectKeys(this[kHeaders]);\n  }\n  getHeaders() {\n    const headers = ObjectCreate(null);\n    return ObjectAssign(headers, this[kHeaders]);\n  }\n  hasHeader(name) {\n    validateString(name, \"name\");\n    name = StringPrototypeToLowerCase(StringPrototypeTrim(name));\n    return ObjectPrototypeHasOwnProperty(this[kHeaders], name);\n  }\n  removeHeader(name) {\n    validateString(name, \"name\");\n    if (this[kStream].headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    name = StringPrototypeToLowerCase(StringPrototypeTrim(name));\n    if (name === \"date\") {\n      this[kState].sendDate = false;\n      return;\n    }\n    delete this[kHeaders][name];\n  }\n  setHeader(name, value) {\n    validateString(name, \"name\");\n    if (this[kStream].headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    this[kSetHeader](name, value);\n  }\n  [kSetHeader](name, value) {\n    name = StringPrototypeToLowerCase(StringPrototypeTrim(name));\n    assertValidHeader(name, value);\n    if (!isConnectionHeaderAllowed(name, value)) {\n      return;\n    }\n    if (name[0] === \":\")\n      assertValidPseudoHeader(name);\n    else if (!checkIsHttpToken(name))\n      this.destroy(new ERR_INVALID_HTTP_TOKEN(\"Header name\", name));\n    this[kHeaders][name] = value;\n  }\n  get statusMessage() {\n    statusMessageWarn();\n    return \"\";\n  }\n  set statusMessage(msg) {\n    statusMessageWarn();\n  }\n  flushHeaders() {\n    const state = this[kState];\n    if (!state.closed && !this[kStream].headersSent)\n      this.writeHead(state.statusCode);\n  }\n  writeHead(statusCode, statusMessage, headers) {\n    const state = this[kState];\n    if (state.closed || this.stream.destroyed)\n      return this;\n    if (this[kStream].headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    if (typeof statusMessage === \"string\")\n      statusMessageWarn();\n    if (headers === void 0 && typeof statusMessage === \"object\")\n      headers = statusMessage;\n    let i;\n    if (ArrayIsArray(headers)) {\n      for (i = 0; i < headers.length; i++) {\n        const header = headers[i];\n        this[kSetHeader](header[0], header[1]);\n      }\n    } else if (typeof headers === \"object\") {\n      const keys = ObjectKeys(headers);\n      let key = \"\";\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        this[kSetHeader](key, headers[key]);\n      }\n    }\n    state.statusCode = statusCode;\n    this[kBeginSend]();\n    return this;\n  }\n  cork() {\n    this[kStream].cork();\n  }\n  uncork() {\n    this[kStream].uncork();\n  }\n  write(chunk, encoding, cb) {\n    const state = this[kState];\n    if (typeof encoding === \"function\") {\n      cb = encoding;\n      encoding = \"utf8\";\n    }\n    let err;\n    if (state.ending) {\n      err = new ERR_STREAM_WRITE_AFTER_END();\n    } else if (state.closed) {\n      err = new ERR_HTTP2_INVALID_STREAM();\n    } else if (state.destroyed) {\n      return false;\n    }\n    if (err) {\n      if (typeof cb === \"function\")\n        process.nextTick(cb, err);\n      this.destroy(err);\n      return false;\n    }\n    const stream = this[kStream];\n    if (!stream.headersSent)\n      this.writeHead(state.statusCode);\n    return stream.write(chunk, encoding, cb);\n  }\n  end(chunk, encoding, cb) {\n    const stream = this[kStream];\n    const state = this[kState];\n    if (typeof chunk === \"function\") {\n      cb = chunk;\n      chunk = null;\n    } else if (typeof encoding === \"function\") {\n      cb = encoding;\n      encoding = \"utf8\";\n    }\n    if ((state.closed || state.ending) && state.headRequest === stream.headRequest) {\n      if (typeof cb === \"function\") {\n        process.nextTick(cb);\n      }\n      return this;\n    }\n    if (chunk !== null && chunk !== void 0)\n      this.write(chunk, encoding);\n    state.headRequest = stream.headRequest;\n    state.ending = true;\n    if (typeof cb === \"function\") {\n      if (stream.writableEnded)\n        this.once(\"finish\", cb);\n      else\n        stream.once(\"finish\", cb);\n    }\n    if (!stream.headersSent)\n      this.writeHead(this[kState].statusCode);\n    if (this[kState].closed || stream.destroyed)\n      ReflectApply(onStreamCloseResponse, stream, []);\n    else\n      stream.end();\n    return this;\n  }\n  destroy(err) {\n    if (this[kState].destroyed)\n      return;\n    this[kState].destroyed = true;\n    this[kStream].destroy(err);\n  }\n  setTimeout(msecs, callback) {\n    if (this[kState].closed)\n      return;\n    this[kStream].setTimeout(msecs, callback);\n  }\n  createPushResponse(headers, callback) {\n    validateCallback(callback);\n    if (this[kState].closed) {\n      process.nextTick(callback, new ERR_HTTP2_INVALID_STREAM());\n      return;\n    }\n    this[kStream].pushStream(headers, {}, (err, stream, headers2, options) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      callback(null, new Http2ServerResponse(stream));\n    });\n  }\n  [kBeginSend]() {\n    const state = this[kState];\n    const headers = this[kHeaders];\n    headers[HTTP2_HEADER_STATUS] = state.statusCode;\n    const options = {\n      endStream: state.ending,\n      waitForTrailers: true,\n      sendDate: state.sendDate\n    };\n    this[kStream].respond(headers, options);\n  }\n  writeContinue() {\n    const stream = this[kStream];\n    if (stream.headersSent || this[kState].closed)\n      return false;\n    stream.additionalHeaders({\n      [HTTP2_HEADER_STATUS]: HTTP_STATUS_CONTINUE\n    });\n    return true;\n  }\n}\nfunction onServerStream(ServerRequest, ServerResponse, stream, headers, flags, rawHeaders) {\n  const server = this;\n  const request = new ServerRequest(stream, headers, void 0, rawHeaders);\n  const response = new ServerResponse(stream);\n  const method = headers[HTTP2_HEADER_METHOD];\n  if (method === \"CONNECT\") {\n    if (!server.emit(\"connect\", request, response)) {\n      response.statusCode = HTTP_STATUS_METHOD_NOT_ALLOWED;\n      response.end();\n    }\n    return;\n  }\n  if (headers.expect !== void 0) {\n    if (headers.expect === \"100-continue\") {\n      if (server.listenerCount(\"checkContinue\")) {\n        server.emit(\"checkContinue\", request, response);\n      } else {\n        response.writeContinue();\n        server.emit(\"request\", request, response);\n      }\n    } else if (server.listenerCount(\"checkExpectation\")) {\n      server.emit(\"checkExpectation\", request, response);\n    } else {\n      response.statusCode = HTTP_STATUS_EXPECTATION_FAILED;\n      response.end();\n    }\n    return;\n  }\n  server.emit(\"request\", request, response);\n}\nmodule.exports = {\n  onServerStream,\n  Http2ServerRequest,\n  Http2ServerResponse\n};\n}"],["internal/http2/core.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  ArrayPrototypeUnshift,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  MathMin,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectKeys,\n  ObjectDefineProperty,\n  ObjectPrototypeHasOwnProperty,\n  Promise,\n  PromisePrototypeCatch,\n  Proxy,\n  ReflectApply,\n  ReflectGet,\n  ReflectGetPrototypeOf,\n  ReflectSet,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  SafeMap,\n  SafeSet,\n  StringPrototypeSlice,\n  Symbol,\n  TypedArrayPrototypeGetLength,\n  Uint32Array,\n  Uint8Array\n} = primordials;\nconst {\n  assertCrypto,\n  customInspectSymbol: kInspect,\n  promisify\n} = require(\"internal/util\");\nassertCrypto();\nconst assert = require(\"assert\");\nconst EventEmitter = require(\"events\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst { readUInt16BE, readUInt32BE } = require(\"internal/buffer\");\nconst { URL } = require(\"internal/url\");\nconst net = require(\"net\");\nconst { Duplex } = require(\"stream\");\nconst tls = require(\"tls\");\nconst { setImmediate, setTimeout, clearTimeout } = require(\"timers\");\nconst {\n  kIncomingMessage,\n  _checkIsHttpToken: checkIsHttpToken\n} = require(\"_http_common\");\nconst { kServerResponse } = require(\"_http_server\");\nconst JSStreamSocket = require(\"internal/js_stream_socket\");\nconst {\n  defaultTriggerAsyncIdScope,\n  symbols: {\n    async_id_symbol,\n    owner_symbol\n  }\n} = require(\"internal/async_hooks\");\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_HTTP2_ALTSVC_INVALID_ORIGIN,\n    ERR_HTTP2_ALTSVC_LENGTH,\n    ERR_HTTP2_CONNECT_AUTHORITY,\n    ERR_HTTP2_CONNECT_PATH,\n    ERR_HTTP2_CONNECT_SCHEME,\n    ERR_HTTP2_GOAWAY_SESSION,\n    ERR_HTTP2_HEADERS_AFTER_RESPOND,\n    ERR_HTTP2_HEADERS_SENT,\n    ERR_HTTP2_INVALID_INFO_STATUS,\n    ERR_HTTP2_INVALID_ORIGIN,\n    ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH,\n    ERR_HTTP2_INVALID_SESSION,\n    ERR_HTTP2_INVALID_SETTING_VALUE,\n    ERR_HTTP2_INVALID_STREAM,\n    ERR_HTTP2_MAX_PENDING_SETTINGS_ACK,\n    ERR_HTTP2_NESTED_PUSH,\n    ERR_HTTP2_NO_MEM,\n    ERR_HTTP2_NO_SOCKET_MANIPULATION,\n    ERR_HTTP2_ORIGIN_LENGTH,\n    ERR_HTTP2_OUT_OF_STREAMS,\n    ERR_HTTP2_PAYLOAD_FORBIDDEN,\n    ERR_HTTP2_PING_CANCEL,\n    ERR_HTTP2_PING_LENGTH,\n    ERR_HTTP2_PUSH_DISABLED,\n    ERR_HTTP2_SEND_FILE,\n    ERR_HTTP2_SEND_FILE_NOSEEK,\n    ERR_HTTP2_SESSION_ERROR,\n    ERR_HTTP2_SETTINGS_CANCEL,\n    ERR_HTTP2_SOCKET_BOUND,\n    ERR_HTTP2_SOCKET_UNBOUND,\n    ERR_HTTP2_STATUS_101,\n    ERR_HTTP2_STATUS_INVALID,\n    ERR_HTTP2_STREAM_CANCEL,\n    ERR_HTTP2_STREAM_ERROR,\n    ERR_HTTP2_STREAM_SELF_DEPENDENCY,\n    ERR_HTTP2_TRAILERS_ALREADY_SENT,\n    ERR_HTTP2_TRAILERS_NOT_READY,\n    ERR_HTTP2_UNSUPPORTED_PROTOCOL,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_CHAR,\n    ERR_INVALID_HTTP_TOKEN,\n    ERR_OUT_OF_RANGE,\n    ERR_SOCKET_CLOSED\n  },\n  hideStackFrames,\n  AbortError\n} = require(\"internal/errors\");\nconst {\n  isUint32,\n  validateCallback,\n  validateInt32,\n  validateInteger,\n  validateNumber,\n  validateString,\n  validateUint32,\n  validateAbortSignal\n} = require(\"internal/validators\");\nconst fsPromisesInternal = require(\"internal/fs/promises\");\nconst { utcDate } = require(\"internal/http\");\nconst {\n  Http2ServerRequest,\n  Http2ServerResponse,\n  onServerStream\n} = require(\"internal/http2/compat\");\nconst {\n  assertIsObject,\n  assertValidPseudoHeader,\n  assertValidPseudoHeaderResponse,\n  assertValidPseudoHeaderTrailer,\n  assertWithinRange,\n  getAuthority,\n  getDefaultSettings,\n  getSessionState,\n  getSettings,\n  getStreamState,\n  isPayloadMeaningless,\n  kSensitiveHeaders,\n  kSocket,\n  kRequest,\n  kProxySocket,\n  mapToHeaders,\n  NghttpError,\n  sessionName,\n  toHeaderObject,\n  updateOptionsBuffer,\n  updateSettingsBuffer\n} = require(\"internal/http2/util\");\nconst {\n  writeGeneric,\n  writevGeneric,\n  onStreamRead,\n  kAfterAsyncWrite,\n  kMaybeDestroy,\n  kUpdateTimer,\n  kHandle,\n  kSession,\n  setStreamTimeout\n} = require(\"internal/stream_base_commons\");\nconst { kTimeout } = require(\"internal/timers\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst { format } = require(\"internal/util/inspect\");\nconst { FileHandle } = internalBinding(\"fs\");\nconst binding = internalBinding(\"http2\");\nconst {\n  ShutdownWrap,\n  kReadBytesOrError,\n  streamBaseState\n} = internalBinding(\"stream_wrap\");\nconst { UV_EOF } = internalBinding(\"uv\");\nconst { StreamPipe } = internalBinding(\"stream_pipe\");\nconst { _connectionListener: httpConnectionListener } = http;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http2\", (fn) => {\n  debug = fn;\n});\nfunction debugStream(id, sessionType, message, ...args) {\n  debug(\"Http2Stream %s [Http2Session %s]: \" + message, id, sessionName(sessionType), ...new SafeArrayIterator(args));\n}\nfunction debugStreamObj(stream, message, ...args) {\n  const session = stream[kSession];\n  const type = session ? session[kType] : void 0;\n  debugStream(stream[kID], type, message, ...new SafeArrayIterator(args));\n}\nfunction debugSession(sessionType, message, ...args) {\n  debug(\"Http2Session %s: \" + message, sessionName(sessionType), ...new SafeArrayIterator(args));\n}\nfunction debugSessionObj(session, message, ...args) {\n  debugSession(session[kType], message, ...new SafeArrayIterator(args));\n}\nconst kMaxFrameSize = 2 ** 24 - 1;\nconst kMaxInt = 2 ** 32 - 1;\nconst kMaxStreams = 2 ** 32 - 1;\nconst kMaxALTSVC = 2 ** 14 - 2;\nconst kQuotedString = /^[\\x09\\x20-\\x5b\\x5d-\\x7e\\x80-\\xff]*$/;\nconst { constants, nameForErrorCode } = binding;\nconst NETServer = net.Server;\nconst TLSServer = tls.Server;\nconst kAlpnProtocol = Symbol(\"alpnProtocol\");\nconst kAuthority = Symbol(\"authority\");\nconst kEncrypted = Symbol(\"encrypted\");\nconst kID = Symbol(\"id\");\nconst kInit = Symbol(\"init\");\nconst kInfoHeaders = Symbol(\"sent-info-headers\");\nconst kLocalSettings = Symbol(\"local-settings\");\nconst kNativeFields = Symbol(\"kNativeFields\");\nconst kOptions = Symbol(\"options\");\nconst kOwner = owner_symbol;\nconst kOrigin = Symbol(\"origin\");\nconst kPendingRequestCalls = Symbol(\"kPendingRequestCalls\");\nconst kProceed = Symbol(\"proceed\");\nconst kProtocol = Symbol(\"protocol\");\nconst kRemoteSettings = Symbol(\"remote-settings\");\nconst kSelectPadding = Symbol(\"select-padding\");\nconst kSentHeaders = Symbol(\"sent-headers\");\nconst kSentTrailers = Symbol(\"sent-trailers\");\nconst kServer = Symbol(\"server\");\nconst kState = Symbol(\"state\");\nconst kType = Symbol(\"type\");\nconst kWriteGeneric = Symbol(\"write-generic\");\nconst {\n  kBitfield,\n  kSessionPriorityListenerCount,\n  kSessionFrameErrorListenerCount,\n  kSessionMaxInvalidFrames,\n  kSessionMaxRejectedStreams,\n  kSessionUint8FieldCount,\n  kSessionHasRemoteSettingsListeners,\n  kSessionRemoteSettingsIsUpToDate,\n  kSessionHasPingListeners,\n  kSessionHasAltsvcListeners\n} = binding;\nconst {\n  NGHTTP2_CANCEL,\n  NGHTTP2_REFUSED_STREAM,\n  NGHTTP2_DEFAULT_WEIGHT,\n  NGHTTP2_FLAG_END_STREAM,\n  NGHTTP2_HCAT_PUSH_RESPONSE,\n  NGHTTP2_HCAT_RESPONSE,\n  NGHTTP2_INTERNAL_ERROR,\n  NGHTTP2_NO_ERROR,\n  NGHTTP2_SESSION_CLIENT,\n  NGHTTP2_SESSION_SERVER,\n  NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE,\n  NGHTTP2_ERR_INVALID_ARGUMENT,\n  NGHTTP2_ERR_STREAM_CLOSED,\n  NGHTTP2_ERR_NOMEM,\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_DATE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_PROTOCOL,\n  HTTP2_HEADER_SCHEME,\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_LENGTH,\n  NGHTTP2_SETTINGS_HEADER_TABLE_SIZE,\n  NGHTTP2_SETTINGS_ENABLE_PUSH,\n  NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,\n  NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,\n  NGHTTP2_SETTINGS_MAX_FRAME_SIZE,\n  NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE,\n  NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL,\n  HTTP2_METHOD_GET,\n  HTTP2_METHOD_HEAD,\n  HTTP2_METHOD_CONNECT,\n  HTTP_STATUS_CONTINUE,\n  HTTP_STATUS_RESET_CONTENT,\n  HTTP_STATUS_OK,\n  HTTP_STATUS_NO_CONTENT,\n  HTTP_STATUS_NOT_MODIFIED,\n  HTTP_STATUS_SWITCHING_PROTOCOLS,\n  HTTP_STATUS_MISDIRECTED_REQUEST,\n  STREAM_OPTION_EMPTY_PAYLOAD,\n  STREAM_OPTION_GET_TRAILERS\n} = constants;\nconst STREAM_FLAGS_PENDING = 0;\nconst STREAM_FLAGS_READY = 1;\nconst STREAM_FLAGS_CLOSED = 2;\nconst STREAM_FLAGS_HEADERS_SENT = 4;\nconst STREAM_FLAGS_HEAD_REQUEST = 8;\nconst STREAM_FLAGS_ABORTED = 16;\nconst STREAM_FLAGS_HAS_TRAILERS = 32;\nconst SESSION_FLAGS_PENDING = 0;\nconst SESSION_FLAGS_READY = 1;\nconst SESSION_FLAGS_CLOSED = 2;\nconst SESSION_FLAGS_DESTROYED = 4;\nfunction emit(self, ...args) {\n  ReflectApply(self.emit, self, args);\n}\nfunction onSessionHeaders(handle, id, cat, flags, headers, sensitiveHeaders) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  const type = session[kType];\n  session[kUpdateTimer]();\n  debugStream(id, type, \"headers received\");\n  const streams = session[kState].streams;\n  const endOfStream = !!(flags & NGHTTP2_FLAG_END_STREAM);\n  let stream = streams.get(id);\n  const obj = toHeaderObject(headers, sensitiveHeaders);\n  if (stream === void 0) {\n    if (session.closed) {\n      handle.rstStream(NGHTTP2_REFUSED_STREAM);\n      handle.destroy();\n      return;\n    }\n    if (type === NGHTTP2_SESSION_SERVER) {\n      stream = new ServerHttp2Stream(session, handle, id, {}, obj);\n      if (endOfStream) {\n        stream.push(null);\n      }\n      if (obj[HTTP2_HEADER_METHOD] === HTTP2_METHOD_HEAD) {\n        stream.end();\n        stream[kState].flags |= STREAM_FLAGS_HEAD_REQUEST;\n      }\n    } else {\n      stream = new ClientHttp2Stream(session, handle, id, {});\n      if (endOfStream) {\n        stream.push(null);\n      }\n      stream.end();\n    }\n    if (endOfStream)\n      stream[kState].endAfterHeaders = true;\n    process.nextTick(emit, session, \"stream\", stream, obj, flags, headers);\n  } else {\n    let event;\n    const status = obj[HTTP2_HEADER_STATUS];\n    if (cat === NGHTTP2_HCAT_RESPONSE) {\n      if (!endOfStream && status !== void 0 && status >= 100 && status < 200) {\n        event = \"headers\";\n      } else {\n        event = \"response\";\n      }\n    } else if (cat === NGHTTP2_HCAT_PUSH_RESPONSE) {\n      event = \"push\";\n    } else if (!endOfStream && status !== void 0 && status >= 200) {\n      event = \"response\";\n    } else {\n      event = endOfStream ? \"trailers\" : \"headers\";\n    }\n    const session2 = stream.session;\n    if (status === HTTP_STATUS_MISDIRECTED_REQUEST) {\n      const originSet = session2[kState].originSet = initOriginSet(session2);\n      originSet.delete(stream[kOrigin]);\n    }\n    debugStream(id, type, \"emitting stream '%s' event\", event);\n    process.nextTick(emit, stream, event, obj, flags, headers);\n  }\n  if (endOfStream) {\n    stream.push(null);\n  }\n}\nfunction tryClose(fd) {\n  fs.close(fd, assert.ifError);\n}\nfunction onStreamTrailers() {\n  const stream = this[kOwner];\n  stream[kState].trailersReady = true;\n  if (stream.destroyed || stream.closed)\n    return;\n  if (!stream.emit(\"wantTrailers\")) {\n    stream.sendTrailers({});\n  }\n}\nfunction submitRstStream(code) {\n  if (this[kHandle] !== void 0) {\n    this[kHandle].rstStream(code);\n  }\n}\nfunction sessionListenerAdded(name) {\n  switch (name) {\n    case \"ping\":\n      this[kNativeFields][kBitfield] |= 1 << kSessionHasPingListeners;\n      break;\n    case \"altsvc\":\n      this[kNativeFields][kBitfield] |= 1 << kSessionHasAltsvcListeners;\n      break;\n    case \"remoteSettings\":\n      this[kNativeFields][kBitfield] |= 1 << kSessionHasRemoteSettingsListeners;\n      break;\n    case \"priority\":\n      this[kNativeFields][kSessionPriorityListenerCount]++;\n      break;\n    case \"frameError\":\n      this[kNativeFields][kSessionFrameErrorListenerCount]++;\n      break;\n  }\n}\nfunction sessionListenerRemoved(name) {\n  switch (name) {\n    case \"ping\":\n      if (this.listenerCount(name) > 0)\n        return;\n      this[kNativeFields][kBitfield] &= ~(1 << kSessionHasPingListeners);\n      break;\n    case \"altsvc\":\n      if (this.listenerCount(name) > 0)\n        return;\n      this[kNativeFields][kBitfield] &= ~(1 << kSessionHasAltsvcListeners);\n      break;\n    case \"remoteSettings\":\n      if (this.listenerCount(name) > 0)\n        return;\n      this[kNativeFields][kBitfield] &= ~(1 << kSessionHasRemoteSettingsListeners);\n      break;\n    case \"priority\":\n      this[kNativeFields][kSessionPriorityListenerCount]--;\n      break;\n    case \"frameError\":\n      this[kNativeFields][kSessionFrameErrorListenerCount]--;\n      break;\n  }\n}\nfunction streamListenerAdded(name) {\n  const session = this[kSession];\n  if (!session)\n    return;\n  switch (name) {\n    case \"priority\":\n      session[kNativeFields][kSessionPriorityListenerCount]++;\n      break;\n    case \"frameError\":\n      session[kNativeFields][kSessionFrameErrorListenerCount]++;\n      break;\n  }\n}\nfunction streamListenerRemoved(name) {\n  const session = this[kSession];\n  if (!session)\n    return;\n  switch (name) {\n    case \"priority\":\n      session[kNativeFields][kSessionPriorityListenerCount]--;\n      break;\n    case \"frameError\":\n      session[kNativeFields][kSessionFrameErrorListenerCount]--;\n      break;\n  }\n}\nfunction onPing(payload) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  session[kUpdateTimer]();\n  debugSessionObj(session, \"new ping received\");\n  session.emit(\"ping\", payload);\n}\nfunction onStreamClose(code) {\n  const stream = this[kOwner];\n  if (!stream || stream.destroyed)\n    return false;\n  debugStreamObj(stream, \"closed with code %d, closed %s, readable %s\", code, stream.closed, stream.readable);\n  if (!stream.closed)\n    closeStream(stream, code, kNoRstStream);\n  stream[kState].fd = -1;\n  if (!stream.readable || code !== NGHTTP2_NO_ERROR) {\n    stream.destroy();\n  } else {\n    stream.on(\"end\", stream[kMaybeDestroy]);\n    stream.push(null);\n    if (stream[kSession][kType] === NGHTTP2_SESSION_SERVER && !stream[kState].didRead && stream.readableFlowing === null)\n      stream.resume();\n    else\n      stream.read(0);\n  }\n  return true;\n}\nfunction onSettings() {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  session[kUpdateTimer]();\n  debugSessionObj(session, \"new settings received\");\n  session[kRemoteSettings] = void 0;\n  session.emit(\"remoteSettings\", session.remoteSettings);\n}\nfunction onPriority(id, parent, weight, exclusive) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  debugStream(id, session[kType], \"priority [parent: %d, weight: %d, exclusive: %s]\", parent, weight, exclusive);\n  const emitter = session[kState].streams.get(id) || session;\n  if (!emitter.destroyed) {\n    emitter[kUpdateTimer]();\n    emitter.emit(\"priority\", id, parent, weight, exclusive);\n  }\n}\nfunction onFrameError(id, type, code) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  debugSessionObj(session, \"error sending frame type %d on stream %d, code: %d\", type, id, code);\n  const emitter = session[kState].streams.get(id) || session;\n  emitter[kUpdateTimer]();\n  emitter.emit(\"frameError\", type, code, id);\n}\nfunction onAltSvc(stream, origin, alt) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  debugSessionObj(session, \"altsvc received: stream: %d, origin: %s, alt: %s\", stream, origin, alt);\n  session[kUpdateTimer]();\n  session.emit(\"altsvc\", alt, origin, stream);\n}\nfunction initOriginSet(session) {\n  let originSet = session[kState].originSet;\n  if (originSet === void 0) {\n    const socket = session[kSocket];\n    session[kState].originSet = originSet = new SafeSet();\n    if (socket.servername != null) {\n      let originString = `https://${socket.servername}`;\n      if (socket.remotePort != null)\n        originString += `:${socket.remotePort}`;\n      originSet.add(new URL(originString).origin);\n    }\n  }\n  return originSet;\n}\nfunction onOrigin(origins) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  debugSessionObj(session, \"origin received: %j\", origins);\n  session[kUpdateTimer]();\n  if (!session.encrypted || session.destroyed)\n    return void 0;\n  const originSet = initOriginSet(session);\n  for (let n = 0; n < origins.length; n++)\n    originSet.add(origins[n]);\n  session.emit(\"origin\", origins);\n}\nfunction onGoawayData(code, lastStreamID, buf) {\n  const session = this[kOwner];\n  if (session.destroyed)\n    return;\n  debugSessionObj(session, \"goaway %d received [last stream id: %d]\", code, lastStreamID);\n  const state = session[kState];\n  state.goawayCode = code;\n  state.goawayLastStreamID = lastStreamID;\n  session.emit(\"goaway\", code, lastStreamID, buf);\n  if (code === NGHTTP2_NO_ERROR) {\n    session.close();\n  } else {\n    session.destroy(new ERR_HTTP2_SESSION_ERROR(code), NGHTTP2_NO_ERROR);\n  }\n}\nfunction requestOnConnect(headers, options) {\n  const session = this[kSession];\n  if (session === void 0 || session.destroyed)\n    return;\n  if (session.closed) {\n    const err = new ERR_HTTP2_GOAWAY_SESSION();\n    this.destroy(err);\n    return;\n  }\n  debugSessionObj(session, \"connected, initializing request\");\n  let streamOptions = 0;\n  if (options.endStream)\n    streamOptions |= STREAM_OPTION_EMPTY_PAYLOAD;\n  if (options.waitForTrailers)\n    streamOptions |= STREAM_OPTION_GET_TRAILERS;\n  const ret = session[kHandle].request(headers, streamOptions, options.parent | 0, options.weight | 0, !!options.exclusive);\n  if (typeof ret === \"number\") {\n    let err;\n    switch (ret) {\n      case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n        err = new ERR_HTTP2_OUT_OF_STREAMS();\n        this.destroy(err);\n        break;\n      case NGHTTP2_ERR_INVALID_ARGUMENT:\n        err = new ERR_HTTP2_STREAM_SELF_DEPENDENCY();\n        this.destroy(err);\n        break;\n      default:\n        session.destroy(new NghttpError(ret));\n    }\n    return;\n  }\n  this[kInit](ret.id(), ret);\n}\nconst setAndValidatePriorityOptions = hideStackFrames((options) => {\n  if (options.weight === void 0) {\n    options.weight = NGHTTP2_DEFAULT_WEIGHT;\n  } else if (typeof options.weight !== \"number\") {\n    throw new ERR_INVALID_ARG_VALUE(\"options.weight\", options.weight);\n  }\n  if (options.parent === void 0) {\n    options.parent = 0;\n  } else if (typeof options.parent !== \"number\" || options.parent < 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"options.parent\", options.parent);\n  }\n  if (options.exclusive === void 0) {\n    options.exclusive = false;\n  } else if (typeof options.exclusive !== \"boolean\") {\n    throw new ERR_INVALID_ARG_VALUE(\"options.exclusive\", options.exclusive);\n  }\n  if (options.silent === void 0) {\n    options.silent = false;\n  } else if (typeof options.silent !== \"boolean\") {\n    throw new ERR_INVALID_ARG_VALUE(\"options.silent\", options.silent);\n  }\n});\nfunction onSessionInternalError(integerCode, customErrorCode) {\n  if (this[kOwner] !== void 0)\n    this[kOwner].destroy(new NghttpError(integerCode, customErrorCode));\n}\nfunction settingsCallback(cb, ack, duration) {\n  this[kState].pendingAck--;\n  this[kLocalSettings] = void 0;\n  if (ack) {\n    debugSessionObj(this, \"settings received\");\n    const settings = this.localSettings;\n    if (typeof cb === \"function\")\n      cb(null, settings, duration);\n    this.emit(\"localSettings\", settings);\n  } else {\n    debugSessionObj(this, \"settings canceled\");\n    if (typeof cb === \"function\")\n      cb(new ERR_HTTP2_SETTINGS_CANCEL());\n  }\n}\nfunction submitSettings(settings, callback) {\n  if (this.destroyed)\n    return;\n  debugSessionObj(this, \"submitting settings\");\n  this[kUpdateTimer]();\n  updateSettingsBuffer(settings);\n  if (!this[kHandle].settings(FunctionPrototypeBind(settingsCallback, this, callback))) {\n    this.destroy(new ERR_HTTP2_MAX_PENDING_SETTINGS_ACK());\n  }\n}\nfunction submitPriority(options) {\n  if (this.destroyed)\n    return;\n  this[kUpdateTimer]();\n  if (options.parent === this[kID])\n    return;\n  this[kHandle].priority(options.parent | 0, options.weight | 0, !!options.exclusive, !!options.silent);\n}\nfunction submitGoaway(code, lastStreamID, opaqueData) {\n  if (this.destroyed)\n    return;\n  debugSessionObj(this, \"submitting goaway\");\n  this[kUpdateTimer]();\n  this[kHandle].goaway(code, lastStreamID, opaqueData);\n}\nconst proxySocketHandler = {\n  get(session, prop) {\n    switch (prop) {\n      case \"setTimeout\":\n      case \"ref\":\n      case \"unref\":\n        return FunctionPrototypeBind(session[prop], session);\n      case \"destroy\":\n      case \"emit\":\n      case \"end\":\n      case \"pause\":\n      case \"read\":\n      case \"resume\":\n      case \"write\":\n      case \"setEncoding\":\n      case \"setKeepAlive\":\n      case \"setNoDelay\":\n        throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();\n      default:\n        const socket = session[kSocket];\n        if (socket === void 0)\n          throw new ERR_HTTP2_SOCKET_UNBOUND();\n        const value = socket[prop];\n        return typeof value === \"function\" ? FunctionPrototypeBind(value, socket) : value;\n    }\n  },\n  getPrototypeOf(session) {\n    const socket = session[kSocket];\n    if (socket === void 0)\n      throw new ERR_HTTP2_SOCKET_UNBOUND();\n    return ReflectGetPrototypeOf(socket);\n  },\n  set(session, prop, value) {\n    switch (prop) {\n      case \"setTimeout\":\n      case \"ref\":\n      case \"unref\":\n        session[prop] = value;\n        return true;\n      case \"destroy\":\n      case \"emit\":\n      case \"end\":\n      case \"pause\":\n      case \"read\":\n      case \"resume\":\n      case \"write\":\n      case \"setEncoding\":\n      case \"setKeepAlive\":\n      case \"setNoDelay\":\n        throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();\n      default:\n        const socket = session[kSocket];\n        if (socket === void 0)\n          throw new ERR_HTTP2_SOCKET_UNBOUND();\n        socket[prop] = value;\n        return true;\n    }\n  }\n};\nfunction pingCallback(cb) {\n  return function pingCallback2(ack, duration, payload) {\n    if (ack) {\n      cb(null, duration, payload);\n    } else {\n      cb(new ERR_HTTP2_PING_CANCEL());\n    }\n  };\n}\nconst validateSettings = hideStackFrames((settings) => {\n  if (settings === void 0)\n    return;\n  assertWithinRange(\"headerTableSize\", settings.headerTableSize, 0, kMaxInt);\n  assertWithinRange(\"initialWindowSize\", settings.initialWindowSize, 0, kMaxInt);\n  assertWithinRange(\"maxFrameSize\", settings.maxFrameSize, 16384, kMaxFrameSize);\n  assertWithinRange(\"maxConcurrentStreams\", settings.maxConcurrentStreams, 0, kMaxStreams);\n  assertWithinRange(\"maxHeaderListSize\", settings.maxHeaderListSize, 0, kMaxInt);\n  assertWithinRange(\"maxHeaderSize\", settings.maxHeaderSize, 0, kMaxInt);\n  if (settings.enablePush !== void 0 && typeof settings.enablePush !== \"boolean\") {\n    throw new ERR_HTTP2_INVALID_SETTING_VALUE(\"enablePush\", settings.enablePush);\n  }\n  if (settings.enableConnectProtocol !== void 0 && typeof settings.enableConnectProtocol !== \"boolean\") {\n    throw new ERR_HTTP2_INVALID_SETTING_VALUE(\"enableConnectProtocol\", settings.enableConnectProtocol);\n  }\n});\nfunction trackAssignmentsTypedArray(typedArray) {\n  const typedArrayLength = TypedArrayPrototypeGetLength(typedArray);\n  const modifiedEntries = new Uint8Array(typedArrayLength);\n  function copyAssigned(target) {\n    for (let i = 0; i < typedArrayLength; i++) {\n      if (modifiedEntries[i]) {\n        target[i] = typedArray[i];\n      }\n    }\n  }\n  return new Proxy(typedArray, {\n    get(obj, prop, receiver) {\n      if (prop === \"copyAssigned\") {\n        return copyAssigned;\n      }\n      return ReflectGet(obj, prop, receiver);\n    },\n    set(obj, prop, value) {\n      if (`${+prop}` === prop) {\n        modifiedEntries[prop] = 1;\n      }\n      return ReflectSet(obj, prop, value);\n    }\n  });\n}\nfunction setupHandle(socket, type, options) {\n  if (this.destroyed) {\n    process.nextTick(emit, this, \"connect\", this, socket);\n    return;\n  }\n  assert(socket._handle !== void 0, \"Internal HTTP/2 Failure. The socket is not connected. Please report this as a bug in Node.js\");\n  debugSession(type, \"setting up session handle\");\n  this[kState].flags |= SESSION_FLAGS_READY;\n  updateOptionsBuffer(options);\n  const handle = new binding.Http2Session(type);\n  handle[kOwner] = this;\n  if (typeof options.selectPadding === \"function\")\n    this[kSelectPadding] = options.selectPadding;\n  handle.consume(socket._handle);\n  this[kHandle] = handle;\n  if (this[kNativeFields]) {\n    this[kNativeFields].copyAssigned(handle.fields);\n  }\n  this[kNativeFields] = handle.fields;\n  if (socket.encrypted) {\n    this[kAlpnProtocol] = socket.alpnProtocol;\n    this[kEncrypted] = true;\n  } else {\n    this[kAlpnProtocol] = \"h2c\";\n    this[kEncrypted] = false;\n  }\n  if (isUint32(options.maxSessionInvalidFrames)) {\n    const uint32 = new Uint32Array(this[kNativeFields].buffer, kSessionMaxInvalidFrames, 1);\n    uint32[0] = options.maxSessionInvalidFrames;\n  }\n  if (isUint32(options.maxSessionRejectedStreams)) {\n    const uint32 = new Uint32Array(this[kNativeFields].buffer, kSessionMaxRejectedStreams, 1);\n    uint32[0] = options.maxSessionRejectedStreams;\n  }\n  const settings = typeof options.settings === \"object\" ? options.settings : {};\n  this.settings(settings);\n  if (type === NGHTTP2_SESSION_SERVER && ArrayIsArray(options.origins)) {\n    ReflectApply(this.origin, this, options.origins);\n  }\n  process.nextTick(emit, this, \"connect\", this, socket);\n}\nfunction emitClose(self, error) {\n  if (error)\n    self.emit(\"error\", error);\n  self.emit(\"close\");\n}\nfunction cleanupSession(session) {\n  const socket = session[kSocket];\n  const handle = session[kHandle];\n  session[kProxySocket] = void 0;\n  session[kSocket] = void 0;\n  session[kHandle] = void 0;\n  session[kNativeFields] = trackAssignmentsTypedArray(new Uint8Array(kSessionUint8FieldCount));\n  if (handle)\n    handle.ondone = null;\n  if (socket) {\n    socket[kSession] = void 0;\n    socket[kServer] = void 0;\n  }\n}\nfunction finishSessionClose(session, error) {\n  debugSessionObj(session, \"finishSessionClose\");\n  const socket = session[kSocket];\n  cleanupSession(session);\n  if (socket && !socket.destroyed) {\n    socket.end((err) => {\n      debugSessionObj(session, \"finishSessionClose socket end\", err, error);\n      socket.destroy(error);\n      emitClose(session, error);\n    });\n  } else {\n    process.nextTick(emitClose, session, error);\n  }\n}\nfunction closeSession(session, code, error) {\n  debugSessionObj(session, \"start closing/destroying\", error);\n  const state = session[kState];\n  state.flags |= SESSION_FLAGS_DESTROYED;\n  state.destroyCode = code;\n  session.setTimeout(0);\n  session.removeAllListeners(\"timeout\");\n  if (state.pendingStreams.size > 0 || state.streams.size > 0) {\n    const cancel = new ERR_HTTP2_STREAM_CANCEL(error);\n    state.pendingStreams.forEach((stream) => stream.destroy(cancel));\n    state.streams.forEach((stream) => stream.destroy(error));\n  }\n  const socket = session[kSocket];\n  const handle = session[kHandle];\n  if (handle !== void 0) {\n    handle.ondone = FunctionPrototypeBind(finishSessionClose, null, session, error);\n    handle.destroy(code, socket.destroyed);\n  } else {\n    finishSessionClose(session, error);\n  }\n}\nclass Http2Session extends EventEmitter {\n  constructor(type, options, socket) {\n    super();\n    if (!socket._handle || !socket._handle.isStreamBase) {\n      socket = new JSStreamSocket(socket);\n    }\n    socket.on(\"error\", socketOnError);\n    socket.on(\"close\", socketOnClose);\n    if (socket[kSession] !== void 0)\n      throw new ERR_HTTP2_SOCKET_BOUND();\n    socket[kSession] = this;\n    this[kState] = {\n      destroyCode: NGHTTP2_NO_ERROR,\n      flags: SESSION_FLAGS_PENDING,\n      goawayCode: null,\n      goawayLastStreamID: null,\n      streams: new SafeMap(),\n      pendingStreams: new SafeSet(),\n      pendingAck: 0,\n      shutdownWritableCalled: false,\n      writeQueueSize: 0,\n      originSet: void 0\n    };\n    this[kEncrypted] = void 0;\n    this[kAlpnProtocol] = void 0;\n    this[kType] = type;\n    this[kProxySocket] = null;\n    this[kSocket] = socket;\n    this[kTimeout] = null;\n    this[kHandle] = void 0;\n    if (typeof socket.setNoDelay === \"function\")\n      socket.setNoDelay();\n    if (typeof socket.disableRenegotiation === \"function\")\n      socket.disableRenegotiation();\n    const setupFn = FunctionPrototypeBind(setupHandle, this, socket, type, options);\n    if (socket.connecting || socket.secureConnecting) {\n      const connectEvent = socket instanceof tls.TLSSocket ? \"secureConnect\" : \"connect\";\n      socket.once(connectEvent, () => {\n        try {\n          setupFn();\n        } catch (error) {\n          socket.destroy(error);\n        }\n      });\n    } else {\n      setupFn();\n    }\n    if (!this[kNativeFields]) {\n      this[kNativeFields] = trackAssignmentsTypedArray(new Uint8Array(kSessionUint8FieldCount));\n    }\n    this.on(\"newListener\", sessionListenerAdded);\n    this.on(\"removeListener\", sessionListenerRemoved);\n    debugSession(type, \"created\");\n  }\n  get encrypted() {\n    return this[kEncrypted];\n  }\n  get alpnProtocol() {\n    return this[kAlpnProtocol];\n  }\n  get originSet() {\n    if (!this.encrypted || this.destroyed)\n      return void 0;\n    return ArrayFrom(initOriginSet(this));\n  }\n  get connecting() {\n    return (this[kState].flags & SESSION_FLAGS_READY) === 0;\n  }\n  get closed() {\n    return !!(this[kState].flags & SESSION_FLAGS_CLOSED);\n  }\n  get destroyed() {\n    return !!(this[kState].flags & SESSION_FLAGS_DESTROYED);\n  }\n  [kUpdateTimer]() {\n    if (this.destroyed)\n      return;\n    if (this[kTimeout])\n      this[kTimeout].refresh();\n  }\n  setNextStreamID(id) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    validateNumber(id, \"id\");\n    if (id <= 0 || id > kMaxStreams)\n      throw new ERR_OUT_OF_RANGE(\"id\", `> 0 and <= ${kMaxStreams}`, id);\n    this[kHandle].setNextStreamID(id);\n  }\n  setLocalWindowSize(windowSize) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    validateInt32(windowSize, \"windowSize\", 0);\n    const ret = this[kHandle].setLocalWindowSize(windowSize);\n    if (ret === NGHTTP2_ERR_NOMEM) {\n      this.destroy(new ERR_HTTP2_NO_MEM());\n    }\n  }\n  ping(payload, callback) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    if (typeof payload === \"function\") {\n      callback = payload;\n      payload = void 0;\n    }\n    if (payload && !isArrayBufferView(payload)) {\n      throw new ERR_INVALID_ARG_TYPE(\"payload\", [\"Buffer\", \"TypedArray\", \"DataView\"], payload);\n    }\n    if (payload && payload.length !== 8) {\n      throw new ERR_HTTP2_PING_LENGTH();\n    }\n    validateCallback(callback);\n    const cb = pingCallback(callback);\n    if (this.connecting || this.closed) {\n      process.nextTick(cb, false, 0, payload);\n      return;\n    }\n    return this[kHandle].ping(payload, cb);\n  }\n  [kInspect](depth, opts) {\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const obj = {\n      type: this[kType],\n      closed: this.closed,\n      destroyed: this.destroyed,\n      state: this.state,\n      localSettings: this.localSettings,\n      remoteSettings: this.remoteSettings\n    };\n    return `Http2Session ${format(obj)}`;\n  }\n  get socket() {\n    const proxySocket = this[kProxySocket];\n    if (proxySocket === null)\n      return this[kProxySocket] = new Proxy(this, proxySocketHandler);\n    return proxySocket;\n  }\n  get type() {\n    return this[kType];\n  }\n  get goawayCode() {\n    return this[kState].goawayCode || NGHTTP2_NO_ERROR;\n  }\n  get goawayLastStreamID() {\n    return this[kState].goawayLastStreamID || 0;\n  }\n  get pendingSettingsAck() {\n    return this[kState].pendingAck > 0;\n  }\n  get state() {\n    return this.connecting || this.destroyed ? {} : getSessionState(this[kHandle]);\n  }\n  get localSettings() {\n    const settings = this[kLocalSettings];\n    if (settings !== void 0)\n      return settings;\n    if (this.destroyed || this.connecting)\n      return {};\n    return this[kLocalSettings] = getSettings(this[kHandle], false);\n  }\n  get remoteSettings() {\n    if (this[kNativeFields][kBitfield] & 1 << kSessionRemoteSettingsIsUpToDate) {\n      const settings = this[kRemoteSettings];\n      if (settings !== void 0) {\n        return settings;\n      }\n    }\n    if (this.destroyed || this.connecting)\n      return {};\n    this[kNativeFields][kBitfield] |= 1 << kSessionRemoteSettingsIsUpToDate;\n    return this[kRemoteSettings] = getSettings(this[kHandle], true);\n  }\n  settings(settings, callback) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    assertIsObject(settings, \"settings\");\n    validateSettings(settings);\n    if (callback) {\n      validateCallback(callback);\n    }\n    debugSessionObj(this, \"sending settings\");\n    this[kState].pendingAck++;\n    const settingsFn = FunctionPrototypeBind(submitSettings, this, { ...settings }, callback);\n    if (this.connecting) {\n      this.once(\"connect\", settingsFn);\n      return;\n    }\n    settingsFn();\n  }\n  goaway(code = NGHTTP2_NO_ERROR, lastStreamID = 0, opaqueData) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    if (opaqueData !== void 0 && !isArrayBufferView(opaqueData)) {\n      throw new ERR_INVALID_ARG_TYPE(\"opaqueData\", [\"Buffer\", \"TypedArray\", \"DataView\"], opaqueData);\n    }\n    validateNumber(code, \"code\");\n    validateNumber(lastStreamID, \"lastStreamID\");\n    const goawayFn = FunctionPrototypeBind(submitGoaway, this, code, lastStreamID, opaqueData);\n    if (this.connecting) {\n      this.once(\"connect\", goawayFn);\n      return;\n    }\n    goawayFn();\n  }\n  destroy(error = NGHTTP2_NO_ERROR, code) {\n    if (this.destroyed)\n      return;\n    debugSessionObj(this, \"destroying\");\n    if (typeof error === \"number\") {\n      code = error;\n      error = code !== NGHTTP2_NO_ERROR ? new ERR_HTTP2_SESSION_ERROR(code) : void 0;\n    }\n    if (code === void 0 && error != null)\n      code = NGHTTP2_INTERNAL_ERROR;\n    closeSession(this, code, error);\n  }\n  close(callback) {\n    if (this.closed || this.destroyed)\n      return;\n    debugSessionObj(this, \"marking session closed\");\n    this[kState].flags |= SESSION_FLAGS_CLOSED;\n    if (typeof callback === \"function\")\n      this.once(\"close\", callback);\n    this.goaway();\n    this[kMaybeDestroy]();\n  }\n  [EventEmitter.captureRejectionSymbol](err, event, ...args) {\n    switch (event) {\n      case \"stream\":\n        const stream = args[0];\n        stream.destroy(err);\n        break;\n      default:\n        this.destroy(err);\n    }\n  }\n  [kMaybeDestroy](error) {\n    if (error == null) {\n      const state = this[kState];\n      if (!this.closed || state.streams.size > 0 || state.pendingStreams.size > 0) {\n        return;\n      }\n    }\n    this.destroy(error);\n  }\n  _onTimeout() {\n    callTimeout(this);\n  }\n  ref() {\n    if (this[kSocket]) {\n      this[kSocket].ref();\n    }\n  }\n  unref() {\n    if (this[kSocket]) {\n      this[kSocket].unref();\n    }\n  }\n}\nclass ServerHttp2Session extends Http2Session {\n  constructor(options, socket, server) {\n    super(NGHTTP2_SESSION_SERVER, options, socket);\n    this[kServer] = server;\n    this[kNativeFields][kSessionPriorityListenerCount] = server.listenerCount(\"priority\");\n  }\n  get server() {\n    return this[kServer];\n  }\n  altsvc(alt, originOrStream) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    let stream = 0;\n    let origin;\n    if (typeof originOrStream === \"string\") {\n      origin = new URL(originOrStream).origin;\n      if (origin === \"null\")\n        throw new ERR_HTTP2_ALTSVC_INVALID_ORIGIN();\n    } else if (typeof originOrStream === \"number\") {\n      if (originOrStream >>> 0 !== originOrStream || originOrStream === 0) {\n        throw new ERR_OUT_OF_RANGE(\"originOrStream\", `> 0 && < ${2 ** 32}`, originOrStream);\n      }\n      stream = originOrStream;\n    } else if (originOrStream !== void 0) {\n      if (originOrStream !== null && typeof originOrStream === \"object\")\n        origin = originOrStream.origin;\n      if (typeof origin !== \"string\") {\n        throw new ERR_INVALID_ARG_TYPE(\"originOrStream\", [\"string\", \"number\", \"URL\", \"object\"], originOrStream);\n      } else if (origin === \"null\" || origin.length === 0) {\n        throw new ERR_HTTP2_ALTSVC_INVALID_ORIGIN();\n      }\n    }\n    validateString(alt, \"alt\");\n    if (!RegExpPrototypeTest(kQuotedString, alt))\n      throw new ERR_INVALID_CHAR(\"alt\");\n    if (alt.length + (origin !== void 0 ? origin.length : 0) > kMaxALTSVC)\n      throw new ERR_HTTP2_ALTSVC_LENGTH();\n    this[kHandle].altsvc(stream, origin || \"\", alt);\n  }\n  origin(...origins) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    if (origins.length === 0)\n      return;\n    let arr = \"\";\n    let len = 0;\n    const count = origins.length;\n    for (let i = 0; i < count; i++) {\n      let origin = origins[i];\n      if (typeof origin === \"string\") {\n        origin = new URL(origin).origin;\n      } else if (origin != null && typeof origin === \"object\") {\n        origin = origin.origin;\n      }\n      validateString(origin, \"origin\");\n      if (origin === \"null\")\n        throw new ERR_HTTP2_INVALID_ORIGIN();\n      arr += `${origin}\\0`;\n      len += origin.length;\n    }\n    if (len > kMaxALTSVC)\n      throw new ERR_HTTP2_ORIGIN_LENGTH();\n    this[kHandle].origin(arr, count);\n  }\n}\nclass ClientHttp2Session extends Http2Session {\n  constructor(options, socket) {\n    super(NGHTTP2_SESSION_CLIENT, options, socket);\n    this[kPendingRequestCalls] = null;\n  }\n  request(headers, options) {\n    debugSessionObj(this, \"initiating request\");\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_SESSION();\n    if (this.closed)\n      throw new ERR_HTTP2_GOAWAY_SESSION();\n    this[kUpdateTimer]();\n    if (headers !== null && headers !== void 0) {\n      const keys = ObjectKeys(headers);\n      for (let i = 0; i < keys.length; i++) {\n        const header = keys[i];\n        if (header[0] === \":\") {\n          assertValidPseudoHeader(header);\n        } else if (header && !checkIsHttpToken(header))\n          this.destroy(new ERR_INVALID_HTTP_TOKEN(\"Header name\", header));\n      }\n    }\n    assertIsObject(headers, \"headers\");\n    assertIsObject(options, \"options\");\n    headers = ObjectAssign(ObjectCreate(null), headers);\n    options = { ...options };\n    if (headers[HTTP2_HEADER_METHOD] === void 0)\n      headers[HTTP2_HEADER_METHOD] = HTTP2_METHOD_GET;\n    const connect2 = headers[HTTP2_HEADER_METHOD] === HTTP2_METHOD_CONNECT;\n    if (!connect2 || headers[HTTP2_HEADER_PROTOCOL] !== void 0) {\n      if (getAuthority(headers) === void 0)\n        headers[HTTP2_HEADER_AUTHORITY] = this[kAuthority];\n      if (headers[HTTP2_HEADER_SCHEME] === void 0)\n        headers[HTTP2_HEADER_SCHEME] = StringPrototypeSlice(this[kProtocol], 0, -1);\n      if (headers[HTTP2_HEADER_PATH] === void 0)\n        headers[HTTP2_HEADER_PATH] = \"/\";\n    } else {\n      if (headers[HTTP2_HEADER_AUTHORITY] === void 0)\n        throw new ERR_HTTP2_CONNECT_AUTHORITY();\n      if (headers[HTTP2_HEADER_SCHEME] !== void 0)\n        throw new ERR_HTTP2_CONNECT_SCHEME();\n      if (headers[HTTP2_HEADER_PATH] !== void 0)\n        throw new ERR_HTTP2_CONNECT_PATH();\n    }\n    setAndValidatePriorityOptions(options);\n    if (options.endStream === void 0) {\n      options.endStream = isPayloadMeaningless(headers[HTTP2_HEADER_METHOD]);\n    } else if (typeof options.endStream !== \"boolean\") {\n      throw new ERR_INVALID_ARG_VALUE(\"options.endStream\", options.endStream);\n    }\n    const headersList = mapToHeaders(headers);\n    const stream = new ClientHttp2Stream(this, void 0, void 0, {});\n    stream[kSentHeaders] = headers;\n    stream[kOrigin] = `${headers[HTTP2_HEADER_SCHEME]}://${getAuthority(headers)}`;\n    if (options.endStream)\n      stream.end();\n    if (options.waitForTrailers)\n      stream[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n    const { signal } = options;\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n      const aborter = () => stream.destroy(new AbortError());\n      if (signal.aborted) {\n        aborter();\n      } else {\n        signal.addEventListener(\"abort\", aborter);\n        stream.once(\"close\", () => {\n          signal.removeEventListener(\"abort\", aborter);\n        });\n      }\n    }\n    const onConnect = FunctionPrototypeBind(requestOnConnect, stream, headersList, options);\n    if (this.connecting) {\n      if (this[kPendingRequestCalls] !== null) {\n        ArrayPrototypePush(this[kPendingRequestCalls], onConnect);\n      } else {\n        this[kPendingRequestCalls] = [onConnect];\n        this.once(\"connect\", () => {\n          ArrayPrototypeForEach(this[kPendingRequestCalls], (f) => f());\n          this[kPendingRequestCalls] = null;\n        });\n      }\n    } else {\n      onConnect();\n    }\n    return stream;\n  }\n}\nfunction trackWriteState(stream, bytes) {\n  const session = stream[kSession];\n  stream[kState].writeQueueSize += bytes;\n  session[kState].writeQueueSize += bytes;\n  session[kHandle].chunksSentSinceLastWrite = 0;\n}\nfunction streamOnResume() {\n  if (!this.destroyed)\n    this[kHandle].readStart();\n}\nfunction streamOnPause() {\n  if (!this.destroyed && !this.pending)\n    this[kHandle].readStop();\n}\nfunction afterShutdown(status) {\n  const stream = this.handle[kOwner];\n  if (stream) {\n    stream.on(\"finish\", () => {\n      stream[kMaybeDestroy]();\n    });\n  }\n  this.callback();\n}\nfunction shutdownWritable(callback) {\n  const handle = this[kHandle];\n  if (!handle)\n    return callback();\n  const state = this[kState];\n  if (state.shutdownWritableCalled) {\n    debugStreamObj(this, \"shutdownWritable() already called\");\n    return callback();\n  }\n  state.shutdownWritableCalled = true;\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.callback = callback;\n  req.handle = handle;\n  const err = handle.shutdown(req);\n  if (err === 1)\n    return ReflectApply(afterShutdown, req, [0]);\n}\nfunction finishSendTrailers(stream, headersList) {\n  if (stream.destroyed) {\n    return;\n  }\n  stream[kState].flags &= ~STREAM_FLAGS_HAS_TRAILERS;\n  const ret = stream[kHandle].trailers(headersList);\n  if (ret < 0)\n    stream.destroy(new NghttpError(ret));\n  else\n    stream[kMaybeDestroy]();\n}\nconst kNoRstStream = 0;\nconst kSubmitRstStream = 1;\nconst kForceRstStream = 2;\nfunction closeStream(stream, code, rstStreamStatus = kSubmitRstStream) {\n  const state = stream[kState];\n  state.flags |= STREAM_FLAGS_CLOSED;\n  state.rstCode = code;\n  stream.setTimeout(0);\n  stream.removeAllListeners(\"timeout\");\n  const { ending } = stream._writableState;\n  if (!ending) {\n    if (!stream.aborted) {\n      state.flags |= STREAM_FLAGS_ABORTED;\n      stream.emit(\"aborted\");\n    }\n    stream.end();\n  }\n  if (rstStreamStatus !== kNoRstStream) {\n    const finishFn = FunctionPrototypeBind(finishCloseStream, stream, code);\n    if (!ending || stream.writableFinished || code !== NGHTTP2_NO_ERROR || rstStreamStatus === kForceRstStream)\n      finishFn();\n    else\n      stream.once(\"finish\", finishFn);\n  }\n}\nfunction finishCloseStream(code) {\n  const rstStreamFn = FunctionPrototypeBind(submitRstStream, this, code);\n  if (this.pending) {\n    this.push(null);\n    this.once(\"ready\", rstStreamFn);\n    return;\n  }\n  rstStreamFn();\n}\nclass Http2Stream extends Duplex {\n  constructor(session, options) {\n    options.allowHalfOpen = true;\n    options.decodeStrings = false;\n    options.autoDestroy = false;\n    super(options);\n    this[async_id_symbol] = -1;\n    this.cork();\n    this[kSession] = session;\n    session[kState].pendingStreams.add(this);\n    this._readableState.readingMore = true;\n    this[kTimeout] = null;\n    this[kState] = {\n      didRead: false,\n      flags: STREAM_FLAGS_PENDING,\n      rstCode: NGHTTP2_NO_ERROR,\n      writeQueueSize: 0,\n      trailersReady: false,\n      endAfterHeaders: false\n    };\n    this[kRequest] = null;\n    this[kProxySocket] = null;\n    this.on(\"pause\", streamOnPause);\n    this.on(\"newListener\", streamListenerAdded);\n    this.on(\"removeListener\", streamListenerRemoved);\n  }\n  [kUpdateTimer]() {\n    if (this.destroyed)\n      return;\n    if (this[kTimeout])\n      this[kTimeout].refresh();\n    if (this[kSession])\n      this[kSession][kUpdateTimer]();\n  }\n  [kInit](id, handle) {\n    const state = this[kState];\n    state.flags |= STREAM_FLAGS_READY;\n    const session = this[kSession];\n    session[kState].pendingStreams.delete(this);\n    session[kState].streams.set(id, this);\n    this[kID] = id;\n    this[async_id_symbol] = handle.getAsyncId();\n    handle[kOwner] = this;\n    this[kHandle] = handle;\n    handle.onread = onStreamRead;\n    this.uncork();\n    this.emit(\"ready\");\n  }\n  [kInspect](depth, opts) {\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const obj = {\n      id: this[kID] || \"<pending>\",\n      closed: this.closed,\n      destroyed: this.destroyed,\n      state: this.state,\n      readableState: this._readableState,\n      writableState: this._writableState\n    };\n    return `Http2Stream ${format(obj)}`;\n  }\n  get bufferSize() {\n    return this[kState].writeQueueSize + this.writableLength;\n  }\n  get endAfterHeaders() {\n    return this[kState].endAfterHeaders;\n  }\n  get sentHeaders() {\n    return this[kSentHeaders];\n  }\n  get sentTrailers() {\n    return this[kSentTrailers];\n  }\n  get sentInfoHeaders() {\n    return this[kInfoHeaders];\n  }\n  get pending() {\n    return this[kID] === void 0;\n  }\n  get id() {\n    return this[kID];\n  }\n  get session() {\n    return this[kSession];\n  }\n  _onTimeout() {\n    callTimeout(this, kSession);\n  }\n  get headersSent() {\n    return !!(this[kState].flags & STREAM_FLAGS_HEADERS_SENT);\n  }\n  get aborted() {\n    return !!(this[kState].flags & STREAM_FLAGS_ABORTED);\n  }\n  get headRequest() {\n    return !!(this[kState].flags & STREAM_FLAGS_HEAD_REQUEST);\n  }\n  get rstCode() {\n    return this[kState].rstCode;\n  }\n  get state() {\n    const id = this[kID];\n    if (this.destroyed || id === void 0)\n      return {};\n    return getStreamState(this[kHandle], id);\n  }\n  [kProceed]() {\n    assert.fail(\"Implementors MUST implement this. Please report this as a bug in Node.js\");\n  }\n  [kAfterAsyncWrite]({ bytes }) {\n    this[kState].writeQueueSize -= bytes;\n    if (this.session !== void 0)\n      this.session[kState].writeQueueSize -= bytes;\n  }\n  [kWriteGeneric](writev, data, encoding, cb) {\n    if (this.pending) {\n      this.once(\"ready\", FunctionPrototypeBind(this[kWriteGeneric], this, writev, data, encoding, cb));\n      return;\n    }\n    if (this.destroyed)\n      return;\n    this[kUpdateTimer]();\n    if (!this.headersSent)\n      this[kProceed]();\n    let req;\n    let waitingForWriteCallback = true;\n    let waitingForEndCheck = true;\n    let writeCallbackErr;\n    let endCheckCallbackErr;\n    const done = () => {\n      if (waitingForEndCheck || waitingForWriteCallback)\n        return;\n      const err = aggregateTwoErrors(endCheckCallbackErr, writeCallbackErr);\n      if (err) {\n        this.destroy(err);\n      }\n      cb(err);\n    };\n    const writeCallback = (err) => {\n      waitingForWriteCallback = false;\n      writeCallbackErr = err;\n      done();\n    };\n    const endCheckCallback = (err) => {\n      waitingForEndCheck = false;\n      endCheckCallbackErr = err;\n      done();\n    };\n    process.nextTick(() => {\n      if (writeCallbackErr || !this._writableState.ending || this._writableState.buffered.length || this[kState].flags & STREAM_FLAGS_HAS_TRAILERS)\n        return endCheckCallback();\n      debugStreamObj(this, \"shutting down writable on last write\");\n      shutdownWritable.call(this, endCheckCallback);\n    });\n    if (writev)\n      req = writevGeneric(this, data, writeCallback);\n    else\n      req = writeGeneric(this, data, encoding, writeCallback);\n    trackWriteState(this, req.bytes);\n  }\n  _write(data, encoding, cb) {\n    this[kWriteGeneric](false, data, encoding, cb);\n  }\n  _writev(data, cb) {\n    this[kWriteGeneric](true, data, \"\", cb);\n  }\n  _final(cb) {\n    if (this.pending) {\n      this.once(\"ready\", () => this._final(cb));\n      return;\n    }\n    debugStreamObj(this, \"shutting down writable on _final\");\n    ReflectApply(shutdownWritable, this, [cb]);\n  }\n  _read(nread) {\n    if (this.destroyed) {\n      this.push(null);\n      return;\n    }\n    if (!this[kState].didRead) {\n      this._readableState.readingMore = false;\n      this[kState].didRead = true;\n    }\n    if (!this.pending) {\n      FunctionPrototypeCall(streamOnResume, this);\n    } else {\n      this.once(\"ready\", streamOnResume);\n    }\n  }\n  priority(options) {\n    if (this.destroyed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    assertIsObject(options, \"options\");\n    options = { ...options };\n    setAndValidatePriorityOptions(options);\n    const priorityFn = FunctionPrototypeBind(submitPriority, this, options);\n    if (this.pending) {\n      this.once(\"ready\", priorityFn);\n      return;\n    }\n    priorityFn();\n  }\n  sendTrailers(headers) {\n    if (this.destroyed || this.closed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    if (this[kSentTrailers])\n      throw new ERR_HTTP2_TRAILERS_ALREADY_SENT();\n    if (!this[kState].trailersReady)\n      throw new ERR_HTTP2_TRAILERS_NOT_READY();\n    assertIsObject(headers, \"headers\");\n    headers = ObjectAssign(ObjectCreate(null), headers);\n    debugStreamObj(this, \"sending trailers\");\n    this[kUpdateTimer]();\n    const headersList = mapToHeaders(headers, assertValidPseudoHeaderTrailer);\n    this[kSentTrailers] = headers;\n    setImmediate(finishSendTrailers, this, headersList);\n  }\n  get closed() {\n    return !!(this[kState].flags & STREAM_FLAGS_CLOSED);\n  }\n  close(code = NGHTTP2_NO_ERROR, callback) {\n    validateInteger(code, \"code\", 0, kMaxInt);\n    if (callback !== void 0) {\n      validateCallback(callback);\n    }\n    if (this.closed)\n      return;\n    if (callback !== void 0)\n      this.once(\"close\", callback);\n    closeStream(this, code);\n  }\n  _destroy(err, callback) {\n    const session = this[kSession];\n    const handle = this[kHandle];\n    const id = this[kID];\n    debugStream(this[kID] || \"pending\", session[kType], \"destroying stream\");\n    const state = this[kState];\n    const sessionState = session[kState];\n    const sessionCode = sessionState.goawayCode || sessionState.destroyCode;\n    const code = err != null ? sessionCode || NGHTTP2_INTERNAL_ERROR : this.closed ? this.rstCode : sessionCode;\n    const hasHandle = handle !== void 0;\n    if (!this.closed)\n      closeStream(this, code, hasHandle ? kForceRstStream : kNoRstStream);\n    this.push(null);\n    if (hasHandle) {\n      handle.destroy();\n      sessionState.streams.delete(id);\n    } else {\n      sessionState.pendingStreams.delete(this);\n    }\n    sessionState.writeQueueSize -= state.writeQueueSize;\n    state.writeQueueSize = 0;\n    if (err == null && code !== NGHTTP2_NO_ERROR && code !== NGHTTP2_CANCEL)\n      err = new ERR_HTTP2_STREAM_ERROR(nameForErrorCode[code] || code);\n    this[kSession] = void 0;\n    this[kHandle] = void 0;\n    session[kMaybeDestroy]();\n    callback(err);\n  }\n  [kMaybeDestroy](code = NGHTTP2_NO_ERROR) {\n    if (code !== NGHTTP2_NO_ERROR) {\n      this.destroy();\n      return;\n    }\n    if (this.writableFinished) {\n      if (!this.readable && this.closed) {\n        this.destroy();\n        return;\n      }\n      const state = this[kState];\n      if (this.headersSent && this[kSession] && this[kSession][kType] === NGHTTP2_SESSION_SERVER && !(state.flags & STREAM_FLAGS_HAS_TRAILERS) && !state.didRead && this.readableFlowing === null) {\n        setImmediate(callStreamClose, this);\n      }\n    }\n  }\n}\nfunction callTimeout(self, kSession2) {\n  if (self.destroyed)\n    return;\n  if (self[kState].writeQueueSize > 0) {\n    const handle = kSession2 ? self[kSession2][kHandle] : self[kHandle];\n    const chunksSentSinceLastWrite = handle !== void 0 ? handle.chunksSentSinceLastWrite : null;\n    if (chunksSentSinceLastWrite !== null && chunksSentSinceLastWrite !== handle.updateChunksSent()) {\n      self[kUpdateTimer]();\n      return;\n    }\n  }\n  self.emit(\"timeout\");\n}\nfunction callStreamClose(stream) {\n  stream.close();\n}\nfunction processHeaders(oldHeaders, options) {\n  assertIsObject(oldHeaders, \"headers\");\n  const headers = ObjectCreate(null);\n  if (oldHeaders !== null && oldHeaders !== void 0) {\n    for (const key in oldHeaders) {\n      if (ObjectPrototypeHasOwnProperty(oldHeaders, key)) {\n        headers[key] = oldHeaders[key];\n      }\n    }\n    headers[kSensitiveHeaders] = oldHeaders[kSensitiveHeaders];\n  }\n  const statusCode = headers[HTTP2_HEADER_STATUS] = headers[HTTP2_HEADER_STATUS] | 0 || HTTP_STATUS_OK;\n  if (options.sendDate == null || options.sendDate) {\n    if (headers[HTTP2_HEADER_DATE] === null || headers[HTTP2_HEADER_DATE] === void 0) {\n      headers[HTTP2_HEADER_DATE] = utcDate();\n    }\n  }\n  if (statusCode < 200 || statusCode > 599)\n    throw new ERR_HTTP2_STATUS_INVALID(headers[HTTP2_HEADER_STATUS]);\n  const neverIndex = headers[kSensitiveHeaders];\n  if (neverIndex !== void 0 && !ArrayIsArray(neverIndex))\n    throw new ERR_INVALID_ARG_VALUE(\"headers[http2.neverIndex]\", neverIndex);\n  return headers;\n}\nfunction onFileUnpipe() {\n  const stream = this.sink[kOwner];\n  if (stream.ownsFd)\n    PromisePrototypeCatch(this.source.close(), FunctionPrototypeBind(stream.destroy, stream));\n  else\n    this.source.releaseFD();\n}\nfunction onPipedFileHandleRead() {\n  const err = streamBaseState[kReadBytesOrError];\n  if (err < 0 && err !== UV_EOF) {\n    this.stream.close(NGHTTP2_INTERNAL_ERROR);\n  }\n}\nfunction processRespondWithFD(self, fd, headers, offset = 0, length = -1, streamOptions = 0) {\n  const state = self[kState];\n  state.flags |= STREAM_FLAGS_HEADERS_SENT;\n  let headersList;\n  try {\n    headersList = mapToHeaders(headers, assertValidPseudoHeaderResponse);\n  } catch (err) {\n    self.destroy(err);\n    return;\n  }\n  self[kSentHeaders] = headers;\n  self._final = null;\n  self.end();\n  const ret = self[kHandle].respond(headersList, streamOptions);\n  if (ret < 0) {\n    self.destroy(new NghttpError(ret));\n    return;\n  }\n  defaultTriggerAsyncIdScope(self[async_id_symbol], startFilePipe, self, fd, offset, length);\n}\nfunction startFilePipe(self, fd, offset, length) {\n  const handle = new FileHandle(fd, offset, length);\n  handle.onread = onPipedFileHandleRead;\n  handle.stream = self;\n  const pipe = new StreamPipe(handle, self[kHandle]);\n  pipe.onunpipe = onFileUnpipe;\n  pipe.start();\n  trackWriteState(self, 1);\n}\nfunction doSendFD(session, options, fd, headers, streamOptions, err, stat) {\n  if (err) {\n    this.destroy(err);\n    return;\n  }\n  if (this.destroyed || this.closed) {\n    this.destroy(new ERR_HTTP2_INVALID_STREAM());\n    return;\n  }\n  const statOptions = {\n    offset: options.offset !== void 0 ? options.offset : 0,\n    length: options.length !== void 0 ? options.length : -1\n  };\n  if (typeof options.statCheck === \"function\" && ReflectApply(options.statCheck, this, [stat, headers, statOptions]) === false || this[kState].flags & STREAM_FLAGS_HEADERS_SENT) {\n    return;\n  }\n  processRespondWithFD(this, fd, headers, statOptions.offset | 0, statOptions.length | 0, streamOptions);\n}\nfunction doSendFileFD(session, options, fd, headers, streamOptions, err, stat) {\n  const onError = options.onError;\n  if (err) {\n    tryClose(fd);\n    if (onError)\n      onError(err);\n    else\n      this.destroy(err);\n    return;\n  }\n  if (!stat.isFile()) {\n    const isDirectory = stat.isDirectory();\n    if (options.offset !== void 0 || options.offset > 0 || options.length !== void 0 || options.length >= 0 || isDirectory) {\n      const err2 = isDirectory ? new ERR_HTTP2_SEND_FILE() : new ERR_HTTP2_SEND_FILE_NOSEEK();\n      tryClose(fd);\n      if (onError)\n        onError(err2);\n      else\n        this.destroy(err2);\n      return;\n    }\n    options.offset = -1;\n    options.length = -1;\n  }\n  if (this.destroyed || this.closed) {\n    tryClose(fd);\n    this.destroy(new ERR_HTTP2_INVALID_STREAM());\n    return;\n  }\n  const statOptions = {\n    offset: options.offset !== void 0 ? options.offset : 0,\n    length: options.length !== void 0 ? options.length : -1\n  };\n  if (typeof options.statCheck === \"function\" && ReflectApply(options.statCheck, this, [stat, headers]) === false || this[kState].flags & STREAM_FLAGS_HEADERS_SENT) {\n    tryClose(fd);\n    return;\n  }\n  if (stat.isFile()) {\n    statOptions.length = statOptions.length < 0 ? stat.size - +statOptions.offset : MathMin(stat.size - +statOptions.offset, statOptions.length);\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = statOptions.length;\n  }\n  processRespondWithFD(this, fd, headers, options.offset | 0, statOptions.length | 0, streamOptions);\n}\nfunction afterOpen(session, options, headers, streamOptions, err, fd) {\n  const state = this[kState];\n  const onError = options.onError;\n  if (err) {\n    if (onError)\n      onError(err);\n    else\n      this.destroy(err);\n    return;\n  }\n  if (this.destroyed || this.closed) {\n    tryClose(fd);\n    return;\n  }\n  state.fd = fd;\n  fs.fstat(fd, FunctionPrototypeBind(doSendFileFD, this, session, options, fd, headers, streamOptions));\n}\nclass ServerHttp2Stream extends Http2Stream {\n  constructor(session, handle, id, options, headers) {\n    super(session, options);\n    handle.owner = this;\n    this[kInit](id, handle);\n    this[kProtocol] = headers[HTTP2_HEADER_SCHEME];\n    this[kAuthority] = getAuthority(headers);\n  }\n  get pushAllowed() {\n    return !this.destroyed && !this.closed && !this.session.closed && !this.session.destroyed && this[kSession].remoteSettings.enablePush;\n  }\n  pushStream(headers, options, callback) {\n    if (!this.pushAllowed)\n      throw new ERR_HTTP2_PUSH_DISABLED();\n    if (this[kID] % 2 === 0)\n      throw new ERR_HTTP2_NESTED_PUSH();\n    const session = this[kSession];\n    debugStreamObj(this, \"initiating push stream\");\n    this[kUpdateTimer]();\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    validateCallback(callback);\n    assertIsObject(options, \"options\");\n    options = { ...options };\n    options.endStream = !!options.endStream;\n    assertIsObject(headers, \"headers\");\n    headers = ObjectAssign(ObjectCreate(null), headers);\n    if (headers[HTTP2_HEADER_METHOD] === void 0)\n      headers[HTTP2_HEADER_METHOD] = HTTP2_METHOD_GET;\n    if (getAuthority(headers) === void 0)\n      headers[HTTP2_HEADER_AUTHORITY] = this[kAuthority];\n    if (headers[HTTP2_HEADER_SCHEME] === void 0)\n      headers[HTTP2_HEADER_SCHEME] = this[kProtocol];\n    if (headers[HTTP2_HEADER_PATH] === void 0)\n      headers[HTTP2_HEADER_PATH] = \"/\";\n    let headRequest = false;\n    if (headers[HTTP2_HEADER_METHOD] === HTTP2_METHOD_HEAD)\n      headRequest = options.endStream = true;\n    const headersList = mapToHeaders(headers);\n    const streamOptions = options.endStream ? STREAM_OPTION_EMPTY_PAYLOAD : 0;\n    const ret = this[kHandle].pushPromise(headersList, streamOptions);\n    let err;\n    if (typeof ret === \"number\") {\n      switch (ret) {\n        case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n          err = new ERR_HTTP2_OUT_OF_STREAMS();\n          break;\n        case NGHTTP2_ERR_STREAM_CLOSED:\n          err = new ERR_HTTP2_INVALID_STREAM();\n          break;\n        default:\n          err = new NghttpError(ret);\n          break;\n      }\n      process.nextTick(callback, err);\n      return;\n    }\n    const id = ret.id();\n    const stream = new ServerHttp2Stream(session, ret, id, options, headers);\n    stream[kSentHeaders] = headers;\n    stream.push(null);\n    if (options.endStream)\n      stream.end();\n    if (headRequest)\n      stream[kState].flags |= STREAM_FLAGS_HEAD_REQUEST;\n    process.nextTick(callback, null, stream, headers, 0);\n  }\n  respond(headers, options) {\n    if (this.destroyed || this.closed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    if (this.headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    const state = this[kState];\n    assertIsObject(options, \"options\");\n    options = { ...options };\n    debugStreamObj(this, \"initiating response\");\n    this[kUpdateTimer]();\n    options.endStream = !!options.endStream;\n    let streamOptions = 0;\n    if (options.endStream)\n      streamOptions |= STREAM_OPTION_EMPTY_PAYLOAD;\n    if (options.waitForTrailers) {\n      streamOptions |= STREAM_OPTION_GET_TRAILERS;\n      state.flags |= STREAM_FLAGS_HAS_TRAILERS;\n    }\n    headers = processHeaders(headers, options);\n    const headersList = mapToHeaders(headers, assertValidPseudoHeaderResponse);\n    this[kSentHeaders] = headers;\n    state.flags |= STREAM_FLAGS_HEADERS_SENT;\n    const statusCode = headers[HTTP2_HEADER_STATUS] | 0;\n    if (!!options.endStream || statusCode === HTTP_STATUS_NO_CONTENT || statusCode === HTTP_STATUS_RESET_CONTENT || statusCode === HTTP_STATUS_NOT_MODIFIED || this.headRequest === true) {\n      options.endStream = true;\n      this.end();\n    }\n    const ret = this[kHandle].respond(headersList, streamOptions);\n    if (ret < 0)\n      this.destroy(new NghttpError(ret));\n  }\n  respondWithFD(fd, headers, options) {\n    if (this.destroyed || this.closed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    if (this.headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    const session = this[kSession];\n    assertIsObject(options, \"options\");\n    options = { ...options };\n    if (options.offset !== void 0 && typeof options.offset !== \"number\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.offset\", options.offset);\n    if (options.length !== void 0 && typeof options.length !== \"number\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.length\", options.length);\n    if (options.statCheck !== void 0 && typeof options.statCheck !== \"function\") {\n      throw new ERR_INVALID_ARG_VALUE(\"options.statCheck\", options.statCheck);\n    }\n    let streamOptions = 0;\n    if (options.waitForTrailers) {\n      streamOptions |= STREAM_OPTION_GET_TRAILERS;\n      this[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n    }\n    if (fd instanceof fsPromisesInternal.FileHandle)\n      fd = fd.fd;\n    else if (typeof fd !== \"number\")\n      throw new ERR_INVALID_ARG_TYPE(\"fd\", [\"number\", \"FileHandle\"], fd);\n    debugStreamObj(this, \"initiating response from fd\");\n    this[kUpdateTimer]();\n    this.ownsFd = false;\n    headers = processHeaders(headers, options);\n    const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;\n    if (statusCode === HTTP_STATUS_NO_CONTENT || statusCode === HTTP_STATUS_RESET_CONTENT || statusCode === HTTP_STATUS_NOT_MODIFIED || this.headRequest) {\n      throw new ERR_HTTP2_PAYLOAD_FORBIDDEN(statusCode);\n    }\n    if (options.statCheck !== void 0) {\n      fs.fstat(fd, FunctionPrototypeBind(doSendFD, this, session, options, fd, headers, streamOptions));\n      return;\n    }\n    processRespondWithFD(this, fd, headers, options.offset, options.length, streamOptions);\n  }\n  respondWithFile(path, headers, options) {\n    if (this.destroyed || this.closed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    if (this.headersSent)\n      throw new ERR_HTTP2_HEADERS_SENT();\n    assertIsObject(options, \"options\");\n    options = { ...options };\n    if (options.offset !== void 0 && typeof options.offset !== \"number\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.offset\", options.offset);\n    if (options.length !== void 0 && typeof options.length !== \"number\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.length\", options.length);\n    if (options.statCheck !== void 0 && typeof options.statCheck !== \"function\") {\n      throw new ERR_INVALID_ARG_VALUE(\"options.statCheck\", options.statCheck);\n    }\n    let streamOptions = 0;\n    if (options.waitForTrailers) {\n      streamOptions |= STREAM_OPTION_GET_TRAILERS;\n      this[kState].flags |= STREAM_FLAGS_HAS_TRAILERS;\n    }\n    const session = this[kSession];\n    debugStreamObj(this, \"initiating response from file\");\n    this[kUpdateTimer]();\n    this.ownsFd = true;\n    headers = processHeaders(headers, options);\n    const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;\n    if (statusCode === HTTP_STATUS_NO_CONTENT || statusCode === HTTP_STATUS_RESET_CONTENT || statusCode === HTTP_STATUS_NOT_MODIFIED || this.headRequest) {\n      throw new ERR_HTTP2_PAYLOAD_FORBIDDEN(statusCode);\n    }\n    fs.open(path, \"r\", FunctionPrototypeBind(afterOpen, this, session, options, headers, streamOptions));\n  }\n  additionalHeaders(headers) {\n    if (this.destroyed || this.closed)\n      throw new ERR_HTTP2_INVALID_STREAM();\n    if (this.headersSent)\n      throw new ERR_HTTP2_HEADERS_AFTER_RESPOND();\n    assertIsObject(headers, \"headers\");\n    headers = ObjectAssign(ObjectCreate(null), headers);\n    debugStreamObj(this, \"sending additional headers\");\n    if (headers[HTTP2_HEADER_STATUS] != null) {\n      const statusCode = headers[HTTP2_HEADER_STATUS] |= 0;\n      if (statusCode === HTTP_STATUS_SWITCHING_PROTOCOLS)\n        throw new ERR_HTTP2_STATUS_101();\n      if (statusCode < 100 || statusCode >= 200) {\n        throw new ERR_HTTP2_INVALID_INFO_STATUS(headers[HTTP2_HEADER_STATUS]);\n      }\n    }\n    this[kUpdateTimer]();\n    const headersList = mapToHeaders(headers, assertValidPseudoHeaderResponse);\n    if (!this[kInfoHeaders])\n      this[kInfoHeaders] = [headers];\n    else\n      ArrayPrototypePush(this[kInfoHeaders], headers);\n    const ret = this[kHandle].info(headersList);\n    if (ret < 0)\n      this.destroy(new NghttpError(ret));\n  }\n}\nServerHttp2Stream.prototype[kProceed] = ServerHttp2Stream.prototype.respond;\nclass ClientHttp2Stream extends Http2Stream {\n  constructor(session, handle, id, options) {\n    super(session, options);\n    this[kState].flags |= STREAM_FLAGS_HEADERS_SENT;\n    if (id !== void 0)\n      this[kInit](id, handle);\n    this.on(\"headers\", handleHeaderContinue);\n  }\n}\nfunction handleHeaderContinue(headers) {\n  if (headers[HTTP2_HEADER_STATUS] === HTTP_STATUS_CONTINUE)\n    this.emit(\"continue\");\n}\nconst setTimeoutValue = {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: setStreamTimeout\n};\nObjectDefineProperty(Http2Stream.prototype, \"setTimeout\", setTimeoutValue);\nObjectDefineProperty(Http2Session.prototype, \"setTimeout\", setTimeoutValue);\nfunction socketOnError(error) {\n  const session = this[kSession];\n  if (session !== void 0) {\n    if (error.code === \"ECONNRESET\" && session[kState].goawayCode !== null)\n      return session.destroy();\n    debugSessionObj(this, \"socket error [%s]\", error.message);\n    session.destroy(error);\n  }\n}\nfunction sessionOnStream(stream, headers, flags, rawHeaders) {\n  if (this[kServer] !== void 0)\n    this[kServer].emit(\"stream\", stream, headers, flags, rawHeaders);\n}\nfunction sessionOnPriority(stream, parent, weight, exclusive) {\n  if (this[kServer] !== void 0)\n    this[kServer].emit(\"priority\", stream, parent, weight, exclusive);\n}\nfunction sessionOnError(error) {\n  if (this[kServer] !== void 0)\n    this[kServer].emit(\"sessionError\", error, this);\n}\nfunction sessionOnTimeout() {\n  if (this.destroyed || this.closed)\n    return;\n  const server = this[kServer];\n  if (!server.emit(\"timeout\", this))\n    this.destroy();\n}\nfunction connectionListener(socket) {\n  debug(\"Http2Session server: received a connection\");\n  const options = this[kOptions] || {};\n  if (socket.alpnProtocol === false || socket.alpnProtocol === \"http/1.1\") {\n    if (options.allowHTTP1 === true) {\n      socket.server[kIncomingMessage] = options.Http1IncomingMessage;\n      socket.server[kServerResponse] = options.Http1ServerResponse;\n      return FunctionPrototypeCall(httpConnectionListener, this, socket);\n    }\n    debug(\"Unknown protocol from %s:%s\", socket.remoteAddress, socket.remotePort);\n    if (!this.emit(\"unknownProtocol\", socket)) {\n      debug(\"Unknown protocol timeout:  %s\", options.unknownProtocolTimeout);\n      const timer = setTimeout(() => {\n        if (!socket.destroyed) {\n          debug(\"UnknownProtocol socket timeout, destroy socket\");\n          socket.destroy();\n        }\n      }, options.unknownProtocolTimeout);\n      timer.unref();\n      socket.once(\"close\", () => clearTimeout(timer));\n      socket.end(\"HTTP/1.0 403 Forbidden\\r\\nContent-Type: text/plain\\r\\n\\r\\nUnknown ALPN Protocol, expected `h2` to be available.\\nIf this is a HTTP request: The server was not configured with the `allowHTTP1` option or a listener for the `unknownProtocol` event.\\n\");\n    }\n    return;\n  }\n  const session = new ServerHttp2Session(options, socket, this);\n  session.on(\"stream\", sessionOnStream);\n  session.on(\"error\", sessionOnError);\n  session.on(\"priority\", sessionOnPriority);\n  session[kNativeFields][kSessionPriorityListenerCount]--;\n  if (this.timeout)\n    session.setTimeout(this.timeout, sessionOnTimeout);\n  socket[kServer] = this;\n  this.emit(\"session\", session);\n}\nfunction initializeOptions(options) {\n  assertIsObject(options, \"options\");\n  options = { ...options };\n  assertIsObject(options.settings, \"options.settings\");\n  options.settings = { ...options.settings };\n  if (options.maxSessionInvalidFrames !== void 0)\n    validateUint32(options.maxSessionInvalidFrames, \"maxSessionInvalidFrames\");\n  if (options.maxSessionRejectedStreams !== void 0) {\n    validateUint32(options.maxSessionRejectedStreams, \"maxSessionRejectedStreams\");\n  }\n  if (options.unknownProtocolTimeout !== void 0)\n    validateUint32(options.unknownProtocolTimeout, \"unknownProtocolTimeout\");\n  else\n    options.unknownProtocolTimeout = 1e4;\n  options.Http1IncomingMessage = options.Http1IncomingMessage || http.IncomingMessage;\n  options.Http1ServerResponse = options.Http1ServerResponse || http.ServerResponse;\n  options.Http2ServerRequest = options.Http2ServerRequest || Http2ServerRequest;\n  options.Http2ServerResponse = options.Http2ServerResponse || Http2ServerResponse;\n  return options;\n}\nfunction initializeTLSOptions(options, servername) {\n  options = initializeOptions(options);\n  options.ALPNProtocols = [\"h2\"];\n  if (options.allowHTTP1 === true)\n    ArrayPrototypePush(options.ALPNProtocols, \"http/1.1\");\n  if (servername !== void 0 && options.servername === void 0)\n    options.servername = servername;\n  return options;\n}\nfunction onErrorSecureServerSession(err, socket) {\n  if (!this.emit(\"clientError\", err, socket))\n    socket.destroy(err);\n}\nclass Http2SecureServer extends TLSServer {\n  constructor(options, requestListener) {\n    options = initializeTLSOptions(options);\n    super(options, connectionListener);\n    this[kOptions] = options;\n    this.timeout = 0;\n    this.on(\"newListener\", setupCompat);\n    if (typeof requestListener === \"function\")\n      this.on(\"request\", requestListener);\n    this.on(\"tlsClientError\", onErrorSecureServerSession);\n  }\n  setTimeout(msecs, callback) {\n    this.timeout = msecs;\n    if (callback !== void 0) {\n      validateCallback(callback);\n      this.on(\"timeout\", callback);\n    }\n    return this;\n  }\n  updateSettings(settings) {\n    assertIsObject(settings, \"settings\");\n    validateSettings(settings);\n    this[kOptions].settings = { ...this[kOptions].settings, ...settings };\n  }\n}\nclass Http2Server extends NETServer {\n  constructor(options, requestListener) {\n    options = initializeOptions(options);\n    super(options, connectionListener);\n    this[kOptions] = options;\n    this.timeout = 0;\n    this.on(\"newListener\", setupCompat);\n    if (typeof requestListener === \"function\")\n      this.on(\"request\", requestListener);\n  }\n  setTimeout(msecs, callback) {\n    this.timeout = msecs;\n    if (callback !== void 0) {\n      validateCallback(callback);\n      this.on(\"timeout\", callback);\n    }\n    return this;\n  }\n  updateSettings(settings) {\n    assertIsObject(settings, \"settings\");\n    validateSettings(settings);\n    this[kOptions].settings = { ...this[kOptions].settings, ...settings };\n  }\n}\nHttp2Server.prototype[EventEmitter.captureRejectionSymbol] = function(err, event, ...args) {\n  switch (event) {\n    case \"stream\":\n      const { 0: stream } = args;\n      if (stream.sentHeaders) {\n        stream.destroy(err);\n      } else {\n        stream.respond({ [HTTP2_HEADER_STATUS]: 500 });\n        stream.end();\n      }\n      break;\n    case \"request\":\n      const { 1: res } = args;\n      if (!res.headersSent && !res.finished) {\n        for (const name of res.getHeaderNames()) {\n          res.removeHeader(name);\n        }\n        res.statusCode = 500;\n        res.end(http.STATUS_CODES[500]);\n      } else {\n        res.destroy();\n      }\n      break;\n    default:\n      ArrayPrototypeUnshift(args, err, event);\n      ReflectApply(net.Server.prototype[EventEmitter.captureRejectionSymbol], this, args);\n  }\n};\nfunction setupCompat(ev) {\n  if (ev === \"request\") {\n    this.removeListener(\"newListener\", setupCompat);\n    this.on(\"stream\", FunctionPrototypeBind(onServerStream, this, this[kOptions].Http2ServerRequest, this[kOptions].Http2ServerResponse));\n  }\n}\nfunction socketOnClose() {\n  const session = this[kSession];\n  if (session !== void 0) {\n    debugSessionObj(session, \"socket closed\");\n    const err = session.connecting ? new ERR_SOCKET_CLOSED() : null;\n    const state = session[kState];\n    state.streams.forEach((stream) => stream.close(NGHTTP2_CANCEL));\n    state.pendingStreams.forEach((stream) => stream.close(NGHTTP2_CANCEL));\n    session.close();\n    session[kMaybeDestroy](err);\n  }\n}\nfunction connect(authority, options, listener) {\n  if (typeof options === \"function\") {\n    listener = options;\n    options = void 0;\n  }\n  assertIsObject(options, \"options\");\n  options = { ...options };\n  if (typeof authority === \"string\")\n    authority = new URL(authority);\n  assertIsObject(authority, \"authority\", [\"string\", \"Object\", \"URL\"]);\n  const protocol = authority.protocol || options.protocol || \"https:\";\n  const port = \"\" + (authority.port !== \"\" ? authority.port : authority.protocol === \"http:\" ? 80 : 443);\n  let host = \"localhost\";\n  if (authority.hostname) {\n    host = authority.hostname;\n    if (host[0] === \"[\")\n      host = StringPrototypeSlice(host, 1, -1);\n  } else if (authority.host) {\n    host = authority.host;\n  }\n  let socket;\n  if (typeof options.createConnection === \"function\") {\n    socket = options.createConnection(authority, options);\n  } else {\n    switch (protocol) {\n      case \"http:\":\n        socket = net.connect({ port, host, ...options });\n        break;\n      case \"https:\":\n        socket = tls.connect(port, host, initializeTLSOptions(options, host));\n        break;\n      default:\n        throw new ERR_HTTP2_UNSUPPORTED_PROTOCOL(protocol);\n    }\n  }\n  const session = new ClientHttp2Session(options, socket);\n  session[kAuthority] = `${options.servername || host}:${port}`;\n  session[kProtocol] = protocol;\n  if (typeof listener === \"function\")\n    session.once(\"connect\", listener);\n  process.nextTick(() => {\n    debug(\"Http2Session connect\", options.createConnection);\n    if (socket && socket.readableLength) {\n      let buf;\n      while ((buf = socket.read()) !== null) {\n        debug(`Http2Session connect: ${buf.length} bytes already in buffer`);\n        session[kHandle].receive(buf);\n      }\n    }\n  });\n  return session;\n}\nObjectDefineProperty(connect, promisify.custom, {\n  value: (authority, options) => {\n    return new Promise((resolve) => {\n      const server = connect(authority, options, () => resolve(server));\n    });\n  }\n});\nfunction createSecureServer(options, handler) {\n  return new Http2SecureServer(options, handler);\n}\nfunction createServer(options, handler) {\n  if (typeof options === \"function\") {\n    handler = options;\n    options = {};\n  }\n  return new Http2Server(options, handler);\n}\nfunction getPackedSettings(settings) {\n  assertIsObject(settings, \"settings\");\n  validateSettings(settings);\n  updateSettingsBuffer({ ...settings });\n  return binding.packSettings();\n}\nfunction getUnpackedSettings(buf, options = {}) {\n  if (!isArrayBufferView(buf) || buf.length === void 0) {\n    throw new ERR_INVALID_ARG_TYPE(\"buf\", [\"Buffer\", \"TypedArray\"], buf);\n  }\n  if (buf.length % 6 !== 0)\n    throw new ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH();\n  const settings = {};\n  let offset = 0;\n  while (offset < buf.length) {\n    const id = ReflectApply(readUInt16BE, buf, [offset]);\n    offset += 2;\n    const value = ReflectApply(readUInt32BE, buf, [offset]);\n    switch (id) {\n      case NGHTTP2_SETTINGS_HEADER_TABLE_SIZE:\n        settings.headerTableSize = value;\n        break;\n      case NGHTTP2_SETTINGS_ENABLE_PUSH:\n        settings.enablePush = value !== 0;\n        break;\n      case NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS:\n        settings.maxConcurrentStreams = value;\n        break;\n      case NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE:\n        settings.initialWindowSize = value;\n        break;\n      case NGHTTP2_SETTINGS_MAX_FRAME_SIZE:\n        settings.maxFrameSize = value;\n        break;\n      case NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE:\n        settings.maxHeaderListSize = settings.maxHeaderSize = value;\n        break;\n      case NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL:\n        settings.enableConnectProtocol = value !== 0;\n    }\n    offset += 4;\n  }\n  if (options != null && options.validate)\n    validateSettings(settings);\n  return settings;\n}\nbinding.setCallbackFunctions(onSessionInternalError, onPriority, onSettings, onPing, onSessionHeaders, onFrameError, onGoawayData, onAltSvc, onOrigin, onStreamTrailers, onStreamClose);\nmodule.exports = {\n  connect,\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders: kSensitiveHeaders,\n  Http2Session,\n  Http2Stream,\n  Http2ServerRequest,\n  Http2ServerResponse\n};\n}"],["internal/http2/util.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  Error,\n  MathMax,\n  Number,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectKeys,\n  SafeSet,\n  String,\n  StringFromCharCode,\n  StringPrototypeIncludes,\n  StringPrototypeToLowerCase,\n  Symbol\n} = primordials;\nconst binding = internalBinding(\"http2\");\nconst {\n  codes: {\n    ERR_HTTP2_HEADER_SINGLE_VALUE,\n    ERR_HTTP2_INVALID_CONNECTION_HEADERS,\n    ERR_HTTP2_INVALID_PSEUDOHEADER,\n    ERR_HTTP2_INVALID_SETTING_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_HTTP_TOKEN\n  },\n  captureLargerStackTrace,\n  getMessage,\n  hideStackFrames,\n  kIsNodeError\n} = require(\"internal/errors\");\nconst kSensitiveHeaders = Symbol(\"nodejs.http2.sensitiveHeaders\");\nconst kSocket = Symbol(\"socket\");\nconst kProxySocket = Symbol(\"proxySocket\");\nconst kRequest = Symbol(\"request\");\nconst {\n  NGHTTP2_NV_FLAG_NONE,\n  NGHTTP2_NV_FLAG_NO_INDEX,\n  NGHTTP2_SESSION_CLIENT,\n  NGHTTP2_SESSION_SERVER,\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_SCHEME,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_PROTOCOL,\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,\n  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE,\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD,\n  HTTP2_HEADER_AGE,\n  HTTP2_HEADER_AUTHORIZATION,\n  HTTP2_HEADER_CONTENT_ENCODING,\n  HTTP2_HEADER_CONTENT_LANGUAGE,\n  HTTP2_HEADER_CONTENT_LENGTH,\n  HTTP2_HEADER_CONTENT_LOCATION,\n  HTTP2_HEADER_CONTENT_MD5,\n  HTTP2_HEADER_CONTENT_RANGE,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_COOKIE,\n  HTTP2_HEADER_DATE,\n  HTTP2_HEADER_DNT,\n  HTTP2_HEADER_ETAG,\n  HTTP2_HEADER_EXPIRES,\n  HTTP2_HEADER_FROM,\n  HTTP2_HEADER_HOST,\n  HTTP2_HEADER_IF_MATCH,\n  HTTP2_HEADER_IF_NONE_MATCH,\n  HTTP2_HEADER_IF_MODIFIED_SINCE,\n  HTTP2_HEADER_IF_RANGE,\n  HTTP2_HEADER_IF_UNMODIFIED_SINCE,\n  HTTP2_HEADER_LAST_MODIFIED,\n  HTTP2_HEADER_LOCATION,\n  HTTP2_HEADER_MAX_FORWARDS,\n  HTTP2_HEADER_PROXY_AUTHORIZATION,\n  HTTP2_HEADER_RANGE,\n  HTTP2_HEADER_REFERER,\n  HTTP2_HEADER_RETRY_AFTER,\n  HTTP2_HEADER_SET_COOKIE,\n  HTTP2_HEADER_TK,\n  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS,\n  HTTP2_HEADER_USER_AGENT,\n  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS,\n  HTTP2_HEADER_CONNECTION,\n  HTTP2_HEADER_UPGRADE,\n  HTTP2_HEADER_HTTP2_SETTINGS,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_TRANSFER_ENCODING,\n  HTTP2_HEADER_KEEP_ALIVE,\n  HTTP2_HEADER_PROXY_CONNECTION,\n  HTTP2_METHOD_DELETE,\n  HTTP2_METHOD_GET,\n  HTTP2_METHOD_HEAD\n} = binding.constants;\nconst kValidPseudoHeaders = new SafeSet([\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_SCHEME,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_PROTOCOL\n]);\nconst kSingleValueHeaders = new SafeSet([\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_SCHEME,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_PROTOCOL,\n  HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,\n  HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE,\n  HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD,\n  HTTP2_HEADER_AGE,\n  HTTP2_HEADER_AUTHORIZATION,\n  HTTP2_HEADER_CONTENT_ENCODING,\n  HTTP2_HEADER_CONTENT_LANGUAGE,\n  HTTP2_HEADER_CONTENT_LENGTH,\n  HTTP2_HEADER_CONTENT_LOCATION,\n  HTTP2_HEADER_CONTENT_MD5,\n  HTTP2_HEADER_CONTENT_RANGE,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_DATE,\n  HTTP2_HEADER_DNT,\n  HTTP2_HEADER_ETAG,\n  HTTP2_HEADER_EXPIRES,\n  HTTP2_HEADER_FROM,\n  HTTP2_HEADER_HOST,\n  HTTP2_HEADER_IF_MATCH,\n  HTTP2_HEADER_IF_MODIFIED_SINCE,\n  HTTP2_HEADER_IF_NONE_MATCH,\n  HTTP2_HEADER_IF_RANGE,\n  HTTP2_HEADER_IF_UNMODIFIED_SINCE,\n  HTTP2_HEADER_LAST_MODIFIED,\n  HTTP2_HEADER_LOCATION,\n  HTTP2_HEADER_MAX_FORWARDS,\n  HTTP2_HEADER_PROXY_AUTHORIZATION,\n  HTTP2_HEADER_RANGE,\n  HTTP2_HEADER_REFERER,\n  HTTP2_HEADER_RETRY_AFTER,\n  HTTP2_HEADER_TK,\n  HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS,\n  HTTP2_HEADER_USER_AGENT,\n  HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS\n]);\nconst kNoPayloadMethods = new SafeSet([\n  HTTP2_METHOD_DELETE,\n  HTTP2_METHOD_GET,\n  HTTP2_METHOD_HEAD\n]);\nconst { settingsBuffer, optionsBuffer } = binding;\nconst { sessionState, streamState } = binding;\nconst IDX_SETTINGS_HEADER_TABLE_SIZE = 0;\nconst IDX_SETTINGS_ENABLE_PUSH = 1;\nconst IDX_SETTINGS_INITIAL_WINDOW_SIZE = 2;\nconst IDX_SETTINGS_MAX_FRAME_SIZE = 3;\nconst IDX_SETTINGS_MAX_CONCURRENT_STREAMS = 4;\nconst IDX_SETTINGS_MAX_HEADER_LIST_SIZE = 5;\nconst IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL = 6;\nconst IDX_SETTINGS_FLAGS = 7;\nconst IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE = 0;\nconst IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH = 1;\nconst IDX_SESSION_STATE_NEXT_STREAM_ID = 2;\nconst IDX_SESSION_STATE_LOCAL_WINDOW_SIZE = 3;\nconst IDX_SESSION_STATE_LAST_PROC_STREAM_ID = 4;\nconst IDX_SESSION_STATE_REMOTE_WINDOW_SIZE = 5;\nconst IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE = 6;\nconst IDX_SESSION_STATE_HD_DEFLATE_DYNAMIC_TABLE_SIZE = 7;\nconst IDX_SESSION_STATE_HD_INFLATE_DYNAMIC_TABLE_SIZE = 8;\nconst IDX_STREAM_STATE = 0;\nconst IDX_STREAM_STATE_WEIGHT = 1;\nconst IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT = 2;\nconst IDX_STREAM_STATE_LOCAL_CLOSE = 3;\nconst IDX_STREAM_STATE_REMOTE_CLOSE = 4;\nconst IDX_STREAM_STATE_LOCAL_WINDOW_SIZE = 5;\nconst IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE = 0;\nconst IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS = 1;\nconst IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH = 2;\nconst IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS = 3;\nconst IDX_OPTIONS_PADDING_STRATEGY = 4;\nconst IDX_OPTIONS_MAX_HEADER_LIST_PAIRS = 5;\nconst IDX_OPTIONS_MAX_OUTSTANDING_PINGS = 6;\nconst IDX_OPTIONS_MAX_OUTSTANDING_SETTINGS = 7;\nconst IDX_OPTIONS_MAX_SESSION_MEMORY = 8;\nconst IDX_OPTIONS_MAX_SETTINGS = 9;\nconst IDX_OPTIONS_FLAGS = 10;\nfunction updateOptionsBuffer(options) {\n  let flags = 0;\n  if (typeof options.maxDeflateDynamicTableSize === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE;\n    optionsBuffer[IDX_OPTIONS_MAX_DEFLATE_DYNAMIC_TABLE_SIZE] = options.maxDeflateDynamicTableSize;\n  }\n  if (typeof options.maxReservedRemoteStreams === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS;\n    optionsBuffer[IDX_OPTIONS_MAX_RESERVED_REMOTE_STREAMS] = options.maxReservedRemoteStreams;\n  }\n  if (typeof options.maxSendHeaderBlockLength === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH;\n    optionsBuffer[IDX_OPTIONS_MAX_SEND_HEADER_BLOCK_LENGTH] = options.maxSendHeaderBlockLength;\n  }\n  if (typeof options.peerMaxConcurrentStreams === \"number\") {\n    flags |= 1 << IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS;\n    optionsBuffer[IDX_OPTIONS_PEER_MAX_CONCURRENT_STREAMS] = options.peerMaxConcurrentStreams;\n  }\n  if (typeof options.paddingStrategy === \"number\") {\n    flags |= 1 << IDX_OPTIONS_PADDING_STRATEGY;\n    optionsBuffer[IDX_OPTIONS_PADDING_STRATEGY] = options.paddingStrategy;\n  }\n  if (typeof options.maxHeaderListPairs === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_HEADER_LIST_PAIRS;\n    optionsBuffer[IDX_OPTIONS_MAX_HEADER_LIST_PAIRS] = options.maxHeaderListPairs;\n  }\n  if (typeof options.maxOutstandingPings === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_OUTSTANDING_PINGS;\n    optionsBuffer[IDX_OPTIONS_MAX_OUTSTANDING_PINGS] = options.maxOutstandingPings;\n  }\n  if (typeof options.maxOutstandingSettings === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_OUTSTANDING_SETTINGS;\n    optionsBuffer[IDX_OPTIONS_MAX_OUTSTANDING_SETTINGS] = MathMax(1, options.maxOutstandingSettings);\n  }\n  if (typeof options.maxSessionMemory === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_SESSION_MEMORY;\n    optionsBuffer[IDX_OPTIONS_MAX_SESSION_MEMORY] = MathMax(1, options.maxSessionMemory);\n  }\n  if (typeof options.maxSettings === \"number\") {\n    flags |= 1 << IDX_OPTIONS_MAX_SETTINGS;\n    optionsBuffer[IDX_OPTIONS_MAX_SETTINGS] = MathMax(1, options.maxSettings);\n  }\n  optionsBuffer[IDX_OPTIONS_FLAGS] = flags;\n}\nfunction getDefaultSettings() {\n  settingsBuffer[IDX_SETTINGS_FLAGS] = 0;\n  binding.refreshDefaultSettings();\n  const holder = ObjectCreate(null);\n  const flags = settingsBuffer[IDX_SETTINGS_FLAGS];\n  if ((flags & 1 << IDX_SETTINGS_HEADER_TABLE_SIZE) === 1 << IDX_SETTINGS_HEADER_TABLE_SIZE) {\n    holder.headerTableSize = settingsBuffer[IDX_SETTINGS_HEADER_TABLE_SIZE];\n  }\n  if ((flags & 1 << IDX_SETTINGS_ENABLE_PUSH) === 1 << IDX_SETTINGS_ENABLE_PUSH) {\n    holder.enablePush = settingsBuffer[IDX_SETTINGS_ENABLE_PUSH] === 1;\n  }\n  if ((flags & 1 << IDX_SETTINGS_INITIAL_WINDOW_SIZE) === 1 << IDX_SETTINGS_INITIAL_WINDOW_SIZE) {\n    holder.initialWindowSize = settingsBuffer[IDX_SETTINGS_INITIAL_WINDOW_SIZE];\n  }\n  if ((flags & 1 << IDX_SETTINGS_MAX_FRAME_SIZE) === 1 << IDX_SETTINGS_MAX_FRAME_SIZE) {\n    holder.maxFrameSize = settingsBuffer[IDX_SETTINGS_MAX_FRAME_SIZE];\n  }\n  if ((flags & 1 << IDX_SETTINGS_MAX_CONCURRENT_STREAMS) === 1 << IDX_SETTINGS_MAX_CONCURRENT_STREAMS) {\n    holder.maxConcurrentStreams = settingsBuffer[IDX_SETTINGS_MAX_CONCURRENT_STREAMS];\n  }\n  if ((flags & 1 << IDX_SETTINGS_MAX_HEADER_LIST_SIZE) === 1 << IDX_SETTINGS_MAX_HEADER_LIST_SIZE) {\n    holder.maxHeaderListSize = holder.maxHeaderSize = settingsBuffer[IDX_SETTINGS_MAX_HEADER_LIST_SIZE];\n  }\n  if ((flags & 1 << IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL) === 1 << IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL) {\n    holder.enableConnectProtocol = settingsBuffer[IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL] === 1;\n  }\n  return holder;\n}\nfunction getSettings(session, remote) {\n  if (remote)\n    session.remoteSettings();\n  else\n    session.localSettings();\n  return {\n    headerTableSize: settingsBuffer[IDX_SETTINGS_HEADER_TABLE_SIZE],\n    enablePush: !!settingsBuffer[IDX_SETTINGS_ENABLE_PUSH],\n    initialWindowSize: settingsBuffer[IDX_SETTINGS_INITIAL_WINDOW_SIZE],\n    maxFrameSize: settingsBuffer[IDX_SETTINGS_MAX_FRAME_SIZE],\n    maxConcurrentStreams: settingsBuffer[IDX_SETTINGS_MAX_CONCURRENT_STREAMS],\n    maxHeaderListSize: settingsBuffer[IDX_SETTINGS_MAX_HEADER_LIST_SIZE],\n    maxHeaderSize: settingsBuffer[IDX_SETTINGS_MAX_HEADER_LIST_SIZE],\n    enableConnectProtocol: !!settingsBuffer[IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL]\n  };\n}\nfunction updateSettingsBuffer(settings) {\n  let flags = 0;\n  if (typeof settings.headerTableSize === \"number\") {\n    flags |= 1 << IDX_SETTINGS_HEADER_TABLE_SIZE;\n    settingsBuffer[IDX_SETTINGS_HEADER_TABLE_SIZE] = settings.headerTableSize;\n  }\n  if (typeof settings.maxConcurrentStreams === \"number\") {\n    flags |= 1 << IDX_SETTINGS_MAX_CONCURRENT_STREAMS;\n    settingsBuffer[IDX_SETTINGS_MAX_CONCURRENT_STREAMS] = settings.maxConcurrentStreams;\n  }\n  if (typeof settings.initialWindowSize === \"number\") {\n    flags |= 1 << IDX_SETTINGS_INITIAL_WINDOW_SIZE;\n    settingsBuffer[IDX_SETTINGS_INITIAL_WINDOW_SIZE] = settings.initialWindowSize;\n  }\n  if (typeof settings.maxFrameSize === \"number\") {\n    flags |= 1 << IDX_SETTINGS_MAX_FRAME_SIZE;\n    settingsBuffer[IDX_SETTINGS_MAX_FRAME_SIZE] = settings.maxFrameSize;\n  }\n  if (typeof settings.maxHeaderListSize === \"number\" || typeof settings.maxHeaderSize === \"number\") {\n    flags |= 1 << IDX_SETTINGS_MAX_HEADER_LIST_SIZE;\n    if (settings.maxHeaderSize !== void 0 && settings.maxHeaderSize !== settings.maxHeaderListSize) {\n      process.emitWarning(\"settings.maxHeaderSize overwrite settings.maxHeaderListSize\");\n      settingsBuffer[IDX_SETTINGS_MAX_HEADER_LIST_SIZE] = settings.maxHeaderSize;\n    } else {\n      settingsBuffer[IDX_SETTINGS_MAX_HEADER_LIST_SIZE] = settings.maxHeaderListSize;\n    }\n  }\n  if (typeof settings.enablePush === \"boolean\") {\n    flags |= 1 << IDX_SETTINGS_ENABLE_PUSH;\n    settingsBuffer[IDX_SETTINGS_ENABLE_PUSH] = Number(settings.enablePush);\n  }\n  if (typeof settings.enableConnectProtocol === \"boolean\") {\n    flags |= 1 << IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL;\n    settingsBuffer[IDX_SETTINGS_ENABLE_CONNECT_PROTOCOL] = Number(settings.enableConnectProtocol);\n  }\n  settingsBuffer[IDX_SETTINGS_FLAGS] = flags;\n}\nfunction getSessionState(session) {\n  session.refreshState();\n  return {\n    effectiveLocalWindowSize: sessionState[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE],\n    effectiveRecvDataLength: sessionState[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH],\n    nextStreamID: sessionState[IDX_SESSION_STATE_NEXT_STREAM_ID],\n    localWindowSize: sessionState[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE],\n    lastProcStreamID: sessionState[IDX_SESSION_STATE_LAST_PROC_STREAM_ID],\n    remoteWindowSize: sessionState[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE],\n    outboundQueueSize: sessionState[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE],\n    deflateDynamicTableSize: sessionState[IDX_SESSION_STATE_HD_DEFLATE_DYNAMIC_TABLE_SIZE],\n    inflateDynamicTableSize: sessionState[IDX_SESSION_STATE_HD_INFLATE_DYNAMIC_TABLE_SIZE]\n  };\n}\nfunction getStreamState(stream) {\n  stream.refreshState();\n  return {\n    state: streamState[IDX_STREAM_STATE],\n    weight: streamState[IDX_STREAM_STATE_WEIGHT],\n    sumDependencyWeight: streamState[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT],\n    localClose: streamState[IDX_STREAM_STATE_LOCAL_CLOSE],\n    remoteClose: streamState[IDX_STREAM_STATE_REMOTE_CLOSE],\n    localWindowSize: streamState[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE]\n  };\n}\nfunction isIllegalConnectionSpecificHeader(name, value) {\n  switch (name) {\n    case HTTP2_HEADER_CONNECTION:\n    case HTTP2_HEADER_UPGRADE:\n    case HTTP2_HEADER_HTTP2_SETTINGS:\n    case HTTP2_HEADER_KEEP_ALIVE:\n    case HTTP2_HEADER_PROXY_CONNECTION:\n    case HTTP2_HEADER_TRANSFER_ENCODING:\n      return true;\n    case HTTP2_HEADER_TE:\n      return value !== \"trailers\";\n    default:\n      return false;\n  }\n}\nconst assertValidPseudoHeader = hideStackFrames((key) => {\n  if (!kValidPseudoHeaders.has(key)) {\n    throw new ERR_HTTP2_INVALID_PSEUDOHEADER(key);\n  }\n});\nconst assertValidPseudoHeaderResponse = hideStackFrames((key) => {\n  if (key !== \":status\") {\n    throw new ERR_HTTP2_INVALID_PSEUDOHEADER(key);\n  }\n});\nconst assertValidPseudoHeaderTrailer = hideStackFrames((key) => {\n  throw new ERR_HTTP2_INVALID_PSEUDOHEADER(key);\n});\nconst emptyArray = [];\nconst kNeverIndexFlag = StringFromCharCode(NGHTTP2_NV_FLAG_NO_INDEX);\nconst kNoHeaderFlags = StringFromCharCode(NGHTTP2_NV_FLAG_NONE);\nfunction mapToHeaders(map, assertValuePseudoHeader = assertValidPseudoHeader) {\n  let ret = \"\";\n  let count = 0;\n  const keys = ObjectKeys(map);\n  const singles = new SafeSet();\n  let i, j;\n  let isArray;\n  let key;\n  let value;\n  let isSingleValueHeader;\n  let err;\n  const neverIndex = ArrayPrototypeMap(map[kSensitiveHeaders] || emptyArray, StringPrototypeToLowerCase);\n  for (i = 0; i < keys.length; ++i) {\n    key = keys[i];\n    value = map[key];\n    if (value === void 0 || key === \"\")\n      continue;\n    key = StringPrototypeToLowerCase(key);\n    isSingleValueHeader = kSingleValueHeaders.has(key);\n    isArray = ArrayIsArray(value);\n    if (isArray) {\n      switch (value.length) {\n        case 0:\n          continue;\n        case 1:\n          value = String(value[0]);\n          isArray = false;\n          break;\n        default:\n          if (isSingleValueHeader)\n            throw new ERR_HTTP2_HEADER_SINGLE_VALUE(key);\n      }\n    } else {\n      value = String(value);\n    }\n    if (isSingleValueHeader) {\n      if (singles.has(key))\n        throw new ERR_HTTP2_HEADER_SINGLE_VALUE(key);\n      singles.add(key);\n    }\n    const flags = ArrayPrototypeIncludes(neverIndex, key) ? kNeverIndexFlag : kNoHeaderFlags;\n    if (key[0] === \":\") {\n      err = assertValuePseudoHeader(key);\n      if (err !== void 0)\n        throw err;\n      ret = `${key}\\0${value}\\0${flags}${ret}`;\n      count++;\n      continue;\n    }\n    if (StringPrototypeIncludes(key, \" \")) {\n      throw new ERR_INVALID_HTTP_TOKEN(\"Header name\", key);\n    }\n    if (isIllegalConnectionSpecificHeader(key, value)) {\n      throw new ERR_HTTP2_INVALID_CONNECTION_HEADERS(key);\n    }\n    if (isArray) {\n      for (j = 0; j < value.length; ++j) {\n        const val = String(value[j]);\n        ret += `${key}\\0${val}\\0${flags}`;\n      }\n      count += value.length;\n      continue;\n    }\n    ret += `${key}\\0${value}\\0${flags}`;\n    count++;\n  }\n  return [ret, count];\n}\nclass NghttpError extends Error {\n  constructor(integerCode, customErrorCode) {\n    super(customErrorCode ? getMessage(customErrorCode, [], null) : binding.nghttp2ErrorString(integerCode));\n    this.code = customErrorCode || \"ERR_HTTP2_ERROR\";\n    this.errno = integerCode;\n    captureLargerStackTrace(this);\n    ObjectDefineProperty(this, kIsNodeError, {\n      value: true,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n}\nconst assertIsObject = hideStackFrames((value, name, types) => {\n  if (value !== void 0 && (value === null || typeof value !== \"object\" || ArrayIsArray(value))) {\n    throw new ERR_INVALID_ARG_TYPE(name, types || \"Object\", value);\n  }\n});\nconst assertWithinRange = hideStackFrames((name, value, min = 0, max = Infinity) => {\n  if (value !== void 0 && (typeof value !== \"number\" || value < min || value > max)) {\n    throw new ERR_HTTP2_INVALID_SETTING_VALUE.RangeError(name, value, min, max);\n  }\n});\nfunction toHeaderObject(headers, sensitiveHeaders) {\n  const obj = ObjectCreate(null);\n  for (var n = 0; n < headers.length; n += 2) {\n    const name = headers[n];\n    let value = headers[n + 1];\n    if (name === HTTP2_HEADER_STATUS)\n      value |= 0;\n    const existing = obj[name];\n    if (existing === void 0) {\n      obj[name] = name === HTTP2_HEADER_SET_COOKIE ? [value] : value;\n    } else if (!kSingleValueHeaders.has(name)) {\n      switch (name) {\n        case HTTP2_HEADER_COOKIE:\n          obj[name] = `${existing}; ${value}`;\n          break;\n        case HTTP2_HEADER_SET_COOKIE:\n          ArrayPrototypePush(existing, value);\n          break;\n        default:\n          obj[name] = `${existing}, ${value}`;\n          break;\n      }\n    }\n  }\n  obj[kSensitiveHeaders] = sensitiveHeaders;\n  return obj;\n}\nfunction isPayloadMeaningless(method) {\n  return kNoPayloadMethods.has(method);\n}\nfunction sessionName(type) {\n  switch (type) {\n    case NGHTTP2_SESSION_CLIENT:\n      return \"client\";\n    case NGHTTP2_SESSION_SERVER:\n      return \"server\";\n    default:\n      return \"<invalid>\";\n  }\n}\nfunction getAuthority(headers) {\n  if (headers[HTTP2_HEADER_AUTHORITY] !== void 0)\n    return headers[HTTP2_HEADER_AUTHORITY];\n  if (headers[HTTP2_HEADER_HOST] !== void 0)\n    return headers[HTTP2_HEADER_HOST];\n}\nmodule.exports = {\n  assertIsObject,\n  assertValidPseudoHeader,\n  assertValidPseudoHeaderResponse,\n  assertValidPseudoHeaderTrailer,\n  assertWithinRange,\n  getAuthority,\n  getDefaultSettings,\n  getSessionState,\n  getSettings,\n  getStreamState,\n  isPayloadMeaningless,\n  kSensitiveHeaders,\n  kSocket,\n  kProxySocket,\n  kRequest,\n  mapToHeaders,\n  NghttpError,\n  sessionName,\n  toHeaderObject,\n  updateOptionsBuffer,\n  updateSettingsBuffer\n};\n}"],["internal/legacy/processbinding.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeFilter,\n  ArrayPrototypeIncludes,\n  ObjectFromEntries,\n  ObjectEntries,\n  SafeArrayIterator\n} = primordials;\nconst { types } = require(\"util\");\nmodule.exports = {\n  util() {\n    return ObjectFromEntries(new SafeArrayIterator(ArrayPrototypeFilter(ObjectEntries(types), ({ 0: key }) => {\n      return ArrayPrototypeIncludes([\n        \"isArrayBuffer\",\n        \"isArrayBufferView\",\n        \"isAsyncFunction\",\n        \"isDataView\",\n        \"isDate\",\n        \"isExternal\",\n        \"isMap\",\n        \"isMapIterator\",\n        \"isNativeError\",\n        \"isPromise\",\n        \"isRegExp\",\n        \"isSet\",\n        \"isSetIterator\",\n        \"isTypedArray\",\n        \"isUint8Array\",\n        \"isAnyArrayBuffer\"\n      ], key);\n    })));\n  }\n};\n}"],["internal/main/check_syntax.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nconst {\n  readStdin\n} = require(\"internal/process/execution\");\nconst { pathToFileURL } = require(\"url\");\nconst {\n  Module: {\n    _resolveFilename: resolveCJSModuleName\n  },\n  wrapSafe\n} = require(\"internal/modules/cjs/loader\");\nprepareMainThreadExecution(true);\nif (process.argv[1] && process.argv[1] !== \"-\") {\n  const path = require(\"path\");\n  process.argv[1] = path.resolve(process.argv[1]);\n  const filename = resolveCJSModuleName(process.argv[1]);\n  const fs = require(\"fs\");\n  const source = fs.readFileSync(filename, \"utf-8\");\n  markBootstrapComplete();\n  checkSyntax(source, filename);\n} else {\n  markBootstrapComplete();\n  readStdin((code) => {\n    checkSyntax(code, \"[stdin]\");\n  });\n}\nfunction checkSyntax(source, filename) {\n  const { getOptionValue } = require(\"internal/options\");\n  let isModule = false;\n  if (filename === \"[stdin]\" || filename === \"[eval]\") {\n    isModule = getOptionValue(\"--input-type\") === \"module\";\n  } else {\n    const { defaultResolve } = require(\"internal/modules/esm/resolve\");\n    const { defaultGetFormat } = require(\"internal/modules/esm/get_format\");\n    const { url } = defaultResolve(pathToFileURL(filename).toString());\n    const { format } = defaultGetFormat(url);\n    isModule = format === \"module\";\n  }\n  if (isModule) {\n    const { ModuleWrap } = internalBinding(\"module_wrap\");\n    new ModuleWrap(filename, void 0, source, 0, 0);\n    return;\n  }\n  wrapSafe(filename, source);\n}\n}"],["internal/main/eval_stdin.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nconst { getOptionValue } = require(\"internal/options\");\nconst {\n  evalModule,\n  evalScript,\n  readStdin\n} = require(\"internal/process/execution\");\nprepareMainThreadExecution();\nmarkBootstrapComplete();\nreadStdin((code) => {\n  process._eval = code;\n  const print = getOptionValue(\"--print\");\n  if (getOptionValue(\"--input-type\") === \"module\")\n    evalModule(code, print);\n  else\n    evalScript(\"[stdin]\", code, getOptionValue(\"--inspect-brk\"), print);\n});\n}"],["internal/main/eval_string.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  globalThis\n} = primordials;\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nconst { evalModule, evalScript } = require(\"internal/process/execution\");\nconst { addBuiltinLibsToObject } = require(\"internal/modules/cjs/helpers\");\nconst { getOptionValue } = require(\"internal/options\");\nprepareMainThreadExecution();\naddBuiltinLibsToObject(globalThis, \"<eval>\");\nmarkBootstrapComplete();\nconst source = getOptionValue(\"--eval\");\nconst print = getOptionValue(\"--print\");\nif (getOptionValue(\"--input-type\") === \"module\")\n  evalModule(source, print);\nelse\n  evalScript(\"[eval]\", source, getOptionValue(\"--inspect-brk\"), print);\n}"],["internal/main/inspect.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nprepareMainThreadExecution();\nmarkBootstrapComplete();\nprocess.nextTick(() => {\n  require(\"internal/debugger/inspect\").start();\n});\n}"],["internal/main/print_help.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeConcat,\n  ArrayPrototypeSort,\n  Boolean,\n  MathFloor,\n  MathMax,\n  ObjectKeys,\n  RegExp,\n  StringPrototypeLocaleCompare,\n  StringPrototypeSlice,\n  StringPrototypeTrimLeft,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  SafeMap\n} = primordials;\nconst { types } = internalBinding(\"options\");\nconst hasCrypto = Boolean(process.versions.openssl);\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nconst typeLookup = [];\nfor (const key of ObjectKeys(types))\n  typeLookup[types[key]] = key;\nconst { hasIntl, hasSmallICU, hasNodeOptions } = internalBinding(\"config\");\nconst envVars = new SafeMap(ArrayPrototypeConcat([\n  [\"FORCE_COLOR\", { helpText: \"when set to 'true', 1, 2, 3, or an empty string causes NO_COLOR and NODE_DISABLE_COLORS to be ignored.\" }],\n  [\"NO_COLOR\", { helpText: \"Alias for NODE_DISABLE_COLORS\" }],\n  [\"NODE_DEBUG\", { helpText: \"','-separated list of core modules that should print debug information\" }],\n  [\"NODE_DEBUG_NATIVE\", { helpText: \"','-separated list of C++ core debug categories that should print debug output\" }],\n  [\"NODE_DISABLE_COLORS\", { helpText: \"set to 1 to disable colors in the REPL\" }],\n  [\"NODE_EXTRA_CA_CERTS\", { helpText: \"path to additional CA certificates file. Only read once during process startup.\" }],\n  [\"NODE_NO_WARNINGS\", { helpText: \"set to 1 to silence process warnings\" }],\n  [\"NODE_PATH\", { helpText: `'${require(\"path\").delimiter}'-separated list of directories prefixed to the module search path` }],\n  [\"NODE_PENDING_DEPRECATION\", { helpText: \"set to 1 to emit pending deprecation warnings\" }],\n  [\"NODE_PENDING_PIPE_INSTANCES\", { helpText: \"set the number of pending pipe instance handles on Windows\" }],\n  [\"NODE_PRESERVE_SYMLINKS\", { helpText: \"set to 1 to preserve symbolic links when resolving and caching modules\" }],\n  [\"NODE_REDIRECT_WARNINGS\", { helpText: \"write warnings to path instead of stderr\" }],\n  [\"NODE_REPL_HISTORY\", { helpText: \"path to the persistent REPL history file\" }],\n  [\"NODE_TLS_REJECT_UNAUTHORIZED\", { helpText: \"set to 0 to disable TLS certificate validation\" }],\n  [\"NODE_V8_COVERAGE\", { helpText: \"directory to output v8 coverage JSON to\" }],\n  [\"UV_THREADPOOL_SIZE\", { helpText: \"sets the number of threads used in libuv's threadpool\" }]\n], hasIntl ? [\n  [\"NODE_ICU_DATA\", { helpText: \"data path for ICU (Intl object) data\" + hasSmallICU ? \"\" : \" (will extend linked-in data)\" }]\n] : []), hasNodeOptions ? [\n  [\"NODE_OPTIONS\", { helpText: \"set CLI options in the environment via a space-separated list\" }]\n] : [], hasCrypto ? [\n  [\"OPENSSL_CONF\", { helpText: \"load OpenSSL configuration from file\" }],\n  [\"SSL_CERT_DIR\", { helpText: \"sets OpenSSL's directory of trusted certificates when used in conjunction with --use-openssl-ca\" }],\n  [\"SSL_CERT_FILE\", { helpText: \"sets OpenSSL's trusted certificate file when used in conjunction with --use-openssl-ca\" }]\n] : []);\nfunction indent(text, depth) {\n  return StringPrototypeReplace(text, /^/gm, StringPrototypeRepeat(\" \", depth));\n}\nfunction fold(text, width) {\n  return StringPrototypeReplace(text, new RegExp(`([^\n]{0,${width}})( |$)`, \"g\"), (_, newLine, end) => newLine + (end === \" \" ? \"\\n\" : \"\"));\n}\nfunction getArgDescription(type) {\n  switch (typeLookup[type]) {\n    case \"kNoOp\":\n    case \"kV8Option\":\n    case \"kBoolean\":\n    case void 0:\n      break;\n    case \"kHostPort\":\n      return \"[host:]port\";\n    case \"kInteger\":\n    case \"kUInteger\":\n    case \"kString\":\n    case \"kStringList\":\n      return \"...\";\n    default:\n      require(\"assert\").fail(`unknown option type ${type}`);\n  }\n}\nfunction format({ options, aliases = new SafeMap(), firstColumn, secondColumn }) {\n  let text = \"\";\n  let maxFirstColumnUsed = 0;\n  const sortedOptions = ArrayPrototypeSort([...options.entries()], ({ 0: name1, 1: option1 }, { 0: name2, 1: option2 }) => {\n    if (option1.defaultIsTrue) {\n      name1 = `--no-${StringPrototypeSlice(name1, 2)}`;\n    }\n    if (option2.defaultIsTrue) {\n      name2 = `--no-${StringPrototypeSlice(name2, 2)}`;\n    }\n    return StringPrototypeLocaleCompare(name1, name2);\n  });\n  for (const {\n    0: name,\n    1: { helpText, type, value, defaultIsTrue }\n  } of sortedOptions) {\n    if (!helpText)\n      continue;\n    let displayName = name;\n    if (defaultIsTrue) {\n      displayName = `--no-${StringPrototypeSlice(displayName, 2)}`;\n    }\n    const argDescription = getArgDescription(type);\n    if (argDescription)\n      displayName += `=${argDescription}`;\n    for (const { 0: from, 1: to } of aliases) {\n      if (to[0] === name && to.length === 1) {\n        displayName = `${from}, ${displayName}`;\n      }\n      const targetInfo = options.get(to[0]);\n      const targetArgDescription = targetInfo ? getArgDescription(targetInfo.type) : \"...\";\n      if (from === `${name}=`) {\n        displayName += `[=${targetArgDescription}]`;\n      } else if (from === `${name} <arg>`) {\n        displayName += ` [${targetArgDescription}]`;\n      }\n    }\n    let displayHelpText = helpText;\n    if (value === !defaultIsTrue) {\n      displayHelpText += \" (currently set)\";\n    }\n    text += displayName;\n    maxFirstColumnUsed = MathMax(maxFirstColumnUsed, displayName.length);\n    if (displayName.length >= firstColumn)\n      text += \"\\n\" + StringPrototypeRepeat(\" \", firstColumn);\n    else\n      text += StringPrototypeRepeat(\" \", firstColumn - displayName.length);\n    text += StringPrototypeTrimLeft(indent(fold(displayHelpText, secondColumn), firstColumn)) + \"\\n\";\n  }\n  if (maxFirstColumnUsed < firstColumn - 4) {\n    return format({\n      options,\n      aliases,\n      firstColumn: maxFirstColumnUsed + 2,\n      secondColumn\n    });\n  }\n  return text;\n}\nfunction print(stream) {\n  const { options, aliases } = require(\"internal/options\");\n  const width = MathMax(70, (stream.columns || 0) * 0.75);\n  const firstColumn = MathFloor(width * 0.4);\n  const secondColumn = MathFloor(width * 0.57);\n  options.set(\"-\", { helpText: \"script read from stdin (default if no file name is provided, interactive mode if a tty)\" });\n  options.set(\"--\", { helpText: \"indicate the end of node options\" });\n  stream.write(\"Usage: node [options] [ script.js ] [arguments]\\n       node inspect [options] [ script.js | host:port ] [arguments]\\n\\nOptions:\\n\");\n  stream.write(indent(format({\n    options,\n    aliases,\n    firstColumn,\n    secondColumn\n  }), 2));\n  stream.write(\"\\nEnvironment variables:\\n\");\n  stream.write(format({\n    options: envVars,\n    firstColumn,\n    secondColumn\n  }));\n  stream.write(\"\\nDocumentation can be found at https://nodejs.org/\\n\");\n}\nprepareMainThreadExecution();\nmarkBootstrapComplete();\nprint(process.stdout);\n}"],["internal/main/prof_process.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nprepareMainThreadExecution();\nmarkBootstrapComplete();\nrequire(\"internal/v8_prof_processor\");\n}"],["internal/main/repl.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nconst esmLoader = require(\"internal/process/esm_loader\");\nconst {\n  evalScript\n} = require(\"internal/process/execution\");\nconst console = require(\"internal/console/global\");\nconst { getOptionValue } = require(\"internal/options\");\nprepareMainThreadExecution();\nmarkBootstrapComplete();\nif (process.env.NODE_REPL_EXTERNAL_MODULE) {\n  require(\"internal/modules/cjs/loader\").Module._load(process.env.NODE_REPL_EXTERNAL_MODULE, void 0, true);\n} else {\n  if (getOptionValue(\"--input-type\")) {\n    console.error(\"Cannot specify --input-type for REPL\");\n    process.exit(1);\n  }\n  esmLoader.loadESM(() => {\n    console.log(`Welcome to Node.js ${process.version}.\nType \".help\" for more information.`);\n    const cliRepl = require(\"internal/repl\");\n    cliRepl.createInternalRepl(process.env, (err, repl) => {\n      if (err) {\n        throw err;\n      }\n      repl.on(\"exit\", () => {\n        if (repl._flushing) {\n          repl.pause();\n          return repl.once(\"flushHistory\", () => {\n            process.exit();\n          });\n        }\n        process.exit();\n      });\n    });\n    if (getOptionValue(\"[has_eval_string]\")) {\n      evalScript(\"[eval]\", getOptionValue(\"--eval\"), getOptionValue(\"--inspect-brk\"), getOptionValue(\"--print\"));\n    }\n  });\n}\n}"],["internal/main/run_main_module.js","function (process, require, internalBinding, primordials, markBootstrapComplete) { \n  \"use strict\";\nconst {\n  prepareMainThreadExecution\n} = require(\"internal/bootstrap/pre_execution\");\nprepareMainThreadExecution(true);\nmarkBootstrapComplete();\nrequire(\"internal/modules/cjs/loader\").Module.runMain(process.argv[1]);\n}"],["internal/main/worker_thread.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypePushApply,\n  ArrayPrototypeSplice,\n  ObjectDefineProperty,\n  PromisePrototypeCatch,\n  globalThis: { Atomics }\n} = primordials;\nconst {\n  patchProcessObject,\n  setupCoverageHooks,\n  setupInspectorHooks,\n  setupWarningHandler,\n  setupDebugEnv,\n  setupPerfHooks,\n  initializeDeprecations,\n  initializeWASI,\n  initializeCJSLoader,\n  initializeESMLoader,\n  initializeFrozenIntrinsics,\n  initializeReport,\n  initializeSourceMapsHandlers,\n  loadPreloadModules,\n  setupTraceCategoryState\n} = require(\"internal/bootstrap/pre_execution\");\nconst {\n  threadId,\n  getEnvMessagePort\n} = internalBinding(\"worker\");\nconst workerIo = require(\"internal/worker/io\");\nconst {\n  messageTypes: {\n    LOAD_SCRIPT,\n    UP_AND_RUNNING,\n    ERROR_MESSAGE,\n    COULD_NOT_SERIALIZE_ERROR,\n    STDIO_PAYLOAD,\n    STDIO_WANTS_MORE_DATA\n  },\n  kStdioWantsMoreDataCallback\n} = workerIo;\nconst {\n  onGlobalUncaughtException\n} = require(\"internal/process/execution\");\nconst publicWorker = require(\"worker_threads\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"worker\", (fn) => {\n  debug = fn;\n});\nconst assert = require(\"internal/assert\");\npatchProcessObject();\nsetupInspectorHooks();\nsetupDebugEnv();\nsetupWarningHandler();\ninitializeSourceMapsHandlers();\nif (process.env.NODE_V8_COVERAGE) {\n  setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n}\ndebug(`[${threadId}] is setting up worker child environment`);\nconst port = getEnvMessagePort();\nif (process.env.NODE_CHANNEL_FD) {\n  const workerThreadSetup = require(\"internal/process/worker_thread_only\");\n  ObjectDefineProperty(process, \"channel\", {\n    enumerable: false,\n    get: workerThreadSetup.unavailable(\"process.channel\")\n  });\n  ObjectDefineProperty(process, \"connected\", {\n    enumerable: false,\n    get: workerThreadSetup.unavailable(\"process.connected\")\n  });\n  process.send = workerThreadSetup.unavailable(\"process.send()\");\n  process.disconnect = workerThreadSetup.unavailable(\"process.disconnect()\");\n}\nport.on(\"message\", (message) => {\n  if (message.type === LOAD_SCRIPT) {\n    port.unref();\n    const {\n      argv,\n      cwdCounter,\n      filename,\n      doEval,\n      workerData,\n      environmentData,\n      publicPort,\n      manifestSrc,\n      manifestURL,\n      hasStdin\n    } = message;\n    setupTraceCategoryState();\n    setupPerfHooks();\n    initializeReport();\n    if (manifestSrc) {\n      require(\"internal/process/policy\").setup(manifestSrc, manifestURL);\n    }\n    initializeDeprecations();\n    initializeWASI();\n    initializeCJSLoader();\n    initializeESMLoader();\n    if (argv !== void 0) {\n      ArrayPrototypePushApply(process.argv, argv);\n    }\n    publicWorker.parentPort = publicPort;\n    publicWorker.workerData = workerData;\n    require(\"internal/worker\").assignEnvironmentData(environmentData);\n    let cachedCwd = \"\";\n    let lastCounter = -1;\n    const originalCwd = process.cwd;\n    process.cwd = function() {\n      const currentCounter = Atomics.load(cwdCounter, 0);\n      if (currentCounter === lastCounter)\n        return cachedCwd;\n      lastCounter = currentCounter;\n      cachedCwd = originalCwd();\n      return cachedCwd;\n    };\n    workerIo.sharedCwdCounter = cwdCounter;\n    const CJSLoader = require(\"internal/modules/cjs/loader\");\n    assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n    loadPreloadModules();\n    initializeFrozenIntrinsics();\n    if (!hasStdin)\n      process.stdin.push(null);\n    debug(`[${threadId}] starts worker script ${filename} (eval = ${eval}) at cwd = ${process.cwd()}`);\n    port.postMessage({ type: UP_AND_RUNNING });\n    if (doEval === \"classic\") {\n      const { evalScript } = require(\"internal/process/execution\");\n      const name = \"[worker eval]\";\n      ObjectDefineProperty(process, \"_eval\", {\n        configurable: true,\n        enumerable: true,\n        value: filename\n      });\n      ArrayPrototypeSplice(process.argv, 1, 0, name);\n      evalScript(name, filename);\n    } else if (doEval === \"module\") {\n      const { evalModule } = require(\"internal/process/execution\");\n      PromisePrototypeCatch(evalModule(filename), (e) => {\n        workerOnGlobalUncaughtException(e, true);\n      });\n    } else {\n      ArrayPrototypeSplice(process.argv, 1, 0, filename);\n      CJSLoader.Module.runMain(filename);\n    }\n  } else if (message.type === STDIO_PAYLOAD) {\n    const { stream, chunks } = message;\n    ArrayPrototypeForEach(chunks, ({ chunk, encoding }) => {\n      process[stream].push(chunk, encoding);\n    });\n  } else {\n    assert(message.type === STDIO_WANTS_MORE_DATA, `Unknown worker message type ${message.type}`);\n    const { stream } = message;\n    process[stream][kStdioWantsMoreDataCallback]();\n  }\n});\nfunction workerOnGlobalUncaughtException(error, fromPromise) {\n  debug(`[${threadId}] gets uncaught exception`);\n  let handled = false;\n  let handlerThrew = false;\n  try {\n    handled = onGlobalUncaughtException(error, fromPromise);\n  } catch (e) {\n    error = e;\n    handlerThrew = true;\n  }\n  debug(`[${threadId}] uncaught exception handled = ${handled}`);\n  if (handled) {\n    return true;\n  }\n  if (!process._exiting) {\n    try {\n      process._exiting = true;\n      process.exitCode = 1;\n      if (!handlerThrew) {\n        process.emit(\"exit\", process.exitCode);\n      }\n    } catch {\n    }\n  }\n  let serialized;\n  try {\n    const { serializeError } = require(\"internal/error_serdes\");\n    serialized = serializeError(error);\n  } catch {\n  }\n  debug(`[${threadId}] uncaught exception serialized = ${!!serialized}`);\n  if (serialized)\n    port.postMessage({\n      type: ERROR_MESSAGE,\n      error: serialized\n    });\n  else\n    port.postMessage({ type: COULD_NOT_SERIALIZE_ERROR });\n  const { clearAsyncIdStack } = require(\"internal/async_hooks\");\n  clearAsyncIdStack();\n  process.exit();\n}\nprocess._fatalException = workerOnGlobalUncaughtException;\nmarkBootstrapComplete();\nport.start();\n}"],["internal/modules/package_json_reader.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding(\"fs\");\nconst { pathToFileURL } = require(\"url\");\nconst { toNamespacedPath } = require(\"path\");\nconst cache = new SafeMap();\nlet manifest;\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n  const { 0: string, 1: containsKeys } = internalModuleReadJSON(toNamespacedPath(jsonPath));\n  const result = { string, containsKeys };\n  const { getOptionValue } = require(\"internal/options\");\n  if (string !== void 0) {\n    if (manifest === void 0) {\n      manifest = getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\").manifest : null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL, string);\n    }\n  }\n  cache.set(jsonPath, result);\n  return result;\n}\nmodule.exports = { read };\n}"],["internal/modules/run_main.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  StringPrototypeEndsWith\n} = primordials;\nconst CJSLoader = require(\"internal/modules/cjs/loader\");\nconst { Module, toRealPath, readPackageScope } = CJSLoader;\nconst { getOptionValue } = require(\"internal/options\");\nconst path = require(\"path\");\nfunction resolveMainPath(main) {\n  let mainPath = Module._findPath(path.resolve(main), null, true);\n  if (!mainPath)\n    return;\n  const preserveSymlinksMain = getOptionValue(\"--preserve-symlinks-main\");\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n  return mainPath;\n}\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue(\"--experimental-loader\");\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution = getOptionValue(\"--experimental-specifier-resolution\");\n  if (esModuleSpecifierResolution === \"node\")\n    return true;\n  if (mainPath && StringPrototypeEndsWith(mainPath, \".mjs\"))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath, \".cjs\"))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === \"module\";\n}\nfunction runMainESM(mainPath) {\n  const { loadESM } = require(\"internal/process/esm_loader\");\n  const { pathToFileURL } = require(\"internal/url\");\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ? pathToFileURL(mainPath).href : mainPath;\n    return esmLoader.import(main);\n  }));\n}\nasync function handleMainPromise(promise) {\n  function handler() {\n    if (process.exitCode === void 0)\n      process.exitCode = 13;\n  }\n  process.on(\"exit\", handler);\n  try {\n    return await promise;\n  } finally {\n    process.off(\"exit\", handler);\n  }\n}\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    Module._load(main, null, true);\n  }\n}\nmodule.exports = {\n  executeUserEntryPoint,\n  handleMainPromise\n};\n}"],["internal/per_context/domexception.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Error,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  SafeWeakMap,\n  SafeMap,\n  SymbolToStringTag,\n  TypeError\n} = primordials;\nclass ERR_INVALID_THIS extends TypeError {\n  constructor(type) {\n    super('Value of \"this\" must be of ' + type);\n  }\n  get code() {\n    return \"ERR_INVALID_THIS\";\n  }\n}\nlet internalsMap;\nlet nameToCodeMap;\nlet isInitialized = false;\nfunction ensureInitialized() {\n  if (isInitialized) {\n    return;\n  }\n  internalsMap = new SafeWeakMap();\n  nameToCodeMap = new SafeMap();\n  forEachCode((name, codeName, value) => {\n    nameToCodeMap.set(name, value);\n  });\n  isInitialized = true;\n}\nclass DOMException extends Error {\n  constructor(message = \"\", name = \"Error\") {\n    ensureInitialized();\n    super();\n    internalsMap.set(this, {\n      message: `${message}`,\n      name: `${name}`\n    });\n  }\n  get name() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === void 0) {\n      throw new ERR_INVALID_THIS(\"DOMException\");\n    }\n    return internals.name;\n  }\n  get message() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === void 0) {\n      throw new ERR_INVALID_THIS(\"DOMException\");\n    }\n    return internals.message;\n  }\n  get code() {\n    ensureInitialized();\n    const internals = internalsMap.get(this);\n    if (internals === void 0) {\n      throw new ERR_INVALID_THIS(\"DOMException\");\n    }\n    const code = nameToCodeMap.get(internals.name);\n    return code === void 0 ? 0 : code;\n  }\n}\nObjectDefineProperties(DOMException.prototype, {\n  [SymbolToStringTag]: { configurable: true, value: \"DOMException\" },\n  name: { enumerable: true, configurable: true },\n  message: { enumerable: true, configurable: true },\n  code: { enumerable: true, configurable: true }\n});\nfunction forEachCode(fn) {\n  fn(\"IndexSizeError\", \"INDEX_SIZE_ERR\", 1);\n  fn(\"DOMStringSizeError\", \"DOMSTRING_SIZE_ERR\", 2);\n  fn(\"HierarchyRequestError\", \"HIERARCHY_REQUEST_ERR\", 3);\n  fn(\"WrongDocumentError\", \"WRONG_DOCUMENT_ERR\", 4);\n  fn(\"InvalidCharacterError\", \"INVALID_CHARACTER_ERR\", 5);\n  fn(\"NoDataAllowedError\", \"NO_DATA_ALLOWED_ERR\", 6);\n  fn(\"NoModificationAllowedError\", \"NO_MODIFICATION_ALLOWED_ERR\", 7);\n  fn(\"NotFoundError\", \"NOT_FOUND_ERR\", 8);\n  fn(\"NotSupportedError\", \"NOT_SUPPORTED_ERR\", 9);\n  fn(\"InUseAttributeError\", \"INUSE_ATTRIBUTE_ERR\", 10);\n  fn(\"InvalidStateError\", \"INVALID_STATE_ERR\", 11);\n  fn(\"SyntaxError\", \"SYNTAX_ERR\", 12);\n  fn(\"InvalidModificationError\", \"INVALID_MODIFICATION_ERR\", 13);\n  fn(\"NamespaceError\", \"NAMESPACE_ERR\", 14);\n  fn(\"InvalidAccessError\", \"INVALID_ACCESS_ERR\", 15);\n  fn(\"ValidationError\", \"VALIDATION_ERR\", 16);\n  fn(\"TypeMismatchError\", \"TYPE_MISMATCH_ERR\", 17);\n  fn(\"SecurityError\", \"SECURITY_ERR\", 18);\n  fn(\"NetworkError\", \"NETWORK_ERR\", 19);\n  fn(\"AbortError\", \"ABORT_ERR\", 20);\n  fn(\"URLMismatchError\", \"URL_MISMATCH_ERR\", 21);\n  fn(\"QuotaExceededError\", \"QUOTA_EXCEEDED_ERR\", 22);\n  fn(\"TimeoutError\", \"TIMEOUT_ERR\", 23);\n  fn(\"InvalidNodeTypeError\", \"INVALID_NODE_TYPE_ERR\", 24);\n  fn(\"DataCloneError\", \"DATA_CLONE_ERR\", 25);\n}\nforEachCode((name, codeName, value) => {\n  const desc = { enumerable: true, value };\n  ObjectDefineProperty(DOMException, codeName, desc);\n  ObjectDefineProperty(DOMException.prototype, codeName, desc);\n});\nexports.DOMException = DOMException;\n}"],["internal/per_context/messageport.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  SymbolFor\n} = primordials;\nclass MessageEvent {\n  constructor(data, target, type, ports) {\n    this.data = data;\n    this.target = target;\n    this.type = type;\n    this.ports = ports ?? [];\n  }\n}\nconst kHybridDispatch = SymbolFor(\"nodejs.internal.kHybridDispatch\");\nconst kCurrentlyReceivingPorts = SymbolFor(\"nodejs.internal.kCurrentlyReceivingPorts\");\nexports.emitMessage = function(data, ports, type) {\n  if (typeof this[kHybridDispatch] === \"function\") {\n    this[kCurrentlyReceivingPorts] = ports;\n    try {\n      this[kHybridDispatch](data, type, void 0);\n    } finally {\n      this[kCurrentlyReceivingPorts] = void 0;\n    }\n    return;\n  }\n  const event = new MessageEvent(data, this, type, ports);\n  if (type === \"message\") {\n    if (typeof this.onmessage === \"function\")\n      this.onmessage(event);\n  } else {\n    if (typeof this.onmessageerror === \"function\")\n      this.onmessageerror(event);\n  }\n};\n}"],["internal/per_context/primordials.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  defineProperty: ReflectDefineProperty,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  ownKeys: ReflectOwnKeys\n} = Reflect;\nconst { apply, bind, call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\nconst varargsMethods = [\n  \"ArrayOf\",\n  \"ArrayPrototypePush\",\n  \"ArrayPrototypeUnshift\",\n  \"MathHypot\",\n  \"MathMax\",\n  \"MathMin\",\n  \"StringPrototypeConcat\",\n  \"TypedArrayOf\"\n];\nfunction getNewKey(key) {\n  return typeof key === \"symbol\" ? `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` : `${key[0].toUpperCase()}${key.slice(1)}`;\n}\nfunction copyAccessor(dest, prefix, key, { enumerable, get, set }) {\n  ReflectDefineProperty(dest, `${prefix}Get${key}`, {\n    value: uncurryThis(get),\n    enumerable\n  });\n  if (set !== void 0) {\n    ReflectDefineProperty(dest, `${prefix}Set${key}`, {\n      value: uncurryThis(set),\n      enumerable\n    });\n  }\n}\nfunction copyPropsRenamed(src, dest, prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src, key);\n    if (\"get\" in desc) {\n      copyAccessor(dest, prefix, newKey, desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest, name, desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest, `${name}Apply`, {\n          value: applyBind(desc.value, src)\n        });\n      }\n    }\n  }\n}\nfunction copyPropsRenamedBound(src, dest, prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src, key);\n    if (\"get\" in desc) {\n      copyAccessor(dest, prefix, newKey, desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === \"function\") {\n        desc.value = value.bind(src);\n      }\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest, name, desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest, `${name}Apply`, {\n          value: applyBind(value, src)\n        });\n      }\n    }\n  }\n}\nfunction copyPrototype(src, dest, prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src, key);\n    if (\"get\" in desc) {\n      copyAccessor(dest, prefix, newKey, desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === \"function\") {\n        desc.value = uncurryThis(value);\n      }\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest, name, desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest, `${name}Apply`, {\n          value: applyBind(value)\n        });\n      }\n    }\n  }\n}\n[\n  \"Proxy\",\n  \"globalThis\"\n].forEach((name) => {\n  primordials[name] = globalThis[name];\n});\n[\n  decodeURI,\n  decodeURIComponent,\n  encodeURI,\n  encodeURIComponent\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n[\n  \"JSON\",\n  \"Math\",\n  \"Proxy\",\n  \"Reflect\"\n].forEach((name) => {\n  copyPropsRenamed(global[name], primordials, name);\n});\n[\n  \"AggregateError\",\n  \"Array\",\n  \"ArrayBuffer\",\n  \"BigInt\",\n  \"BigInt64Array\",\n  \"BigUint64Array\",\n  \"Boolean\",\n  \"DataView\",\n  \"Date\",\n  \"Error\",\n  \"EvalError\",\n  \"FinalizationRegistry\",\n  \"Float32Array\",\n  \"Float64Array\",\n  \"Function\",\n  \"Int16Array\",\n  \"Int32Array\",\n  \"Int8Array\",\n  \"Map\",\n  \"Number\",\n  \"Object\",\n  \"RangeError\",\n  \"ReferenceError\",\n  \"RegExp\",\n  \"Set\",\n  \"String\",\n  \"Symbol\",\n  \"SyntaxError\",\n  \"TypeError\",\n  \"URIError\",\n  \"Uint16Array\",\n  \"Uint32Array\",\n  \"Uint8Array\",\n  \"Uint8ClampedArray\",\n  \"WeakMap\",\n  \"WeakRef\",\n  \"WeakSet\"\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n[\n  \"Promise\"\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n[\n  { name: \"TypedArray\", original: Reflect.getPrototypeOf(Uint8Array) },\n  { name: \"ArrayIterator\", original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\n  } },\n  { name: \"StringIterator\", original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\n  } }\n].forEach(({ name, original }) => {\n  primordials[name] = original;\n  copyPrototype(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\nconst {\n  ArrayPrototypeForEach,\n  FinalizationRegistry,\n  FunctionPrototypeCall,\n  Map,\n  ObjectFreeze,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromisePrototypeThen,\n  Set,\n  SymbolIterator,\n  WeakMap,\n  WeakRef,\n  WeakSet\n} = primordials;\nconst createSafeIterator = (factory, next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype, null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\nprimordials.SafeArrayIterator = createSafeIterator(primordials.ArrayPrototypeSymbolIterator, primordials.ArrayIteratorPrototypeNext);\nprimordials.SafeStringIterator = createSafeIterator(primordials.StringPrototypeSymbolIterator, primordials.StringIteratorPrototypeNext);\nconst copyProps = (src, dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src), (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest, key)) {\n      ReflectDefineProperty(dest, key, ReflectGetOwnPropertyDescriptor(src, key));\n    }\n  });\n};\nconst makeSafe = (unsafe, safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next;\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype), (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype, key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype, key);\n        if (typeof desc.value === \"function\" && desc.value.length === 0 && SymbolIterator in (FunctionPrototypeCall(desc.value, dummy) ?? {})) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator, next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype, key, desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype, safe.prototype);\n  }\n  copyProps(unsafe, safe);\n  ObjectSetPrototypeOf(safe.prototype, null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\nprimordials.SafeMap = makeSafe(Map, class SafeMap extends Map {\n  constructor(i) {\n    super(i);\n  }\n});\nprimordials.SafeWeakMap = makeSafe(WeakMap, class SafeWeakMap extends WeakMap {\n  constructor(i) {\n    super(i);\n  }\n});\nprimordials.SafeSet = makeSafe(Set, class SafeSet extends Set {\n  constructor(i) {\n    super(i);\n  }\n});\nprimordials.SafeWeakSet = makeSafe(WeakSet, class SafeWeakSet extends WeakSet {\n  constructor(i) {\n    super(i);\n  }\n});\nprimordials.SafeFinalizationRegistry = makeSafe(FinalizationRegistry, class SafeFinalizationRegistry extends FinalizationRegistry {\n  constructor(cleanupCallback) {\n    super(cleanupCallback);\n  }\n});\nprimordials.SafeWeakRef = makeSafe(WeakRef, class SafeWeakRef extends WeakRef {\n  constructor(target) {\n    super(target);\n  }\n});\nconst SafePromise = makeSafe(Promise, class SafePromise2 extends Promise {\n  constructor(executor) {\n    super(executor);\n  }\n});\nprimordials.PromisePrototypeCatch = (thisPromise, onRejected) => PromisePrototypeThen(thisPromise, void 0, onRejected);\nprimordials.SafePromisePrototypeFinally = (thisPromise, onFinally) => new Promise((a, b) => new SafePromise((a2, b2) => PromisePrototypeThen(thisPromise, a2, b2)).finally(onFinally).then(a, b));\nprimordials.AsyncIteratorPrototype = primordials.ReflectGetPrototypeOf(primordials.ReflectGetPrototypeOf(async function* () {\n}).prototype);\nObjectSetPrototypeOf(primordials, null);\nObjectFreeze(primordials);\n}"],["internal/perf/event_loop_delay.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Symbol\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\n  }\n} = require(\"internal/errors\");\nconst {\n  ELDHistogram: _ELDHistogram\n} = internalBinding(\"performance\");\nconst {\n  validateInteger,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  Histogram,\n  kHandle\n} = require(\"internal/histogram\");\nconst kEnabled = Symbol(\"kEnabled\");\nclass ELDHistogram extends Histogram {\n  constructor(i) {\n    if (!(i instanceof _ELDHistogram)) {\n      throw new ERR_ILLEGAL_CONSTRUCTOR();\n    }\n    super(i);\n    this[kEnabled] = false;\n  }\n  enable() {\n    if (this[kEnabled])\n      return false;\n    this[kEnabled] = true;\n    this[kHandle].start();\n    return true;\n  }\n  disable() {\n    if (!this[kEnabled])\n      return false;\n    this[kEnabled] = false;\n    this[kHandle].stop();\n    return true;\n  }\n}\nfunction monitorEventLoopDelay(options = {}) {\n  validateObject(options, \"options\");\n  const { resolution = 10 } = options;\n  validateInteger(resolution, \"options.resolution\", 1);\n  return new ELDHistogram(new _ELDHistogram(resolution));\n}\nmodule.exports = monitorEventLoopDelay;\n}"],["internal/perf/event_loop_utilization.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst nodeTiming = require(\"internal/perf/nodetiming\");\nconst { now } = require(\"internal/perf/utils\");\nfunction eventLoopUtilization(util1, util2) {\n  const ls = nodeTiming.loopStart;\n  if (ls <= 0) {\n    return { idle: 0, active: 0, utilization: 0 };\n  }\n  if (util2) {\n    const idle2 = util1.idle - util2.idle;\n    const active2 = util1.active - util2.active;\n    return { idle: idle2, active: active2, utilization: active2 / (idle2 + active2) };\n  }\n  const idle = nodeTiming.idleTime;\n  const active = now() - ls - idle;\n  if (!util1) {\n    return { idle, active, utilization: active / (idle + active) };\n  }\n  const idle_delta = idle - util1.idle;\n  const active_delta = active - util1.active;\n  const utilization = active_delta / (idle_delta + active_delta);\n  return { idle: idle_delta, active: active_delta, utilization };\n}\nmodule.exports = eventLoopUtilization;\n}"],["internal/perf/nodetiming.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf\n} = primordials;\nconst { PerformanceEntry } = require(\"internal/perf/performance_entry\");\nconst {\n  now,\n  getMilestoneTimestamp\n} = require(\"internal/perf/utils\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst { inspect } = require(\"util\");\nconst {\n  constants: {\n    NODE_PERFORMANCE_MILESTONE_NODE_START,\n    NODE_PERFORMANCE_MILESTONE_V8_START,\n    NODE_PERFORMANCE_MILESTONE_LOOP_START,\n    NODE_PERFORMANCE_MILESTONE_LOOP_EXIT,\n    NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE,\n    NODE_PERFORMANCE_MILESTONE_ENVIRONMENT\n  },\n  loopIdleTime\n} = internalBinding(\"performance\");\nclass PerformanceNodeTiming {\n  constructor() {\n    ObjectDefineProperties(this, {\n      name: {\n        enumerable: true,\n        configurable: true,\n        value: \"node\"\n      },\n      entryType: {\n        enumerable: true,\n        configurable: true,\n        value: \"node\"\n      },\n      startTime: {\n        enumerable: true,\n        configurable: true,\n        value: 0\n      },\n      duration: {\n        enumerable: true,\n        configurable: true,\n        get: now\n      },\n      nodeStart: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_NODE_START);\n        }\n      },\n      v8Start: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_V8_START);\n        }\n      },\n      environment: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_ENVIRONMENT);\n        }\n      },\n      loopStart: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_LOOP_START);\n        }\n      },\n      loopExit: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);\n        }\n      },\n      bootstrapComplete: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return getMilestoneTimestamp(NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);\n        }\n      },\n      idleTime: {\n        enumerable: true,\n        configurable: true,\n        get: loopIdleTime\n      }\n    });\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `PerformanceNodeTiming ${inspect(this.toJSON(), opts)}`;\n  }\n  toJSON() {\n    return {\n      name: \"node\",\n      entryType: \"node\",\n      startTime: this.startTime,\n      duration: this.duration,\n      nodeStart: this.nodeStart,\n      v8Start: this.v8Start,\n      bootstrapComplete: this.bootstrapComplete,\n      environment: this.environment,\n      loopStart: this.loopStart,\n      loopExit: this.loopExit,\n      idleTime: this.idleTime\n    };\n  }\n}\nObjectSetPrototypeOf(PerformanceNodeTiming.prototype, PerformanceEntry.prototype);\nmodule.exports = new PerformanceNodeTiming();\n}"],["internal/perf/observe.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeFlatMap,\n  ArrayPrototypeIncludes,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  Error,\n  ObjectDefineProperties,\n  ObjectFreeze,\n  ObjectKeys,\n  SafeMap,\n  SafeSet,\n  Symbol\n} = primordials;\nconst {\n  constants: {\n    NODE_PERFORMANCE_ENTRY_TYPE_GC,\n    NODE_PERFORMANCE_ENTRY_TYPE_HTTP2,\n    NODE_PERFORMANCE_ENTRY_TYPE_HTTP\n  },\n  installGarbageCollectionTracking,\n  observerCounts,\n  removeGarbageCollectionTracking,\n  setupObservers\n} = internalBinding(\"performance\");\nconst {\n  InternalPerformanceEntry,\n  isPerformanceEntry,\n  kBufferNext\n} = require(\"internal/perf/performance_entry\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_MISSING_ARGS\n  }\n} = require(\"internal/errors\");\nconst {\n  validateCallback,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  customInspectSymbol: kInspect,\n  deprecate,\n  lazyDOMException\n} = require(\"internal/util\");\nconst {\n  setImmediate\n} = require(\"timers\");\nconst { inspect } = require(\"util\");\nconst kBuffer = Symbol(\"kBuffer\");\nconst kCallback = Symbol(\"kCallback\");\nconst kDispatch = Symbol(\"kDispatch\");\nconst kEntryTypes = Symbol(\"kEntryTypes\");\nconst kMaybeBuffer = Symbol(\"kMaybeBuffer\");\nconst kDeprecatedFields = Symbol(\"kDeprecatedFields\");\nconst kType = Symbol(\"kType\");\nconst kDeprecationMessage = \"Custom PerformanceEntry accessors are deprecated. Please use the detail property.\";\nconst kTypeSingle = 0;\nconst kTypeMultiple = 1;\nlet gcTrackingInstalled = false;\nconst kSupportedEntryTypes = ObjectFreeze([\n  \"function\",\n  \"gc\",\n  \"http\",\n  \"http2\",\n  \"mark\",\n  \"measure\"\n]);\nconst markEntryBuffer = createBuffer();\nconst measureEntryBuffer = createBuffer();\nconst kMaxPerformanceEntryBuffers = 1e6;\nconst kClearPerformanceEntryBuffers = ObjectFreeze({\n  \"mark\": \"performance.clearMarks\",\n  \"measure\": \"performance.clearMeasures\"\n});\nconst kWarnedEntryTypes = new SafeMap();\nconst kObservers = new SafeSet();\nconst kPending = new SafeSet();\nlet isPending = false;\nfunction queuePending() {\n  if (isPending)\n    return;\n  isPending = true;\n  setImmediate(() => {\n    isPending = false;\n    const pendings = ArrayFrom(kPending.values());\n    kPending.clear();\n    for (const pending of pendings)\n      pending[kDispatch]();\n  });\n}\nfunction getObserverType(type) {\n  switch (type) {\n    case \"gc\":\n      return NODE_PERFORMANCE_ENTRY_TYPE_GC;\n    case \"http2\":\n      return NODE_PERFORMANCE_ENTRY_TYPE_HTTP2;\n    case \"http\":\n      return NODE_PERFORMANCE_ENTRY_TYPE_HTTP;\n  }\n}\nfunction maybeDecrementObserverCounts(entryTypes) {\n  for (const type of entryTypes) {\n    const observerType = getObserverType(type);\n    if (observerType !== void 0) {\n      observerCounts[observerType]--;\n      if (observerType === NODE_PERFORMANCE_ENTRY_TYPE_GC && observerCounts[observerType] === 0) {\n        removeGarbageCollectionTracking();\n        gcTrackingInstalled = false;\n      }\n    }\n  }\n}\nfunction maybeIncrementObserverCount(type) {\n  const observerType = getObserverType(type);\n  if (observerType !== void 0) {\n    observerCounts[observerType]++;\n    if (!gcTrackingInstalled && observerType === NODE_PERFORMANCE_ENTRY_TYPE_GC) {\n      installGarbageCollectionTracking();\n      gcTrackingInstalled = true;\n    }\n  }\n}\nclass PerformanceObserverEntryList {\n  constructor(entries) {\n    this[kBuffer] = ArrayPrototypeSort(entries, (first, second) => {\n      if (first.startTime < second.startTime)\n        return -1;\n      if (first.startTime > second.startTime)\n        return 1;\n      return 0;\n    });\n  }\n  getEntries() {\n    return ArrayPrototypeSlice(this[kBuffer]);\n  }\n  getEntriesByType(type) {\n    type = `${type}`;\n    return ArrayPrototypeFilter(this[kBuffer], (entry) => entry.entryType === type);\n  }\n  getEntriesByName(name, type) {\n    name = `${name}`;\n    if (type != null) {\n      return ArrayPrototypeFilter(this[kBuffer], (entry) => entry.name === name && entry.entryType === type);\n    }\n    return ArrayPrototypeFilter(this[kBuffer], (entry) => entry.name === name);\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `PerformanceObserverEntryList ${inspect(this[kBuffer], opts)}`;\n  }\n}\nclass PerformanceObserver {\n  constructor(callback) {\n    this[kBuffer] = [];\n    this[kEntryTypes] = new SafeSet();\n    this[kType] = void 0;\n    validateCallback(callback);\n    this[kCallback] = callback;\n  }\n  observe(options = {}) {\n    validateObject(options, \"options\");\n    const {\n      entryTypes,\n      type,\n      buffered\n    } = { ...options };\n    if (entryTypes === void 0 && type === void 0)\n      throw new ERR_MISSING_ARGS(\"options.entryTypes\", \"options.type\");\n    if (entryTypes != null && type != null)\n      throw new ERR_INVALID_ARG_VALUE(\"options.entryTypes\", entryTypes, \"options.entryTypes can not set with options.type together\");\n    switch (this[kType]) {\n      case void 0:\n        if (entryTypes !== void 0)\n          this[kType] = kTypeMultiple;\n        if (type !== void 0)\n          this[kType] = kTypeSingle;\n        break;\n      case kTypeSingle:\n        if (entryTypes !== void 0)\n          throw lazyDOMException(\"PerformanceObserver can not change to multiple observations\", \"InvalidModificationError\");\n        break;\n      case kTypeMultiple:\n        if (type !== void 0)\n          throw lazyDOMException(\"PerformanceObserver can not change to single observation\", \"InvalidModificationError\");\n        break;\n    }\n    if (this[kType] === kTypeMultiple) {\n      if (!ArrayIsArray(entryTypes)) {\n        throw new ERR_INVALID_ARG_TYPE(\"options.entryTypes\", \"string[]\", entryTypes);\n      }\n      maybeDecrementObserverCounts(this[kEntryTypes]);\n      this[kEntryTypes].clear();\n      for (let n = 0; n < entryTypes.length; n++) {\n        if (ArrayPrototypeIncludes(kSupportedEntryTypes, entryTypes[n])) {\n          this[kEntryTypes].add(entryTypes[n]);\n          maybeIncrementObserverCount(entryTypes[n]);\n        }\n      }\n    } else {\n      if (!ArrayPrototypeIncludes(kSupportedEntryTypes, type))\n        return;\n      this[kEntryTypes].add(type);\n      maybeIncrementObserverCount(type);\n      if (buffered) {\n        const entries = filterBufferMapByNameAndType(void 0, type);\n        ArrayPrototypePushApply(this[kBuffer], entries);\n        kPending.add(this);\n        if (kPending.size)\n          queuePending();\n      }\n    }\n    if (this[kEntryTypes].size)\n      kObservers.add(this);\n    else\n      this.disconnect();\n  }\n  disconnect() {\n    maybeDecrementObserverCounts(this[kEntryTypes]);\n    kObservers.delete(this);\n    kPending.delete(this);\n    this[kBuffer] = [];\n    this[kEntryTypes].clear();\n    this[kType] = void 0;\n  }\n  takeRecords() {\n    const list = this[kBuffer];\n    this[kBuffer] = [];\n    return list;\n  }\n  static get supportedEntryTypes() {\n    return kSupportedEntryTypes;\n  }\n  [kMaybeBuffer](entry) {\n    if (!this[kEntryTypes].has(entry.entryType))\n      return;\n    ArrayPrototypePush(this[kBuffer], entry);\n    kPending.add(this);\n    if (kPending.size)\n      queuePending();\n  }\n  [kDispatch]() {\n    this[kCallback](new PerformanceObserverEntryList(this.takeRecords()), this);\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `PerformanceObserver ${inspect({\n      connected: kObservers.has(this),\n      pending: kPending.has(this),\n      entryTypes: ArrayFrom(this[kEntryTypes]),\n      buffer: this[kBuffer]\n    }, opts)}`;\n  }\n}\nfunction enqueue(entry) {\n  if (!isPerformanceEntry(entry))\n    throw new ERR_INVALID_ARG_TYPE(\"entry\", \"PerformanceEntry\", entry);\n  for (const obs of kObservers) {\n    obs[kMaybeBuffer](entry);\n  }\n  const entryType = entry.entryType;\n  let buffer;\n  if (entryType === \"mark\") {\n    buffer = markEntryBuffer;\n  } else if (entryType === \"measure\") {\n    buffer = measureEntryBuffer;\n  } else {\n    return;\n  }\n  const count = buffer.count + 1;\n  buffer.count = count;\n  if (count === 1) {\n    buffer.head = entry;\n    buffer.tail = entry;\n    return;\n  }\n  buffer.tail[kBufferNext] = entry;\n  buffer.tail = entry;\n  if (count > kMaxPerformanceEntryBuffers && !kWarnedEntryTypes.has(entryType)) {\n    kWarnedEntryTypes.set(entryType, true);\n    const w = new Error(`Possible perf_hooks memory leak detected. ${count} ${entryType} entries added to the global performance entry buffer. Use ${kClearPerformanceEntryBuffers[entryType]} to clear the buffer.`);\n    w.name = \"MaxPerformanceEntryBufferExceededWarning\";\n    w.entryType = entryType;\n    w.count = count;\n    process.emitWarning(w);\n  }\n}\nfunction clearEntriesFromBuffer(type, name) {\n  let buffer;\n  if (type === \"mark\") {\n    buffer = markEntryBuffer;\n  } else if (type === \"measure\") {\n    buffer = measureEntryBuffer;\n  } else {\n    return;\n  }\n  if (name === void 0) {\n    resetBuffer(buffer);\n    return;\n  }\n  let head = null;\n  let tail = null;\n  let count = 0;\n  for (let entry = buffer.head; entry !== null; entry = entry[kBufferNext]) {\n    if (entry.name !== name) {\n      head = head ?? entry;\n      tail = entry;\n      continue;\n    }\n    if (tail === null) {\n      continue;\n    }\n    tail[kBufferNext] = entry[kBufferNext];\n    count++;\n  }\n  buffer.head = head;\n  buffer.tail = tail;\n  buffer.count = count;\n}\nfunction filterBufferMapByNameAndType(name, type) {\n  let bufferList;\n  if (type === \"mark\") {\n    bufferList = [markEntryBuffer];\n  } else if (type === \"measure\") {\n    bufferList = [measureEntryBuffer];\n  } else if (type !== void 0) {\n    return [];\n  } else {\n    bufferList = [markEntryBuffer, measureEntryBuffer];\n  }\n  return ArrayPrototypeFlatMap(bufferList, (buffer) => filterBufferByName(buffer, name));\n}\nfunction filterBufferByName(buffer, name) {\n  const arr = [];\n  for (let entry = buffer.head; entry !== null; entry = entry[kBufferNext]) {\n    if (name === void 0 || entry.name === name) {\n      ArrayPrototypePush(arr, entry);\n    }\n  }\n  return arr;\n}\nfunction observerCallback(name, type, startTime, duration, details) {\n  const entry = new InternalPerformanceEntry(name, type, startTime, duration, details);\n  if (details !== void 0) {\n    entry[kDeprecatedFields] = new SafeMap();\n    const detailKeys = ObjectKeys(details);\n    const props = {};\n    for (let n = 0; n < detailKeys.length; n++) {\n      const key = detailKeys[n];\n      entry[kDeprecatedFields].set(key, details[key]);\n      props[key] = {\n        configurable: true,\n        enumerable: true,\n        get: deprecate(() => {\n          return entry[kDeprecatedFields].get(key);\n        }, kDeprecationMessage, \"DEP0152\"),\n        set: deprecate((value) => {\n          entry[kDeprecatedFields].set(key, value);\n        }, kDeprecationMessage, \"DEP0152\")\n      };\n    }\n    ObjectDefineProperties(entry, props);\n  }\n  enqueue(entry);\n}\nsetupObservers(observerCallback);\nfunction hasObserver(type) {\n  const observerType = getObserverType(type);\n  return observerCounts[observerType] > 0;\n}\nfunction createBuffer() {\n  return {\n    head: null,\n    tail: null,\n    count: 0\n  };\n}\nfunction resetBuffer(buffer) {\n  buffer.head = null;\n  buffer.tail = null;\n  buffer.count = 0;\n}\nmodule.exports = {\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  enqueue,\n  hasObserver,\n  clearEntriesFromBuffer,\n  filterBufferMapByNameAndType\n};\n}"],["internal/perf/performance.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\n  }\n} = require(\"internal/errors\");\nconst {\n  EventTarget\n} = require(\"internal/event_target\");\nconst { now } = require(\"internal/perf/utils\");\nconst {\n  mark,\n  measure,\n  clearMarkTimings\n} = require(\"internal/perf/usertiming\");\nconst {\n  clearEntriesFromBuffer,\n  filterBufferMapByNameAndType\n} = require(\"internal/perf/observe\");\nconst eventLoopUtilization = require(\"internal/perf/event_loop_utilization\");\nconst nodeTiming = require(\"internal/perf/nodetiming\");\nconst timerify = require(\"internal/perf/timerify\");\nconst { customInspectSymbol: kInspect } = require(\"internal/util\");\nconst { inspect } = require(\"util\");\nconst {\n  getTimeOriginTimestamp\n} = internalBinding(\"performance\");\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming,\n      timeOrigin: this.timeOrigin\n    }, opts)}`;\n  }\n}\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming,\n    timeOrigin: this.timeOrigin,\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\nfunction clearMarks(name) {\n  if (name !== void 0) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer(\"mark\", name);\n}\nfunction clearMeasures(name) {\n  if (name !== void 0) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer(\"measure\", name);\n}\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\nfunction getEntriesByName(name) {\n  if (name !== void 0) {\n    name = `${name}`;\n  }\n  return filterBufferMapByNameAndType(name, void 0);\n}\nfunction getEntriesByType(type) {\n  if (type !== void 0) {\n    type = `${type}`;\n  }\n  return filterBufferMapByNameAndType(void 0, type);\n}\nclass InternalPerformance extends EventTarget {\n}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype, Performance.prototype);\nObjectDefineProperties(Performance.prototype, {\n  clearMarks: {\n    configurable: true,\n    enumerable: false,\n    value: clearMarks\n  },\n  clearMeasures: {\n    configurable: true,\n    enumerable: false,\n    value: clearMeasures\n  },\n  eventLoopUtilization: {\n    configurable: true,\n    enumerable: false,\n    value: eventLoopUtilization\n  },\n  getEntries: {\n    configurable: true,\n    enumerable: false,\n    value: getEntries\n  },\n  getEntriesByName: {\n    configurable: true,\n    enumerable: false,\n    value: getEntriesByName\n  },\n  getEntriesByType: {\n    configurable: true,\n    enumerable: false,\n    value: getEntriesByType\n  },\n  mark: {\n    configurable: true,\n    enumerable: false,\n    value: mark\n  },\n  measure: {\n    configurable: true,\n    enumerable: false,\n    value: measure\n  },\n  nodeTiming: {\n    configurable: true,\n    enumerable: false,\n    value: nodeTiming\n  },\n  now: {\n    configurable: true,\n    enumerable: false,\n    value: now\n  },\n  timerify: {\n    configurable: true,\n    enumerable: false,\n    value: timerify\n  },\n  timeOrigin: {\n    configurable: true,\n    enumerable: true,\n    value: getTimeOriginTimestamp()\n  },\n  toJSON: {\n    configurable: true,\n    enumerable: true,\n    value: toJSON\n  }\n});\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype, \"timeOrigin\", {\n    configurable: true,\n    enumerable: true,\n    value: getTimeOriginTimestamp()\n  });\n}\nmodule.exports = {\n  InternalPerformance,\n  refreshTimeOrigin\n};\n}"],["internal/perf/performance_entry.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\n  }\n} = require(\"internal/errors\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst { inspect } = require(\"util\");\nconst kName = Symbol(\"kName\");\nconst kType = Symbol(\"kType\");\nconst kStart = Symbol(\"kStart\");\nconst kDuration = Symbol(\"kDuration\");\nconst kDetail = Symbol(\"kDetail\");\nconst kBufferNext = Symbol(\"kBufferNext\");\nfunction isPerformanceEntry(obj) {\n  return obj?.[kName] !== void 0;\n}\nclass PerformanceEntry {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get name() {\n    return this[kName];\n  }\n  get entryType() {\n    return this[kType];\n  }\n  get startTime() {\n    return this[kStart];\n  }\n  get duration() {\n    return this[kDuration];\n  }\n  get detail() {\n    return this[kDetail];\n  }\n  [kInspect](depth, options) {\n    if (depth < 0)\n      return this;\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `${this.constructor.name} ${inspect(this.toJSON(), opts)}`;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      entryType: this.entryType,\n      startTime: this.startTime,\n      duration: this.duration,\n      detail: this.detail\n    };\n  }\n}\nclass InternalPerformanceEntry {\n  constructor(name, type, start, duration, detail) {\n    this[kName] = name;\n    this[kType] = type;\n    this[kStart] = start;\n    this[kDuration] = duration;\n    this[kDetail] = detail;\n    this[kBufferNext] = null;\n  }\n}\nInternalPerformanceEntry.prototype.constructor = PerformanceEntry;\nObjectSetPrototypeOf(InternalPerformanceEntry.prototype, PerformanceEntry.prototype);\nmodule.exports = {\n  InternalPerformanceEntry,\n  PerformanceEntry,\n  isPerformanceEntry,\n  kBufferNext\n};\n}"],["internal/perf/timerify.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  ObjectDefineProperties,\n  MathCeil,\n  ReflectApply,\n  ReflectConstruct,\n  Symbol\n} = primordials;\nconst { InternalPerformanceEntry } = require(\"internal/perf/performance_entry\");\nconst { now } = require(\"internal/perf/utils\");\nconst {\n  validateFunction,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  isHistogram\n} = require(\"internal/histogram\");\nconst {\n  isConstructor\n} = internalBinding(\"util\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  enqueue\n} = require(\"internal/perf/observe\");\nconst kTimerified = Symbol(\"kTimerified\");\nfunction processComplete(name, start, args, histogram) {\n  const duration = now() - start;\n  if (histogram !== void 0)\n    histogram.record(MathCeil(duration * 1e6));\n  const entry = new InternalPerformanceEntry(name, \"function\", start, duration, args);\n  for (let n = 0; n < args.length; n++)\n    entry[n] = args[n];\n  enqueue(entry);\n}\nfunction timerify(fn, options = {}) {\n  validateFunction(fn, \"fn\");\n  validateObject(options, \"options\");\n  const {\n    histogram\n  } = options;\n  if (histogram !== void 0 && (!isHistogram(histogram) || typeof histogram.record !== \"function\")) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.histogram\", \"RecordableHistogram\", histogram);\n  }\n  if (fn[kTimerified])\n    return fn[kTimerified];\n  const constructor = isConstructor(fn);\n  function timerified(...args) {\n    const start = now();\n    const result = constructor ? ReflectConstruct(fn, args, fn) : ReflectApply(fn, this, args);\n    if (!constructor && typeof result?.finally === \"function\") {\n      return result.finally(FunctionPrototypeBind(processComplete, result, fn.name, start, args, histogram));\n    }\n    processComplete(fn.name, start, args, histogram);\n    return result;\n  }\n  ObjectDefineProperties(timerified, {\n    [kTimerified]: {\n      configurable: false,\n      enumerable: false,\n      value: timerified\n    },\n    length: {\n      configurable: false,\n      enumerable: true,\n      value: fn.length\n    },\n    name: {\n      configurable: false,\n      enumerable: true,\n      value: `timerified ${fn.name}`\n    }\n  });\n  ObjectDefineProperties(fn, {\n    [kTimerified]: {\n      configurable: false,\n      enumerable: false,\n      value: timerified\n    }\n  });\n  return timerified;\n}\nmodule.exports = timerify;\n}"],["internal/perf/usertiming.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  SafeMap,\n  SafeSet,\n  SafeArrayIterator,\n  SymbolToStringTag\n} = primordials;\nconst { InternalPerformanceEntry } = require(\"internal/perf/performance_entry\");\nconst { now } = require(\"internal/perf/utils\");\nconst { enqueue } = require(\"internal/perf/observe\");\nconst nodeTiming = require(\"internal/perf/nodetiming\");\nconst {\n  validateNumber,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_PERFORMANCE_INVALID_TIMESTAMP,\n    ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS\n  }\n} = require(\"internal/errors\");\nconst { structuredClone, lazyDOMException } = require(\"internal/util\");\nconst markTimings = new SafeMap();\nconst nodeTimingReadOnlyAttributes = new SafeSet(new SafeArrayIterator([\n  \"nodeStart\",\n  \"v8Start\",\n  \"environment\",\n  \"loopStart\",\n  \"loopExit\",\n  \"bootstrapComplete\"\n]));\nfunction getMark(name) {\n  if (name === void 0)\n    return;\n  if (typeof name === \"number\") {\n    if (name < 0)\n      throw new ERR_PERFORMANCE_INVALID_TIMESTAMP(name);\n    return name;\n  }\n  name = `${name}`;\n  if (nodeTimingReadOnlyAttributes.has(name))\n    return nodeTiming[name];\n  const ts = markTimings.get(name);\n  if (ts === void 0)\n    throw lazyDOMException(`The \"${name}\" performance mark has not been set`, \"SyntaxError\");\n  return ts;\n}\nclass PerformanceMark extends InternalPerformanceEntry {\n  constructor(name, options) {\n    name = `${name}`;\n    if (nodeTimingReadOnlyAttributes.has(name))\n      throw new ERR_INVALID_ARG_VALUE(\"name\", name);\n    options ??= {};\n    validateObject(options, \"options\");\n    const startTime = options.startTime ?? now();\n    validateNumber(startTime, \"startTime\");\n    if (startTime < 0)\n      throw new ERR_PERFORMANCE_INVALID_TIMESTAMP(startTime);\n    markTimings.set(name, startTime);\n    let detail = options.detail;\n    detail = detail != null ? structuredClone(detail) : null;\n    super(name, \"mark\", startTime, 0, detail);\n  }\n  get [SymbolToStringTag]() {\n    return \"PerformanceMark\";\n  }\n}\nclass PerformanceMeasure extends InternalPerformanceEntry {\n  constructor(name, start, duration, detail) {\n    super(name, \"measure\", start, duration, detail);\n  }\n  get [SymbolToStringTag]() {\n    return \"PerformanceMeasure\";\n  }\n}\nfunction mark(name, options = {}) {\n  const mark2 = new PerformanceMark(name, options);\n  enqueue(mark2);\n  return mark2;\n}\nfunction calculateStartDuration(startOrMeasureOptions, endMark) {\n  startOrMeasureOptions ??= 0;\n  let start;\n  let end;\n  let duration;\n  let optionsValid = false;\n  if (typeof startOrMeasureOptions === \"object\") {\n    ({ start, end, duration } = startOrMeasureOptions);\n    optionsValid = start !== void 0 || end !== void 0;\n  }\n  if (optionsValid) {\n    if (endMark !== void 0) {\n      throw new ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS(\"endMark must not be specified\");\n    }\n    if (start === void 0 && end === void 0) {\n      throw new ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS(\"One of options.start or options.end is required\");\n    }\n    if (start !== void 0 && end !== void 0 && duration !== void 0) {\n      throw new ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS(\"Must not have options.start, options.end, and options.duration specified\");\n    }\n  }\n  if (endMark !== void 0) {\n    end = getMark(endMark);\n  } else if (optionsValid && end !== void 0) {\n    end = getMark(end);\n  } else if (optionsValid && start !== void 0 && duration !== void 0) {\n    end = getMark(start) + getMark(duration);\n  } else {\n    end = now();\n  }\n  if (typeof startOrMeasureOptions === \"string\") {\n    start = getMark(startOrMeasureOptions);\n  } else if (optionsValid && start !== void 0) {\n    start = getMark(start);\n  } else if (optionsValid && duration !== void 0 && end !== void 0) {\n    start = end - getMark(duration);\n  } else {\n    start = 0;\n  }\n  duration = end - start;\n  return { start, duration };\n}\nfunction measure(name, startOrMeasureOptions, endMark) {\n  validateString(name, \"name\");\n  const {\n    start,\n    duration\n  } = calculateStartDuration(startOrMeasureOptions, endMark);\n  let detail = startOrMeasureOptions?.detail;\n  detail = detail != null ? structuredClone(detail) : null;\n  const measure2 = new PerformanceMeasure(name, start, duration, detail);\n  enqueue(measure2);\n  return measure2;\n}\nfunction clearMarkTimings(name) {\n  if (name !== void 0) {\n    name = `${name}`;\n    if (nodeTimingReadOnlyAttributes.has(name))\n      throw new ERR_INVALID_ARG_VALUE(\"name\", name);\n    markTimings.delete(name);\n    return;\n  }\n  markTimings.clear();\n}\nmodule.exports = {\n  PerformanceMark,\n  PerformanceMeasure,\n  clearMarkTimings,\n  mark,\n  measure\n};\n}"],["internal/perf/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst binding = internalBinding(\"performance\");\nconst {\n  milestones,\n  getTimeOrigin\n} = binding;\nlet timeOrigin = getTimeOrigin();\nfunction now() {\n  const hr = process.hrtime();\n  return hr[0] * 1e3 + hr[1] / 1e6 - timeOrigin;\n}\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\nmodule.exports = {\n  now,\n  getMilestoneTimestamp,\n  refreshTimeOrigin\n};\n}"],["internal/policy/manifest.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeSort,\n  ObjectCreate,\n  ObjectEntries,\n  ObjectFreeze,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  RegExpPrototypeExec,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeReplace,\n  Symbol,\n  uncurryThis\n} = primordials;\nconst {\n  ERR_MANIFEST_ASSERT_INTEGRITY,\n  ERR_MANIFEST_INVALID_RESOURCE_FIELD,\n  ERR_MANIFEST_INVALID_SPECIFIER,\n  ERR_MANIFEST_UNKNOWN_ONERROR\n} = require(\"internal/errors\").codes;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"policy\", (fn) => {\n  debug = fn;\n});\nconst SRI = require(\"internal/policy/sri\");\nconst crypto = require(\"crypto\");\nconst { Buffer } = require(\"buffer\");\nconst { URL } = require(\"internal/url\");\nconst { createHash, timingSafeEqual } = crypto;\nconst HashUpdate = uncurryThis(crypto.Hash.prototype.update);\nconst HashDigest = uncurryThis(crypto.Hash.prototype.digest);\nconst BufferToString = uncurryThis(Buffer.prototype.toString);\nconst kRelativeURLStringPattern = /^\\.{0,2}\\//;\nconst { getOptionValue } = require(\"internal/options\");\nconst shouldAbortOnUncaughtException = getOptionValue(\"--abort-on-uncaught-exception\");\nconst { abort, exit, _rawDebug } = process;\nconst kSpecialSchemes = new SafeSet([\n  \"file:\",\n  \"ftp:\",\n  \"http:\",\n  \"https:\",\n  \"ws:\",\n  \"wss:\"\n]);\nconst kCascade = Symbol(\"cascade\");\nconst kFallThrough = Symbol(\"fall through\");\nfunction REACTION_THROW(error) {\n  throw error;\n}\nfunction REACTION_EXIT(error) {\n  REACTION_LOG(error);\n  if (shouldAbortOnUncaughtException) {\n    abort();\n  }\n  exit(1);\n}\nfunction REACTION_LOG(error) {\n  _rawDebug(error.stack);\n}\nclass DependencyMapperInstance {\n  href;\n  #dependencies;\n  #patternDependencies;\n  #parentDependencyMapper;\n  #normalized = false;\n  cascade;\n  allowSameHREFScope;\n  constructor(parentHREF, dependencies, cascade = false, allowSameHREFScope = false) {\n    this.href = parentHREF;\n    if (dependencies === kFallThrough || dependencies === void 0 || dependencies === null) {\n      this.#dependencies = dependencies;\n      this.#patternDependencies = void 0;\n    } else {\n      const patterns = [];\n      for (const { 0: key } of ObjectEntries(dependencies)) {\n        if (StringPrototypeEndsWith(key, \"*\")) {\n          const target = RegExpPrototypeExec(/^([^*]*)\\*([^*]*)$/);\n          if (!target) {\n            throw new ERR_MANIFEST_INVALID_SPECIFIER(this.href, target + ', pattern needs to have a singletrailing \"*\" in target');\n          }\n          const prefix = target[1];\n          const suffix = target[2];\n          patterns.push([\n            target.slice(0, -1),\n            [prefix, suffix]\n          ]);\n        }\n      }\n      ArrayPrototypeSort(patterns, (a, b) => {\n        return a[0] < b[0] ? -1 : 1;\n      });\n      this.#dependencies = dependencies;\n      this.#patternDependencies = patterns;\n    }\n    this.cascade = cascade;\n    this.allowSameHREFScope = allowSameHREFScope;\n    ObjectFreeze(this);\n  }\n  _resolveAlreadyNormalized(normalizedSpecifier, conditions, manifest) {\n    let dependencies = this.#dependencies;\n    debug(this.href, \"resolving\", normalizedSpecifier);\n    if (dependencies === kFallThrough)\n      return true;\n    if (dependencies !== void 0 && typeof dependencies === \"object\") {\n      const normalized = this.#normalized;\n      if (normalized !== true) {\n        const normalizedDependencyMap = ObjectCreate(null);\n        for (let specifier in dependencies) {\n          const target = dependencies[specifier];\n          specifier = canonicalizeSpecifier(specifier, manifest.href);\n          normalizedDependencyMap[specifier] = target;\n        }\n        ObjectFreeze(normalizedDependencyMap);\n        dependencies = normalizedDependencyMap;\n        this.#dependencies = normalizedDependencyMap;\n        this.#normalized = true;\n      }\n      debug(dependencies);\n      if (normalizedSpecifier in dependencies === true) {\n        const to = searchDependencies(this.href, dependencies[normalizedSpecifier], conditions);\n        debug({ to });\n        if (to === true) {\n          return true;\n        }\n        let ret;\n        if (parsedURLs && parsedURLs.has(to)) {\n          ret = parsedURLs.get(to);\n        } else if (RegExpPrototypeTest(kRelativeURLStringPattern, to)) {\n          ret = resolve(to, manifest.href);\n        } else {\n          ret = resolve(to);\n        }\n        return ret;\n      }\n    }\n    const { cascade } = this;\n    if (cascade !== true) {\n      return null;\n    }\n    let parentDependencyMapper = this.#parentDependencyMapper;\n    if (parentDependencyMapper === void 0) {\n      parentDependencyMapper = manifest.getScopeDependencyMapper(this.href, this.allowSameHREFScope);\n      this.#parentDependencyMapper = parentDependencyMapper;\n    }\n    if (parentDependencyMapper === null) {\n      return null;\n    }\n    return parentDependencyMapper._resolveAlreadyNormalized(normalizedSpecifier, conditions, manifest);\n  }\n}\nconst kArbitraryDependencies = new DependencyMapperInstance(\"arbitrary dependencies\", kFallThrough, false, true);\nconst kNoDependencies = new DependencyMapperInstance(\"no dependencies\", null, false, true);\nconst insertDependencyMap = (href, dependencies, cascade, allowSameHREFScope, store) => {\n  if (cascade !== void 0 && typeof cascade !== \"boolean\") {\n    throw new ERR_MANIFEST_INVALID_RESOURCE_FIELD(href, \"cascade\");\n  }\n  if (dependencies === true) {\n    store.set(href, kArbitraryDependencies);\n    return;\n  }\n  if (dependencies === null || dependencies === void 0) {\n    store.set(href, cascade ? new DependencyMapperInstance(href, null, true, allowSameHREFScope) : kNoDependencies);\n    return;\n  }\n  if (objectButNotArray(dependencies)) {\n    store.set(href, new DependencyMapperInstance(href, dependencies, cascade, allowSameHREFScope));\n    return;\n  }\n  throw new ERR_MANIFEST_INVALID_RESOURCE_FIELD(href, \"dependencies\");\n};\nfunction findScopeHREF(href, scopeStore, allowSame) {\n  let protocol;\n  if (href !== \"\") {\n    if (RegExpPrototypeTest(/^[^:]*[:]$/, href)) {\n      protocol = href;\n    } else {\n      let currentURL = new URL(href);\n      const normalizedHREF = currentURL.href;\n      protocol = currentURL.protocol;\n      if (protocol === \"blob:\" && currentURL.origin !== \"null\") {\n        currentURL = new URL(currentURL.origin);\n        protocol = currentURL.protocol;\n      }\n      if (kSpecialSchemes.has(currentURL.protocol)) {\n        if (!StringPrototypeEndsWith(currentURL.pathname, \"/\")) {\n          currentURL.pathname += \"/\";\n        }\n        let lastHREF;\n        let currentHREF = currentURL.href;\n        do {\n          if (scopeStore.has(currentHREF)) {\n            if (allowSame || currentHREF !== normalizedHREF) {\n              return currentHREF;\n            }\n          }\n          lastHREF = currentHREF;\n          currentURL = new URL(\"..\", currentURL);\n          currentHREF = currentURL.href;\n        } while (lastHREF !== currentHREF);\n      }\n    }\n  }\n  if (scopeStore.has(protocol)) {\n    if (allowSame || protocol !== href)\n      return protocol;\n  }\n  if (scopeStore.has(\"\")) {\n    if (allowSame || href !== \"\")\n      return \"\";\n  }\n  return null;\n}\nclass Manifest {\n  #defaultDependencies;\n  href;\n  #reaction;\n  #resourceDependencies = new SafeMap();\n  #resourceIntegrities = new SafeMap();\n  #scopeDependencies = new SafeMap();\n  #scopeIntegrities = new SafeMap();\n  constructor(obj, manifestHREF) {\n    this.href = manifestHREF;\n    const scopes = this.#scopeDependencies;\n    const integrities = this.#resourceIntegrities;\n    const resourceDependencies = this.#resourceDependencies;\n    let reaction = REACTION_THROW;\n    if (objectButNotArray(obj) && \"onerror\" in obj) {\n      const behavior = obj.onerror;\n      if (behavior === \"throw\") {\n      } else if (behavior === \"exit\") {\n        reaction = REACTION_EXIT;\n      } else if (behavior === \"log\") {\n        reaction = REACTION_LOG;\n      } else {\n        throw new ERR_MANIFEST_UNKNOWN_ONERROR(behavior);\n      }\n    }\n    this.#reaction = reaction;\n    const jsonResourcesEntries = ObjectEntries(obj.resources ?? ObjectCreate(null));\n    const jsonScopesEntries = ObjectEntries(obj.scopes ?? ObjectCreate(null));\n    const defaultDependencies = obj.dependencies ?? ObjectCreate(null);\n    this.#defaultDependencies = new DependencyMapperInstance(\"default\", defaultDependencies === true ? kFallThrough : defaultDependencies, false);\n    for (let i = 0; i < jsonResourcesEntries.length; i++) {\n      const { 0: originalHREF, 1: descriptor } = jsonResourcesEntries[i];\n      const { cascade, dependencies, integrity } = descriptor;\n      const href = resolve(originalHREF, manifestHREF).href;\n      if (typeof integrity !== \"undefined\") {\n        debug(\"Manifest contains integrity for resource %s\", originalHREF);\n        if (typeof integrity === \"string\") {\n          integrities.set(href, integrity);\n        } else if (integrity === true) {\n          integrities.set(href, true);\n        } else {\n          throw new ERR_MANIFEST_INVALID_RESOURCE_FIELD(href, \"integrity\");\n        }\n      } else {\n        integrities.set(href, cascade === true ? kCascade : false);\n      }\n      insertDependencyMap(href, dependencies, cascade, true, resourceDependencies);\n    }\n    const scopeIntegrities = this.#scopeIntegrities;\n    for (let i = 0; i < jsonScopesEntries.length; i++) {\n      const { 0: originalHREF, 1: descriptor } = jsonScopesEntries[i];\n      const { cascade, dependencies, integrity } = descriptor;\n      const href = emptyOrProtocolOrResolve(originalHREF, manifestHREF);\n      if (typeof integrity !== \"undefined\") {\n        debug(\"Manifest contains integrity for scope %s\", originalHREF);\n        if (integrity === true) {\n          scopeIntegrities.set(href, true);\n        } else {\n          throw new ERR_MANIFEST_INVALID_RESOURCE_FIELD(href, \"integrity\");\n        }\n      } else {\n        scopeIntegrities.set(href, cascade === true ? kCascade : false);\n      }\n      insertDependencyMap(href, dependencies, cascade, false, scopes);\n    }\n    ObjectFreeze(this);\n  }\n  getDependencyMapper(requester) {\n    const requesterHREF = `${requester}`;\n    const dependencies = this.#resourceDependencies;\n    const instance = (dependencies.has(requesterHREF) ? dependencies.get(requesterHREF) ?? null : this.getScopeDependencyMapper(requesterHREF, true)) ?? this.#defaultDependencies;\n    return {\n      resolve: (specifier, conditions) => {\n        const normalizedSpecifier = canonicalizeSpecifier(specifier, requesterHREF);\n        const result = instance._resolveAlreadyNormalized(normalizedSpecifier, conditions, this);\n        if (result === kFallThrough)\n          return true;\n        return result;\n      },\n      reaction: this.#reaction\n    };\n  }\n  assertIntegrity(url, content) {\n    const href = `${url}`;\n    debug(\"Checking integrity of %s\", href);\n    const realIntegrities = new SafeMap();\n    const integrities = this.#resourceIntegrities;\n    function processEntry(href2) {\n      let integrityEntries = integrities.get(href2);\n      if (integrityEntries === true)\n        return true;\n      if (typeof integrityEntries === \"string\") {\n        const sri = ObjectFreeze(SRI.parse(integrityEntries));\n        integrities.set(href2, sri);\n        integrityEntries = sri;\n      }\n      return integrityEntries;\n    }\n    if (integrities.has(href)) {\n      const integrityEntries = processEntry(href);\n      if (integrityEntries === true)\n        return true;\n      if (ArrayIsArray(integrityEntries)) {\n        for (let i = 0; i < integrityEntries.length; i++) {\n          const { algorithm, value: expected } = integrityEntries[i];\n          const hash = createHash(algorithm);\n          HashUpdate(hash, content, \"utf8\");\n          const digest = HashDigest(hash, \"buffer\");\n          if (digest.length === expected.length && timingSafeEqual(digest, expected)) {\n            return true;\n          }\n          realIntegrities.set(algorithm, BufferToString(digest, \"base64\"));\n        }\n      }\n      if (integrityEntries !== kCascade) {\n        const error2 = new ERR_MANIFEST_ASSERT_INTEGRITY(url, realIntegrities);\n        this.#reaction(error2);\n      }\n    }\n    let scope = findScopeHREF(href, this.#scopeIntegrities, true);\n    while (scope !== null) {\n      if (this.#scopeIntegrities.has(scope)) {\n        const entry = this.#scopeIntegrities.get(scope);\n        if (entry === true) {\n          return true;\n        } else if (entry === kCascade) {\n        } else {\n          break;\n        }\n      }\n      const nextScope = findScopeHREF(scope, this.#scopeDependencies, false);\n      if (!nextScope) {\n        break;\n      }\n      scope = nextScope;\n    }\n    const error = new ERR_MANIFEST_ASSERT_INTEGRITY(url, realIntegrities);\n    this.#reaction(error);\n  }\n  getScopeDependencyMapper(href, allowSameHREFScope) {\n    if (href === null) {\n      return this.#defaultDependencies;\n    }\n    const scopeHREF = findScopeHREF(href, this.#scopeDependencies, allowSameHREFScope);\n    if (scopeHREF === null)\n      return this.#defaultDependencies;\n    return this.#scopeDependencies.get(scopeHREF);\n  }\n}\nObjectSetPrototypeOf(Manifest, null);\nObjectSetPrototypeOf(Manifest.prototype, null);\nObjectFreeze(Manifest);\nObjectFreeze(Manifest.prototype);\nmodule.exports = ObjectFreeze({ Manifest });\nfunction canonicalizeSpecifier(specifier, base) {\n  try {\n    if (RegExpPrototypeTest(kRelativeURLStringPattern, specifier)) {\n      return resolve(specifier, base).href;\n    }\n    return resolve(specifier).href;\n  } catch {\n  }\n  return specifier;\n}\nconst emptyOrProtocolOrResolve = (resourceHREF, base) => {\n  if (resourceHREF === \"\")\n    return \"\";\n  if (StringPrototypeEndsWith(resourceHREF, \":\")) {\n    resourceHREF = StringPrototypeReplace(resourceHREF, /^[\\x00-\\x1F\\x20]|\\x09\\x0A\\x0D|[\\x00-\\x1F\\x20]$/g, \"\");\n    if (RegExpPrototypeTest(/^[a-zA-Z][a-zA-Z+\\-.]*:$/, resourceHREF)) {\n      return resourceHREF;\n    }\n  }\n  return resolve(resourceHREF, base).href;\n};\nlet parsedURLs;\nconst resolve = (originalHREF, base) => {\n  parsedURLs = parsedURLs ?? new SafeMap();\n  if (parsedURLs.has(originalHREF)) {\n    return parsedURLs.get(originalHREF);\n  } else if (RegExpPrototypeTest(kRelativeURLStringPattern, originalHREF)) {\n    const resourceURL2 = new URL(originalHREF, base);\n    parsedURLs.set(resourceURL2.href, resourceURL2);\n    return resourceURL2;\n  }\n  const resourceURL = new URL(originalHREF);\n  parsedURLs.set(originalHREF, resourceURL);\n  return resourceURL;\n};\nfunction objectButNotArray(o) {\n  return o && typeof o === \"object\" && !ArrayIsArray(o);\n}\nfunction searchDependencies(href, target, conditions) {\n  if (objectButNotArray(target)) {\n    const keys = ObjectKeys(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (conditions.has(key)) {\n        const ret = searchDependencies(href, target[key], conditions);\n        if (ret != null) {\n          return ret;\n        }\n      }\n    }\n  } else if (typeof target === \"string\") {\n    return target;\n  } else if (target === true) {\n    return target;\n  } else {\n    throw new ERR_MANIFEST_INVALID_RESOURCE_FIELD(href, \"dependencies\");\n  }\n  return null;\n}\n}"],["internal/policy/sri.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototype,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectSeal,\n  ObjectSetPrototypeOf,\n  RegExp,\n  RegExpPrototypeExec,\n  RegExpPrototypeTest,\n  StringPrototypeSlice\n} = primordials;\nconst {\n  ERR_SRI_PARSE\n} = require(\"internal/errors\").codes;\nconst kWSP = \"[\\\\x20\\\\x09]\";\nconst kVCHAR = \"[\\\\x21-\\\\x7E]\";\nconst kHASH_ALGO = \"sha(?:256|384|512)\";\nconst kHASH_VALUE = \"[A-Za-z0-9+/]+[=]{0,2}\";\nconst kHASH_EXPRESSION = `(${kHASH_ALGO})-(${kHASH_VALUE})`;\nconst kOPTION_EXPRESSION = `(?:${kVCHAR}*)`;\nconst kHASH_WITH_OPTIONS = `${kHASH_EXPRESSION}(?:[?](${kOPTION_EXPRESSION}))?`;\nconst kSRIPattern = RegExp(`(${kWSP}*)(?:${kHASH_WITH_OPTIONS})`, \"g\");\nObjectSeal(kSRIPattern);\nconst kAllWSP = RegExp(`^${kWSP}*$`);\nObjectSeal(kAllWSP);\nconst BufferFrom = require(\"buffer\").Buffer.from;\nconst parse = (str) => {\n  let prevIndex = 0;\n  let match;\n  const entries = [];\n  while (match = RegExpPrototypeExec(kSRIPattern, str)) {\n    if (match.index !== prevIndex) {\n      throw new ERR_SRI_PARSE(str, str[prevIndex], prevIndex);\n    }\n    if (entries.length > 0 && match[1] === \"\") {\n      throw new ERR_SRI_PARSE(str, str[prevIndex], prevIndex);\n    }\n    ObjectDefineProperty(entries, entries.length, {\n      enumerable: true,\n      configurable: true,\n      value: ObjectFreeze({\n        __proto__: null,\n        algorithm: match[2],\n        value: BufferFrom(match[3], \"base64\"),\n        options: match[4] === void 0 ? null : match[4]\n      })\n    });\n    prevIndex += match[0].length;\n  }\n  if (prevIndex !== str.length) {\n    if (!RegExpPrototypeTest(kAllWSP, StringPrototypeSlice(str, prevIndex))) {\n      throw new ERR_SRI_PARSE(str, str[prevIndex], prevIndex);\n    }\n  }\n  return ObjectSetPrototypeOf(entries, ArrayPrototype);\n};\nmodule.exports = {\n  parse\n};\n}"],["internal/process/esm_loader.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\n} = require(\"internal/errors\").codes;\nconst { ESMLoader } = require(\"internal/modules/esm/loader\");\nconst {\n  hasUncaughtExceptionCaptureCallback\n} = require(\"internal/process/execution\");\nconst { pathToFileURL } = require(\"internal/url\");\nconst {\n  getModuleFromWrap\n} = require(\"internal/vm/module\");\nexports.initializeImportMetaObject = function(wrap, meta) {\n  const { callbackMap } = internalBinding(\"module_wrap\");\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== void 0) {\n      initializeImportMeta(meta, getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\nexports.importModuleDynamicallyCallback = async function(wrap, specifier) {\n  const { callbackMap } = internalBinding(\"module_wrap\");\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== void 0) {\n      return importModuleDynamically(specifier, getModuleFromWrap(wrap) || wrap);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\nconst esmLoader = new ESMLoader();\nexports.esmLoader = esmLoader;\nasync function initializeLoader() {\n  const { getOptionValue } = require(\"internal/options\");\n  const customLoaders = getOptionValue(\"--experimental-loader\");\n  if (!customLoaders.length)\n    return;\n  const { emitExperimentalWarning } = require(\"internal/util\");\n  emitExperimentalWarning(\"--experimental-loader\");\n  let cwd;\n  try {\n    cwd = process.cwd() + \"/\";\n  } catch {\n    cwd = \"file:///\";\n  }\n  const internalEsmLoader = new ESMLoader();\n  const exports2 = await internalEsmLoader.import(customLoaders, pathToFileURL(cwd).href);\n  await esmLoader.addCustomLoaders(exports2);\n}\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding(\"errors\").triggerUncaughtException(err, true);\n  }\n};\n}"],["internal/process/execution.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  globalThis\n} = primordials;\nconst path = require(\"path\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET,\n    ERR_EVAL_ESM_CANNOT_PRINT\n  }\n} = require(\"internal/errors\");\nconst {\n  executionAsyncId,\n  clearDefaultTriggerAsyncId,\n  clearAsyncIdStack,\n  hasAsyncIdStack,\n  afterHooksExist,\n  emitAfter\n} = require(\"internal/async_hooks\");\nconst { shouldAbortOnUncaughtToggle } = internalBinding(\"util\");\nfunction tryGetCwd() {\n  try {\n    return process.cwd();\n  } catch {\n    return path.dirname(process.execPath);\n  }\n}\nfunction evalModule(source, print) {\n  if (print) {\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\n  }\n  const { log } = require(\"internal/console/global\");\n  const { loadESM } = require(\"internal/process/esm_loader\");\n  const { handleMainPromise } = require(\"internal/modules/run_main\");\n  return handleMainPromise(loadESM(async (loader) => {\n    const { result } = await loader.eval(source);\n    if (print) {\n      log(result);\n    }\n  }));\n}\nfunction evalScript(name, body, breakFirstLine, print) {\n  const CJSModule = require(\"internal/modules/cjs/loader\").Module;\n  const { kVmBreakFirstLineSymbol } = require(\"internal/util\");\n  const { pathToFileURL } = require(\"url\");\n  const cwd = tryGetCwd();\n  const origModule = globalThis.module;\n  const module2 = new CJSModule(name);\n  module2.filename = path.join(cwd, name);\n  module2.paths = CJSModule._nodeModulePaths(cwd);\n  const asyncESM = require(\"internal/process/esm_loader\");\n  const baseUrl = pathToFileURL(module2.filename).href;\n  const script = `\n    globalThis.module = module;\n    globalThis.exports = exports;\n    globalThis.__dirname = __dirname;\n    globalThis.require = require;\n    return (main) => main();\n  `;\n  globalThis.__filename = name;\n  const result = module2._compile(script, `${name}-wrapper`)(() => require(\"vm\").runInThisContext(body, {\n    filename: name,\n    displayErrors: true,\n    [kVmBreakFirstLineSymbol]: !!breakFirstLine,\n    async importModuleDynamically(specifier) {\n      const loader = await asyncESM.esmLoader;\n      return loader.import(specifier, baseUrl);\n    }\n  }));\n  if (print) {\n    const { log } = require(\"internal/console/global\");\n    log(result);\n  }\n  if (origModule !== void 0)\n    globalThis.module = origModule;\n}\nconst exceptionHandlerState = {\n  captureFn: null,\n  reportFlag: false\n};\nfunction setUncaughtExceptionCaptureCallback(fn) {\n  if (fn === null) {\n    exceptionHandlerState.captureFn = fn;\n    shouldAbortOnUncaughtToggle[0] = 1;\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\n    return;\n  }\n  if (typeof fn !== \"function\") {\n    throw new ERR_INVALID_ARG_TYPE(\"fn\", [\"Function\", \"null\"], fn);\n  }\n  if (exceptionHandlerState.captureFn !== null) {\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\n  }\n  exceptionHandlerState.captureFn = fn;\n  shouldAbortOnUncaughtToggle[0] = 0;\n  exceptionHandlerState.reportFlag = process.report.reportOnUncaughtException === true;\n  process.report.reportOnUncaughtException = false;\n}\nfunction hasUncaughtExceptionCaptureCallback() {\n  return exceptionHandlerState.captureFn !== null;\n}\nfunction noop() {\n}\nfunction createOnGlobalUncaughtException() {\n  return (er, fromPromise) => {\n    clearDefaultTriggerAsyncId();\n    if (er == null || er.domain == null) {\n      try {\n        const report = internalBinding(\"report\");\n        if (report != null && report.shouldReportOnUncaughtException()) {\n          report.writeReport(typeof er?.message === \"string\" ? er.message : \"Exception\", \"Exception\", null, er ? er : {});\n        }\n      } catch {\n      }\n    }\n    const type = fromPromise ? \"unhandledRejection\" : \"uncaughtException\";\n    process.emit(\"uncaughtExceptionMonitor\", er, type);\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit(\"uncaughtException\", er, type)) {\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit(\"exit\", 1);\n        }\n      } catch {\n      }\n      return false;\n    }\n    require(\"timers\").setImmediate(noop);\n    if (afterHooksExist()) {\n      do {\n        emitAfter(executionAsyncId());\n      } while (hasAsyncIdStack());\n    }\n    clearAsyncIdStack();\n    return true;\n  };\n}\nfunction readStdin(callback) {\n  process.stdin.setEncoding(\"utf8\");\n  let code = \"\";\n  process.stdin.on(\"data\", (d) => {\n    code += d;\n  });\n  process.stdin.on(\"end\", () => {\n    callback(code);\n  });\n}\nmodule.exports = {\n  readStdin,\n  tryGetCwd,\n  evalModule,\n  evalScript,\n  onGlobalUncaughtException: createOnGlobalUncaughtException(),\n  setUncaughtExceptionCaptureCallback,\n  hasUncaughtExceptionCaptureCallback\n};\n}"],["internal/process/per_thread.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeEvery,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypeSplice,\n  BigUint64Array,\n  Float64Array,\n  NumberMAX_SAFE_INTEGER,\n  ObjectFreeze,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  Set,\n  SetPrototypeEntries,\n  SetPrototypeValues,\n  StringPrototypeEndsWith,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n  Symbol,\n  SymbolIterator,\n  Uint32Array\n} = primordials;\nconst {\n  errnoException,\n  codes: {\n    ERR_ASSERTION,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require(\"internal/errors\");\nconst format = require(\"internal/util/inspect\").format;\nconst {\n  validateArray,\n  validateNumber,\n  validateObject\n} = require(\"internal/validators\");\nconst constants = internalBinding(\"constants\").os.signals;\nconst kInternal = Symbol(\"internal properties\");\nfunction assert(x, msg) {\n  if (!x)\n    throw new ERR_ASSERTION(msg || \"assertion error\");\n}\nfunction getFastAPIs(binding) {\n  const {\n    hrtime: _hrtime\n  } = binding.getFastAPIs();\n  const hrValues = new Uint32Array(_hrtime.buffer);\n  function hrtime(time) {\n    _hrtime.hrtime();\n    if (time !== void 0) {\n      validateArray(time, \"time\");\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE(\"time\", 2, time.length);\n      }\n      const sec = hrValues[0] * 4294967296 + hrValues[1] - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];\n    }\n    return [\n      hrValues[0] * 4294967296 + hrValues[1],\n      hrValues[2]\n    ];\n  }\n  const hrBigintValues = new BigUint64Array(_hrtime.buffer, 0, 1);\n  function hrtimeBigInt() {\n    _hrtime.hrtimeBigInt();\n    return hrBigintValues[0];\n  }\n  return {\n    hrtime,\n    hrtimeBigInt\n  };\n}\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage,\n    memoryUsage: _memoryUsage,\n    rss,\n    resourceUsage: _resourceUsage\n  } = binding;\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format, null, args));\n  }\n  const cpuValues = new Float64Array(2);\n  function cpuUsage(prevValue) {\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue, \"prevValue\");\n        validateNumber(prevValue.user, \"prevValue.user\");\n        throw new ERR_INVALID_ARG_VALUE.RangeError(\"prevValue.user\", prevValue.user);\n      }\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system, \"prevValue.system\");\n        throw new ERR_INVALID_ARG_VALUE.RangeError(\"prevValue.system\", prevValue.system);\n      }\n    }\n    _cpuUsage(cpuValues);\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user,\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n    return {\n      user: cpuValues[0],\n      system: cpuValues[1]\n    };\n  }\n  function previousValueIsValid(num) {\n    return typeof num === \"number\" && num <= NumberMAX_SAFE_INTEGER && num >= 0;\n  }\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0],\n      heapTotal: memValues[1],\n      heapUsed: memValues[2],\n      external: memValues[3],\n      arrayBuffers: memValues[4]\n    };\n  }\n  memoryUsage.rss = rss;\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit(\"exit\", process.exitCode || 0);\n    }\n    process.reallyExit(process.exitCode || 0);\n  }\n  function kill(pid, sig) {\n    let err;\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE(\"pid\", \"number\", pid);\n    }\n    if (sig === (sig | 0)) {\n      err = process._kill(pid, sig);\n    } else {\n      sig = sig || \"SIGTERM\";\n      if (constants[sig]) {\n        err = process._kill(pid, constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n    if (err)\n      throw errnoException(err, \"kill\");\n    return true;\n  }\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0],\n      systemCPUTime: resourceValues[1],\n      maxRSS: resourceValues[2],\n      sharedMemorySize: resourceValues[3],\n      unsharedDataSize: resourceValues[4],\n      unsharedStackSize: resourceValues[5],\n      minorPageFault: resourceValues[6],\n      majorPageFault: resourceValues[7],\n      swappedOut: resourceValues[8],\n      fsRead: resourceValues[9],\n      fsWrite: resourceValues[10],\n      ipcSent: resourceValues[11],\n      ipcReceived: resourceValues[12],\n      signalsCount: resourceValues[13],\n      voluntaryContextSwitches: resourceValues[14],\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n  return {\n    _rawDebug,\n    cpuUsage,\n    resourceUsage,\n    memoryUsage,\n    kill,\n    exit\n  };\n}\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment },\n    types: { kBoolean }\n  } = internalBinding(\"options\");\n  const { options, aliases } = require(\"internal/options\");\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name, 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags, name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags, negatedName);\n      }\n    }\n  }\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to, \"-\") || to === \"--\")\n      return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion, 0, 1);\n      return ArrayPrototypeEvery(recursiveExpansion, isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from, 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion, isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical, \"=\"))\n        canonical = StringPrototypeSlice(canonical, 0, canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical, \" <arg>\"))\n        canonical = StringPrototypeSlice(canonical, 0, canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags, canonical);\n    }\n  }\n  const trimLeadingDashes = (flag) => StringPrototypeReplace(flag, leadingDashesRegex, \"\");\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags, trimLeadingDashes);\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n    add() {\n      return this;\n    }\n    delete() {\n      return false;\n    }\n    clear() {\n    }\n    has(key) {\n      if (typeof key === \"string\") {\n        key = StringPrototypeReplace(key, replaceUnderscoresRegex, \"-\");\n        if (RegExpPrototypeTest(leadingDashesRegex, key)) {\n          key = StringPrototypeReplace(key, trailingValuesRegex, \"\");\n          return ArrayPrototypeIncludes(this[kInternal].array, key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags, key);\n      }\n      return false;\n    }\n    entries() {\n      this[kInternal].set ??= new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n    forEach(callback, thisArg = void 0) {\n      ArrayPrototypeForEach(this[kInternal].array, (v) => ReflectApply(callback, thisArg, [v, v, this]));\n    }\n    get size() {\n      return this[kInternal].array.length;\n    }\n    values() {\n      this[kInternal].set ??= new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[SymbolIterator] = NodeEnvironmentFlagsSet.prototype.values;\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));\n}\nlet traceEventsAsyncHook;\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook = require(\"internal/trace_events_async_hooks\").createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\nmodule.exports = {\n  toggleTraceCategoryState,\n  getFastAPIs,\n  assert,\n  buildAllowedFlags,\n  wrapProcessMethods\n};\n}"],["internal/process/policy.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  JSONParse,\n  ObjectFreeze,\n  ReflectSetPrototypeOf\n} = primordials;\nconst {\n  ERR_MANIFEST_TDZ\n} = require(\"internal/errors\").codes;\nconst { Manifest } = require(\"internal/policy/manifest\");\nlet manifest;\nlet manifestSrc;\nlet manifestURL;\nmodule.exports = ObjectFreeze({\n  __proto__: null,\n  setup(src, url) {\n    manifestSrc = src;\n    manifestURL = url;\n    if (src === null) {\n      manifest = null;\n      return;\n    }\n    const json = JSONParse(src, (_, o) => {\n      if (o && typeof o === \"object\") {\n        ReflectSetPrototypeOf(o, null);\n        ObjectFreeze(o);\n      }\n      return o;\n    });\n    manifest = new Manifest(json, url);\n  },\n  get manifest() {\n    if (typeof manifest === \"undefined\") {\n      throw new ERR_MANIFEST_TDZ();\n    }\n    return manifest;\n  },\n  get src() {\n    if (typeof manifestSrc === \"undefined\") {\n      throw new ERR_MANIFEST_TDZ();\n    }\n    return manifestSrc;\n  },\n  get url() {\n    if (typeof manifestURL === \"undefined\") {\n      throw new ERR_MANIFEST_TDZ();\n    }\n    return manifestURL;\n  },\n  assertIntegrity(moduleURL, content) {\n    this.manifest.assertIntegrity(moduleURL, content);\n  }\n});\n}"],["internal/process/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  Error,\n  ObjectDefineProperty,\n  SafeWeakMap\n} = primordials;\nconst {\n  tickInfo,\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler,\n    kPromiseHandlerAddedAfterReject,\n    kPromiseResolveAfterResolved,\n    kPromiseRejectAfterResolved\n  },\n  setPromiseRejectCallback\n} = internalBinding(\"task_queue\");\nconst {\n  noSideEffectsToString,\n  triggerUncaughtException\n} = internalBinding(\"errors\");\nconst {\n  pushAsyncContext,\n  popAsyncContext\n} = require(\"internal/async_hooks\");\nconst async_hooks = require(\"async_hooks\");\nconst { isErrorStackTraceLimitWritable } = require(\"internal/errors\");\nconst kHasRejectionToWarn = 1;\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\nconst kIgnoreUnhandledRejections = 0;\nconst kAlwaysWarnUnhandledRejections = 1;\nconst kStrictUnhandledRejections = 2;\nconst kThrowUnhandledRejections = 3;\nconst kWarnWithErrorCodeUnhandledRejections = 4;\nlet unhandledRejectionsMode;\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require(\"internal/options\");\n  switch (getOptionValue(\"--unhandled-rejections\")) {\n    case \"none\":\n      return kIgnoreUnhandledRejections;\n    case \"warn\":\n      return kAlwaysWarnUnhandledRejections;\n    case \"strict\":\n      return kStrictUnhandledRejections;\n    case \"throw\":\n      return kThrowUnhandledRejections;\n    case \"warn-with-error-code\":\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\nfunction promiseRejectHandler(type, promise, reason) {\n  if (unhandledRejectionsMode === void 0) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise, reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError(\"resolve\", promise, reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError(\"reject\", promise, reason);\n      break;\n  }\n}\nfunction resolveError(type, promise, reason) {\n  process.nextTick(() => {\n    process.emit(\"multipleResolves\", type, promise, reason);\n  });\n}\nfunction unhandledRejection(promise, reason) {\n  const asyncId = async_hooks.executionAsyncId();\n  const triggerAsyncId = async_hooks.triggerAsyncId();\n  const resource = promise;\n  const emit = (reason2, promise2, promiseInfo) => {\n    try {\n      pushAsyncContext(asyncId, triggerAsyncId, resource);\n      if (promiseInfo.domain) {\n        return promiseInfo.domain.emit(\"error\", reason2);\n      }\n      return process.emit(\"unhandledRejection\", reason2, promise2);\n    } finally {\n      popAsyncContext(asyncId);\n    }\n  };\n  maybeUnhandledPromises.set(promise, {\n    reason,\n    uid: ++lastPromiseId,\n    warned: false,\n    domain: process.domain,\n    emit\n  });\n  ArrayPrototypePush(pendingUnhandledRejections, promise);\n  setHasRejectionToWarn(true);\n}\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== void 0) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      const warning = new Error(`Promise rejection was handled asynchronously (rejection id: ${uid})`);\n      warning.name = \"PromiseRejectionHandledWarning\";\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections, { promise, warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\nconst unhandledRejectionErrName = \"UnhandledPromiseRejectionWarning\";\nfunction emitUnhandledRejectionWarning(uid, reason) {\n  const warning = getErrorWithoutStack(unhandledRejectionErrName, `Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag \\`--unhandled-rejections=strict\\` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: ${uid})`);\n  try {\n    if (reason instanceof Error) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack, unhandledRejectionErrName);\n    } else {\n      process.emitWarning(noSideEffectsToString(reason), unhandledRejectionErrName);\n    }\n  } catch {\n  }\n  process.emitWarning(warning);\n}\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n  while (asyncHandledRejections.length > 0) {\n    const { promise, warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit(\"rejectionHandled\", promise)) {\n      process.emitWarning(warning);\n    }\n  }\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === void 0) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason, uid, emit } = promiseInfo;\n    switch (unhandledRejectionsMode) {\n      case kStrictUnhandledRejections: {\n        const err = reason instanceof Error ? reason : generateUnhandledRejectionError(reason);\n        triggerUncaughtException(err, true);\n        const handled = emit(reason, promise, promiseInfo);\n        if (!handled)\n          emitUnhandledRejectionWarning(uid, reason);\n        break;\n      }\n      case kIgnoreUnhandledRejections: {\n        emit(reason, promise, promiseInfo);\n        break;\n      }\n      case kAlwaysWarnUnhandledRejections: {\n        emit(reason, promise, promiseInfo);\n        emitUnhandledRejectionWarning(uid, reason);\n        break;\n      }\n      case kThrowUnhandledRejections: {\n        const handled = emit(reason, promise, promiseInfo);\n        if (!handled) {\n          const err = reason instanceof Error ? reason : generateUnhandledRejectionError(reason);\n          triggerUncaughtException(err, true);\n        }\n        break;\n      }\n      case kWarnWithErrorCodeUnhandledRejections: {\n        const handled = emit(reason, promise, promiseInfo);\n        if (!handled) {\n          emitUnhandledRejectionWarning(uid, reason);\n          process.exitCode = 1;\n        }\n        break;\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks || pendingUnhandledRejections.length !== 0;\n}\nfunction getErrorWithoutStack(name, message) {\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err, \"name\", {\n    value: name,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n  return err;\n}\nfunction generateUnhandledRejectionError(reason) {\n  const message = `This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"${noSideEffectsToString(reason)}\".`;\n  const err = getErrorWithoutStack(\"UnhandledPromiseRejection\", message);\n  err.code = \"ERR_UNHANDLED_REJECTION\";\n  return err;\n}\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn,\n  setHasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections\n};\n}"],["internal/process/report.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_SYNTHETIC\n} = require(\"internal/errors\").codes;\nconst {\n  validateBoolean,\n  validateObject,\n  validateSignalName,\n  validateString\n} = require(\"internal/validators\");\nconst nr = internalBinding(\"report\");\nconst {\n  JSONParse\n} = primordials;\nconst report = {\n  writeReport(file, err) {\n    if (typeof file === \"object\" && file !== null) {\n      err = file;\n      file = void 0;\n    } else if (file !== void 0 && typeof file !== \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(\"file\", \"String\", file);\n    } else if (err === void 0) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err, \"err\");\n    }\n    return nr.writeReport(\"JavaScript API\", \"API\", file, err);\n  },\n  getReport(err) {\n    if (err === void 0)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err, \"err\");\n    return JSONParse(nr.getReport(err));\n  },\n  get directory() {\n    return nr.getDirectory();\n  },\n  set directory(dir) {\n    validateString(dir, \"directory\");\n    nr.setDirectory(dir);\n  },\n  get filename() {\n    return nr.getFilename();\n  },\n  set filename(name) {\n    validateString(name, \"filename\");\n    nr.setFilename(name);\n  },\n  get compact() {\n    return nr.getCompact();\n  },\n  set compact(b) {\n    validateBoolean(b, \"compact\");\n    nr.setCompact(b);\n  },\n  get signal() {\n    return nr.getSignal();\n  },\n  set signal(sig) {\n    validateSignalName(sig, \"signal\");\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  },\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  },\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger, \"trigger\");\n    nr.setReportOnFatalError(trigger);\n  },\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  },\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger, \"trigger\");\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  },\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  },\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger, \"trigger\");\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== \"string\")\n      sig = nr.getSignal();\n    process.on(sig, signalHandler);\n  }\n}\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n  if (sig)\n    process.removeListener(sig, signalHandler);\n}\nfunction signalHandler(sig) {\n  nr.writeReport(sig, \"Signal\", null, \"\");\n}\nmodule.exports = {\n  addSignalHandler,\n  report\n};\n}"],["internal/process/signal.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  SafeMap\n} = primordials;\nconst {\n  errnoException\n} = require(\"internal/errors\");\nconst { signals } = internalBinding(\"constants\").os;\nlet Signal;\nconst signalWraps = new SafeMap();\nfunction isSignal(event) {\n  return typeof event === \"string\" && signals[event] !== void 0;\n}\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === void 0)\n      Signal = internalBinding(\"signal_wrap\").Signal;\n    const wrap = new Signal();\n    wrap.unref();\n    wrap.onsignal = FunctionPrototypeBind(process.emit, process, type, type);\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err, \"uv_signal_start\");\n    }\n    signalWraps.set(type, wrap);\n  }\n}\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== void 0 && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\nmodule.exports = {\n  startListeningIfSignal,\n  stopListeningIfSignal\n};\n}"],["internal/process/task_queues.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  FunctionPrototypeBind\n} = primordials;\nconst {\n  tickInfo,\n  runMicrotasks,\n  setTickCallback,\n  enqueueMicrotask\n} = internalBinding(\"task_queue\");\nconst {\n  setHasRejectionToWarn,\n  hasRejectionToWarn,\n  listenForRejections,\n  processPromiseRejections\n} = require(\"internal/process/promises\");\nconst {\n  getDefaultTriggerAsyncId,\n  newAsyncId,\n  initHooksExist,\n  destroyHooksExist,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n  symbols: { async_id_symbol, trigger_async_id_symbol }\n} = require(\"internal/async_hooks\");\nconst FixedQueue = require(\"internal/fixed_queue\");\nconst {\n  validateCallback,\n  validateFunction\n} = require(\"internal/validators\");\nconst { AsyncResource } = require(\"async_hooks\");\nconst kHasTickScheduled = 0;\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\nconst queue = new FixedQueue();\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n  processTicksAndRejections();\n}\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while (tock = queue.shift()) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId, tock[trigger_async_id_symbol], tock);\n      try {\n        const callback = tock.callback;\n        if (tock.args === void 0) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1:\n              callback(args[0]);\n              break;\n            case 2:\n              callback(args[0], args[1]);\n              break;\n            case 3:\n              callback(args[0], args[1], args[2]);\n              break;\n            case 4:\n              callback(args[0], args[1], args[2], args[3]);\n              break;\n            default:\n              callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\nfunction nextTick(callback) {\n  validateCallback(callback);\n  if (process._exiting)\n    return;\n  let args;\n  switch (arguments.length) {\n    case 1:\n      break;\n    case 2:\n      args = [arguments[1]];\n      break;\n    case 3:\n      args = [arguments[1], arguments[2]];\n      break;\n    case 4:\n      args = [arguments[1], arguments[2], arguments[3]];\n      break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId,\n    [trigger_async_id_symbol]: triggerAsyncId,\n    callback,\n    args\n  };\n  if (initHooksExist())\n    emitInit(asyncId, \"TickObject\", triggerAsyncId, tickObject);\n  queue.push(tickObject);\n}\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\nfunction queueMicrotask(callback) {\n  validateFunction(callback, \"callback\");\n  const asyncResource = new AsyncResource(\"Microtask\", defaultMicrotaskResourceOpts);\n  asyncResource.callback = callback;\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask, asyncResource));\n}\nmodule.exports = {\n  setupTaskQueue() {\n    listenForRejections();\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick,\n      runNextTicks\n    };\n  },\n  queueMicrotask\n};\n}"],["internal/process/warning.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  Error,\n  ErrorPrototypeToString,\n  ErrorCaptureStackTrace,\n  String\n} = primordials;\nconst assert = require(\"internal/assert\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  },\n  isErrorStackTraceLimitWritable\n} = require(\"internal/errors\");\nconst { validateString } = require(\"internal/validators\");\nlet fs;\nlet fd;\nlet warningFile;\nlet options;\nfunction lazyOption() {\n  if (warningFile === void 0) {\n    options = require(\"internal/options\");\n    if (options.getOptionValue(\"--diagnostic-dir\") !== \"\") {\n      warningFile = options.getOptionValue(\"--diagnostic-dir\");\n    }\n    if (options.getOptionValue(\"--redirect-warnings\") !== \"\") {\n      warningFile = options.getOptionValue(\"--redirect-warnings\");\n    } else {\n      warningFile = \"\";\n    }\n  }\n  return warningFile;\n}\nlet error;\nfunction writeOut(message) {\n  if (!error) {\n    error = require(\"internal/console/global\").error;\n  }\n  error(message);\n}\nfunction writeToFile(message) {\n  if (fd === void 0) {\n    fs = require(\"fs\");\n    try {\n      fd = fs.openSync(warningFile, \"a\");\n    } catch {\n      return writeOut(message);\n    }\n    process.on(\"exit\", () => {\n      try {\n        fs.closeSync(fd);\n      } catch {\n      }\n    });\n  }\n  fs.appendFile(fd, `${message}\n`, (err) => {\n    if (err) {\n      writeOut(message);\n    }\n  });\n}\nfunction doEmitWarning(warning) {\n  process.emit(\"warning\", warning);\n}\nlet traceWarningHelperShown = false;\nfunction onWarning(warning) {\n  if (!(warning instanceof Error))\n    return;\n  const isDeprecation = warning.name === \"DeprecationWarning\";\n  if (isDeprecation && process.noDeprecation)\n    return;\n  const trace = process.traceProcessWarnings || isDeprecation && process.traceDeprecation;\n  let msg = `(${process.release.name}:${process.pid}) `;\n  if (warning.code)\n    msg += `[${warning.code}] `;\n  if (trace && warning.stack) {\n    msg += `${warning.stack}`;\n  } else {\n    msg += typeof warning.toString === \"function\" ? `${warning.toString()}` : ErrorPrototypeToString(warning);\n  }\n  if (typeof warning.detail === \"string\") {\n    msg += `\n${warning.detail}`;\n  }\n  if (!trace && !traceWarningHelperShown) {\n    const flag = isDeprecation ? \"--trace-deprecation\" : \"--trace-warnings\";\n    const argv0 = require(\"path\").basename(process.argv0 || \"node\", \".exe\");\n    msg += `\n(Use \\`${argv0} ${flag} ...\\` to show where the warning was created)`;\n    traceWarningHelperShown = true;\n  }\n  const warningFile2 = lazyOption();\n  if (warningFile2) {\n    return writeToFile(msg);\n  }\n  writeOut(msg);\n}\nfunction emitWarning(warning, type, code, ctor) {\n  let detail;\n  if (type !== null && typeof type === \"object\" && !ArrayIsArray(type)) {\n    ctor = type.ctor;\n    code = type.code;\n    if (typeof type.detail === \"string\")\n      detail = type.detail;\n    type = type.type || \"Warning\";\n  } else if (typeof type === \"function\") {\n    ctor = type;\n    code = void 0;\n    type = \"Warning\";\n  }\n  if (type !== void 0)\n    validateString(type, \"type\");\n  if (typeof code === \"function\") {\n    ctor = code;\n    code = void 0;\n  } else if (code !== void 0) {\n    validateString(code, \"code\");\n  }\n  if (typeof warning === \"string\") {\n    warning = createWarningObject(warning, type, code, ctor, detail);\n  } else if (!(warning instanceof Error)) {\n    throw new ERR_INVALID_ARG_TYPE(\"warning\", [\"Error\", \"string\"], warning);\n  }\n  if (warning.name === \"DeprecationWarning\") {\n    if (process.noDeprecation)\n      return;\n    if (process.throwDeprecation) {\n      return process.nextTick(() => {\n        throw warning;\n      });\n    }\n  }\n  process.nextTick(doEmitWarning, warning);\n}\nfunction emitWarningSync(warning) {\n  process.emit(\"warning\", createWarningObject(warning));\n}\nfunction createWarningObject(warning, type, code, ctor, detail) {\n  assert(typeof warning === \"string\");\n  const tmpStackLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = 0;\n  warning = new Error(warning);\n  if (isErrorStackTraceLimitWritable())\n    Error.stackTraceLimit = tmpStackLimit;\n  warning.name = String(type || \"Warning\");\n  if (code !== void 0)\n    warning.code = code;\n  if (detail !== void 0)\n    warning.detail = detail;\n  ErrorCaptureStackTrace(warning, ctor || process.emitWarning);\n  return warning;\n}\nmodule.exports = {\n  emitWarning,\n  emitWarningSync,\n  onWarning\n};\n}"],["internal/process/worker_thread_only.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  codes: { ERR_WORKER_UNSUPPORTED_OPERATION }\n} = require(\"internal/errors\");\nfunction unavailable(name) {\n  function unavailableInWorker() {\n    throw new ERR_WORKER_UNSUPPORTED_OPERATION(name);\n  }\n  unavailableInWorker.disabled = true;\n  return unavailableInWorker;\n}\nmodule.exports = {\n  unavailable\n};\n}"],["internal/readline/callbacks.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  NumberIsNaN\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_CURSOR_POS\n  }\n} = require(\"internal/errors\");\nconst {\n  validateCallback\n} = require(\"internal/validators\");\nconst {\n  CSI\n} = require(\"internal/readline/utils\");\nconst {\n  kClearLine,\n  kClearScreenDown,\n  kClearToLineBeginning,\n  kClearToLineEnd\n} = CSI;\nfunction cursorTo(stream, x, y, callback) {\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  if (typeof y === \"function\") {\n    callback = y;\n    y = void 0;\n  }\n  if (NumberIsNaN(x))\n    throw new ERR_INVALID_ARG_VALUE(\"x\", x);\n  if (NumberIsNaN(y))\n    throw new ERR_INVALID_ARG_VALUE(\"y\", y);\n  if (stream == null || typeof x !== \"number\" && typeof y !== \"number\") {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return true;\n  }\n  if (typeof x !== \"number\")\n    throw new ERR_INVALID_CURSOR_POS();\n  const data = typeof y !== \"number\" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data, callback);\n}\nfunction moveCursor(stream, dx, dy, callback) {\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return true;\n  }\n  let data = \"\";\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n  return stream.write(data, callback);\n}\nfunction clearLine(stream, dir, callback) {\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return true;\n  }\n  const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type, callback);\n}\nfunction clearScreenDown(stream, callback) {\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  if (stream === null || stream === void 0) {\n    if (typeof callback === \"function\")\n      process.nextTick(callback, null);\n    return true;\n  }\n  return stream.write(kClearScreenDown, callback);\n}\nmodule.exports = {\n  clearLine,\n  clearScreenDown,\n  cursorTo,\n  moveCursor\n};\n}"],["internal/readline/emitKeypressEvents.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  SafeStringIterator,\n  Symbol\n} = primordials;\nconst {\n  charLengthAt,\n  CSI,\n  emitKeys\n} = require(\"internal/readline/utils\");\nconst {\n  kSawKeyPress\n} = require(\"internal/readline/interface\");\nconst { clearTimeout, setTimeout } = require(\"timers\");\nconst {\n  kEscape\n} = CSI;\nconst { StringDecoder } = require(\"string_decoder\");\nconst KEYPRESS_DECODER = Symbol(\"keypress-decoder\");\nconst ESCAPE_DECODER = Symbol(\"escape-decoder\");\nconst ESCAPE_CODE_TIMEOUT = 500;\nfunction emitKeypressEvents(stream, iface = {}) {\n  if (stream[KEYPRESS_DECODER])\n    return;\n  stream[KEYPRESS_DECODER] = new StringDecoder(\"utf8\");\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n  const triggerEscape = () => stream[ESCAPE_DECODER].next(\"\");\n  const { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  let timeoutId;\n  function onData(input) {\n    if (stream.listenerCount(\"keypress\") > 0) {\n      const string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n        iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;\n        iface.isCompletionEnabled = false;\n        let length = 0;\n        for (const character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape, escapeCodeTimeout);\n            }\n          } catch (err) {\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      stream.removeListener(\"data\", onData);\n      stream.on(\"newListener\", onNewListener);\n    }\n  }\n  function onNewListener(event) {\n    if (event === \"keypress\") {\n      stream.on(\"data\", onData);\n      stream.removeListener(\"newListener\", onNewListener);\n    }\n  }\n  if (stream.listenerCount(\"keypress\") > 0) {\n    stream.on(\"data\", onData);\n  } else {\n    stream.on(\"newListener\", onNewListener);\n  }\n}\nmodule.exports = emitKeypressEvents;\n}"],["internal/readline/interface.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayFrom,\n  ArrayPrototypeFilter,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypeReverse,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  DateNow,\n  FunctionPrototypeCall,\n  MathCeil,\n  MathFloor,\n  MathMax,\n  MathMaxApply,\n  NumberIsFinite,\n  NumberIsNaN,\n  ObjectSetPrototypeOf,\n  RegExpPrototypeTest,\n  StringPrototypeCodePointAt,\n  StringPrototypeEndsWith,\n  StringPrototypeMatch,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeTrim,\n  Symbol,\n  SymbolAsyncIterator,\n  SafeStringIterator\n} = primordials;\nconst { codes } = require(\"internal/errors\");\nconst { ERR_INVALID_ARG_VALUE } = codes;\nconst {\n  validateAbortSignal,\n  validateArray,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  inspect,\n  getStringWidth,\n  stripVTControlCharacters\n} = require(\"internal/util/inspect\");\nconst EventEmitter = require(\"events\");\nconst {\n  charLengthAt,\n  charLengthLeft,\n  commonPrefix,\n  kSubstringSearch\n} = require(\"internal/readline/utils\");\nlet emitKeypressEvents;\nconst {\n  clearScreenDown,\n  cursorTo,\n  moveCursor\n} = require(\"internal/readline/callbacks\");\nconst { StringDecoder } = require(\"string_decoder\");\nlet Readable;\nconst kHistorySize = 30;\nconst kMincrlfDelay = 100;\nconst lineEnding = /\\r?\\n|\\r(?!\\n)/;\nconst kLineObjectStream = Symbol(\"line object stream\");\nconst kQuestionCancel = Symbol(\"kQuestionCancel\");\nconst ESCAPE_CODE_TIMEOUT = 500;\nconst kAddHistory = Symbol(\"_addHistory\");\nconst kDecoder = Symbol(\"_decoder\");\nconst kDeleteLeft = Symbol(\"_deleteLeft\");\nconst kDeleteLineLeft = Symbol(\"_deleteLineLeft\");\nconst kDeleteLineRight = Symbol(\"_deleteLineRight\");\nconst kDeleteRight = Symbol(\"_deleteRight\");\nconst kDeleteWordLeft = Symbol(\"_deleteWordLeft\");\nconst kDeleteWordRight = Symbol(\"_deleteWordRight\");\nconst kGetDisplayPos = Symbol(\"_getDisplayPos\");\nconst kHistoryNext = Symbol(\"_historyNext\");\nconst kHistoryPrev = Symbol(\"_historyPrev\");\nconst kInsertString = Symbol(\"_insertString\");\nconst kLine = Symbol(\"_line\");\nconst kLine_buffer = Symbol(\"_line_buffer\");\nconst kMoveCursor = Symbol(\"_moveCursor\");\nconst kNormalWrite = Symbol(\"_normalWrite\");\nconst kOldPrompt = Symbol(\"_oldPrompt\");\nconst kOnLine = Symbol(\"_onLine\");\nconst kPreviousKey = Symbol(\"_previousKey\");\nconst kPrompt = Symbol(\"_prompt\");\nconst kQuestionCallback = Symbol(\"_questionCallback\");\nconst kRefreshLine = Symbol(\"_refreshLine\");\nconst kSawKeyPress = Symbol(\"_sawKeyPress\");\nconst kSawReturnAt = Symbol(\"_sawReturnAt\");\nconst kSetRawMode = Symbol(\"_setRawMode\");\nconst kTabComplete = Symbol(\"_tabComplete\");\nconst kTabCompleter = Symbol(\"_tabCompleter\");\nconst kTtyWrite = Symbol(\"_ttyWrite\");\nconst kWordLeft = Symbol(\"_wordLeft\");\nconst kWordRight = Symbol(\"_wordRight\");\nconst kWriteToOutput = Symbol(\"_writeToOutput\");\nfunction InterfaceConstructor(input, output, completer, terminal) {\n  this[kSawReturnAt] = 0;\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n  FunctionPrototypeCall(EventEmitter, this);\n  let history;\n  let historySize;\n  let removeHistoryDuplicates = false;\n  let crlfDelay;\n  let prompt = \"> \";\n  let signal;\n  if (input?.input) {\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n    if (input.tabSize !== void 0) {\n      validateUint32(input.tabSize, \"tabSize\", true);\n      this.tabSize = input.tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    if (input.prompt !== void 0) {\n      prompt = input.prompt;\n    }\n    if (input.escapeCodeTimeout !== void 0) {\n      if (NumberIsFinite(input.escapeCodeTimeout)) {\n        this.escapeCodeTimeout = input.escapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\"input.escapeCodeTimeout\", this.escapeCodeTimeout);\n      }\n    }\n    if (signal) {\n      validateAbortSignal(signal, \"options.signal\");\n    }\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n  if (completer !== void 0 && typeof completer !== \"function\") {\n    throw new ERR_INVALID_ARG_VALUE(\"completer\", completer);\n  }\n  if (history === void 0) {\n    history = [];\n  } else {\n    validateArray(history, \"history\");\n  }\n  if (historySize === void 0) {\n    historySize = kHistorySize;\n  }\n  if (typeof historySize !== \"number\" || NumberIsNaN(historySize) || historySize < 0) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"historySize\", historySize);\n  }\n  if (terminal === void 0 && !(output === null || output === void 0)) {\n    terminal = !!output.isTTY;\n  }\n  const self = this;\n  this.line = \"\";\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this.history = history;\n  this.historySize = historySize;\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ? MathMax(kMincrlfDelay, crlfDelay) : kMincrlfDelay;\n  this.completer = completer;\n  this.setPrompt(prompt);\n  this.terminal = !!terminal;\n  function onerror(err) {\n    self.emit(\"error\", err);\n  }\n  function ondata(data) {\n    self[kNormalWrite](data);\n  }\n  function onend() {\n    if (typeof self[kLine_buffer] === \"string\" && self[kLine_buffer].length > 0) {\n      self.emit(\"line\", self[kLine_buffer]);\n    }\n    self.close();\n  }\n  function ontermend() {\n    if (typeof self.line === \"string\" && self.line.length > 0) {\n      self.emit(\"line\", self.line);\n    }\n    self.close();\n  }\n  function onkeypress(s, key) {\n    self[kTtyWrite](s, key);\n    if (key && key.sequence) {\n      const ch = StringPrototypeCodePointAt(key.sequence, 0);\n      if (ch >= 55296 && ch <= 57343)\n        self[kRefreshLine]();\n    }\n  }\n  function onresize() {\n    self[kRefreshLine]();\n  }\n  this[kLineObjectStream] = void 0;\n  input.on(\"error\", onerror);\n  if (!this.terminal) {\n    let onSelfCloseWithoutTerminal = function() {\n      input.removeListener(\"data\", ondata);\n      input.removeListener(\"error\", onerror);\n      input.removeListener(\"end\", onend);\n    };\n    input.on(\"data\", ondata);\n    input.on(\"end\", onend);\n    self.once(\"close\", onSelfCloseWithoutTerminal);\n    this[kDecoder] = new StringDecoder(\"utf8\");\n  } else {\n    let onSelfCloseWithTerminal = function() {\n      input.removeListener(\"keypress\", onkeypress);\n      input.removeListener(\"error\", onerror);\n      input.removeListener(\"end\", ontermend);\n      if (output !== null && output !== void 0) {\n        output.removeListener(\"resize\", onresize);\n      }\n    };\n    emitKeypressEvents ??= require(\"internal/readline/emitKeypressEvents\");\n    emitKeypressEvents(input, this);\n    input.on(\"keypress\", onkeypress);\n    input.on(\"end\", ontermend);\n    this[kSetRawMode](true);\n    this.terminal = true;\n    this.cursor = 0;\n    this.historyIndex = -1;\n    if (output !== null && output !== void 0)\n      output.on(\"resize\", onresize);\n    self.once(\"close\", onSelfCloseWithTerminal);\n  }\n  if (signal) {\n    const onAborted = () => self.close();\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener(\"abort\", onAborted, { once: true });\n      self.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n  this.line = \"\";\n  input.resume();\n}\nObjectSetPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor, EventEmitter);\nclass Interface extends InterfaceConstructor {\n  constructor(input, output, completer, terminal) {\n    super(input, output, completer, terminal);\n  }\n  get columns() {\n    if (this.output && this.output.columns)\n      return this.output.columns;\n    return Infinity;\n  }\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n  getPrompt() {\n    return this[kPrompt];\n  }\n  [kSetRawMode](mode) {\n    const wasInRawMode = this.input.isRaw;\n    if (typeof this.input.setRawMode === \"function\") {\n      this.input.setRawMode(mode);\n    }\n    return wasInRawMode;\n  }\n  prompt(preserveCursor) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal && process.env.TERM !== \"dumb\") {\n      if (!preserveCursor)\n        this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n  question(query, cb) {\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      const cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit(\"line\", line);\n    }\n  }\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite, \"stringToWrite\");\n    if (this.output !== null && this.output !== void 0) {\n      this.output.write(stringToWrite);\n    }\n  }\n  [kAddHistory]() {\n    if (this.line.length === 0)\n      return \"\";\n    if (this.historySize === 0)\n      return this.line;\n    if (StringPrototypeTrim(this.line).length === 0)\n      return this.line;\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        const dupIndex = ArrayPrototypeIndexOf(this.history, this.line);\n        if (dupIndex !== -1)\n          ArrayPrototypeSplice(this.history, dupIndex, 1);\n      }\n      ArrayPrototypeUnshift(this.history, this.line);\n      if (this.history.length > this.historySize)\n        ArrayPrototypePop(this.history);\n    }\n    this.historyIndex = -1;\n    const line = this.history[0];\n    this.emit(\"history\", this.history);\n    return line;\n  }\n  [kRefreshLine]() {\n    const line = this[kPrompt] + this.line;\n    const dispPos = this[kGetDisplayPos](line);\n    const lineCols = dispPos.cols;\n    const lineRows = dispPos.rows;\n    const cursorPos = this.getCursorPos();\n    const prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output, 0, -prevRows);\n    }\n    cursorTo(this.output, 0);\n    clearScreenDown(this.output);\n    this[kWriteToOutput](line);\n    if (lineCols === 0) {\n      this[kWriteToOutput](\" \");\n    }\n    cursorTo(this.output, cursorPos.cols);\n    const diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output, 0, -diff);\n    }\n    this.prevRows = cursorPos.rows;\n  }\n  close() {\n    if (this.closed)\n      return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit(\"close\");\n  }\n  pause() {\n    if (this.paused)\n      return;\n    this.input.pause();\n    this.paused = true;\n    this.emit(\"pause\");\n    return this;\n  }\n  resume() {\n    if (!this.paused)\n      return;\n    this.input.resume();\n    this.paused = false;\n    this.emit(\"resume\");\n    return this;\n  }\n  write(d, key) {\n    if (this.paused)\n      this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d, key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n  [kNormalWrite](b) {\n    if (b === void 0) {\n      return;\n    }\n    let string = this[kDecoder].write(b);\n    if (this[kSawReturnAt] && DateNow() - this[kSawReturnAt] <= this.crlfDelay) {\n      string = StringPrototypeReplace(string, /^\\n/, \"\");\n      this[kSawReturnAt] = 0;\n    }\n    const newPartContainsEnding = RegExpPrototypeTest(lineEnding, string);\n    if (this[kLine_buffer]) {\n      string = this[kLine_buffer] + string;\n      this[kLine_buffer] = null;\n    }\n    if (newPartContainsEnding) {\n      this[kSawReturnAt] = StringPrototypeEndsWith(string, \"\\r\") ? DateNow() : 0;\n      const lines = StringPrototypeSplit(string, lineEnding);\n      string = ArrayPrototypePop(lines);\n      this[kLine_buffer] = string;\n      for (let n = 0; n < lines.length; n++)\n        this[kOnLine](lines[n]);\n    } else if (string) {\n      this[kLine_buffer] = string;\n    }\n  }\n  [kInsertString](c) {\n    if (this.cursor < this.line.length) {\n      const beg = StringPrototypeSlice(this.line, 0, this.cursor);\n      const end = StringPrototypeSlice(this.line, this.cursor, this.line.length);\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      this.line += c;\n      this.cursor += c.length;\n      if (this.getCursorPos().cols === 0) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    const string = StringPrototypeSlice(this.line, 0, this.cursor);\n    let value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  }\n  [kTabCompleter](lastKeypressWasTab, { 0: completions, 1: completeOn }) {\n    if (!completions || completions.length === 0) {\n      return;\n    }\n    const prefix = commonPrefix(ArrayPrototypeFilter(completions, (e) => e !== \"\"));\n    if (StringPrototypeStartsWith(prefix, completeOn) && prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice(prefix, completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith(completeOn, prefix)) {\n      this.line = StringPrototypeSlice(this.line, 0, this.cursor - completeOn.length) + prefix + StringPrototypeSlice(this.line, this.cursor, this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n    if (!lastKeypressWasTab) {\n      return;\n    }\n    const completionsWidth = ArrayPrototypeMap(completions, (e) => getStringWidth(e));\n    const width = MathMaxApply(completionsWidth) + 2;\n    let maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    let output = \"\\r\\n\";\n    let lineIndex = 0;\n    let whitespace = 0;\n    for (let i = 0; i < completions.length; i++) {\n      const completion = completions[i];\n      if (completion === \"\" || lineIndex === maxColumns) {\n        output += \"\\r\\n\";\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat(\" \", whitespace);\n      }\n      if (completion !== \"\") {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += \"\\r\\n\";\n      }\n    }\n    if (lineIndex !== 0) {\n      output += \"\\r\\n\\r\\n\";\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      const leading = StringPrototypeSlice(this.line, 0, this.cursor);\n      const reversed = ArrayPrototypeJoin(ArrayPrototypeReverse(ArrayFrom(leading)), \"\");\n      const match = StringPrototypeMatch(reversed, /^\\s*(?:[^\\w\\s]+|\\w+)?/);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      const trailing = StringPrototypeSlice(this.line, this.cursor);\n      const match = StringPrototypeMatch(trailing, /^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      const charSize = charLengthLeft(this.line, this.cursor);\n      this.line = StringPrototypeSlice(this.line, 0, this.cursor - charSize) + StringPrototypeSlice(this.line, this.cursor, this.line.length);\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      const charSize = charLengthAt(this.line, this.cursor);\n      this.line = StringPrototypeSlice(this.line, 0, this.cursor) + StringPrototypeSlice(this.line, this.cursor + charSize, this.line.length);\n      this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      let leading = StringPrototypeSlice(this.line, 0, this.cursor);\n      const reversed = ArrayPrototypeJoin(ArrayPrototypeReverse(ArrayFrom(leading)), \"\");\n      const match = StringPrototypeMatch(reversed, /^\\s*(?:[^\\w\\s]+|\\w+)?/);\n      leading = StringPrototypeSlice(leading, 0, leading.length - match[0].length);\n      this.line = leading + StringPrototypeSlice(this.line, this.cursor, this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      const trailing = StringPrototypeSlice(this.line, this.cursor);\n      const match = StringPrototypeMatch(trailing, /^(?:\\s+|\\W+|\\w+)\\s*/);\n      this.line = StringPrototypeSlice(this.line, 0, this.cursor) + StringPrototypeSlice(trailing, match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n  [kDeleteLineLeft]() {\n    this.line = StringPrototypeSlice(this.line, this.cursor);\n    this.cursor = 0;\n    this[kRefreshLine]();\n  }\n  [kDeleteLineRight]() {\n    this.line = StringPrototypeSlice(this.line, 0, this.cursor);\n    this[kRefreshLine]();\n  }\n  clearLine() {\n    this[kMoveCursor](Infinity);\n    this[kWriteToOutput](\"\\r\\n\");\n    this.line = \"\";\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n  [kLine]() {\n    const line = this[kAddHistory]();\n    this.clearLine();\n    this[kOnLine](line);\n  }\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      const search = this[kSubstringSearch] || \"\";\n      let index = this.historyIndex - 1;\n      while (index >= 0 && (!StringPrototypeStartsWith(this.history[index], search) || this.line === this.history[index])) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length;\n      this[kRefreshLine]();\n    }\n  }\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      const search = this[kSubstringSearch] || \"\";\n      let index = this.historyIndex + 1;\n      while (index < this.history.length && (!StringPrototypeStartsWith(this.history[index], search) || this.line === this.history[index])) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length;\n      this[kRefreshLine]();\n    }\n  }\n  [kGetDisplayPos](str) {\n    let offset = 0;\n    const col = this.columns;\n    let rows = 0;\n    str = stripVTControlCharacters(str);\n    for (const char of new SafeStringIterator(str)) {\n      if (char === \"\\n\") {\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      if (char === \"\t\") {\n        offset += this.tabSize - offset % this.tabSize;\n        continue;\n      }\n      const width = getStringWidth(char);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    const cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols, rows };\n  }\n  getCursorPos() {\n    const strBeforeCursor = this[kPrompt] + StringPrototypeSlice(this.line, 0, this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    const oldPos = this.getCursorPos();\n    this.cursor += dx;\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n    const newPos = this.getCursorPos();\n    if (oldPos.rows === newPos.rows) {\n      const diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output, diffWidth, 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n  [kTtyWrite](s, key) {\n    const previousKey = this[kPreviousKey];\n    key = key || {};\n    this[kPreviousKey] = key;\n    if ((key.name === \"up\" || key.name === \"down\") && !key.ctrl && !key.meta && !key.shift) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice(this.line, 0, this.cursor);\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n    if (key.name === \"escape\")\n      return;\n    if (key.ctrl && key.shift) {\n      switch (key.name) {\n        case \"backspace\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (key.ctrl) {\n      switch (key.name) {\n        case \"c\":\n          if (this.listenerCount(\"SIGINT\") > 0) {\n            this.emit(\"SIGINT\");\n          } else {\n            this.close();\n          }\n          break;\n        case \"h\":\n          this[kDeleteLeft]();\n          break;\n        case \"d\":\n          if (this.cursor === 0 && this.line.length === 0) {\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n        case \"u\":\n          this[kDeleteLineLeft]();\n          break;\n        case \"k\":\n          this[kDeleteLineRight]();\n          break;\n        case \"a\":\n          this[kMoveCursor](-Infinity);\n          break;\n        case \"e\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"b\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"f\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"l\":\n          cursorTo(this.output, 0, 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n        case \"n\":\n          this[kHistoryNext]();\n          break;\n        case \"p\":\n          this[kHistoryPrev]();\n          break;\n        case \"z\":\n          if (process.platform === \"win32\")\n            break;\n          if (this.listenerCount(\"SIGTSTP\") > 0) {\n            this.emit(\"SIGTSTP\");\n          } else {\n            process.once(\"SIGCONT\", () => {\n              if (!this.paused) {\n                this.pause();\n                this.emit(\"SIGCONT\");\n              }\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid, \"SIGTSTP\");\n          }\n          break;\n        case \"w\":\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"left\":\n          this[kWordLeft]();\n          break;\n        case \"right\":\n          this[kWordRight]();\n          break;\n      }\n    } else if (key.meta) {\n      switch (key.name) {\n        case \"b\":\n          this[kWordLeft]();\n          break;\n        case \"f\":\n          this[kWordRight]();\n          break;\n        case \"d\":\n        case \"delete\":\n          this[kDeleteWordRight]();\n          break;\n        case \"backspace\":\n          this[kDeleteWordLeft]();\n          break;\n      }\n    } else {\n      if (this[kSawReturnAt] && key.name !== \"enter\")\n        this[kSawReturnAt] = 0;\n      switch (key.name) {\n        case \"return\":\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n        case \"enter\":\n          if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n        case \"backspace\":\n          this[kDeleteLeft]();\n          break;\n        case \"delete\":\n          this[kDeleteRight]();\n          break;\n        case \"left\":\n          this[kMoveCursor](-charLengthLeft(this.line, this.cursor));\n          break;\n        case \"right\":\n          this[kMoveCursor](+charLengthAt(this.line, this.cursor));\n          break;\n        case \"home\":\n          this[kMoveCursor](-Infinity);\n          break;\n        case \"end\":\n          this[kMoveCursor](Infinity);\n          break;\n        case \"up\":\n          this[kHistoryPrev]();\n          break;\n        case \"down\":\n          this[kHistoryNext]();\n          break;\n        case \"tab\":\n          if (typeof this.completer === \"function\" && this.isCompletionEnabled) {\n            const lastKeypressWasTab = previousKey && previousKey.name === \"tab\";\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        default:\n          if (typeof s === \"string\" && s) {\n            const lines = StringPrototypeSplit(s, /\\r\\n|\\n|\\r/);\n            for (let i = 0, len = lines.length; i < len; i++) {\n              if (i > 0) {\n                this[kLine]();\n              }\n              this[kInsertString](lines[i]);\n            }\n          }\n      }\n    }\n  }\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === void 0) {\n      if (Readable === void 0) {\n        Readable = require(\"stream\").Readable;\n      }\n      const readable = new Readable({\n        objectMode: true,\n        read: () => {\n          this.resume();\n        },\n        destroy: (err, cb) => {\n          this.off(\"line\", lineListener);\n          this.off(\"close\", closeListener);\n          this.close();\n          cb(err);\n        }\n      });\n      const lineListener = (input) => {\n        if (!readable.push(input)) {\n          this.pause();\n        }\n      };\n      const closeListener = () => {\n        readable.push(null);\n      };\n      const errorListener = (err) => {\n        readable.destroy(err);\n      };\n      this.on(\"error\", errorListener);\n      this.on(\"line\", lineListener);\n      this.on(\"close\", closeListener);\n      this[kLineObjectStream] = readable;\n    }\n    return this[kLineObjectStream][SymbolAsyncIterator]();\n  }\n}\nmodule.exports = {\n  Interface,\n  InterfaceConstructor,\n  kAddHistory,\n  kDecoder,\n  kDeleteLeft,\n  kDeleteLineLeft,\n  kDeleteLineRight,\n  kDeleteRight,\n  kDeleteWordLeft,\n  kDeleteWordRight,\n  kGetDisplayPos,\n  kHistoryNext,\n  kHistoryPrev,\n  kInsertString,\n  kLine,\n  kLine_buffer,\n  kMoveCursor,\n  kNormalWrite,\n  kOldPrompt,\n  kOnLine,\n  kPreviousKey,\n  kPrompt,\n  kQuestionCallback,\n  kQuestionCancel,\n  kRefreshLine,\n  kSawKeyPress,\n  kSawReturnAt,\n  kSetRawMode,\n  kTabComplete,\n  kTabCompleter,\n  kTtyWrite,\n  kWordLeft,\n  kWordRight,\n  kWriteToOutput\n};\n}"],["internal/readline/promises.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  Promise\n} = primordials;\nconst { CSI } = require(\"internal/readline/utils\");\nconst { validateBoolean, validateInteger } = require(\"internal/validators\");\nconst { isWritable } = require(\"internal/streams/utils\");\nconst { codes: { ERR_INVALID_ARG_TYPE } } = require(\"internal/errors\");\nconst {\n  kClearToLineBeginning,\n  kClearToLineEnd,\n  kClearLine,\n  kClearScreenDown\n} = CSI;\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n  constructor(stream, options = void 0) {\n    if (!isWritable(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"Writable\", stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit, \"options.autoCommit\");\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n  cursorTo(x, y = void 0) {\n    validateInteger(x, \"x\");\n    if (y != null)\n      validateInteger(y, \"y\");\n    const data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush(this.#todo, data);\n    return this;\n  }\n  moveCursor(dx, dy) {\n    if (dx || dy) {\n      validateInteger(dx, \"dx\");\n      validateInteger(dy, \"dy\");\n      let data = \"\";\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit)\n        process.nextTick(() => this.#stream.write(data));\n      else\n        ArrayPrototypePush(this.#todo, data);\n    }\n    return this;\n  }\n  clearLine(dir) {\n    validateInteger(dir, \"dir\", -1, 1);\n    const data = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n    if (this.#autoCommit)\n      process.nextTick(() => this.#stream.write(data));\n    else\n      ArrayPrototypePush(this.#todo, data);\n    return this;\n  }\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush(this.#todo, kClearScreenDown);\n    }\n    return this;\n  }\n  commit() {\n    return new Promise((resolve) => {\n      this.#stream.write(ArrayPrototypeJoin(this.#todo, \"\"), resolve);\n      this.#todo = [];\n    });\n  }\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\nmodule.exports = {\n  Readline\n};\n}"],["internal/readline/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  RegExpPrototypeTest,\n  StringFromCharCode,\n  StringPrototypeCharCodeAt,\n  StringPrototypeCodePointAt,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase,\n  Symbol\n} = primordials;\nconst kUTF16SurrogateThreshold = 65536;\nconst kEscape = \"\u001b\";\nconst kSubstringSearch = Symbol(\"kSubstringSearch\");\nfunction CSI(strings, ...args) {\n  let ret = `${kEscape}[`;\n  for (let n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length)\n      ret += args[n];\n  }\n  return ret;\n}\nCSI.kEscape = kEscape;\nCSI.kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = CSI`0K`;\nCSI.kClearLine = CSI`2K`;\nCSI.kClearScreenDown = CSI`0J`;\nfunction charLengthLeft(str, i) {\n  if (i <= 0)\n    return 0;\n  if (i > 1 && StringPrototypeCodePointAt(str, i - 2) >= kUTF16SurrogateThreshold || StringPrototypeCodePointAt(str, i - 1) >= kUTF16SurrogateThreshold) {\n    return 2;\n  }\n  return 1;\n}\nfunction charLengthAt(str, i) {\n  if (str.length <= i) {\n    return 1;\n  }\n  return StringPrototypeCodePointAt(str, i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\nfunction* emitKeys(stream) {\n  while (true) {\n    let ch = yield;\n    let s = ch;\n    let escaped = false;\n    const key = {\n      sequence: null,\n      name: void 0,\n      ctrl: false,\n      meta: false,\n      shift: false\n    };\n    if (ch === kEscape) {\n      escaped = true;\n      s += ch = yield;\n      if (ch === kEscape) {\n        s += ch = yield;\n      }\n    }\n    if (escaped && (ch === \"O\" || ch === \"[\")) {\n      let code = ch;\n      let modifier = 0;\n      if (ch === \"O\") {\n        s += ch = yield;\n        if (ch >= \"0\" && ch <= \"9\") {\n          modifier = (ch >> 0) - 1;\n          s += ch = yield;\n        }\n        code += ch;\n      } else if (ch === \"[\") {\n        s += ch = yield;\n        if (ch === \"[\") {\n          code += ch;\n          s += ch = yield;\n        }\n        const cmdStart = s.length - 1;\n        if (ch >= \"0\" && ch <= \"9\") {\n          s += ch = yield;\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += ch = yield;\n          }\n        }\n        if (ch === \";\") {\n          s += ch = yield;\n          if (ch >= \"0\" && ch <= \"9\") {\n            s += yield;\n          }\n        }\n        const cmd = StringPrototypeSlice(s, cmdStart);\n        let match;\n        if (match = StringPrototypeMatch(cmd, /^(\\d\\d?)(;(\\d))?([~^$])$/)) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if (match = StringPrototypeMatch(cmd, /^((\\d;)?(\\d))?([A-Za-z])$/)) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n      switch (code) {\n        case \"[P\":\n          key.name = \"f1\";\n          break;\n        case \"[Q\":\n          key.name = \"f2\";\n          break;\n        case \"[R\":\n          key.name = \"f3\";\n          break;\n        case \"[S\":\n          key.name = \"f4\";\n          break;\n        case \"OP\":\n          key.name = \"f1\";\n          break;\n        case \"OQ\":\n          key.name = \"f2\";\n          break;\n        case \"OR\":\n          key.name = \"f3\";\n          break;\n        case \"OS\":\n          key.name = \"f4\";\n          break;\n        case \"[11~\":\n          key.name = \"f1\";\n          break;\n        case \"[12~\":\n          key.name = \"f2\";\n          break;\n        case \"[13~\":\n          key.name = \"f3\";\n          break;\n        case \"[14~\":\n          key.name = \"f4\";\n          break;\n        case \"[[A\":\n          key.name = \"f1\";\n          break;\n        case \"[[B\":\n          key.name = \"f2\";\n          break;\n        case \"[[C\":\n          key.name = \"f3\";\n          break;\n        case \"[[D\":\n          key.name = \"f4\";\n          break;\n        case \"[[E\":\n          key.name = \"f5\";\n          break;\n        case \"[15~\":\n          key.name = \"f5\";\n          break;\n        case \"[17~\":\n          key.name = \"f6\";\n          break;\n        case \"[18~\":\n          key.name = \"f7\";\n          break;\n        case \"[19~\":\n          key.name = \"f8\";\n          break;\n        case \"[20~\":\n          key.name = \"f9\";\n          break;\n        case \"[21~\":\n          key.name = \"f10\";\n          break;\n        case \"[23~\":\n          key.name = \"f11\";\n          break;\n        case \"[24~\":\n          key.name = \"f12\";\n          break;\n        case \"[A\":\n          key.name = \"up\";\n          break;\n        case \"[B\":\n          key.name = \"down\";\n          break;\n        case \"[C\":\n          key.name = \"right\";\n          break;\n        case \"[D\":\n          key.name = \"left\";\n          break;\n        case \"[E\":\n          key.name = \"clear\";\n          break;\n        case \"[F\":\n          key.name = \"end\";\n          break;\n        case \"[H\":\n          key.name = \"home\";\n          break;\n        case \"OA\":\n          key.name = \"up\";\n          break;\n        case \"OB\":\n          key.name = \"down\";\n          break;\n        case \"OC\":\n          key.name = \"right\";\n          break;\n        case \"OD\":\n          key.name = \"left\";\n          break;\n        case \"OE\":\n          key.name = \"clear\";\n          break;\n        case \"OF\":\n          key.name = \"end\";\n          break;\n        case \"OH\":\n          key.name = \"home\";\n          break;\n        case \"[1~\":\n          key.name = \"home\";\n          break;\n        case \"[2~\":\n          key.name = \"insert\";\n          break;\n        case \"[3~\":\n          key.name = \"delete\";\n          break;\n        case \"[4~\":\n          key.name = \"end\";\n          break;\n        case \"[5~\":\n          key.name = \"pageup\";\n          break;\n        case \"[6~\":\n          key.name = \"pagedown\";\n          break;\n        case \"[[5~\":\n          key.name = \"pageup\";\n          break;\n        case \"[[6~\":\n          key.name = \"pagedown\";\n          break;\n        case \"[7~\":\n          key.name = \"home\";\n          break;\n        case \"[8~\":\n          key.name = \"end\";\n          break;\n        case \"[a\":\n          key.name = \"up\";\n          key.shift = true;\n          break;\n        case \"[b\":\n          key.name = \"down\";\n          key.shift = true;\n          break;\n        case \"[c\":\n          key.name = \"right\";\n          key.shift = true;\n          break;\n        case \"[d\":\n          key.name = \"left\";\n          key.shift = true;\n          break;\n        case \"[e\":\n          key.name = \"clear\";\n          key.shift = true;\n          break;\n        case \"[2$\":\n          key.name = \"insert\";\n          key.shift = true;\n          break;\n        case \"[3$\":\n          key.name = \"delete\";\n          key.shift = true;\n          break;\n        case \"[5$\":\n          key.name = \"pageup\";\n          key.shift = true;\n          break;\n        case \"[6$\":\n          key.name = \"pagedown\";\n          key.shift = true;\n          break;\n        case \"[7$\":\n          key.name = \"home\";\n          key.shift = true;\n          break;\n        case \"[8$\":\n          key.name = \"end\";\n          key.shift = true;\n          break;\n        case \"Oa\":\n          key.name = \"up\";\n          key.ctrl = true;\n          break;\n        case \"Ob\":\n          key.name = \"down\";\n          key.ctrl = true;\n          break;\n        case \"Oc\":\n          key.name = \"right\";\n          key.ctrl = true;\n          break;\n        case \"Od\":\n          key.name = \"left\";\n          key.ctrl = true;\n          break;\n        case \"Oe\":\n          key.name = \"clear\";\n          key.ctrl = true;\n          break;\n        case \"[2^\":\n          key.name = \"insert\";\n          key.ctrl = true;\n          break;\n        case \"[3^\":\n          key.name = \"delete\";\n          key.ctrl = true;\n          break;\n        case \"[5^\":\n          key.name = \"pageup\";\n          key.ctrl = true;\n          break;\n        case \"[6^\":\n          key.name = \"pagedown\";\n          key.ctrl = true;\n          break;\n        case \"[7^\":\n          key.name = \"home\";\n          key.ctrl = true;\n          break;\n        case \"[8^\":\n          key.name = \"end\";\n          key.ctrl = true;\n          break;\n        case \"[Z\":\n          key.name = \"tab\";\n          key.shift = true;\n          break;\n        default:\n          key.name = \"undefined\";\n          break;\n      }\n    } else if (ch === \"\\r\") {\n      key.name = \"return\";\n      key.meta = escaped;\n    } else if (ch === \"\\n\") {\n      key.name = \"enter\";\n      key.meta = escaped;\n    } else if (ch === \"\t\") {\n      key.name = \"tab\";\n      key.meta = escaped;\n    } else if (ch === \"\\b\" || ch === \"\\x7F\") {\n      key.name = \"backspace\";\n      key.meta = escaped;\n    } else if (ch === kEscape) {\n      key.name = \"escape\";\n      key.meta = escaped;\n    } else if (ch === \" \") {\n      key.name = \"space\";\n      key.meta = escaped;\n    } else if (!escaped && ch <= \"\u001a\") {\n      key.name = StringFromCharCode(StringPrototypeCharCodeAt(ch) + StringPrototypeCharCodeAt(\"a\") - 1);\n      key.ctrl = true;\n    } else if (RegExpPrototypeTest(/^[0-9A-Za-z]$/, ch)) {\n      key.name = StringPrototypeToLowerCase(ch);\n      key.shift = RegExpPrototypeTest(/^[A-Z]$/, ch);\n      key.meta = escaped;\n    } else if (escaped) {\n      key.name = ch.length ? void 0 : \"escape\";\n      key.meta = true;\n    }\n    key.sequence = s;\n    if (s.length !== 0 && (key.name !== void 0 || escaped)) {\n      stream.emit(\"keypress\", escaped ? void 0 : s, key);\n    } else if (charLengthAt(s, 0) === s.length) {\n      stream.emit(\"keypress\", s, key);\n    }\n  }\n}\nfunction commonPrefix(strings) {\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(strings));\n  const min = sorted[0];\n  const max = sorted[sorted.length - 1];\n  for (let i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice(min, 0, i);\n    }\n  }\n  return min;\n}\nmodule.exports = {\n  charLengthAt,\n  charLengthLeft,\n  commonPrefix,\n  emitKeys,\n  kSubstringSearch,\n  CSI\n};\n}"],["internal/repl/await.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError\n} = primordials;\nconst parser = require(\"internal/deps/acorn/acorn/dist/acorn\").Parser;\nconst walk = require(\"internal/deps/acorn/acorn-walk/dist/walk\");\nconst { Recoverable } = require(\"internal/repl\");\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(state.hoistedDeclarationStatements, `let ${node.id.name}; `);\n    }\n    walk.base.ClassDeclaration(node, state, c);\n  },\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n    walk.base.ForOfStatement(node, state, c);\n  },\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `this.${node.id.name} = ${node.id.name}; `);\n    ArrayPrototypePush(state.hoistedDeclarationStatements, `var ${node.id.name}; `);\n  },\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes([\"ForOfStatement\", \"ForInStatement\"], state.ancestors[state.ancestors.length - 2].type);\n    if (variableKind === \"var\" || isTopLevelDeclaration(state)) {\n      let registerVariableDeclarationIdentifiers = function(node2) {\n        switch (node2.type) {\n          case \"Identifier\":\n            ArrayPrototypePush(variableIdentifiersToHoist[variableKind === \"var\" ? 0 : 1][1], node2.name);\n            break;\n          case \"ObjectPattern\":\n            ArrayPrototypeForEach(node2.properties, (property) => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n          case \"ArrayPattern\":\n            ArrayPrototypeForEach(node2.elements, (element) => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      };\n      state.replace(node.start, node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0), variableKind === \"var\" && isIterableForDeclaration ? \"\" : \"void\" + (node.declarations.length === 1 ? \"\" : \" (\"));\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, (decl) => {\n          state.prepend(decl, \"(\");\n          state.append(decl, decl.init ? \")\" : \"=undefined)\");\n        });\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], \")\");\n        }\n      }\n      const variableIdentifiersToHoist = [\n        [\"var\", []],\n        [\"let\", []]\n      ];\n      ArrayPrototypeForEach(node.declarations, (decl) => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n      ArrayPrototypeForEach(variableIdentifiersToHoist, ({ 0: kind, 1: identifiers }) => {\n        if (identifiers.length > 0) {\n          ArrayPrototypePush(state.hoistedDeclarationStatements, `${kind} ${ArrayPrototypeJoin(identifiers, \", \")}; `);\n        }\n      });\n    }\n    walk.base.VariableDeclaration(node, state, c);\n  }\n};\nconst visitors = {};\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n    callback(node, state, c);\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = \"(async () => { \";\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = StringPrototypeSplit(wrapped, \"\");\n  let root;\n  try {\n    root = parser.parse(wrapped, { ecmaVersion: \"latest\" });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, \"Unterminated \"))\n      throw new Recoverable(e);\n    const awaitPos = StringPrototypeIndexOf(src, \"await\");\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos)\n      return null;\n    if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, \"Expecting Unicode escape sequence\"))\n      return null;\n    if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, \"Unexpected token\"))\n      return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = \"\\n\" + StringPrototypeSplit(src, \"\\n\")[line - 1] + \"\\n\" + StringPrototypeRepeat(\" \", column) + \"^\\n\\n\" + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, \"\");\n    if (StringPrototypeEndsWith(message, \"Unexpected token\"))\n      message += \" '\" + (src[e.pos - wrapPrefix.length] ?? src[src.length - 1]) + \"'\";\n    throw new SyntaxError(message);\n  }\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = \"\";\n      }\n      if (from === to)\n        str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n    containsAwait: false,\n    containsReturn: false\n  };\n  walk.recursive(body, state, visitors);\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n  const last = body.body[body.body.length - 1];\n  if (last.type === \"ExpressionStatement\") {\n    state.prepend(last, \"return (\");\n    state.append(last.expression, \")\");\n  }\n  return ArrayPrototypeJoin(state.hoistedDeclarationStatements, \"\") + ArrayPrototypeJoin(wrappedArray, \"\");\n}\nmodule.exports = {\n  processTopLevelAwait\n};\n}"],["internal/repl/history.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  Boolean,\n  FunctionPrototype,\n  StringPrototypeSplit,\n  StringPrototypeTrim\n} = primordials;\nconst { Interface } = require(\"readline\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"repl\", (fn) => {\n  debug = fn;\n});\nconst { clearTimeout, setTimeout } = require(\"timers\");\nconst noop = FunctionPrototype;\nconst kDebounceHistoryMS = 15;\nmodule.exports = setupHistory;\nfunction _writeToOutput(repl, message) {\n  repl._writeToOutput(message);\n  repl._refreshLine();\n}\nfunction setupHistory(repl, historyPath, ready) {\n  if (typeof historyPath === \"string\")\n    historyPath = StringPrototypeTrim(historyPath);\n  if (historyPath === \"\") {\n    repl._historyPrev = _replHistoryMessage;\n    return ready(null, repl);\n  }\n  if (!historyPath) {\n    try {\n      historyPath = path.join(os.homedir(), \".node_repl_history\");\n    } catch (err) {\n      _writeToOutput(repl, \"\\nError: Could not get the home directory.\\nREPL session history will not be persisted.\\n\");\n      debug(err.stack);\n      repl._historyPrev = _replHistoryMessage;\n      return ready(null, repl);\n    }\n  }\n  let timer = null;\n  let writing = false;\n  let pending = false;\n  repl.pause();\n  fs.open(historyPath, \"a+\", 384, oninit);\n  function oninit(err, hnd) {\n    if (err) {\n      _writeToOutput(repl, \"\\nError: Could not open history file.\\nREPL session history will not be persisted.\\n\");\n      debug(err.stack);\n      repl._historyPrev = _replHistoryMessage;\n      repl.resume();\n      return ready(null, repl);\n    }\n    fs.close(hnd, onclose);\n  }\n  function onclose(err) {\n    if (err) {\n      return ready(err);\n    }\n    fs.readFile(historyPath, \"utf8\", onread);\n  }\n  function onread(err, data) {\n    if (err) {\n      return ready(err);\n    }\n    if (data) {\n      repl.history = StringPrototypeSplit(data, /[\\n\\r]+/, repl.historySize);\n    } else {\n      repl.history = [];\n    }\n    fs.open(historyPath, \"r+\", onhandle);\n  }\n  function onhandle(err, hnd) {\n    if (err) {\n      return ready(err);\n    }\n    fs.ftruncate(hnd, 0, (err2) => {\n      repl._historyHandle = hnd;\n      repl.on(\"line\", online);\n      repl.once(\"exit\", onexit);\n      repl.once(\"flushHistory\", function() {\n        repl.resume();\n        ready(null, repl);\n      });\n      flushHistory();\n    });\n  }\n  function online(line) {\n    repl._flushing = true;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(flushHistory, kDebounceHistoryMS);\n  }\n  function flushHistory() {\n    timer = null;\n    if (writing) {\n      pending = true;\n      return;\n    }\n    writing = true;\n    const historyData = ArrayPrototypeJoin(repl.history, os.EOL);\n    fs.write(repl._historyHandle, historyData, 0, \"utf8\", onwritten);\n  }\n  function onwritten(err, data) {\n    writing = false;\n    if (pending) {\n      pending = false;\n      online();\n    } else {\n      repl._flushing = Boolean(timer);\n      if (!repl._flushing) {\n        repl.emit(\"flushHistory\");\n      }\n    }\n  }\n  function onexit() {\n    if (repl._flushing) {\n      repl.once(\"flushHistory\", onexit);\n      return;\n    }\n    repl.off(\"line\", online);\n    fs.close(repl._historyHandle, noop);\n  }\n}\nfunction _replHistoryMessage() {\n  if (this.history.length === 0) {\n    _writeToOutput(this, \"\\nPersistent history support disabled. Set the NODE_REPL_HISTORY environment\\nvariable to a valid, user-writable path to enable.\\n\");\n  }\n  this._historyPrev = Interface.prototype._historyPrev;\n  return this._historyPrev();\n}\n}"],["internal/repl/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeFilter,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeMap,\n  Boolean,\n  FunctionPrototypeBind,\n  MathMin,\n  RegExpPrototypeTest,\n  SafeSet,\n  SafeStringIterator,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  Symbol\n} = primordials;\nconst { tokTypes: tt, Parser: AcornParser } = require(\"internal/deps/acorn/acorn/dist/acorn\");\nconst { sendInspectorCommand } = require(\"internal/util/inspector\");\nconst {\n  ERR_INSPECTOR_NOT_AVAILABLE\n} = require(\"internal/errors\").codes;\nconst {\n  clearLine,\n  clearScreenDown,\n  cursorTo,\n  moveCursor\n} = require(\"internal/readline/callbacks\");\nconst {\n  commonPrefix,\n  kSubstringSearch\n} = require(\"internal/readline/utils\");\nconst {\n  getStringWidth,\n  inspect\n} = require(\"internal/util/inspect\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"repl\", (fn) => {\n  debug = fn;\n});\nconst previewOptions = {\n  colors: false,\n  depth: 1,\n  showHidden: false\n};\nconst REPL_MODE_STRICT = Symbol(\"repl-strict\");\nfunction isRecoverableError(e, code) {\n  if (RegExpPrototypeTest(/^\\s*\\{/, code) && isRecoverableError(e, `(${code}`))\n    return true;\n  let recoverable = false;\n  const RecoverableParser = AcornParser.extend((Parser) => {\n    return class extends Parser {\n      constructor(options, input, startPos) {\n        super(options, input, startPos);\n      }\n      nextToken() {\n        super.nextToken();\n        if (this.type === tt.eof)\n          recoverable = true;\n      }\n      raise(pos, message) {\n        switch (message) {\n          case \"Unterminated template\":\n          case \"Unterminated comment\":\n            recoverable = true;\n            break;\n          case \"Unterminated string constant\":\n            const token = StringPrototypeSlice(this.input, this.lastTokStart, this.pos);\n            if (RegExpPrototypeTest(/\\\\(?:\\r\\n?|\\n|\\u2028|\\u2029)$/, token)) {\n              recoverable = true;\n            }\n        }\n        super.raise(pos, message);\n      }\n    };\n  });\n  try {\n    RecoverableParser.parse(code, { ecmaVersion: \"latest\" });\n    return false;\n  } catch {\n    return recoverable;\n  }\n}\nfunction setupPreview(repl, contextSymbol, bufferSymbol, active) {\n  if (process.env.TERM === \"dumb\" || !active) {\n    return { showPreview() {\n    }, clearPreview() {\n    } };\n  }\n  let inputPreview = null;\n  let lastInputPreview = \"\";\n  let previewCompletionCounter = 0;\n  let completionPreview = null;\n  let hasCompletions = false;\n  let wrapped = false;\n  let escaped = null;\n  function getPreviewPos() {\n    const displayPos = repl._getDisplayPos(`${repl.getPrompt()}${repl.line}`);\n    const cursorPos = repl.line.length !== repl.cursor ? repl.getCursorPos() : displayPos;\n    return { displayPos, cursorPos };\n  }\n  function isCursorAtInputEnd() {\n    const { cursorPos, displayPos } = getPreviewPos();\n    return cursorPos.rows === displayPos.rows && cursorPos.cols === displayPos.cols;\n  }\n  const clearPreview = (key) => {\n    if (inputPreview !== null) {\n      const { displayPos, cursorPos } = getPreviewPos();\n      const rows = displayPos.rows - cursorPos.rows + 1;\n      moveCursor(repl.output, 0, rows);\n      clearLine(repl.output);\n      moveCursor(repl.output, 0, -rows);\n      lastInputPreview = inputPreview;\n      inputPreview = null;\n    }\n    if (completionPreview !== null) {\n      const move = repl.line.length !== repl.cursor;\n      let pos, rows;\n      if (move) {\n        pos = getPreviewPos();\n        cursorTo(repl.output, pos.displayPos.cols);\n        rows = pos.displayPos.rows - pos.cursorPos.rows;\n        moveCursor(repl.output, 0, rows);\n      }\n      const totalLine = `${repl.getPrompt()}${repl.line}${completionPreview}`;\n      const newPos = repl._getDisplayPos(totalLine);\n      if (newPos.rows === 0 || pos && pos.displayPos.rows === newPos.rows) {\n        clearLine(repl.output, 1);\n      } else {\n        clearScreenDown(repl.output);\n      }\n      if (move) {\n        cursorTo(repl.output, pos.cursorPos.cols);\n        moveCursor(repl.output, 0, -rows);\n      }\n      if (!key.ctrl && !key.shift) {\n        if (key.name === \"escape\") {\n          if (escaped === null && key.meta) {\n            escaped = repl.line;\n          }\n        } else if ((key.name === \"return\" || key.name === \"enter\") && !key.meta && escaped !== repl.line && isCursorAtInputEnd()) {\n          repl._insertString(completionPreview);\n        }\n      }\n      completionPreview = null;\n    }\n    if (escaped !== repl.line) {\n      escaped = null;\n    }\n  };\n  function showCompletionPreview(line, insertPreview) {\n    previewCompletionCounter++;\n    const count = previewCompletionCounter;\n    repl.completer(line, (error, data) => {\n      if (count !== previewCompletionCounter) {\n        return;\n      }\n      if (error) {\n        debug(\"Error while generating completion preview\", error);\n        return;\n      }\n      const { 0: rawCompletions, 1: completeOn } = data;\n      if (!rawCompletions || rawCompletions.length === 0) {\n        return;\n      }\n      hasCompletions = true;\n      const completions = ArrayPrototypeFilter(rawCompletions, Boolean);\n      const prefix = commonPrefix(completions);\n      if (prefix.length <= completeOn.length) {\n        return;\n      }\n      const suffix = StringPrototypeSlice(prefix, completeOn.length);\n      if (insertPreview) {\n        repl._insertString(suffix);\n        return;\n      }\n      completionPreview = suffix;\n      const result = repl.useColors ? `\u001b[90m${suffix}\u001b[39m` : ` // ${suffix}`;\n      const { cursorPos, displayPos } = getPreviewPos();\n      if (repl.line.length !== repl.cursor) {\n        cursorTo(repl.output, displayPos.cols);\n        moveCursor(repl.output, 0, displayPos.rows - cursorPos.rows);\n      }\n      repl.output.write(result);\n      cursorTo(repl.output, cursorPos.cols);\n      const totalLine = `${repl.getPrompt()}${repl.line}${suffix}`;\n      const newPos = repl._getDisplayPos(totalLine);\n      const rows = newPos.rows - cursorPos.rows - (newPos.cols === 0 ? 1 : 0);\n      moveCursor(repl.output, 0, -rows);\n    });\n  }\n  function isInStrictMode(repl2) {\n    return repl2.replMode === REPL_MODE_STRICT || ArrayPrototypeIncludes(ArrayPrototypeMap(process.execArgv, (e) => StringPrototypeReplace(StringPrototypeToLowerCase(e), /_/g, \"-\")), \"--use-strict\");\n  }\n  function getInputPreview(input, callback) {\n    if (StringPrototypeStartsWith(input, \"{\") && !StringPrototypeEndsWith(input, \";\") && !wrapped) {\n      input = `(${input})`;\n      wrapped = true;\n    }\n    sendInspectorCommand((session) => {\n      session.post(\"Runtime.evaluate\", {\n        expression: input,\n        throwOnSideEffect: true,\n        timeout: 333,\n        contextId: repl[contextSymbol]\n      }, (error, preview) => {\n        if (error) {\n          callback(error);\n          return;\n        }\n        const { result } = preview;\n        if (result.value !== void 0) {\n          callback(null, inspect(result.value, previewOptions));\n        } else if (preview.exceptionDetails && (result.className === \"EvalError\" || result.className === \"SyntaxError\" || result.className === \"ReferenceError\" && (hasCompletions || !isInStrictMode(repl)))) {\n          callback(null, null);\n        } else if (result.objectId) {\n          const inspectOptions = inspect({\n            ...repl.writer.options,\n            colors: false,\n            depth: 1,\n            compact: true,\n            breakLength: Infinity\n          }, previewOptions);\n          session.post(\"Runtime.callFunctionOn\", {\n            functionDeclaration: `(v) =>\n                    Reflect\n                    .getOwnPropertyDescriptor(globalThis, 'util')\n                    .get().inspect(v, ${inspectOptions})`,\n            objectId: result.objectId,\n            arguments: [result]\n          }, (error2, preview2) => {\n            if (error2) {\n              callback(error2);\n            } else {\n              callback(null, preview2.result.value);\n            }\n          });\n        } else {\n          callback(null, result.unserializableValue || result.type);\n        }\n      });\n    }, () => callback(new ERR_INSPECTOR_NOT_AVAILABLE()));\n  }\n  const showPreview = () => {\n    if (inputPreview !== null || !repl.isCompletionEnabled) {\n      return;\n    }\n    const line = StringPrototypeTrim(repl.line);\n    if (line === \"\") {\n      return;\n    }\n    hasCompletions = false;\n    const insertPreview = false;\n    showCompletionPreview(repl.line, insertPreview);\n    if (repl[bufferSymbol]) {\n      return;\n    }\n    const inputPreviewCallback = (error, inspected) => {\n      if (inspected == null) {\n        return;\n      }\n      wrapped = false;\n      if (line === inspected && lastInputPreview !== inspected) {\n        return;\n      }\n      if (error) {\n        debug(\"Error while generating preview\", error);\n        return;\n      }\n      if (inspected === \"undefined\" && (!repl.useColors || repl.ignoreUndefined)) {\n        return;\n      }\n      inputPreview = inspected;\n      let maxColumns = MathMin(repl.columns, 250);\n      if (inspected.length * 2 >= maxColumns && getStringWidth(inspected) > maxColumns) {\n        maxColumns -= 4 + (repl.useColors ? 0 : 3);\n        let res = \"\";\n        for (const char of new SafeStringIterator(inspected)) {\n          maxColumns -= getStringWidth(char);\n          if (maxColumns < 0)\n            break;\n          res += char;\n        }\n        inspected = `${res}...`;\n      }\n      const lineBreakPos = StringPrototypeIndexOf(inspected, \"\\n\");\n      if (lineBreakPos !== -1) {\n        inspected = `${StringPrototypeSlice(inspected, 0, lineBreakPos)}`;\n      }\n      const result = repl.useColors ? `\u001b[90m${inspected}\u001b[39m` : `// ${inspected}`;\n      const { cursorPos, displayPos } = getPreviewPos();\n      const rows = displayPos.rows - cursorPos.rows;\n      moveCursor(repl.output, 0, rows);\n      repl.output.write(`\n${result}`);\n      cursorTo(repl.output, cursorPos.cols);\n      moveCursor(repl.output, 0, -rows - 1);\n    };\n    let previewLine = line;\n    if (completionPreview !== null && isCursorAtInputEnd() && escaped !== repl.line) {\n      previewLine += completionPreview;\n    }\n    getInputPreview(previewLine, inputPreviewCallback);\n    if (wrapped) {\n      getInputPreview(previewLine, inputPreviewCallback);\n    }\n    wrapped = false;\n  };\n  const originalRefresh = FunctionPrototypeBind(repl._refreshLine, repl);\n  repl._refreshLine = () => {\n    inputPreview = null;\n    originalRefresh();\n    showPreview();\n  };\n  let insertCompletionPreview = true;\n  const originalMoveCursor = FunctionPrototypeBind(repl._moveCursor, repl);\n  repl._moveCursor = (dx) => {\n    const currentCursor = repl.cursor;\n    originalMoveCursor(dx);\n    if (currentCursor + dx > repl.line.length && typeof repl.completer === \"function\" && insertCompletionPreview) {\n      const insertPreview = true;\n      showCompletionPreview(repl.line, insertPreview);\n    }\n  };\n  const originalClearLine = FunctionPrototypeBind(repl.clearLine, repl);\n  repl.clearLine = () => {\n    insertCompletionPreview = false;\n    originalClearLine();\n    insertCompletionPreview = true;\n  };\n  return { showPreview, clearPreview };\n}\nfunction setupReverseSearch(repl) {\n  if (process.env.TERM === \"dumb\") {\n    return { reverseSearch() {\n      return false;\n    } };\n  }\n  const alreadyMatched = new SafeSet();\n  const labels = {\n    r: \"bck-i-search: \",\n    s: \"fwd-i-search: \"\n  };\n  let isInReverseSearch = false;\n  let historyIndex = -1;\n  let input = \"\";\n  let cursor = -1;\n  let dir = \"r\";\n  let lastMatch = -1;\n  let lastCursor = -1;\n  let promptPos;\n  function checkAndSetDirectionKey(keyName) {\n    if (!labels[keyName]) {\n      return false;\n    }\n    if (dir !== keyName) {\n      alreadyMatched.clear();\n      dir = keyName;\n    }\n    return true;\n  }\n  function goToNextHistoryIndex() {\n    alreadyMatched.add(repl.history[historyIndex]);\n    historyIndex += dir === \"r\" ? 1 : -1;\n    cursor = -1;\n  }\n  function search() {\n    if (input === \"\") {\n      print(repl.line, `${labels[dir]}_`);\n      return;\n    }\n    if (dir === \"r\") {\n      if (historyIndex < 0) {\n        historyIndex = 0;\n      }\n    } else if (historyIndex >= repl.history.length) {\n      historyIndex = repl.history.length - 1;\n    }\n    while (historyIndex >= 0 && historyIndex < repl.history.length) {\n      let entry = repl.history[historyIndex];\n      if (alreadyMatched.has(entry)) {\n        historyIndex += dir === \"r\" ? 1 : -1;\n        continue;\n      }\n      if (dir === \"r\") {\n        if (cursor === -1) {\n          cursor = entry.length;\n        }\n        cursor = StringPrototypeLastIndexOf(entry, input, cursor - 1);\n      } else {\n        cursor = StringPrototypeIndexOf(entry, input, cursor + 1);\n      }\n      if (cursor === -1) {\n        goToNextHistoryIndex();\n      } else {\n        if (repl.useColors) {\n          const start = StringPrototypeSlice(entry, 0, cursor);\n          const end = StringPrototypeSlice(entry, cursor + input.length);\n          entry = `${start}\u001b[4m${input}\u001b[24m${end}`;\n        }\n        print(entry, `${labels[dir]}${input}_`, cursor);\n        lastMatch = historyIndex;\n        lastCursor = cursor;\n        if (dir === \"r\" && cursor === 0 || dir === \"s\" && entry.length === cursor + input.length) {\n          goToNextHistoryIndex();\n        }\n        return;\n      }\n    }\n    print(repl.line, `failed-${labels[dir]}${input}_`);\n  }\n  function print(outputLine, inputLine, cursor2 = repl.cursor) {\n    let rows = 0;\n    if (lastMatch !== -1) {\n      const line = StringPrototypeSlice(repl.history[lastMatch], 0, lastCursor);\n      rows = repl._getDisplayPos(`${repl.getPrompt()}${line}`).rows;\n      cursorTo(repl.output, promptPos.cols);\n    } else if (isInReverseSearch && repl.line !== \"\") {\n      rows = repl.getCursorPos().rows;\n      cursorTo(repl.output, promptPos.cols);\n    }\n    if (rows !== 0)\n      moveCursor(repl.output, 0, -rows);\n    if (isInReverseSearch) {\n      clearScreenDown(repl.output);\n      repl.output.write(`${outputLine}\n${inputLine}`);\n    } else {\n      repl.output.write(`\n${inputLine}`);\n    }\n    lastMatch = -1;\n    const prompt = repl.getPrompt();\n    const cursorLine = prompt + StringPrototypeSlice(outputLine, 0, cursor2);\n    const cursorPos = repl._getDisplayPos(cursorLine);\n    const outputPos = repl._getDisplayPos(`${prompt}${outputLine}`);\n    const inputPos = repl._getDisplayPos(inputLine);\n    const inputRows = inputPos.rows - (inputPos.cols === 0 ? 1 : 0);\n    rows = -1 - inputRows - (outputPos.rows - cursorPos.rows);\n    moveCursor(repl.output, 0, rows);\n    cursorTo(repl.output, cursorPos.cols);\n  }\n  function reset(string) {\n    isInReverseSearch = string !== void 0;\n    if (!isInReverseSearch) {\n      if (lastMatch !== -1) {\n        repl.line = repl.history[lastMatch];\n        repl.cursor = lastCursor;\n        repl.historyIndex = lastMatch;\n      }\n      lastMatch = -1;\n      cursorTo(repl.output, promptPos.cols);\n      moveCursor(repl.output, 0, promptPos.rows);\n      clearScreenDown(repl.output);\n      if (repl.line !== \"\") {\n        repl.output.write(repl.line);\n        if (repl.line.length !== repl.cursor) {\n          const { cols, rows } = repl.getCursorPos();\n          cursorTo(repl.output, cols);\n          moveCursor(repl.output, 0, rows);\n        }\n      }\n    }\n    input = string || \"\";\n    cursor = -1;\n    historyIndex = repl.historyIndex;\n    alreadyMatched.clear();\n  }\n  function reverseSearch(string, key) {\n    if (!isInReverseSearch) {\n      if (key.ctrl && checkAndSetDirectionKey(key.name)) {\n        historyIndex = repl.historyIndex;\n        promptPos = repl._getDisplayPos(`${repl.getPrompt()}`);\n        print(repl.line, `${labels[dir]}_`);\n        isInReverseSearch = true;\n      }\n    } else if (key.ctrl && checkAndSetDirectionKey(key.name)) {\n      search();\n    } else if (key.name === \"backspace\" || key.ctrl && (key.name === \"h\" || key.name === \"w\")) {\n      reset(StringPrototypeSlice(input, 0, input.length - 1));\n      search();\n    } else if (key.ctrl && key.name === \"c\" || key.name === \"escape\") {\n      lastMatch = -1;\n      reset();\n      return true;\n    } else if (key.ctrl || key.meta || key.name === \"return\" || key.name === \"enter\" || typeof string !== \"string\" || string === \"\") {\n      reset();\n      repl[kSubstringSearch] = \"\";\n    } else {\n      reset(`${input}${string}`);\n      search();\n    }\n    return isInReverseSearch;\n  }\n  return { reverseSearch };\n}\nmodule.exports = {\n  REPL_MODE_SLOPPY: Symbol(\"repl-sloppy\"),\n  REPL_MODE_STRICT,\n  isRecoverableError,\n  kStandaloneREPL: Symbol(\"kStandaloneREPL\"),\n  setupPreview,\n  setupReverseSearch\n};\n}"],["internal/source_map/prepare_stack_trace.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ErrorPrototypeToString,\n  StringPrototypeRepeat,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SafeStringIterator\n} = primordials;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"source_map\", (fn) => {\n  debug = fn;\n});\nconst { getStringWidth } = require(\"internal/util/inspect\");\nconst { readFileSync } = require(\"fs\");\nconst { findSourceMap } = require(\"internal/source_map/source_map_cache\");\nconst {\n  kNoOverride,\n  overrideStackTrace,\n  maybeOverridePrepareStackTrace,\n  kIsNodeError\n} = require(\"internal/errors\");\nconst { fileURLToPath } = require(\"internal/url\");\nconst prepareStackTrace = (globalThis, error, trace) => {\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error, trace);\n  }\n  const globalOverride = maybeOverridePrepareStackTrace(globalThis, error, trace);\n  if (globalOverride !== kNoOverride)\n    return globalOverride;\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  let errorSource = \"\";\n  let lastSourceMap;\n  let lastFileName;\n  const preparedTrace = ArrayPrototypeJoin(ArrayPrototypeMap(trace, (t, i) => {\n    const str = i !== 0 ? \"\\n    at \" : \"\";\n    try {\n      const fileName = t.getFileName();\n      const sm = fileName === lastFileName ? lastSourceMap : findSourceMap(fileName);\n      lastSourceMap = sm;\n      lastFileName = fileName;\n      if (sm) {\n        const {\n          originalLine,\n          originalColumn,\n          originalSource\n        } = sm.findEntry(t.getLineNumber() - 1, t.getColumnNumber() - 1);\n        if (originalSource && originalLine !== void 0 && originalColumn !== void 0) {\n          const name = getOriginalSymbolName(sm, trace, i);\n          if (i === 0) {\n            errorSource = getErrorSource(sm, originalSource, originalLine, originalColumn);\n          }\n          const fnName = t.getFunctionName() ?? t.getMethodName();\n          const originalName = `${t.getTypeName() !== \"global\" ? `${t.getTypeName()}.` : \"\"}${fnName ? fnName : \"<anonymous>\"}`;\n          const prefix = name && name !== originalName ? `${name}` : `${originalName ? originalName : \"\"}`;\n          const hasName = !!(name || originalName);\n          const originalSourceNoScheme = StringPrototypeStartsWith(originalSource, \"file://\") ? fileURLToPath(originalSource) : originalSource;\n          return `${str}${prefix}${hasName ? \" (\" : \"\"}${originalSourceNoScheme}:${originalLine + 1}:${originalColumn + 1}${hasName ? \")\" : \"\"}`;\n        }\n      }\n    } catch (err) {\n      debug(err.stack);\n    }\n    return `${str}${t}`;\n  }), \"\");\n  return `${errorSource}${errorString}\n    at ${preparedTrace}`;\n};\nfunction getOriginalSymbolName(sourceMap, trace, curIndex) {\n  const enclosingEntry = sourceMap.findEntry(trace[curIndex].getEnclosingLineNumber() - 1, trace[curIndex].getEnclosingColumnNumber() - 1);\n  if (enclosingEntry.name)\n    return enclosingEntry.name;\n  const currentFileName = trace[curIndex].getFileName();\n  const nextCallSite = trace[curIndex + 1];\n  if (nextCallSite && currentFileName === nextCallSite.getFileName()) {\n    const { name } = sourceMap.findEntry(nextCallSite.getLineNumber() - 1, nextCallSite.getColumnNumber() - 1);\n    return name;\n  }\n}\nfunction getErrorSource(sourceMap, originalSourcePath, originalLine, originalColumn) {\n  let exceptionLine = \"\";\n  const originalSourcePathNoScheme = StringPrototypeStartsWith(originalSourcePath, \"file://\") ? fileURLToPath(originalSourcePath) : originalSourcePath;\n  const source = getOriginalSource(sourceMap.payload, originalSourcePathNoScheme);\n  const lines = StringPrototypeSplit(source, /\\r?\\n/, originalLine + 1);\n  const line = lines[originalLine];\n  if (!line)\n    return exceptionLine;\n  let prefix = \"\";\n  for (const character of new SafeStringIterator(StringPrototypeSlice(line, 0, originalColumn + 1))) {\n    prefix += character === \"\t\" ? \"\t\" : StringPrototypeRepeat(\" \", getStringWidth(character));\n  }\n  prefix = StringPrototypeSlice(prefix, 0, -1);\n  exceptionLine = `${originalSourcePathNoScheme}:${originalLine + 1}\n${line}\n${prefix}^\n\n`;\n  return exceptionLine;\n}\nfunction getOriginalSource(payload, originalSourcePath) {\n  let source;\n  const originalSourcePathNoScheme = StringPrototypeStartsWith(originalSourcePath, \"file://\") ? fileURLToPath(originalSourcePath) : originalSourcePath;\n  const sourceContentIndex = ArrayPrototypeIndexOf(payload.sources, originalSourcePath);\n  if (payload.sourcesContent?.[sourceContentIndex]) {\n    source = payload.sourcesContent[sourceContentIndex];\n  } else {\n    try {\n      source = readFileSync(originalSourcePathNoScheme, \"utf8\");\n    } catch (err) {\n      debug(err);\n      source = \"\";\n    }\n  }\n  return source;\n}\nmodule.exports = {\n  prepareStackTrace\n};\n}"],["internal/source_map/source_map.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  ObjectPrototypeHasOwnProperty,\n  StringPrototypeCharAt\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE\n} = require(\"internal/errors\").codes;\nlet base64Map;\nconst VLQ_BASE_SHIFT = 5;\nconst VLQ_BASE_MASK = (1 << 5) - 1;\nconst VLQ_CONTINUATION_MASK = 1 << 5;\nclass StringCharIterator {\n  constructor(string) {\n    this._string = string;\n    this._position = 0;\n  }\n  next() {\n    return StringPrototypeCharAt(this._string, this._position++);\n  }\n  peek() {\n    return StringPrototypeCharAt(this._string, this._position);\n  }\n  hasNext() {\n    return this._position < this._string.length;\n  }\n}\nclass SourceMap {\n  #payload;\n  #mappings = [];\n  #sources = {};\n  #sourceContentByURL = {};\n  constructor(payload) {\n    if (!base64Map) {\n      const base64Digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      base64Map = {};\n      for (let i = 0; i < base64Digits.length; ++i)\n        base64Map[base64Digits[i]] = i;\n    }\n    this.#payload = cloneSourceMapV3(payload);\n    this.#parseMappingPayload();\n  }\n  get payload() {\n    return cloneSourceMapV3(this.#payload);\n  }\n  #parseMappingPayload = () => {\n    if (this.#payload.sections) {\n      this.#parseSections(this.#payload.sections);\n    } else {\n      this.#parseMap(this.#payload, 0, 0);\n    }\n    ArrayPrototypeSort(this.#mappings, compareSourceMapEntry);\n  };\n  #parseSections = (sections) => {\n    for (let i = 0; i < sections.length; ++i) {\n      const section = sections[i];\n      this.#parseMap(section.map, section.offset.line, section.offset.column);\n    }\n  };\n  findEntry(lineNumber, columnNumber) {\n    let first = 0;\n    let count = this.#mappings.length;\n    while (count > 1) {\n      const step = count >> 1;\n      const middle = first + step;\n      const mapping = this.#mappings[middle];\n      if (lineNumber < mapping[0] || lineNumber === mapping[0] && columnNumber < mapping[1]) {\n        count = step;\n      } else {\n        first = middle;\n        count -= step;\n      }\n    }\n    const entry = this.#mappings[first];\n    if (!first && entry && (lineNumber < entry[0] || lineNumber === entry[0] && columnNumber < entry[1])) {\n      return {};\n    } else if (!entry) {\n      return {};\n    }\n    return {\n      generatedLine: entry[0],\n      generatedColumn: entry[1],\n      originalSource: entry[2],\n      originalLine: entry[3],\n      originalColumn: entry[4],\n      name: entry[5]\n    };\n  }\n  #parseMap(map, lineNumber, columnNumber) {\n    let sourceIndex = 0;\n    let sourceLineNumber = 0;\n    let sourceColumnNumber = 0;\n    let nameIndex = 0;\n    const sources = [];\n    const originalToCanonicalURLMap = {};\n    for (let i = 0; i < map.sources.length; ++i) {\n      const url = map.sources[i];\n      originalToCanonicalURLMap[url] = url;\n      ArrayPrototypePush(sources, url);\n      this.#sources[url] = true;\n      if (map.sourcesContent && map.sourcesContent[i])\n        this.#sourceContentByURL[url] = map.sourcesContent[i];\n    }\n    const stringCharIterator = new StringCharIterator(map.mappings);\n    let sourceURL = sources[sourceIndex];\n    while (true) {\n      if (stringCharIterator.peek() === \",\")\n        stringCharIterator.next();\n      else {\n        while (stringCharIterator.peek() === \";\") {\n          lineNumber += 1;\n          columnNumber = 0;\n          stringCharIterator.next();\n        }\n        if (!stringCharIterator.hasNext())\n          break;\n      }\n      columnNumber += decodeVLQ(stringCharIterator);\n      if (isSeparator(stringCharIterator.peek())) {\n        ArrayPrototypePush(this.#mappings, [lineNumber, columnNumber]);\n        continue;\n      }\n      const sourceIndexDelta = decodeVLQ(stringCharIterator);\n      if (sourceIndexDelta) {\n        sourceIndex += sourceIndexDelta;\n        sourceURL = sources[sourceIndex];\n      }\n      sourceLineNumber += decodeVLQ(stringCharIterator);\n      sourceColumnNumber += decodeVLQ(stringCharIterator);\n      let name;\n      if (!isSeparator(stringCharIterator.peek())) {\n        nameIndex += decodeVLQ(stringCharIterator);\n        name = map.names?.[nameIndex];\n      }\n      ArrayPrototypePush(this.#mappings, [\n        lineNumber,\n        columnNumber,\n        sourceURL,\n        sourceLineNumber,\n        sourceColumnNumber,\n        name\n      ]);\n    }\n  }\n}\nfunction isSeparator(char) {\n  return char === \",\" || char === \";\";\n}\nfunction decodeVLQ(stringCharIterator) {\n  let result = 0;\n  let shift = 0;\n  let digit;\n  do {\n    digit = base64Map[stringCharIterator.next()];\n    result += (digit & VLQ_BASE_MASK) << shift;\n    shift += VLQ_BASE_SHIFT;\n  } while (digit & VLQ_CONTINUATION_MASK);\n  const negative = result & 1;\n  result >>>= 1;\n  if (!negative) {\n    return result;\n  }\n  return -result | 1 << 31;\n}\nfunction cloneSourceMapV3(payload) {\n  if (typeof payload !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"payload\", [\"Object\"], payload);\n  }\n  payload = { ...payload };\n  for (const key in payload) {\n    if (ObjectPrototypeHasOwnProperty(payload, key) && ArrayIsArray(payload[key])) {\n      payload[key] = ArrayPrototypeSlice(payload[key]);\n    }\n  }\n  return payload;\n}\nfunction compareSourceMapEntry(entry1, entry2) {\n  const { 0: lineNumber1, 1: columnNumber1 } = entry1;\n  const { 0: lineNumber2, 1: columnNumber2 } = entry2;\n  if (lineNumber1 !== lineNumber2) {\n    return lineNumber1 - lineNumber2;\n  }\n  return columnNumber1 - columnNumber2;\n}\nmodule.exports = {\n  SourceMap\n};\n}"],["internal/source_map/source_map_cache.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeMap,\n  JSONParse,\n  ObjectCreate,\n  ObjectKeys,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  StringPrototypeMatch,\n  StringPrototypeSplit\n} = primordials;\nfunction ObjectGetValueSafe(obj, key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n  return ObjectPrototypeHasOwnProperty(desc, \"value\") ? desc.value : void 0;\n}\nconst { Buffer } = require(\"buffer\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"source_map\", (fn) => {\n  debug = fn;\n});\nconst fs = require(\"fs\");\nconst { getOptionValue } = require(\"internal/options\");\nconst { IterableWeakMap } = require(\"internal/util/iterable_weak_map\");\nconst {\n  normalizeReferrerURL\n} = require(\"internal/modules/cjs/helpers\");\nconst { validateBoolean } = require(\"internal/validators\");\nconst cjsSourceMapCache = new IterableWeakMap();\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath, pathToFileURL, URL } = require(\"internal/url\");\nlet SourceMap;\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === void 0) {\n    setSourceMapsEnabled(getOptionValue(\"--enable-source-maps\"));\n  }\n  return sourceMapsEnabled;\n}\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val, \"val\");\n  const {\n    setSourceMapsEnabled: setSourceMapsEnabled2,\n    setPrepareStackTraceCallback\n  } = internalBinding(\"errors\");\n  setSourceMapsEnabled2(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require(\"internal/source_map/prepare_stack_trace\");\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== void 0) {\n    const {\n      prepareStackTrace\n    } = require(\"internal/errors\");\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n  sourceMapsEnabled = val;\n}\nfunction maybeCacheSourceMap(filename, content, cjsModuleInstance) {\n  const sourceMapsEnabled2 = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled2))\n    return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    debug(err.stack);\n    return;\n  }\n  const match = StringPrototypeMatch(content, /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/);\n  if (match) {\n    const data = dataFromUrl(filename, match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance, {\n        filename,\n        lineLengths: lineLengths(content),\n        data,\n        url\n      });\n    } else {\n      esmSourceMapCache.set(filename, {\n        lineLengths: lineLengths(content),\n        data,\n        url\n      });\n    }\n  }\n}\nfunction dataFromUrl(sourceURL, sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case \"data:\":\n        return sourceMapFromDataUrl(sourceURL, url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    const mapURL = new URL(sourceMappingURL, sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\nfunction lineLengths(content) {\n  return ArrayPrototypeMap(StringPrototypeSplit(content, /\\n|\\u2028|\\u2029/), (line) => {\n    return line.length;\n  });\n}\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL), \"utf8\");\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL, data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\nfunction sourceMapFromDataUrl(sourceURL, url) {\n  const { 0: format, 1: data } = StringPrototypeSplit(url, \",\");\n  const splitFormat = StringPrototypeSplit(format, \";\");\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === \"base64\";\n  if (contentType === \"application/json\") {\n    const decodedData = base64 ? Buffer.from(data, \"base64\").toString(\"utf8\") : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL, parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\nfunction sourcesToAbsolute(baseURL, data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || \"\") + source;\n    return new URL(source, baseURL).href;\n  });\n  data.sourceRoot = \"\";\n  return data;\n}\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n  for (const { 0: k, 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n  appendCJSCache(obj);\n  if (ObjectKeys(obj).length === 0) {\n    return void 0;\n  }\n  return obj;\n}\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value, \"filename\")] = {\n      lineLengths: ObjectGetValueSafe(value, \"lineLengths\"),\n      data: ObjectGetValueSafe(value, \"data\"),\n      url: ObjectGetValueSafe(value, \"url\")\n    };\n  }\n}\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//, sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require(\"internal/source_map/source_map\").SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === void 0) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value, \"filename\");\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value, \"data\")\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return void 0;\n}\nmodule.exports = {\n  findSourceMap,\n  getSourceMapsEnabled,\n  setSourceMapsEnabled,\n  maybeCacheSourceMap,\n  sourceMapCacheToObject\n};\n}"],["internal/streams/add-abort-signal.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  AbortError,\n  codes\n} = require(\"internal/errors\");\nconst eos = require(\"internal/streams/end-of-stream\");\nconst { ERR_INVALID_ARG_TYPE } = codes;\nconst validateAbortSignal = (signal, name) => {\n  if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n    throw new ERR_INVALID_ARG_TYPE(name, \"AbortSignal\", signal);\n  }\n};\nfunction isNodeStream(obj) {\n  return !!(obj && typeof obj.pipe === \"function\");\n}\nmodule.exports.addAbortSignal = function addAbortSignal(signal, stream) {\n  validateAbortSignal(signal, \"signal\");\n  if (!isNodeStream(stream)) {\n    throw new ERR_INVALID_ARG_TYPE(\"stream\", \"stream.Stream\", stream);\n  }\n  return module.exports.addAbortSignalNoValidate(signal, stream);\n};\nmodule.exports.addAbortSignalNoValidate = function(signal, stream) {\n  if (typeof signal !== \"object\" || !(\"aborted\" in signal)) {\n    return stream;\n  }\n  const onAbort = () => {\n    stream.destroy(new AbortError());\n  };\n  if (signal.aborted) {\n    onAbort();\n  } else {\n    signal.addEventListener(\"abort\", onAbort);\n    eos(stream, () => signal.removeEventListener(\"abort\", onAbort));\n  }\n  return stream;\n};\n}"],["internal/streams/buffer_list.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  StringPrototypeSlice,\n  SymbolIterator,\n  TypedArrayPrototypeSet,\n  Uint8Array\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst { inspect } = require(\"internal/util/inspect\");\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  push(v) {\n    const entry = { data: v, next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n  unshift(v) {\n    const entry = { data: v, next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n  join(s) {\n    if (this.length === 0)\n      return \"\";\n    let p = this.head;\n    let ret = \"\" + p.data;\n    while (p = p.next)\n      ret += s + p.data;\n    return ret;\n  }\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n  consume(n, hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      const slice = data.slice(0, n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      return this.shift();\n    }\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n  first() {\n    return this.head.data;\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n  _getString(n) {\n    let ret = \"\";\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str, 0, n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str, n);\n        }\n        break;\n      }\n      ++c;\n    } while (p = p.next);\n    this.length -= c;\n    return ret;\n  }\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while (p = p.next);\n    this.length -= c;\n    return ret;\n  }\n  [inspect.custom](_, options) {\n    return inspect(this, {\n      ...options,\n      depth: 0,\n      customInspect: false\n    });\n  }\n};\n}"],["internal/streams/compose.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { pipeline } = require(\"internal/streams/pipeline\");\nconst Duplex = require(\"internal/streams/duplex\");\nconst { destroyer } = require(\"internal/streams/destroy\");\nconst {\n  isNodeStream,\n  isReadable,\n  isWritable\n} = require(\"internal/streams/utils\");\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_MISSING_ARGS\n  }\n} = require(\"internal/errors\");\nclass ComposeDuplex extends Duplex {\n  constructor(options) {\n    super(options);\n    if (options?.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n    if (options?.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  }\n}\nmodule.exports = function compose(...streams) {\n  if (streams.length === 0) {\n    throw new ERR_MISSING_ARGS(\"streams\");\n  }\n  if (streams.length === 1) {\n    return Duplex.from(streams[0]);\n  }\n  const orgStreams = [...streams];\n  if (typeof streams[0] === \"function\") {\n    streams[0] = Duplex.from(streams[0]);\n  }\n  if (typeof streams[streams.length - 1] === \"function\") {\n    const idx = streams.length - 1;\n    streams[idx] = Duplex.from(streams[idx]);\n  }\n  for (let n = 0; n < streams.length; ++n) {\n    if (!isNodeStream(streams[n])) {\n      continue;\n    }\n    if (n < streams.length - 1 && !isReadable(streams[n])) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be readable\");\n    }\n    if (n > 0 && !isWritable(streams[n])) {\n      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], \"must be writable\");\n    }\n  }\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n  const head = streams[0];\n  const tail = pipeline(streams, onfinished);\n  const writable = !!isWritable(head);\n  const readable = !!isReadable(tail);\n  d = new ComposeDuplex({\n    writableObjectMode: !!head?.writableObjectMode,\n    readableObjectMode: !!tail?.writableObjectMode,\n    writable,\n    readable\n  });\n  if (writable) {\n    d._write = function(chunk, encoding, callback) {\n      if (head.write(chunk, encoding)) {\n        callback();\n      } else {\n        ondrain = callback;\n      }\n    };\n    d._final = function(callback) {\n      head.end();\n      onfinish = callback;\n    };\n    head.on(\"drain\", function() {\n      if (ondrain) {\n        const cb = ondrain;\n        ondrain = null;\n        cb();\n      }\n    });\n    tail.on(\"finish\", function() {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n  if (readable) {\n    tail.on(\"readable\", function() {\n      if (onreadable) {\n        const cb = onreadable;\n        onreadable = null;\n        cb();\n      }\n    });\n    tail.on(\"end\", function() {\n      d.push(null);\n    });\n    d._read = function() {\n      while (true) {\n        const buf = tail.read();\n        if (buf === null) {\n          onreadable = d._read;\n          return;\n        }\n        if (!d.push(buf)) {\n          return;\n        }\n      }\n    };\n  }\n  d._destroy = function(err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      destroyer(tail, err);\n    }\n  };\n  return d;\n};\n}"],["internal/streams/destroy.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_MULTIPLE_CALLBACK\n  },\n  AbortError\n} = require(\"internal/errors\");\nconst {\n  Symbol\n} = primordials;\nconst {\n  kDestroyed,\n  isDestroyed,\n  isFinished,\n  isServerRequest\n} = require(\"internal/streams/utils\");\nconst kDestroy = Symbol(\"kDestroy\");\nconst kConstruct = Symbol(\"kConstruct\");\nfunction checkError(err, w, r) {\n  if (err) {\n    err.stack;\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\nfunction destroy(err, cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  const s = w || r;\n  if (w && w.destroyed || r && r.destroyed) {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n    return this;\n  }\n  checkError(err, w, r);\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n  if (!s.constructed) {\n    this.once(kDestroy, function(er) {\n      _destroy(this, aggregateTwoErrors(er, err), cb);\n    });\n  } else {\n    _destroy(this, err, cb);\n  }\n  return this;\n}\nfunction _destroy(self, err, cb) {\n  let called = false;\n  function onDestroy(err2) {\n    if (called) {\n      return;\n    }\n    called = true;\n    const r = self._readableState;\n    const w = self._writableState;\n    checkError(err2, w, r);\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n    if (typeof cb === \"function\") {\n      cb(err2);\n    }\n    if (err2) {\n      process.nextTick(emitErrorCloseNT, self, err2);\n    } else {\n      process.nextTick(emitCloseNT, self);\n    }\n  }\n  try {\n    const result = self._destroy(err || null, onDestroy);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === \"function\") {\n        then.call(result, function() {\n          process.nextTick(onDestroy, null);\n        }, function(err2) {\n          process.nextTick(onDestroy, err2);\n        });\n      }\n    }\n  } catch (err2) {\n    onDestroy(err2);\n  }\n}\nfunction emitErrorCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n  if (w && w.emitClose || r && r.emitClose) {\n    self.emit(\"close\");\n  }\n}\nfunction emitErrorNT(self, err) {\n  const r = self._readableState;\n  const w = self._writableState;\n  if (w && w.errorEmitted || r && r.errorEmitted) {\n    return;\n  }\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n  self.emit(\"error\", err);\n}\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\nfunction errorOrDestroy(stream, err, sync) {\n  const r = stream._readableState;\n  const w = stream._writableState;\n  if (w && w.destroyed || r && r.destroyed) {\n    return this;\n  }\n  if (r && r.autoDestroy || w && w.autoDestroy)\n    stream.destroy(err);\n  else if (err) {\n    err.stack;\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT, stream, err);\n    } else {\n      emitErrorNT(stream, err);\n    }\n  }\n}\nfunction construct(stream, cb) {\n  if (typeof stream._construct !== \"function\") {\n    return;\n  }\n  const r = stream._readableState;\n  const w = stream._writableState;\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n  stream.once(kConstruct, cb);\n  if (stream.listenerCount(kConstruct) > 1) {\n    return;\n  }\n  process.nextTick(constructNT, stream);\n}\nfunction constructNT(stream) {\n  let called = false;\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n    if (s.destroyed) {\n      stream.emit(kDestroy, err);\n    } else if (err) {\n      errorOrDestroy(stream, err, true);\n    } else {\n      process.nextTick(emitConstructNT, stream);\n    }\n  }\n  try {\n    const result = stream._construct(onConstruct);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === \"function\") {\n        then.call(result, function() {\n          process.nextTick(onConstruct, null);\n        }, function(err) {\n          process.nextTick(onConstruct, err);\n        });\n      }\n    }\n  } catch (err) {\n    onConstruct(err);\n  }\n}\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\nfunction isRequest(stream) {\n  return stream && stream.setHeader && typeof stream.abort === \"function\";\n}\nfunction emitCloseLegacy(stream) {\n  stream.emit(\"close\");\n}\nfunction emitErrorCloseLegacy(stream, err) {\n  stream.emit(\"error\", err);\n  process.nextTick(emitCloseLegacy, stream);\n}\nfunction destroyer(stream, err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === \"function\") {\n    stream.destroy(err);\n  } else if (typeof stream.close === \"function\") {\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy, stream);\n  } else {\n    process.nextTick(emitCloseLegacy, stream);\n  }\n  if (!stream.destroyed) {\n    stream[kDestroyed] = true;\n  }\n}\nmodule.exports = {\n  construct,\n  destroyer,\n  destroy,\n  undestroy,\n  errorOrDestroy\n};\n}"],["internal/streams/duplex.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectKeys,\n  ObjectSetPrototypeOf\n} = primordials;\nmodule.exports = Duplex;\nconst Readable = require(\"internal/streams/readable\");\nconst Writable = require(\"internal/streams/writable\");\nObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);\nObjectSetPrototypeOf(Duplex, Readable);\n{\n  for (const method of ObjectKeys(Writable.prototype)) {\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  } else {\n    this.allowHalfOpen = true;\n  }\n}\nObjectDefineProperties(Duplex.prototype, {\n  writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writable\"),\n  writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableHighWaterMark\"),\n  writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableObjectMode\"),\n  writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableBuffer\"),\n  writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableLength\"),\n  writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableFinished\"),\n  writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableCorked\"),\n  writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableEnded\"),\n  writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, \"writableNeedDrain\"),\n  destroyed: {\n    get() {\n      if (this._readableState === void 0 || this._writableState === void 0) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    },\n    set(value) {\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\n  }\n});\nlet webStreamsAdapters;\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === void 0)\n    webStreamsAdapters = require(\"internal/webstreams/adapters\");\n  return webStreamsAdapters;\n}\nDuplex.fromWeb = function(pair, options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);\n};\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\nlet duplexify;\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require(\"internal/streams/duplexify\");\n  }\n  return duplexify(body, \"body\");\n};\n}"],["internal/streams/duplexify.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  isReadable,\n  isWritable,\n  isIterable,\n  isNodeStream,\n  isReadableNodeStream,\n  isWritableNodeStream,\n  isDuplexNodeStream\n} = require(\"internal/streams/utils\");\nconst eos = require(\"internal/streams/end-of-stream\");\nconst {\n  AbortError,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE\n  }\n} = require(\"internal/errors\");\nconst { destroyer } = require(\"internal/streams/destroy\");\nconst Duplex = require(\"internal/streams/duplex\");\nconst Readable = require(\"internal/streams/readable\");\nconst { createDeferredPromise } = require(\"internal/util\");\nconst from = require(\"internal/streams/from\");\nconst {\n  isBlob\n} = require(\"internal/blob\");\nconst { AbortController } = require(\"internal/abort_controller\");\nconst {\n  FunctionPrototypeCall\n} = primordials;\nclass Duplexify extends Duplex {\n  constructor(options) {\n    super(options);\n    if (options?.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n    if (options?.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  }\n}\nmodule.exports = function duplexify(body, name) {\n  if (isDuplexNodeStream(body)) {\n    return body;\n  }\n  if (isReadableNodeStream(body)) {\n    return _duplexify({ readable: body });\n  }\n  if (isWritableNodeStream(body)) {\n    return _duplexify({ writable: body });\n  }\n  if (isNodeStream(body)) {\n    return _duplexify({ writable: false, readable: false });\n  }\n  if (typeof body === \"function\") {\n    const { value, write, final, destroy } = fromAsyncGen(body);\n    if (isIterable(value)) {\n      return from(Duplexify, value, {\n        objectMode: true,\n        write,\n        final,\n        destroy\n      });\n    }\n    const then2 = value?.then;\n    if (typeof then2 === \"function\") {\n      let d;\n      const promise = FunctionPrototypeCall(then2, value, (val) => {\n        if (val != null) {\n          throw new ERR_INVALID_RETURN_VALUE(\"nully\", \"body\", val);\n        }\n      }, (err) => {\n        destroyer(d, err);\n      });\n      return d = new Duplexify({\n        objectMode: true,\n        readable: false,\n        write,\n        final(cb) {\n          final(async () => {\n            try {\n              await promise;\n              process.nextTick(cb, null);\n            } catch (err) {\n              process.nextTick(cb, err);\n            }\n          });\n        },\n        destroy\n      });\n    }\n    throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or AsyncFunction\", name, value);\n  }\n  if (isBlob(body)) {\n    return duplexify(body.arrayBuffer());\n  }\n  if (isIterable(body)) {\n    return from(Duplexify, body, {\n      objectMode: true,\n      writable: false\n    });\n  }\n  if (typeof body?.writable === \"object\" || typeof body?.readable === \"object\") {\n    const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : void 0;\n    const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : void 0;\n    return _duplexify({ readable, writable });\n  }\n  const then = body?.then;\n  if (typeof then === \"function\") {\n    let d;\n    FunctionPrototypeCall(then, body, (val) => {\n      if (val != null) {\n        d.push(val);\n      }\n      d.push(null);\n    }, (err) => {\n      destroyer(d, err);\n    });\n    return d = new Duplexify({\n      objectMode: true,\n      writable: false,\n      read() {\n      }\n    });\n  }\n  throw new ERR_INVALID_ARG_TYPE(name, [\n    \"Blob\",\n    \"ReadableStream\",\n    \"WritableStream\",\n    \"Stream\",\n    \"Iterable\",\n    \"AsyncIterable\",\n    \"Function\",\n    \"{ readable, writable } pair\",\n    \"Promise\"\n  ], body);\n};\nfunction fromAsyncGen(fn) {\n  let { promise, resolve } = createDeferredPromise();\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const value = fn(async function* () {\n    while (true) {\n      const { chunk, done, cb } = await promise;\n      process.nextTick(cb);\n      if (done)\n        return;\n      if (signal.aborted)\n        throw new AbortError();\n      yield chunk;\n      ({ promise, resolve } = createDeferredPromise());\n    }\n  }(), { signal });\n  return {\n    value,\n    write(chunk, encoding, cb) {\n      resolve({ chunk, done: false, cb });\n    },\n    final(cb) {\n      resolve({ done: true, cb });\n    },\n    destroy(err, cb) {\n      ac.abort();\n      cb(err);\n    }\n  };\n}\nfunction _duplexify(pair) {\n  const r = pair.readable && typeof pair.readable.read !== \"function\" ? Readable.wrap(pair.readable) : pair.readable;\n  const w = pair.writable;\n  let readable = !!isReadable(r);\n  let writable = !!isWritable(w);\n  let ondrain;\n  let onfinish;\n  let onreadable;\n  let onclose;\n  let d;\n  function onfinished(err) {\n    const cb = onclose;\n    onclose = null;\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      d.destroy(err);\n    } else if (!readable && !writable) {\n      d.destroy();\n    }\n  }\n  d = new Duplexify({\n    readableObjectMode: !!r?.readableObjectMode,\n    writableObjectMode: !!w?.writableObjectMode,\n    readable,\n    writable\n  });\n  if (writable) {\n    eos(w, (err) => {\n      writable = false;\n      if (err) {\n        destroyer(r, err);\n      }\n      onfinished(err);\n    });\n    d._write = function(chunk, encoding, callback) {\n      if (w.write(chunk, encoding)) {\n        callback();\n      } else {\n        ondrain = callback;\n      }\n    };\n    d._final = function(callback) {\n      w.end();\n      onfinish = callback;\n    };\n    w.on(\"drain\", function() {\n      if (ondrain) {\n        const cb = ondrain;\n        ondrain = null;\n        cb();\n      }\n    });\n    w.on(\"finish\", function() {\n      if (onfinish) {\n        const cb = onfinish;\n        onfinish = null;\n        cb();\n      }\n    });\n  }\n  if (readable) {\n    eos(r, (err) => {\n      readable = false;\n      if (err) {\n        destroyer(r, err);\n      }\n      onfinished(err);\n    });\n    r.on(\"readable\", function() {\n      if (onreadable) {\n        const cb = onreadable;\n        onreadable = null;\n        cb();\n      }\n    });\n    r.on(\"end\", function() {\n      d.push(null);\n    });\n    d._read = function() {\n      while (true) {\n        const buf = r.read();\n        if (buf === null) {\n          onreadable = d._read;\n          return;\n        }\n        if (!d.push(buf)) {\n          return;\n        }\n      }\n    };\n  }\n  d._destroy = function(err, callback) {\n    if (!err && onclose !== null) {\n      err = new AbortError();\n    }\n    onreadable = null;\n    ondrain = null;\n    onfinish = null;\n    if (onclose === null) {\n      callback(err);\n    } else {\n      onclose = callback;\n      destroyer(w, err);\n      destroyer(r, err);\n    }\n  };\n  return d;\n}\n}"],["internal/streams/end-of-stream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  AbortError,\n  codes\n} = require(\"internal/errors\");\nconst {\n  ERR_STREAM_PREMATURE_CLOSE\n} = codes;\nconst { once } = require(\"internal/util\");\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableFinished,\n  isWritable,\n  isWritableNodeStream,\n  isWritableFinished,\n  isNodeStream,\n  willEmitClose: _willEmitClose\n} = require(\"internal/streams/utils\");\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === \"function\";\n}\nconst nop = () => {\n};\nfunction eos(stream, options, callback) {\n  if (arguments.length === 2) {\n    callback = options;\n    options = {};\n  } else if (options == null) {\n    options = {};\n  } else {\n    validateObject(options, \"options\");\n  }\n  validateFunction(callback, \"callback\");\n  validateAbortSignal(options.signal, \"options.signal\");\n  callback = once(callback);\n  const readable = options.readable || options.readable !== false && isReadableNodeStream(stream);\n  const writable = options.writable || options.writable !== false && isWritableNodeStream(stream);\n  if (isNodeStream(stream)) {\n  } else {\n  }\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const onlegacyfinish = () => {\n    if (!stream.writable)\n      onfinish();\n  };\n  let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n  let writableFinished = isWritableFinished(stream, false);\n  const onfinish = () => {\n    writableFinished = true;\n    if (stream.destroyed)\n      willEmitClose = false;\n    if (willEmitClose && (!stream.readable || readable))\n      return;\n    if (!readable || readableFinished)\n      callback.call(stream);\n  };\n  let readableFinished = isReadableFinished(stream, false);\n  const onend = () => {\n    readableFinished = true;\n    if (stream.destroyed)\n      willEmitClose = false;\n    if (willEmitClose && (!stream.writable || writable))\n      return;\n    if (!writable || writableFinished)\n      callback.call(stream);\n  };\n  const onerror = (err) => {\n    callback.call(stream, err);\n  };\n  let closed = isClosed(stream);\n  const onclose = () => {\n    closed = true;\n    const errored = wState?.errored || rState?.errored;\n    if (errored && typeof errored !== \"boolean\") {\n      return callback.call(stream, errored);\n    }\n    if (readable && !readableFinished) {\n      if (!isReadableFinished(stream, false))\n        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false))\n        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    callback.call(stream);\n  };\n  const onrequest = () => {\n    stream.req.on(\"finish\", onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on(\"complete\", onfinish);\n    if (!willEmitClose) {\n      stream.on(\"abort\", onclose);\n    }\n    if (stream.req)\n      onrequest();\n    else\n      stream.on(\"request\", onrequest);\n  } else if (writable && !wState) {\n    stream.on(\"end\", onlegacyfinish);\n    stream.on(\"close\", onlegacyfinish);\n  }\n  if (!willEmitClose && typeof stream.aborted === \"boolean\") {\n    stream.on(\"aborted\", onclose);\n  }\n  stream.on(\"end\", onend);\n  stream.on(\"finish\", onfinish);\n  if (options.error !== false)\n    stream.on(\"error\", onerror);\n  stream.on(\"close\", onclose);\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState?.errorEmitted || rState?.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclose);\n    }\n  } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || !isWritable(stream))) {\n    process.nextTick(onclose);\n  } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || !isReadable(stream))) {\n    process.nextTick(onclose);\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclose);\n  }\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener(\"aborted\", onclose);\n    stream.removeListener(\"complete\", onfinish);\n    stream.removeListener(\"abort\", onclose);\n    stream.removeListener(\"request\", onrequest);\n    if (stream.req)\n      stream.req.removeListener(\"finish\", onfinish);\n    stream.removeListener(\"end\", onlegacyfinish);\n    stream.removeListener(\"close\", onlegacyfinish);\n    stream.removeListener(\"finish\", onfinish);\n    stream.removeListener(\"end\", onend);\n    stream.removeListener(\"error\", onerror);\n    stream.removeListener(\"close\", onclose);\n  };\n  if (options.signal && !closed) {\n    const abort = () => {\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(stream, new AbortError());\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      const originalCallback = callback;\n      callback = once((...args) => {\n        options.signal.removeEventListener(\"abort\", abort);\n        originalCallback.apply(stream, args);\n      });\n      options.signal.addEventListener(\"abort\", abort);\n    }\n  }\n  return cleanup;\n}\nmodule.exports = eos;\n}"],["internal/streams/from.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  PromisePrototypeThen,\n  SymbolAsyncIterator,\n  SymbolIterator\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_NULL_VALUES\n} = require(\"internal/errors\").codes;\nfunction from(Readable, iterable, opts) {\n  let iterator;\n  if (typeof iterable === \"string\" || iterable instanceof Buffer) {\n    return new Readable({\n      objectMode: true,\n      ...opts,\n      read() {\n        this.push(iterable);\n        this.push(null);\n      }\n    });\n  }\n  let isAsync;\n  if (iterable && iterable[SymbolAsyncIterator]) {\n    isAsync = true;\n    iterator = iterable[SymbolAsyncIterator]();\n  } else if (iterable && iterable[SymbolIterator]) {\n    isAsync = false;\n    iterator = iterable[SymbolIterator]();\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"iterable\", [\"Iterable\"], iterable);\n  }\n  const readable = new Readable({\n    objectMode: true,\n    highWaterMark: 1,\n    ...opts\n  });\n  let reading = false;\n  readable._read = function() {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n  readable._destroy = function(error, cb) {\n    PromisePrototypeThen(close(error), () => process.nextTick(cb, error), (e) => process.nextTick(cb, e || error));\n  };\n  async function close(error) {\n    const hadError = error !== void 0 && error !== null;\n    const hasThrow = typeof iterator.throw === \"function\";\n    if (hadError && hasThrow) {\n      const { value, done } = await iterator.throw(error);\n      await value;\n      if (done) {\n        return;\n      }\n    }\n    if (typeof iterator.return === \"function\") {\n      const { value } = await iterator.return();\n      await value;\n    }\n  }\n  async function next() {\n    for (; ; ) {\n      try {\n        const { value, done } = isAsync ? await iterator.next() : iterator.next();\n        if (done) {\n          readable.push(null);\n        } else {\n          const res = value && typeof value.then === \"function\" ? await value : value;\n          if (res === null) {\n            reading = false;\n            throw new ERR_STREAM_NULL_VALUES();\n          } else if (readable.push(res)) {\n            continue;\n          } else {\n            reading = false;\n          }\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n      break;\n    }\n  }\n  return readable;\n}\nmodule.exports = from;\n}"],["internal/streams/lazy_transform.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf\n} = primordials;\nconst stream = require(\"stream\");\nconst {\n  getDefaultEncoding\n} = require(\"internal/crypto/util\");\nmodule.exports = LazyTransform;\nfunction LazyTransform(options) {\n  this._options = options;\n}\nObjectSetPrototypeOf(LazyTransform.prototype, stream.Transform.prototype);\nObjectSetPrototypeOf(LazyTransform, stream.Transform);\nfunction makeGetter(name) {\n  return function() {\n    stream.Transform.call(this, this._options);\n    this._writableState.decodeStrings = false;\n    if (!this._options || !this._options.defaultEncoding) {\n      this._writableState.defaultEncoding = getDefaultEncoding();\n    }\n    return this[name];\n  };\n}\nfunction makeSetter(name) {\n  return function(val) {\n    ObjectDefineProperty(this, name, {\n      value: val,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  };\n}\nObjectDefineProperties(LazyTransform.prototype, {\n  _readableState: {\n    get: makeGetter(\"_readableState\"),\n    set: makeSetter(\"_readableState\"),\n    configurable: true,\n    enumerable: true\n  },\n  _writableState: {\n    get: makeGetter(\"_writableState\"),\n    set: makeSetter(\"_writableState\"),\n    configurable: true,\n    enumerable: true\n  }\n});\n}"],["internal/streams/legacy.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ObjectSetPrototypeOf\n} = primordials;\nconst EE = require(\"events\");\nfunction Stream(opts) {\n  EE.call(this, opts);\n}\nObjectSetPrototypeOf(Stream.prototype, EE.prototype);\nObjectSetPrototypeOf(Stream, EE);\nStream.prototype.pipe = function(dest, options) {\n  const source = this;\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n  source.on(\"data\", ondata);\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n  dest.on(\"drain\", ondrain);\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on(\"end\", onend);\n    source.on(\"close\", onclose);\n  }\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd)\n      return;\n    didOnEnd = true;\n    dest.end();\n  }\n  function onclose() {\n    if (didOnEnd)\n      return;\n    didOnEnd = true;\n    if (typeof dest.destroy === \"function\")\n      dest.destroy();\n  }\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, \"error\") === 0) {\n      this.emit(\"error\", er);\n    }\n  }\n  prependListener(source, \"error\", onerror);\n  prependListener(dest, \"error\", onerror);\n  function cleanup() {\n    source.removeListener(\"data\", ondata);\n    dest.removeListener(\"drain\", ondrain);\n    source.removeListener(\"end\", onend);\n    source.removeListener(\"close\", onclose);\n    source.removeListener(\"error\", onerror);\n    dest.removeListener(\"error\", onerror);\n    source.removeListener(\"end\", cleanup);\n    source.removeListener(\"close\", cleanup);\n    dest.removeListener(\"close\", cleanup);\n  }\n  source.on(\"end\", cleanup);\n  source.on(\"close\", cleanup);\n  dest.on(\"close\", cleanup);\n  dest.emit(\"pipe\", source);\n  return dest;\n};\nfunction prependListener(emitter, event, fn) {\n  if (typeof emitter.prependListener === \"function\")\n    return emitter.prependListener(event, fn);\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event, fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn, emitter._events[event]];\n}\nmodule.exports = { Stream, prependListener };\n}"],["internal/streams/passthrough.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf\n} = primordials;\nmodule.exports = PassThrough;\nconst Transform = require(\"internal/streams/transform\");\nObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);\nObjectSetPrototypeOf(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n}"],["internal/streams/pipeline.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  Promise,\n  SymbolAsyncIterator\n} = primordials;\nconst eos = require(\"internal/streams/end-of-stream\");\nconst { once } = require(\"internal/util\");\nconst destroyImpl = require(\"internal/streams/destroy\");\nconst Duplex = require(\"internal/streams/duplex\");\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED\n  },\n  AbortError\n} = require(\"internal/errors\");\nconst {\n  validateCallback,\n  validateAbortSignal\n} = require(\"internal/validators\");\nconst {\n  isIterable,\n  isReadableNodeStream,\n  isNodeStream\n} = require(\"internal/streams/utils\");\nconst { AbortController } = require(\"internal/abort_controller\");\nlet PassThrough;\nlet Readable;\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  let finished = false;\n  stream.on(\"close\", () => {\n    finished = true;\n  });\n  eos(stream, { readable: reading, writable: writing }, (err) => {\n    finished = !err;\n    const rState = stream._readableState;\n    if (err && err.code === \"ERR_STREAM_PREMATURE_CLOSE\" && reading && (rState && rState.ended && !rState.errored && !rState.errorEmitted)) {\n      stream.once(\"end\", callback).once(\"error\", callback);\n    } else {\n      callback(err);\n    }\n  });\n  return (err) => {\n    if (finished)\n      return;\n    finished = true;\n    destroyImpl.destroyer(stream, err);\n    callback(err || new ERR_STREAM_DESTROYED(\"pipe\"));\n  };\n}\nfunction popCallback(streams) {\n  validateCallback(streams[streams.length - 1]);\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"val\", [\"Readable\", \"Iterable\", \"AsyncIterable\"], val);\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require(\"internal/streams/readable\");\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\nasync function pump(iterable, writable, finish) {\n  let error;\n  let onresolve = null;\n  const resume = (err) => {\n    if (err) {\n      error = err;\n    }\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n  const wait = () => new Promise((resolve, reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n  writable.on(\"drain\", resume);\n  const cleanup = eos(writable, { readable: false }, resume);\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n    writable.end();\n    await wait();\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err);\n  } finally {\n    cleanup();\n    writable.off(\"drain\", resume);\n  }\n}\nfunction pipeline(...streams) {\n  const callback = once(popCallback(streams));\n  if (ArrayIsArray(streams[0]) && streams.length === 1) {\n    streams = streams[0];\n  }\n  return pipelineImpl(streams, callback);\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS(\"streams\");\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts?.signal;\n  validateAbortSignal(outerSignal, \"options.signal\");\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  outerSignal?.addEventListener(\"abort\", abort);\n  let error;\n  let value;\n  const destroys = [];\n  let finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === \"ERR_STREAM_PREMATURE_CLOSE\")) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    outerSignal?.removeEventListener(\"abort\", abort);\n    ac.abort();\n    if (final) {\n      callback(error, value);\n    }\n  }\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    if (isNodeStream(stream)) {\n      finishCount++;\n      destroys.push(destroyer(stream, reading, writing, finish));\n    }\n    if (i === 0) {\n      if (typeof stream === \"function\") {\n        ret = stream({ signal });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE(\"Iterable, AsyncIterable or Stream\", \"source\", ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === \"function\") {\n      ret = makeAsyncIterable(ret);\n      ret = stream(ret, { signal });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable\", `transform[${i - 1}]`, ret);\n        }\n      } else {\n        if (!PassThrough) {\n          PassThrough = require(\"internal/streams/passthrough\");\n        }\n        const pt = new PassThrough({\n          objectMode: true\n        });\n        const then = ret?.then;\n        if (typeof then === \"function\") {\n          then.call(ret, (val) => {\n            value = val;\n            pt.end(val);\n          }, (err) => {\n            pt.destroy(err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pump(ret, pt, finish);\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE(\"AsyncIterable or Promise\", \"destination\", ret);\n        }\n        ret = pt;\n        finishCount++;\n        destroys.push(destroyer(ret, false, true, finish));\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        ret.pipe(stream);\n        if (stream === process.stdout || stream === process.stderr) {\n          ret.on(\"end\", () => stream.end());\n        }\n      } else {\n        ret = makeAsyncIterable(ret);\n        finishCount++;\n        pump(ret, stream, finish);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n  if (signal?.aborted || outerSignal?.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nmodule.exports = { pipelineImpl, pipeline };\n}"],["internal/streams/readable.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  NumberIsInteger,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperties,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  SafeSet,\n  SymbolAsyncIterator,\n  Symbol\n} = primordials;\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\nconst EE = require(\"events\");\nconst { Stream, prependListener } = require(\"internal/streams/legacy\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  addAbortSignal\n} = require(\"internal/streams/add-abort-signal\");\nconst eos = require(\"internal/streams/end-of-stream\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"stream\", (fn) => {\n  debug = fn;\n});\nconst BufferList = require(\"internal/streams/buffer_list\");\nconst destroyImpl = require(\"internal/streams/destroy\");\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark\n} = require(\"internal/streams/state\");\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_OUT_OF_RANGE,\n    ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n  }\n} = require(\"internal/errors\");\nconst { validateObject } = require(\"internal/validators\");\nconst kPaused = Symbol(\"kPaused\");\nconst { StringDecoder } = require(\"string_decoder\");\nconst from = require(\"internal/streams/from\");\nObjectSetPrototypeOf(Readable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Readable, Stream);\nconst nop = () => {\n};\nconst { errorOrDestroy } = destroyImpl;\nfunction ReadableState(options, stream, isDuplex) {\n  if (typeof isDuplex !== \"boolean\")\n    isDuplex = stream instanceof Stream.Duplex;\n  this.objectMode = !!(options && options.objectMode);\n  if (isDuplex)\n    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);\n  this.highWaterMark = options ? getHighWaterMark(this, options, \"readableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(false);\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n  this.constructed = true;\n  this.sync = true;\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n  this.errorEmitted = false;\n  this.emitClose = !options || options.emitClose !== false;\n  this.autoDestroy = !options || options.autoDestroy !== false;\n  this.destroyed = false;\n  this.errored = null;\n  this.closed = false;\n  this.closeEmitted = false;\n  this.defaultEncoding = options && options.defaultEncoding || \"utf8\";\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n  this.readingMore = false;\n  this.dataEmitted = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n  const isDuplex = this instanceof Stream.Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n  if (options) {\n    if (typeof options.read === \"function\")\n      this._read = options.read;\n    if (typeof options.destroy === \"function\")\n      this._destroy = options.destroy;\n    if (typeof options.construct === \"function\")\n      this._construct = options.construct;\n    if (options.signal && !isDuplex)\n      addAbortSignal(options.signal, this);\n  }\n  Stream.call(this, options);\n  destroyImpl.construct(this, () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this, this._readableState);\n    }\n  });\n}\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n  cb(err);\n};\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\nReadable.prototype.push = function(chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, false);\n};\nReadable.prototype.unshift = function(chunk, encoding) {\n  return readableAddChunk(this, chunk, encoding, true);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront) {\n  debug(\"readableAddChunk\", chunk);\n  const state = stream._readableState;\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === \"string\") {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          chunk = Buffer.from(chunk, encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk, encoding);\n          encoding = \"\";\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = \"\";\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = \"\";\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n    }\n  }\n  if (err) {\n    errorOrDestroy(stream, err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (addToFront) {\n      if (state.endEmitted)\n        errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else if (state.destroyed || state.errored)\n        return false;\n      else\n        addChunk(stream, state, chunk, true);\n    } else if (state.ended) {\n      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream, state, chunk, false);\n        else\n          maybeReadMore(stream, state);\n      } else {\n        addChunk(stream, state, chunk, false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream, state);\n  }\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount(\"data\") > 0) {\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n    state.dataEmitted = true;\n    stream.emit(\"data\", chunk);\n  } else {\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  this._readableState.encoding = this._readableState.decoder.encoding;\n  const buffer = this._readableState.buffer;\n  let content = \"\";\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== \"\")\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\nconst MAX_HWM = 1073741824;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE(\"size\", \"<= 1GiB\", n);\n  } else {\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended)\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (NumberIsNaN(n)) {\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\nReadable.prototype.read = function(n) {\n  debug(\"read\", n);\n  if (n === void 0) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n, 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n  if (n !== 0)\n    state.emittedReadable = false;\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug(\"read: emitReadable\", state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n  let doRead = state.needReadable;\n  debug(\"need readable\", doRead);\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug(\"length less than watermark\", doRead);\n  }\n  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {\n    doRead = false;\n    debug(\"reading, ended or constructing\", doRead);\n  } else if (doRead) {\n    debug(\"do read\");\n    state.reading = true;\n    state.sync = true;\n    if (state.length === 0)\n      state.needReadable = true;\n    try {\n      const result = this._read(state.highWaterMark);\n      if (result != null) {\n        const then = result.then;\n        if (typeof then === \"function\") {\n          then.call(result, nop, function(err) {\n            errorOrDestroy(this, err);\n          });\n        }\n      }\n    } catch (err) {\n      errorOrDestroy(this, err);\n    }\n    state.sync = false;\n    if (!state.reading)\n      n = howMuchToRead(nOrig, state);\n  }\n  let ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n  if (state.length === 0) {\n    if (!state.ended)\n      state.needReadable = true;\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit(\"data\", ret);\n  }\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug(\"onEofChunk\");\n  if (state.ended)\n    return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    emitReadable(stream);\n  } else {\n    state.needReadable = false;\n    state.emittedReadable = true;\n    emitReadable_(stream);\n  }\n}\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug(\"emitReadable\", state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug(\"emitReadable\", state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug(\"emitReadable_\", state.destroyed, state.length, state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit(\"readable\");\n    state.emittedReadable = false;\n  }\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    const len = state.length;\n    debug(\"maybeReadMore read 0\");\n    stream.read(0);\n    if (len === state.length)\n      break;\n  }\n  state.readingMore = false;\n}\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\");\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);\n    }\n  }\n  state.pipes.push(dest);\n  debug(\"pipe count=%d opts=%j\", state.pipes.length, pipeOpts);\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once(\"end\", endFn);\n  dest.on(\"unpipe\", onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug(\"onunpipe\");\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug(\"onend\");\n    dest.end();\n  }\n  let ondrain;\n  let cleanedUp = false;\n  function cleanup() {\n    debug(\"cleanup\");\n    dest.removeListener(\"close\", onclose);\n    dest.removeListener(\"finish\", onfinish);\n    if (ondrain) {\n      dest.removeListener(\"drain\", ondrain);\n    }\n    dest.removeListener(\"error\", onerror);\n    dest.removeListener(\"unpipe\", onunpipe);\n    src.removeListener(\"end\", onend);\n    src.removeListener(\"end\", unpipe);\n    src.removeListener(\"data\", ondata);\n    cleanedUp = true;\n    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n  function pause() {\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug(\"false write response, pause\", 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug(\"false write response, pause\", state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      ondrain = pipeOnDrain(src, dest);\n      dest.on(\"drain\", ondrain);\n    }\n  }\n  src.on(\"data\", ondata);\n  function ondata(chunk) {\n    debug(\"ondata\");\n    const ret = dest.write(chunk);\n    debug(\"dest.write\", ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n  function onerror(er) {\n    debug(\"onerror\", er);\n    unpipe();\n    dest.removeListener(\"error\", onerror);\n    if (EE.listenerCount(dest, \"error\") === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        errorOrDestroy(dest, er);\n      } else {\n        dest.emit(\"error\", er);\n      }\n    }\n  }\n  prependListener(dest, \"error\", onerror);\n  function onclose() {\n    dest.removeListener(\"finish\", onfinish);\n    unpipe();\n  }\n  dest.once(\"close\", onclose);\n  function onfinish() {\n    debug(\"onfinish\");\n    dest.removeListener(\"close\", onclose);\n    unpipe();\n  }\n  dest.once(\"finish\", onfinish);\n  function unpipe() {\n    debug(\"unpipe\");\n    src.unpipe(dest);\n  }\n  dest.emit(\"pipe\", src);\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug(\"pipe resume\");\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src, dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n    if (state.awaitDrainWriters === dest) {\n      debug(\"pipeOnDrain\", 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug(\"pipeOnDrain\", state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EE.listenerCount(src, \"data\")) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n  if (state.pipes.length === 0)\n    return this;\n  if (!dest) {\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit(\"unpipe\", this, { hasUnpiped: false });\n    return this;\n  }\n  const index = ArrayPrototypeIndexOf(state.pipes, dest);\n  if (index === -1)\n    return this;\n  state.pipes.splice(index, 1);\n  if (state.pipes.length === 0)\n    this.pause();\n  dest.emit(\"unpipe\", this, unpipeInfo);\n  return this;\n};\nReadable.prototype.on = function(ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n  const state = this._readableState;\n  if (ev === \"data\") {\n    state.readableListening = this.listenerCount(\"readable\") > 0;\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === \"readable\") {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug(\"on readable\", state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function(ev, fn) {\n  const res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === \"readable\") {\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === \"readable\" || ev === void 0) {\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount(\"readable\") > 0;\n  if (state.resumeScheduled && state[kPaused] === false) {\n    state.flowing = true;\n  } else if (self.listenerCount(\"data\") > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\nfunction nReadingNextTick(self) {\n  debug(\"readable nexttick read 0\");\n  self.read(0);\n}\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug(\"resume\");\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state[kPaused] = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug(\"resume\", state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit(\"resume\");\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\nReadable.prototype.pause = function() {\n  debug(\"call pause flowing=%j\", this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug(\"pause\");\n    this._readableState.flowing = false;\n    this.emit(\"pause\");\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug(\"flow\", state.flowing);\n  while (state.flowing && stream.read() !== null)\n    ;\n}\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n  stream.on(\"data\", (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n  stream.on(\"end\", () => {\n    this.push(null);\n  });\n  stream.on(\"error\", (err) => {\n    errorOrDestroy(this, err);\n  });\n  stream.on(\"close\", () => {\n    this.destroy();\n  });\n  stream.on(\"destroy\", () => {\n    this.destroy();\n  });\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === void 0 && typeof stream[i] === \"function\") {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n  return this;\n};\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\nReadable.prototype.iterator = function(options) {\n  if (options !== void 0) {\n    validateObject(options, \"options\");\n  }\n  return streamToAsyncIterator(this, options);\n};\nfunction streamToAsyncIterator(stream, options) {\n  if (typeof stream.read !== \"function\") {\n    stream = Readable.wrap(stream, { objectMode: true });\n  }\n  const iter = createAsyncIterator(stream, options);\n  iter.stream = stream;\n  return iter;\n}\nasync function* createAsyncIterator(stream, options) {\n  let callback = nop;\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n  stream.on(\"readable\", next);\n  let error;\n  eos(stream, { writable: false }, (err) => {\n    error = err ? aggregateTwoErrors(error, err) : null;\n    callback();\n    callback = nop;\n  });\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error, err);\n    throw error;\n  } finally {\n    if ((error || options?.destroyOnReturn !== false) && (error === void 0 || stream._readableState.autoDestroy)) {\n      destroyImpl.destroyer(stream, null);\n    }\n  }\n}\nObjectDefineProperties(Readable.prototype, {\n  readable: {\n    get() {\n      const r = this._readableState;\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;\n    },\n    set(val) {\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  },\n  readableDidRead: {\n    enumerable: false,\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\n  },\n  readableAborted: {\n    enumerable: false,\n    get: function() {\n      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;\n    }\n  },\n  readableHighWaterMark: {\n    enumerable: false,\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\n  },\n  readableBuffer: {\n    enumerable: false,\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\n  },\n  readableFlowing: {\n    enumerable: false,\n    get: function() {\n      return this._readableState.flowing;\n    },\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  },\n  readableLength: {\n    enumerable: false,\n    get() {\n      return this._readableState.length;\n    }\n  },\n  readableObjectMode: {\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  },\n  readableEncoding: {\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  },\n  destroyed: {\n    enumerable: false,\n    get() {\n      if (this._readableState === void 0) {\n        return false;\n      }\n      return this._readableState.destroyed;\n    },\n    set(value) {\n      if (!this._readableState) {\n        return;\n      }\n      this._readableState.destroyed = value;\n    }\n  },\n  readableEnded: {\n    enumerable: false,\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\n});\nObjectDefineProperties(ReadableState.prototype, {\n  pipesCount: {\n    get() {\n      return this.pipes.length;\n    }\n  },\n  paused: {\n    get() {\n      return this[kPaused] !== false;\n    },\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\nReadable._fromList = fromList;\nfunction fromList(n, state) {\n  if (state.length === 0)\n    return null;\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    if (state.decoder)\n      ret = state.buffer.join(\"\");\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  const state = stream._readableState;\n  debug(\"endReadable\", state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug(\"endReadableNT\", state.endEmitted, state.length);\n  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit(\"end\");\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT, stream);\n    } else if (state.autoDestroy) {\n      const wState = stream._writableState;\n      const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\nReadable.from = function(iterable, opts) {\n  return from(Readable, iterable, opts);\n};\nlet webStreamsAdapters;\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === void 0)\n    webStreamsAdapters = require(\"internal/webstreams/adapters\");\n  return webStreamsAdapters;\n}\nReadable.fromWeb = function(readableStream, options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);\n};\nReadable.toWeb = function(streamReadable) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n};\nReadable.wrap = function(src, options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true,\n    ...options,\n    destroy(err, callback) {\n      destroyImpl.destroyer(src, err);\n      callback(err);\n    }\n  }).wrap(src);\n};\n}"],["internal/streams/state.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  MathFloor,\n  NumberIsInteger\n} = primordials;\nconst { ERR_INVALID_ARG_VALUE } = require(\"internal/errors\").codes;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? 16 : 16 * 1024;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : \"options.highWaterMark\";\n      throw new ERR_INVALID_ARG_VALUE(name, hwm);\n    }\n    return MathFloor(hwm);\n  }\n  return getDefaultHighWaterMark(state.objectMode);\n}\nmodule.exports = {\n  getHighWaterMark,\n  getDefaultHighWaterMark\n};\n}"],["internal/streams/transform.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nmodule.exports = Transform;\nconst {\n  ERR_METHOD_NOT_IMPLEMENTED\n} = require(\"internal/errors\").codes;\nconst Duplex = require(\"internal/streams/duplex\");\nObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);\nObjectSetPrototypeOf(Transform, Duplex);\nconst kCallback = Symbol(\"kCallback\");\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n  Duplex.call(this, options);\n  this._readableState.sync = false;\n  this[kCallback] = null;\n  if (options) {\n    if (typeof options.transform === \"function\")\n      this._transform = options.transform;\n    if (typeof options.flush === \"function\")\n      this._flush = options.flush;\n  }\n  this.on(\"prefinish\", prefinish);\n}\nfunction final(cb) {\n  let called = false;\n  if (typeof this._flush === \"function\" && !this.destroyed) {\n    const result = this._flush((er, data) => {\n      called = true;\n      if (er) {\n        if (cb) {\n          cb(er);\n        } else {\n          this.destroy(er);\n        }\n        return;\n      }\n      if (data != null) {\n        this.push(data);\n      }\n      this.push(null);\n      if (cb) {\n        cb();\n      }\n    });\n    if (result !== void 0 && result !== null) {\n      try {\n        const then = result.then;\n        if (typeof then === \"function\") {\n          then.call(result, (data) => {\n            if (called)\n              return;\n            if (data != null)\n              this.push(data);\n            this.push(null);\n            if (cb)\n              process.nextTick(cb);\n          }, (err) => {\n            if (cb) {\n              process.nextTick(cb, err);\n            } else {\n              process.nextTick(() => this.destroy(err));\n            }\n          });\n        }\n      } catch (err) {\n        process.nextTick(() => this.destroy(err));\n      }\n    }\n  } else {\n    this.push(null);\n    if (cb) {\n      cb();\n    }\n  }\n}\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this);\n  }\n}\nTransform.prototype._final = final;\nTransform.prototype._transform = function(chunk, encoding, callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\");\n};\nTransform.prototype._write = function(chunk, encoding, callback) {\n  const rState = this._readableState;\n  const wState = this._writableState;\n  const length = rState.length;\n  let called = false;\n  const result = this._transform(chunk, encoding, (err, val) => {\n    called = true;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (val != null) {\n      this.push(val);\n    }\n    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {\n      callback();\n    } else {\n      this[kCallback] = callback;\n    }\n  });\n  if (result !== void 0 && result != null) {\n    try {\n      const then = result.then;\n      if (typeof then === \"function\") {\n        then.call(result, (val) => {\n          if (called)\n            return;\n          if (val != null) {\n            this.push(val);\n          }\n          if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {\n            process.nextTick(callback);\n          } else {\n            this[kCallback] = callback;\n          }\n        }, (err) => {\n          process.nextTick(callback, err);\n        });\n      }\n    } catch (err) {\n      process.nextTick(callback, err);\n    }\n  }\n};\nTransform.prototype._read = function() {\n  if (this[kCallback]) {\n    const callback = this[kCallback];\n    this[kCallback] = null;\n    callback();\n  }\n};\n}"],["internal/streams/utils.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Symbol,\n  SymbolAsyncIterator,\n  SymbolIterator\n} = primordials;\nconst kDestroyed = Symbol(\"kDestroyed\");\nconst kIsDisturbed = Symbol(\"kIsDisturbed\");\nfunction isReadableNodeStream(obj) {\n  return !!(obj && typeof obj.pipe === \"function\" && typeof obj.on === \"function\" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));\n}\nfunction isWritableNodeStream(obj) {\n  return !!(obj && typeof obj.write === \"function\" && typeof obj.on === \"function\" && (!obj._readableState || obj._writableState?.writable !== false));\n}\nfunction isDuplexNodeStream(obj) {\n  return !!(obj && (typeof obj.pipe === \"function\" && obj._readableState) && typeof obj.on === \"function\" && typeof obj.write === \"function\");\n}\nfunction isNodeStream(obj) {\n  return obj && (obj._readableState || obj._writableState || typeof obj.write === \"function\" && typeof obj.on === \"function\" || typeof obj.pipe === \"function\" && typeof obj.on === \"function\");\n}\nfunction isIterable(obj, isAsync) {\n  if (obj == null)\n    return false;\n  if (isAsync === true)\n    return typeof obj[SymbolAsyncIterator] === \"function\";\n  if (isAsync === false)\n    return typeof obj[SymbolIterator] === \"function\";\n  return typeof obj[SymbolAsyncIterator] === \"function\" || typeof obj[SymbolIterator] === \"function\";\n}\nfunction isDestroyed(stream) {\n  if (!isNodeStream(stream))\n    return null;\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n  return !!(stream.destroyed || stream[kDestroyed] || state?.destroyed);\n}\nfunction isWritableEnded(stream) {\n  if (!isWritableNodeStream(stream))\n    return null;\n  if (stream.writableEnded === true)\n    return true;\n  const wState = stream._writableState;\n  if (wState?.errored)\n    return false;\n  if (typeof wState?.ended !== \"boolean\")\n    return null;\n  return wState.ended;\n}\nfunction isWritableFinished(stream, strict) {\n  if (!isWritableNodeStream(stream))\n    return null;\n  if (stream.writableFinished === true)\n    return true;\n  const wState = stream._writableState;\n  if (wState?.errored)\n    return false;\n  if (typeof wState?.finished !== \"boolean\")\n    return null;\n  return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);\n}\nfunction isReadableEnded(stream) {\n  if (!isReadableNodeStream(stream))\n    return null;\n  if (stream.readableEnded === true)\n    return true;\n  const rState = stream._readableState;\n  if (!rState || rState.errored)\n    return false;\n  if (typeof rState?.ended !== \"boolean\")\n    return null;\n  return rState.ended;\n}\nfunction isReadableFinished(stream, strict) {\n  if (!isReadableNodeStream(stream))\n    return null;\n  const rState = stream._readableState;\n  if (rState?.errored)\n    return false;\n  if (typeof rState?.endEmitted !== \"boolean\")\n    return null;\n  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);\n}\nfunction isReadable(stream) {\n  const r = isReadableNodeStream(stream);\n  if (r === null || typeof stream?.readable !== \"boolean\")\n    return null;\n  if (isDestroyed(stream))\n    return false;\n  return r && stream.readable && !isReadableFinished(stream);\n}\nfunction isWritable(stream) {\n  const r = isWritableNodeStream(stream);\n  if (r === null || typeof stream?.writable !== \"boolean\")\n    return null;\n  if (isDestroyed(stream))\n    return false;\n  return r && stream.writable && !isWritableEnded(stream);\n}\nfunction isFinished(stream, opts) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n  if (isDestroyed(stream)) {\n    return true;\n  }\n  if (opts?.readable !== false && isReadable(stream)) {\n    return false;\n  }\n  if (opts?.writable !== false && isWritable(stream)) {\n    return false;\n  }\n  return true;\n}\nfunction isClosed(stream) {\n  if (!isNodeStream(stream)) {\n    return null;\n  }\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  if (typeof wState?.closed === \"boolean\" || typeof rState?.closed === \"boolean\") {\n    return wState?.closed || rState?.closed;\n  }\n  if (typeof stream._closed === \"boolean\" && isOutgoingMessage(stream)) {\n    return stream._closed;\n  }\n  return null;\n}\nfunction isOutgoingMessage(stream) {\n  return typeof stream._closed === \"boolean\" && typeof stream._defaultKeepAlive === \"boolean\" && typeof stream._removedConnection === \"boolean\" && typeof stream._removedContLen === \"boolean\";\n}\nfunction isServerResponse(stream) {\n  return typeof stream._sent100 === \"boolean\" && isOutgoingMessage(stream);\n}\nfunction isServerRequest(stream) {\n  return typeof stream._consuming === \"boolean\" && typeof stream._dumped === \"boolean\" && stream.req?.upgradeOrConnect === void 0;\n}\nfunction willEmitClose(stream) {\n  if (!isNodeStream(stream))\n    return null;\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const state = wState || rState;\n  return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);\n}\nfunction isDisturbed(stream) {\n  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));\n}\nmodule.exports = {\n  kDestroyed,\n  isDisturbed,\n  kIsDisturbed,\n  isClosed,\n  isDestroyed,\n  isDuplexNodeStream,\n  isFinished,\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isReadableEnded,\n  isReadableFinished,\n  isNodeStream,\n  isWritable,\n  isWritableNodeStream,\n  isWritableEnded,\n  isWritableFinished,\n  isServerRequest,\n  isServerResponse,\n  willEmitClose\n};\n}"],["internal/streams/writable.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeSlice,\n  Error,\n  FunctionPrototypeSymbolHasInstance,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  StringPrototypeToLowerCase,\n  Symbol,\n  SymbolHasInstance\n} = primordials;\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\nconst EE = require(\"events\");\nconst Stream = require(\"internal/streams/legacy\").Stream;\nconst { Buffer } = require(\"buffer\");\nconst destroyImpl = require(\"internal/streams/destroy\");\nconst {\n  addAbortSignal\n} = require(\"internal/streams/add-abort-signal\");\nconst {\n  getHighWaterMark,\n  getDefaultHighWaterMark\n} = require(\"internal/streams/state\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED,\n  ERR_STREAM_ALREADY_FINISHED,\n  ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING\n} = require(\"internal/errors\").codes;\nconst { errorOrDestroy } = destroyImpl;\nObjectSetPrototypeOf(Writable.prototype, Stream.prototype);\nObjectSetPrototypeOf(Writable, Stream);\nfunction nop() {\n}\nconst kOnFinished = Symbol(\"kOnFinished\");\nfunction WritableState(options, stream, isDuplex) {\n  if (typeof isDuplex !== \"boolean\")\n    isDuplex = stream instanceof Stream.Duplex;\n  this.objectMode = !!(options && options.objectMode);\n  if (isDuplex)\n    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);\n  this.highWaterMark = options ? getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex) : getDefaultHighWaterMark(false);\n  this.finalCalled = false;\n  this.needDrain = false;\n  this.ending = false;\n  this.ended = false;\n  this.finished = false;\n  this.destroyed = false;\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n  this.defaultEncoding = options && options.defaultEncoding || \"utf8\";\n  this.length = 0;\n  this.writing = false;\n  this.corked = 0;\n  this.sync = true;\n  this.bufferProcessing = false;\n  this.onwrite = onwrite.bind(void 0, stream);\n  this.writecb = null;\n  this.writelen = 0;\n  this.afterWriteTickInfo = null;\n  resetBuffer(this);\n  this.pendingcb = 0;\n  this.constructed = true;\n  this.prefinished = false;\n  this.errorEmitted = false;\n  this.emitClose = !options || options.emitClose !== false;\n  this.autoDestroy = !options || options.autoDestroy !== false;\n  this.errored = null;\n  this.closed = false;\n  this.closeEmitted = false;\n  this[kOnFinished] = [];\n}\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);\n};\nObjectDefineProperty(WritableState.prototype, \"bufferedRequestCount\", {\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\n});\nfunction Writable(options) {\n  const isDuplex = this instanceof Stream.Duplex;\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))\n    return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n  if (options) {\n    if (typeof options.write === \"function\")\n      this._write = options.write;\n    if (typeof options.writev === \"function\")\n      this._writev = options.writev;\n    if (typeof options.destroy === \"function\")\n      this._destroy = options.destroy;\n    if (typeof options.final === \"function\")\n      this._final = options.final;\n    if (typeof options.construct === \"function\")\n      this._construct = options.construct;\n    if (options.signal)\n      addAbortSignal(options.signal, this);\n  }\n  Stream.call(this, options);\n  destroyImpl.construct(this, () => {\n    const state = this._writableState;\n    if (!state.writing) {\n      clearBuffer(this, state);\n    }\n    finishMaybe(this, state);\n  });\n}\nObjectDefineProperty(Writable, SymbolHasInstance, {\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this, object))\n      return true;\n    if (this !== Writable)\n      return false;\n    return object && object._writableState instanceof WritableState;\n  }\n});\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction _write(stream, chunk, encoding, cb) {\n  const state = stream._writableState;\n  if (typeof encoding === \"function\") {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== \"buffer\" && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== \"function\")\n      cb = nop;\n  }\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === \"string\") {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = \"buffer\";\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = \"buffer\";\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = \"buffer\";\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n    }\n  }\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED(\"write\");\n  }\n  if (err) {\n    process.nextTick(cb, err);\n    errorOrDestroy(stream, err, true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream, state, chunk, encoding, cb);\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n  return _write(this, chunk, encoding, cb) === true;\n};\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing)\n      clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  if (typeof encoding === \"string\")\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nfunction writeOrBuffer(stream, state, chunk, encoding, callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  const ret = state.length < state.highWaterMark;\n  if (!ret)\n    state.needDrain = true;\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk, encoding, callback });\n    if (state.allBuffers && encoding !== \"buffer\") {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n  }\n  return ret && !state.errored && !state.destroyed;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n  else if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, er, cb) {\n  --state.pendingcb;\n  cb(er);\n  errorBuffer(state);\n  errorOrDestroy(stream, er);\n}\nfunction onwrite(stream, er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n  if (typeof cb !== \"function\") {\n    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n  if (er) {\n    er.stack;\n    if (!state.errored) {\n      state.errored = er;\n    }\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n    if (sync) {\n      process.nextTick(onwriteError, stream, state, er, cb);\n    } else {\n      onwriteError(stream, state, er, cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1, cb, stream, state };\n        process.nextTick(afterWriteTick, state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream, state, 1, cb);\n    }\n  }\n}\nfunction afterWriteTick({ stream, state, count, cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream, state, count, cb);\n}\nfunction afterWrite(stream, state, count, cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit(\"drain\");\n  }\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n  finishMaybe(stream, state);\n}\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk, callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(state.errored ?? new ERR_STREAM_DESTROYED(\"write\"));\n  }\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED(\"end\"));\n  }\n  resetBuffer(state);\n}\nfunction clearBuffer(stream, state) {\n  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {\n    return;\n  }\n  const { buffered, bufferedIndex, objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n  if (!bufferedLength) {\n    return;\n  }\n  let i = bufferedIndex;\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);\n    chunks.allBuffers = state.allBuffers;\n    doWrite(stream, state, true, state.length, chunks, \"\", callback);\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk, encoding, callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, callback);\n    } while (i < buffered.length && !state.writing);\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0, i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n  if (this._writev) {\n    this._writev([{ chunk, encoding }], cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\");\n  }\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function(chunk, encoding, cb) {\n  const state = this._writableState;\n  if (typeof chunk === \"function\") {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === \"function\") {\n    cb = encoding;\n    encoding = null;\n  }\n  let err;\n  if (chunk !== null && chunk !== void 0) {\n    const ret = _write(this, chunk, encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n  if (err) {\n  } else if (!state.errored && !state.ending) {\n    state.ending = true;\n    finishMaybe(this, state, true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED(\"end\");\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED(\"end\");\n  }\n  if (typeof cb === \"function\") {\n    if (err || state.finished) {\n      process.nextTick(cb, err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n  return this;\n};\nfunction needFinish(state) {\n  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;\n}\nfunction callFinal(stream, state) {\n  let called = false;\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream, err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream, err, state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit(\"prefinish\");\n      state.pendingcb++;\n      process.nextTick(finish, stream, state);\n    }\n  }\n  state.sync = true;\n  state.pendingcb++;\n  try {\n    const result = stream._final(onFinish);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === \"function\") {\n        then.call(result, function() {\n          process.nextTick(onFinish, null);\n        }, function(err) {\n          process.nextTick(onFinish, err);\n        });\n      }\n    }\n  } catch (err) {\n    onFinish(stream, state, err);\n  }\n  state.sync = false;\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === \"function\" && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit(\"prefinish\");\n    }\n  }\n}\nfunction finishMaybe(stream, state, sync) {\n  if (needFinish(state)) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0 && needFinish(state)) {\n      state.pendingcb++;\n      if (sync) {\n        process.nextTick(finish, stream, state);\n      } else {\n        finish(stream, state);\n      }\n    }\n  }\n}\nfunction finish(stream, state) {\n  state.pendingcb--;\n  state.finished = true;\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n  stream.emit(\"finish\");\n  if (state.autoDestroy) {\n    const rState = stream._readableState;\n    const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\nObjectDefineProperties(Writable.prototype, {\n  destroyed: {\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    },\n    set(value) {\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\n  },\n  writable: {\n    get() {\n      const w = this._writableState;\n      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;\n    },\n    set(val) {\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\n  },\n  writableFinished: {\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\n  },\n  writableObjectMode: {\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\n  },\n  writableBuffer: {\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  },\n  writableEnded: {\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\n  },\n  writableNeedDrain: {\n    get() {\n      const wState = this._writableState;\n      if (!wState)\n        return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\n  },\n  writableHighWaterMark: {\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\n  },\n  writableCorked: {\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\n  },\n  writableLength: {\n    get() {\n      return this._writableState && this._writableState.length;\n    }\n  }\n});\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err, cb) {\n  const state = this._writableState;\n  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {\n    process.nextTick(errorBuffer, state);\n  }\n  destroy.call(this, err, cb);\n  return this;\n};\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n  cb(err);\n};\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\nlet webStreamsAdapters;\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === void 0)\n    webStreamsAdapters = require(\"internal/webstreams/adapters\");\n  return webStreamsAdapters;\n}\nWritable.fromWeb = function(writableStream, options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);\n};\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n}"],["internal/test/binding.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  globalThis\n} = primordials;\nprocess.emitWarning(\"These APIs are for internal testing only. Do not use them.\", \"internal/test/binding\");\nif (module.isPreloading) {\n  globalThis.internalBinding = internalBinding;\n  globalThis.primordials = primordials;\n}\nmodule.exports = { internalBinding, primordials };\n}"],["internal/test/transfer.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  makeTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nprocess.emitWarning(\"These APIs are for internal testing only. Do not use them.\", \"internal/test/transfer\");\nclass E {\n  constructor(b) {\n    this.b = b;\n  }\n}\nclass F extends E {\n  constructor(b) {\n    super(b);\n    return makeTransferable(this);\n  }\n  [kClone]() {\n    return {\n      data: { b: this.b },\n      deserializeInfo: \"internal/test/transfer:F\"\n    };\n  }\n  [kDeserialize]({ b }) {\n    this.b = b;\n  }\n}\nmodule.exports = { E, F };\n}"],["internal/tls/parse-cert-string.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  StringPrototypeIndexOf,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  ObjectCreate\n} = primordials;\nfunction parseCertString(s) {\n  const out = ObjectCreate(null);\n  ArrayPrototypeForEach(StringPrototypeSplit(s, \"\\n\"), (part) => {\n    const sepIndex = StringPrototypeIndexOf(part, \"=\");\n    if (sepIndex > 0) {\n      const key = StringPrototypeSlice(part, 0, sepIndex);\n      const value = StringPrototypeSlice(part, sepIndex + 1);\n      if (key in out) {\n        if (!ArrayIsArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        ArrayPrototypePush(out[key], value);\n      } else {\n        out[key] = value;\n      }\n    }\n  });\n  return out;\n}\nexports.parseCertString = parseCertString;\n}"],["internal/tls/secure-context.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeForEach,\n  ArrayPrototypeJoin,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst {\n  codes: {\n    ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE\n  }\n} = require(\"internal/errors\");\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  validateInt32,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst {\n  toBuf\n} = require(\"internal/crypto/util\");\nconst {\n  crypto: {\n    TLS1_2_VERSION,\n    TLS1_3_VERSION\n  }\n} = internalBinding(\"constants\");\nfunction getDefaultEcdhCurve() {\n  return require(\"tls\").DEFAULT_ECDH_CURVE || \"auto\";\n}\nfunction getDefaultCiphers() {\n  return require(\"tls\").DEFAULT_CIPHERS;\n}\nfunction addCACerts(context, certs, name) {\n  ArrayPrototypeForEach(certs, (cert) => {\n    validateKeyOrCertOption(name, cert);\n    context.addCACert(cert);\n  });\n}\nfunction setCerts(context, certs, name) {\n  ArrayPrototypeForEach(certs, (cert) => {\n    validateKeyOrCertOption(name, cert);\n    context.setCert(cert);\n  });\n}\nfunction validateKeyOrCertOption(name, value) {\n  if (typeof value !== \"string\" && !isArrayBufferView(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name, [\n      \"string\",\n      \"Buffer\",\n      \"TypedArray\",\n      \"DataView\"\n    ], value);\n  }\n}\nfunction setKey(context, key, passphrase, name) {\n  validateKeyOrCertOption(`${name}.key`, key);\n  if (passphrase != null)\n    validateString(passphrase, `${name}.passphrase`);\n  context.setKey(key, passphrase);\n}\nfunction processCiphers(ciphers, name) {\n  ciphers = StringPrototypeSplit(ciphers || getDefaultCiphers(), \":\");\n  const cipherList = ArrayPrototypeJoin(ArrayPrototypeFilter(ciphers, (cipher) => {\n    return cipher.length > 0 && !StringPrototypeStartsWith(cipher, \"TLS_\");\n  }), \":\");\n  const cipherSuites = ArrayPrototypeJoin(ArrayPrototypeFilter(ciphers, (cipher) => {\n    return cipher.length > 0 && StringPrototypeStartsWith(cipher, \"TLS_\");\n  }), \":\");\n  if (cipherSuites === \"\" && cipherList === \"\")\n    throw new ERR_INVALID_ARG_VALUE(name, ciphers);\n  return { cipherList, cipherSuites };\n}\nfunction configSecureContext(context, options = {}, name = \"options\") {\n  validateObject(options, name);\n  const {\n    ca,\n    cert,\n    ciphers = getDefaultCiphers(),\n    clientCertEngine,\n    crl,\n    dhparam,\n    ecdhCurve = getDefaultEcdhCurve(),\n    key,\n    passphrase,\n    pfx,\n    privateKeyIdentifier,\n    privateKeyEngine,\n    sessionIdContext,\n    sessionTimeout,\n    sigalgs,\n    ticketKeys\n  } = options;\n  if (ca) {\n    addCACerts(context, ArrayIsArray(ca) ? ca : [ca], `${name}.ca`);\n  } else {\n    context.addRootCerts();\n  }\n  if (cert) {\n    setCerts(context, ArrayIsArray(cert) ? cert : [cert], `${name}.cert`);\n  }\n  if (key) {\n    if (ArrayIsArray(key)) {\n      for (let i = 0; i < key.length; ++i) {\n        const val = key[i];\n        const pem = val != void 0 && val.pem !== void 0 ? val.pem : val;\n        setKey(context, pem, val.passphrase || passphrase, name);\n      }\n    } else {\n      setKey(context, key, passphrase, name);\n    }\n  }\n  if (sigalgs !== void 0) {\n    validateString(sigalgs, `${name}.sigalgs`);\n    if (sigalgs === \"\")\n      throw new ERR_INVALID_ARG_VALUE(`${name}.sigalgs`, sigalgs);\n    context.setSigalgs(sigalgs);\n  }\n  if (privateKeyIdentifier !== void 0) {\n    if (privateKeyEngine === void 0) {\n      throw new ERR_INVALID_ARG_VALUE(`${name}.privateKeyEngine`, privateKeyEngine);\n    }\n    if (key) {\n      throw new ERR_INVALID_ARG_VALUE(`${name}.privateKeyIdentifier`, privateKeyIdentifier);\n    }\n    if (typeof privateKeyIdentifier === \"string\" && typeof privateKeyEngine === \"string\") {\n      if (context.setEngineKey)\n        context.setEngineKey(privateKeyIdentifier, privateKeyEngine);\n      else\n        throw new ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED();\n    } else if (typeof privateKeyIdentifier !== \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(`${name}.privateKeyIdentifier`, [\"string\", \"undefined\"], privateKeyIdentifier);\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`${name}.privateKeyEngine`, [\"string\", \"undefined\"], privateKeyEngine);\n    }\n  }\n  if (ciphers != null)\n    validateString(ciphers, `${name}.ciphers`);\n  const {\n    cipherList,\n    cipherSuites\n  } = processCiphers(ciphers, `${name}.ciphers`);\n  context.setCipherSuites(cipherSuites);\n  context.setCiphers(cipherList);\n  if (cipherSuites === \"\" && context.getMaxProto() > TLS1_2_VERSION && context.getMinProto() < TLS1_3_VERSION) {\n    context.setMaxProto(TLS1_2_VERSION);\n  }\n  if (cipherList === \"\" && context.getMinProto() < TLS1_3_VERSION && context.getMaxProto() > TLS1_2_VERSION) {\n    context.setMinProto(TLS1_3_VERSION);\n  }\n  validateString(ecdhCurve, `${name}.ecdhCurve`);\n  context.setECDHCurve(ecdhCurve);\n  if (dhparam !== void 0) {\n    validateKeyOrCertOption(`${name}.dhparam`, dhparam);\n    const warning = context.setDHParam(dhparam);\n    if (warning)\n      process.emitWarning(warning, \"SecurityWarning\");\n  }\n  if (crl !== void 0) {\n    if (ArrayIsArray(crl)) {\n      for (const val of crl) {\n        validateKeyOrCertOption(`${name}.crl`, val);\n        context.addCRL(val);\n      }\n    } else {\n      validateKeyOrCertOption(`${name}.crl`, crl);\n      context.addCRL(crl);\n    }\n  }\n  if (sessionIdContext !== void 0) {\n    validateString(sessionIdContext, `${name}.sessionIdContext`);\n    context.setSessionIdContext(sessionIdContext);\n  }\n  if (pfx !== void 0) {\n    if (ArrayIsArray(pfx)) {\n      ArrayPrototypeForEach(pfx, (val) => {\n        const raw = val.buf ? val.buf : val;\n        const pass = val.passphrase || passphrase;\n        if (pass !== void 0) {\n          context.loadPKCS12(toBuf(raw), toBuf(pass));\n        } else {\n          context.loadPKCS12(toBuf(raw));\n        }\n      });\n    } else if (passphrase) {\n      context.loadPKCS12(toBuf(pfx), toBuf(passphrase));\n    } else {\n      context.loadPKCS12(toBuf(pfx));\n    }\n  }\n  if (typeof clientCertEngine === \"string\") {\n    if (typeof context.setClientCertEngine !== \"function\")\n      throw new ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED();\n    else\n      context.setClientCertEngine(clientCertEngine);\n  } else if (clientCertEngine !== void 0) {\n    throw new ERR_INVALID_ARG_TYPE(`${name}.clientCertEngine`, [\"string\", \"null\", \"undefined\"], clientCertEngine);\n  }\n  if (ticketKeys !== void 0) {\n    if (!isArrayBufferView(ticketKeys)) {\n      throw new ERR_INVALID_ARG_TYPE(`${name}.ticketKeys`, [\"Buffer\", \"TypedArray\", \"DataView\"], ticketKeys);\n    }\n    if (ticketKeys.byteLength !== 48) {\n      throw new ERR_INVALID_ARG_VALUE(`${name}.ticketKeys`, ticketKeys.byteLength, \"must be exactly 48 bytes\");\n    }\n    context.setTicketKeys(ticketKeys);\n  }\n  if (sessionTimeout !== void 0) {\n    validateInt32(sessionTimeout, `${name}.sessionTimeout`);\n    context.setSessionTimeout(sessionTimeout);\n  }\n}\nmodule.exports = {\n  configSecureContext\n};\n}"],["internal/tls/secure-pair.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst EventEmitter = require(\"events\");\nconst { Duplex } = require(\"stream\");\nconst _tls_wrap = require(\"_tls_wrap\");\nconst _tls_common = require(\"_tls_common\");\nconst {\n  Symbol,\n  ReflectConstruct\n} = primordials;\nconst kCallback = Symbol(\"Callback\");\nconst kOtherSide = Symbol(\"Other\");\nclass DuplexSocket extends Duplex {\n  constructor() {\n    super();\n    this[kCallback] = null;\n    this[kOtherSide] = null;\n  }\n  _read() {\n    const callback = this[kCallback];\n    if (callback) {\n      this[kCallback] = null;\n      callback();\n    }\n  }\n  _write(chunk, encoding, callback) {\n    if (chunk.length === 0) {\n      process.nextTick(callback);\n    } else {\n      this[kOtherSide].push(chunk);\n      this[kOtherSide][kCallback] = callback;\n    }\n  }\n  _final(callback) {\n    this[kOtherSide].on(\"end\", callback);\n    this[kOtherSide].push(null);\n  }\n}\nclass DuplexPair {\n  constructor() {\n    this.socket1 = new DuplexSocket();\n    this.socket2 = new DuplexSocket();\n    this.socket1[kOtherSide] = this.socket2;\n    this.socket2[kOtherSide] = this.socket1;\n  }\n}\nclass SecurePair extends EventEmitter {\n  constructor(secureContext = _tls_common.createSecureContext(), isServer = false, requestCert = !isServer, rejectUnauthorized = false, options = {}) {\n    super();\n    const { socket1, socket2 } = new DuplexPair();\n    this.server = options.server;\n    this.credentials = secureContext;\n    this.encrypted = socket1;\n    this.cleartext = new _tls_wrap.TLSSocket(socket2, {\n      secureContext,\n      isServer,\n      requestCert,\n      rejectUnauthorized,\n      ...options\n    });\n    this.cleartext.once(\"secure\", () => this.emit(\"secure\"));\n  }\n  destroy() {\n    this.cleartext.destroy();\n    this.encrypted.destroy();\n  }\n}\nexports.createSecurePair = function createSecurePair(...args) {\n  return ReflectConstruct(SecurePair, args);\n};\n}"],["internal/util/comparisons.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypePush,\n  BigIntPrototypeValueOf,\n  BooleanPrototypeValueOf,\n  DatePrototypeGetTime,\n  Error,\n  NumberIsNaN,\n  NumberPrototypeValueOf,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectPrototypePropertyIsEnumerable,\n  ObjectPrototypeToString,\n  SafeMap,\n  SafeSet,\n  StringPrototypeValueOf,\n  SymbolPrototypeValueOf,\n  TypedArrayPrototypeGetSymbolToStringTag,\n  Uint8Array\n} = primordials;\nconst { compare } = internalBinding(\"buffer\");\nconst assert = require(\"internal/assert\");\nconst types = require(\"internal/util/types\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isDate,\n  isMap,\n  isRegExp,\n  isSet,\n  isNativeError,\n  isBoxedPrimitive,\n  isNumberObject,\n  isStringObject,\n  isBooleanObject,\n  isBigIntObject,\n  isSymbolObject,\n  isFloat32Array,\n  isFloat64Array\n} = types;\nconst {\n  getOwnNonIndexProperties,\n  propertyFilter: {\n    ONLY_ENUMERABLE,\n    SKIP_SYMBOLS\n  }\n} = internalBinding(\"util\");\nconst kStrict = true;\nconst kLoose = false;\nconst kNoIterator = 0;\nconst kIsArray = 1;\nconst kIsSet = 2;\nconst kIsMap = 3;\nfunction areSimilarRegExps(a, b) {\n  return a.source === b.source && a.flags === b.flags;\n}\nfunction areSimilarFloatArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (let offset = 0; offset < a.byteLength; offset++) {\n    if (a[offset] !== b[offset]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areSimilarTypedArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n}\nfunction areEqualArrayBuffers(buf1, buf2) {\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n}\nfunction isEqualBoxedPrimitive(val1, val2) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && ObjectIs(NumberPrototypeValueOf(val1), NumberPrototypeValueOf(val2));\n  }\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && StringPrototypeValueOf(val1) === StringPrototypeValueOf(val2);\n  }\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && BooleanPrototypeValueOf(val1) === BooleanPrototypeValueOf(val2);\n  }\n  if (isBigIntObject(val1)) {\n    return isBigIntObject(val2) && BigIntPrototypeValueOf(val1) === BigIntPrototypeValueOf(val2);\n  }\n  if (isSymbolObject(val1)) {\n    return isSymbolObject(val2) && SymbolPrototypeValueOf(val1) === SymbolPrototypeValueOf(val2);\n  }\n  assert.fail(`Unknown boxed type ${val1}`);\n}\nfunction innerDeepEqual(val1, val2, strict, memos) {\n  if (val1 === val2) {\n    if (val1 !== 0)\n      return true;\n    return strict ? ObjectIs(val1, val2) : true;\n  }\n  if (strict) {\n    if (typeof val1 !== \"object\") {\n      return typeof val1 === \"number\" && NumberIsNaN(val1) && NumberIsNaN(val2);\n    }\n    if (typeof val2 !== \"object\" || val1 === null || val2 === null) {\n      return false;\n    }\n    if (ObjectGetPrototypeOf(val1) !== ObjectGetPrototypeOf(val2)) {\n      return false;\n    }\n  } else {\n    if (val1 === null || typeof val1 !== \"object\") {\n      if (val2 === null || typeof val2 !== \"object\") {\n        return val1 == val2 || NumberIsNaN(val1) && NumberIsNaN(val2);\n      }\n      return false;\n    }\n    if (val2 === null || typeof val2 !== \"object\") {\n      return false;\n    }\n  }\n  const val1Tag = ObjectPrototypeToString(val1);\n  const val2Tag = ObjectPrototypeToString(val2);\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n  if (ArrayIsArray(val1)) {\n    if (!ArrayIsArray(val2) || val1.length !== val2.length) {\n      return false;\n    }\n    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;\n    const keys1 = getOwnNonIndexProperties(val1, filter);\n    const keys2 = getOwnNonIndexProperties(val2, filter);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n  } else if (val1Tag === \"[object Object]\") {\n    return keyCheck(val1, val2, strict, memos, kNoIterator);\n  } else if (isDate(val1)) {\n    if (!isDate(val2) || DatePrototypeGetTime(val1) !== DatePrototypeGetTime(val2)) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    if (!isNativeError(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {\n      return false;\n    }\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n      if (!areSimilarFloatArrays(val1, val2)) {\n        return false;\n      }\n    } else if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    }\n    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;\n    const keys1 = getOwnNonIndexProperties(val1, filter);\n    const keys2 = getOwnNonIndexProperties(val2, filter);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kNoIterator, keys1);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1)) {\n    if (!isEqualBoxedPrimitive(val1, val2)) {\n      return false;\n    }\n  } else if (ArrayIsArray(val2) || isArrayBufferView(val2) || isSet(val2) || isMap(val2) || isDate(val2) || isRegExp(val2) || isAnyArrayBuffer(val2) || isBoxedPrimitive(val2) || isNativeError(val2) || val2 instanceof Error) {\n    return false;\n  }\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\n}\nfunction getEnumerables(val, keys) {\n  return ArrayPrototypeFilter(keys, (k) => ObjectPrototypePropertyIsEnumerable(val, k));\n}\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n  if (arguments.length === 5) {\n    aKeys = ObjectKeys(val1);\n    const bKeys = ObjectKeys(val2);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  }\n  let i = 0;\n  for (; i < aKeys.length; i++) {\n    if (!ObjectPrototypePropertyIsEnumerable(val2, aKeys[i])) {\n      return false;\n    }\n  }\n  if (strict && arguments.length === 5) {\n    const symbolKeysA = ObjectGetOwnPropertySymbols(val1);\n    if (symbolKeysA.length !== 0) {\n      let count = 0;\n      for (i = 0; i < symbolKeysA.length; i++) {\n        const key = symbolKeysA[i];\n        if (ObjectPrototypePropertyIsEnumerable(val1, key)) {\n          if (!ObjectPrototypePropertyIsEnumerable(val2, key)) {\n            return false;\n          }\n          ArrayPrototypePush(aKeys, key);\n          count++;\n        } else if (ObjectPrototypePropertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n      const symbolKeysB = ObjectGetOwnPropertySymbols(val2);\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\n        return false;\n      }\n    } else {\n      const symbolKeysB = ObjectGetOwnPropertySymbols(val2);\n      if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {\n        return false;\n      }\n    }\n  }\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\n    return true;\n  }\n  if (memos === void 0) {\n    memos = {\n      val1: new SafeMap(),\n      val2: new SafeMap(),\n      position: 0\n    };\n  } else {\n    const val2MemoA = memos.val1.get(val1);\n    if (val2MemoA !== void 0) {\n      const val2MemoB = memos.val2.get(val2);\n      if (val2MemoB !== void 0) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n    memos.position++;\n  }\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n  return areEq;\n}\nfunction setHasEqualElement(set, val1, strict, memo) {\n  for (const val2 of set) {\n    if (innerDeepEqual(val1, val2, strict, memo)) {\n      set.delete(val2);\n      return true;\n    }\n  }\n  return false;\n}\nfunction findLooseMatchingPrimitives(prim) {\n  switch (typeof prim) {\n    case \"undefined\":\n      return null;\n    case \"object\":\n      return void 0;\n    case \"symbol\":\n      return false;\n    case \"string\":\n      prim = +prim;\n    case \"number\":\n      if (NumberIsNaN(prim)) {\n        return false;\n      }\n  }\n  return true;\n}\nfunction setMightHaveLoosePrim(a, b, prim) {\n  const altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null)\n    return altValue;\n  return b.has(altValue) && !a.has(altValue);\n}\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\n  const altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  const curB = b.get(altValue);\n  if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\n    return false;\n  }\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\n}\nfunction setEquiv(a, b, strict, memo) {\n  let set = null;\n  for (const val of a) {\n    if (typeof val === \"object\" && val !== null) {\n      if (set === null) {\n        set = new SafeSet();\n      }\n      set.add(val);\n    } else if (!b.has(val)) {\n      if (strict)\n        return false;\n      if (!setMightHaveLoosePrim(a, b, val)) {\n        return false;\n      }\n      if (set === null) {\n        set = new SafeSet();\n      }\n      set.add(val);\n    }\n  }\n  if (set !== null) {\n    for (const val of b) {\n      if (typeof val === \"object\" && val !== null) {\n        if (!setHasEqualElement(set, val, strict, memo))\n          return false;\n      } else if (!strict && !a.has(val) && !setHasEqualElement(set, val, strict, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n  for (const key2 of set) {\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\n      set.delete(key2);\n      return true;\n    }\n  }\n  return false;\n}\nfunction mapEquiv(a, b, strict, memo) {\n  let set = null;\n  for (const { 0: key, 1: item1 } of a) {\n    if (typeof key === \"object\" && key !== null) {\n      if (set === null) {\n        set = new SafeSet();\n      }\n      set.add(key);\n    } else {\n      const item2 = b.get(key);\n      if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\n        if (strict)\n          return false;\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo))\n          return false;\n        if (set === null) {\n          set = new SafeSet();\n        }\n        set.add(key);\n      }\n    }\n  }\n  if (set !== null) {\n    for (const { 0: key, 1: item } of b) {\n      if (typeof key === \"object\" && key !== null) {\n        if (!mapHasEqualEntry(set, a, key, item, strict, memo))\n          return false;\n      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\n  let i = 0;\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (ObjectPrototypeHasOwnProperty(a, i)) {\n        if (!ObjectPrototypeHasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\n          return false;\n        }\n      } else if (ObjectPrototypeHasOwnProperty(b, i)) {\n        return false;\n      } else {\n        const keysA = ObjectKeys(a);\n        for (; i < keysA.length; i++) {\n          const key = keysA[i];\n          if (!ObjectPrototypeHasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\n            return false;\n          }\n        }\n        if (keysA.length !== ObjectKeys(b).length) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n  for (i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!innerDeepEqual(a[key], b[key], strict, memos)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isDeepEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kLoose);\n}\nfunction isDeepStrictEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kStrict);\n}\nmodule.exports = {\n  isDeepEqual,\n  isDeepStrictEqual\n};\n}"],["internal/util/debuglog.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectCreate,\n  ObjectDefineProperty,\n  RegExp,\n  RegExpPrototypeExec,\n  SafeArrayIterator,\n  StringPrototypeToLowerCase,\n  StringPrototypeToUpperCase\n} = primordials;\nconst { inspect, format, formatWithOptions } = require(\"internal/util/inspect\");\nlet debugImpls;\nlet testEnabled;\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replaceAll(\"*\", \".*\").replaceAll(\",\", \"$|^\");\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`, \"i\");\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex, str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\nfunction emitWarningIfNeeded(set) {\n  if (set === \"HTTP\" || set === \"HTTP2\") {\n    process.emitWarning(\"Setting the NODE_DEBUG environment variable to '\" + StringPrototypeToLowerCase(set) + \"' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.\");\n  }\n}\nconst noop = () => {\n};\nfunction debuglogImpl(enabled, set) {\n  if (debugImpls[set] === void 0) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }, ...args);\n        const coloredPID = inspect(pid, { colors });\n        process.stderr.write(format(\"%s %s: %s\\n\", set, coloredPID, msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\nfunction debuglog(set, cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    debug = debuglogImpl(enabled, set);\n    if (typeof cb === \"function\")\n      cb(debug);\n    switch (args.length) {\n      case 0:\n        return debug();\n      case 1:\n        return debug(args[0]);\n      case 2:\n        return debug(args[0], args[1]);\n      default:\n        return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 0:\n        return debug();\n      case 1:\n        return debug(args[0]);\n      case 2:\n        return debug(args[0], args[1]);\n      default:\n        return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger, \"enabled\", {\n    get() {\n      return test();\n    },\n    configurable: true,\n    enumerable: true\n  });\n  return logger;\n}\nmodule.exports = {\n  debuglog,\n  initializeDebugEnv\n};\n}"],["internal/util/inspect.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeForEach,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypePushApply,\n  ArrayPrototypeSort,\n  ArrayPrototypeUnshift,\n  BigIntPrototypeValueOf,\n  BooleanPrototypeValueOf,\n  DatePrototypeGetTime,\n  DatePrototypeToISOString,\n  DatePrototypeToString,\n  ErrorPrototypeToString,\n  FunctionPrototypeCall,\n  FunctionPrototypeToString,\n  JSONStringify,\n  MapPrototypeGetSize,\n  MapPrototypeEntries,\n  MathFloor,\n  MathMax,\n  MathMin,\n  MathRound,\n  MathSqrt,\n  Number,\n  NumberIsNaN,\n  NumberParseFloat,\n  NumberParseInt,\n  NumberPrototypeValueOf,\n  Object,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetOwnPropertySymbols,\n  ObjectGetPrototypeOf,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeHasOwnProperty,\n  ObjectPrototypePropertyIsEnumerable,\n  ObjectSeal,\n  ObjectSetPrototypeOf,\n  ReflectOwnKeys,\n  RegExp,\n  RegExpPrototypeTest,\n  RegExpPrototypeToString,\n  SafeStringIterator,\n  SafeMap,\n  SafeSet,\n  SetPrototypeGetSize,\n  SetPrototypeValues,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeCodePointAt,\n  StringPrototypeIncludes,\n  StringPrototypeNormalize,\n  StringPrototypePadEnd,\n  StringPrototypePadStart,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  StringPrototypeValueOf,\n  SymbolPrototypeToString,\n  SymbolPrototypeValueOf,\n  SymbolIterator,\n  SymbolToStringTag,\n  TypedArrayPrototypeGetLength,\n  TypedArrayPrototypeGetSymbolToStringTag,\n  Uint8Array,\n  globalThis,\n  uncurryThis\n} = primordials;\nconst {\n  getOwnNonIndexProperties,\n  getPromiseDetails,\n  getProxyDetails,\n  kPending,\n  kRejected,\n  previewEntries,\n  getConstructorName: internalGetConstructorName,\n  getExternalValue,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE\n  }\n} = internalBinding(\"util\");\nconst {\n  customInspectSymbol,\n  isError,\n  join,\n  removeColors\n} = require(\"internal/util\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  },\n  isStackOverflowError\n} = require(\"internal/errors\");\nconst {\n  isAsyncFunction,\n  isGeneratorFunction,\n  isAnyArrayBuffer,\n  isArrayBuffer,\n  isArgumentsObject,\n  isBoxedPrimitive,\n  isDataView,\n  isExternal,\n  isMap,\n  isMapIterator,\n  isModuleNamespaceObject,\n  isNativeError,\n  isPromise,\n  isSet,\n  isSetIterator,\n  isWeakMap,\n  isWeakSet,\n  isRegExp,\n  isDate,\n  isTypedArray,\n  isStringObject,\n  isNumberObject,\n  isBooleanObject,\n  isBigIntObject\n} = require(\"internal/util/types\");\nconst assert = require(\"internal/assert\");\nconst { NativeModule } = require(\"internal/bootstrap/loaders\");\nconst {\n  validateObject\n} = require(\"internal/validators\");\nlet hexSlice;\nconst builtInObjects = new SafeSet(ArrayPrototypeFilter(ObjectGetOwnPropertyNames(globalThis), (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/, e)));\nconst isUndetectableObject = (v) => typeof v === \"undefined\" && v !== void 0;\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  maxStringLength: 1e4,\n  breakLength: 80,\n  compact: 3,\n  sorted: false,\n  getters: false\n});\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g;\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\nconst coreModuleRegExp = /^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\nconst kMinLineLength = 16;\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\nconst meta = [\n  \"\\\\x00\",\n  \"\\\\x01\",\n  \"\\\\x02\",\n  \"\\\\x03\",\n  \"\\\\x04\",\n  \"\\\\x05\",\n  \"\\\\x06\",\n  \"\\\\x07\",\n  \"\\\\b\",\n  \"\\\\t\",\n  \"\\\\n\",\n  \"\\\\x0B\",\n  \"\\\\f\",\n  \"\\\\r\",\n  \"\\\\x0E\",\n  \"\\\\x0F\",\n  \"\\\\x10\",\n  \"\\\\x11\",\n  \"\\\\x12\",\n  \"\\\\x13\",\n  \"\\\\x14\",\n  \"\\\\x15\",\n  \"\\\\x16\",\n  \"\\\\x17\",\n  \"\\\\x18\",\n  \"\\\\x19\",\n  \"\\\\x1A\",\n  \"\\\\x1B\",\n  \"\\\\x1C\",\n  \"\\\\x1D\",\n  \"\\\\x1E\",\n  \"\\\\x1F\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\'\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\\\\\\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\x7F\",\n  \"\\\\x80\",\n  \"\\\\x81\",\n  \"\\\\x82\",\n  \"\\\\x83\",\n  \"\\\\x84\",\n  \"\\\\x85\",\n  \"\\\\x86\",\n  \"\\\\x87\",\n  \"\\\\x88\",\n  \"\\\\x89\",\n  \"\\\\x8A\",\n  \"\\\\x8B\",\n  \"\\\\x8C\",\n  \"\\\\x8D\",\n  \"\\\\x8E\",\n  \"\\\\x8F\",\n  \"\\\\x90\",\n  \"\\\\x91\",\n  \"\\\\x92\",\n  \"\\\\x93\",\n  \"\\\\x94\",\n  \"\\\\x95\",\n  \"\\\\x96\",\n  \"\\\\x97\",\n  \"\\\\x98\",\n  \"\\\\x99\",\n  \"\\\\x9A\",\n  \"\\\\x9B\",\n  \"\\\\x9C\",\n  \"\\\\x9D\",\n  \"\\\\x9E\",\n  \"\\\\x9F\"\n];\nconst ansiPattern = \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\";\nconst ansi = new RegExp(ansiPattern, \"g\");\nlet getStringWidth;\nfunction getUserOptions(ctx, isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize,\n    showHidden: ctx.showHidden,\n    depth: ctx.depth,\n    colors: ctx.colors,\n    customInspect: ctx.customInspect,\n    showProxy: ctx.showProxy,\n    maxArrayLength: ctx.maxArrayLength,\n    maxStringLength: ctx.maxStringLength,\n    breakLength: ctx.breakLength,\n    compact: ctx.compact,\n    sorted: ctx.sorted,\n    getters: ctx.getters,\n    ...ctx.userOptions\n  };\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret, null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === \"object\" || typeof ret[key] === \"function\") && ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value, flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value, flavour)}`;\n      } catch {\n      }\n      if (typeof stylized !== \"string\")\n        return value;\n      return stylized;\n    }, null);\n  }\n  return ret;\n}\nfunction inspect(value, opts) {\n  const ctx = {\n    budget: {},\n    indentationLvl: 0,\n    seen: [],\n    currentDepth: 0,\n    stylize: stylizeNoColor,\n    showHidden: inspectDefaultOptions.showHidden,\n    depth: inspectDefaultOptions.depth,\n    colors: inspectDefaultOptions.colors,\n    customInspect: inspectDefaultOptions.customInspect,\n    showProxy: inspectDefaultOptions.showProxy,\n    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n    maxStringLength: inspectDefaultOptions.maxStringLength,\n    breakLength: inspectDefaultOptions.breakLength,\n    compact: inspectDefaultOptions.compact,\n    sorted: inspectDefaultOptions.sorted,\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    if (arguments.length > 2) {\n      if (arguments[2] !== void 0) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== void 0) {\n        ctx.colors = arguments[3];\n      }\n    }\n    if (typeof opts === \"boolean\") {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        if (ObjectPrototypeHasOwnProperty(inspectDefaultOptions, key) || key === \"stylize\") {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === void 0) {\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors)\n    ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null)\n    ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null)\n    ctx.maxStringLength = Infinity;\n  return formatValue(ctx, value, 0);\n}\ninspect.custom = customInspectSymbol;\nObjectDefineProperty(inspect, \"defaultOptions\", {\n  get() {\n    return inspectDefaultOptions;\n  },\n  set(options) {\n    validateObject(options, \"options\");\n    return ObjectAssign(inspectDefaultOptions, options);\n  }\n});\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null), {\n  reset: [0, 0],\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  blink: [5, 25],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  doubleunderline: [21, 24],\n  black: [30, defaultFG],\n  red: [31, defaultFG],\n  green: [32, defaultFG],\n  yellow: [33, defaultFG],\n  blue: [34, defaultFG],\n  magenta: [35, defaultFG],\n  cyan: [36, defaultFG],\n  white: [37, defaultFG],\n  bgBlack: [40, defaultBG],\n  bgRed: [41, defaultBG],\n  bgGreen: [42, defaultBG],\n  bgYellow: [43, defaultBG],\n  bgBlue: [44, defaultBG],\n  bgMagenta: [45, defaultBG],\n  bgCyan: [46, defaultBG],\n  bgWhite: [47, defaultBG],\n  framed: [51, 54],\n  overlined: [53, 55],\n  gray: [90, defaultFG],\n  redBright: [91, defaultFG],\n  greenBright: [92, defaultFG],\n  yellowBright: [93, defaultFG],\n  blueBright: [94, defaultFG],\n  magentaBright: [95, defaultFG],\n  cyanBright: [96, defaultFG],\n  whiteBright: [97, defaultFG],\n  bgGray: [100, defaultBG],\n  bgRedBright: [101, defaultBG],\n  bgGreenBright: [102, defaultBG],\n  bgYellowBright: [103, defaultBG],\n  bgBlueBright: [104, defaultBG],\n  bgMagentaBright: [105, defaultBG],\n  bgCyanBright: [106, defaultBG],\n  bgWhiteBright: [107, defaultBG]\n});\nfunction defineColorAlias(target, alias) {\n  ObjectDefineProperty(inspect.colors, alias, {\n    get() {\n      return this[target];\n    },\n    set(value) {\n      this[target] = value;\n    },\n    configurable: true,\n    enumerable: false\n  });\n}\ndefineColorAlias(\"gray\", \"grey\");\ndefineColorAlias(\"gray\", \"blackBright\");\ndefineColorAlias(\"bgGray\", \"bgGrey\");\ndefineColorAlias(\"bgGray\", \"bgBlackBright\");\ndefineColorAlias(\"dim\", \"faint\");\ndefineColorAlias(\"strikethrough\", \"crossedout\");\ndefineColorAlias(\"strikethrough\", \"strikeThrough\");\ndefineColorAlias(\"strikethrough\", \"crossedOut\");\ndefineColorAlias(\"hidden\", \"conceal\");\ndefineColorAlias(\"inverse\", \"swapColors\");\ndefineColorAlias(\"inverse\", \"swapcolors\");\ndefineColorAlias(\"doubleunderline\", \"doubleUnderline\");\ninspect.styles = ObjectAssign(ObjectCreate(null), {\n  special: \"cyan\",\n  number: \"yellow\",\n  bigint: \"yellow\",\n  boolean: \"yellow\",\n  undefined: \"grey\",\n  null: \"bold\",\n  string: \"green\",\n  symbol: \"green\",\n  date: \"magenta\",\n  regexp: \"red\",\n  module: \"underline\"\n});\nfunction addQuotes(str, quotes) {\n  if (quotes === -1) {\n    return `\"${str}\"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\nconst escapeFn = (str) => meta[StringPrototypeCharCodeAt(str)];\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n  if (StringPrototypeIncludes(str, \"'\")) {\n    if (!StringPrototypeIncludes(str, '\"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str, \"`\") && !StringPrototypeIncludes(str, \"${\")) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n  if (str.length < 5e3 && !RegExpPrototypeTest(escapeTest, str))\n    return addQuotes(str, singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str, escapeReplace, escapeFn);\n    return addQuotes(str, singleQuote);\n  }\n  let result = \"\";\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = StringPrototypeCharCodeAt(str, i);\n    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str, last, i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n  if (last !== lastIndex) {\n    result += StringPrototypeSlice(str, last);\n  }\n  return addQuotes(result, singleQuote);\n}\nfunction stylizeWithColor(str, styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== void 0) {\n    const color = inspect.colors[style];\n    if (color !== void 0)\n      return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;\n  }\n  return str;\n}\nfunction stylizeNoColor(str) {\n  return str;\n}\nfunction getEmptyFormatArray() {\n  return [];\n}\nfunction isInstanceof(object, proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\nfunction getConstructorName(obj, ctx, recurseTimes, protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj, \"constructor\");\n    if (descriptor !== void 0 && typeof descriptor.value === \"function\" && descriptor.value.name !== \"\" && isInstanceof(tmp, descriptor.value)) {\n      if (protoProps !== void 0 && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);\n      }\n      return descriptor.value.name;\n    }\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === void 0) {\n      firstProto = obj;\n    }\n  }\n  if (firstProto === null) {\n    return null;\n  }\n  const res = internalGetConstructorName(tmp);\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n  const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto, {\n      ...ctx,\n      customInspect: false,\n      depth: -1\n    })}>`;\n  }\n  return `${res} <${protoConstr}>`;\n}\nfunction addPrototypeProperties(ctx, main, obj, recurseTimes, output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      if (obj === null) {\n        return;\n      }\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj, \"constructor\");\n      if (descriptor !== void 0 && typeof descriptor.value === \"function\" && builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys, (key) => keySet.add(key));\n    }\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen, main);\n    for (const key of keys) {\n      if (key === \"constructor\" || ObjectPrototypeHasOwnProperty(main, key) || depth !== 0 && keySet.has(key)) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj, key);\n      if (typeof desc.value === \"function\") {\n        continue;\n      }\n      const value = formatProperty(ctx, obj, recurseTimes, key, kObjectType, desc, main);\n      if (ctx.colors) {\n        ArrayPrototypePush(output, `\u001b[2m${value}\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output, value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  } while (++depth !== 3);\n}\nfunction getPrefix(constructor, tag, fallback, size = \"\") {\n  if (constructor === null) {\n    if (tag !== \"\" && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n  if (tag !== \"\" && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\nfunction getKeys(value, showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys, symbols);\n  } else {\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === \"ReferenceError\" && isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value, key);\n      ArrayPrototypePushApply(keys, ArrayPrototypeFilter(symbols, filter));\n    }\n  }\n  return keys;\n}\nfunction getCtxStyle(value, constructor, tag) {\n  let fallback = \"\";\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = \"Object\";\n    }\n  }\n  return getPrefix(constructor, tag, fallback);\n}\nfunction formatProxy(ctx, proxy, recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize(\"Proxy [Array]\", \"special\");\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx, proxy[0], recurseTimes),\n    formatValue(ctx, proxy[1], recurseTimes)\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(ctx, res, \"\", [\"Proxy [\", \"]\"], kArrayExtrasType, recurseTimes);\n}\nfunction formatValue(ctx, value, recurseTimes, typedArray) {\n  if (typeof value !== \"object\" && typeof value !== \"function\" && !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize, value, ctx);\n  }\n  if (value === null) {\n    return ctx.stylize(\"null\", \"null\");\n  }\n  const context = value;\n  const proxy = getProxyDetails(value, !!ctx.showProxy);\n  if (proxy !== void 0) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx, proxy, recurseTimes);\n    }\n    value = proxy;\n  }\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === \"function\" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext = proxy !== void 0 || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(maybeCustom, context, depth, getUserOptions(ctx, isCrossContext));\n      if (ret !== context) {\n        if (typeof ret !== \"string\") {\n          return formatValue(ctx, ret, recurseTimes);\n        }\n        return ret.replace(/\\n/g, `\n${\" \".repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === void 0) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value, index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === void 0) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value, index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`, \"special\");\n  }\n  return formatRaw(ctx, value, recurseTimes, typedArray);\n}\nfunction formatRaw(ctx, value, recurseTimes, typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);\n  if (protoProps !== void 0 && protoProps.length === 0) {\n    protoProps = void 0;\n  }\n  let tag = value[SymbolToStringTag];\n  if (typeof tag !== \"string\" || tag !== \"\" && (ctx.showHidden ? ObjectPrototypeHasOwnProperty : ObjectPrototypePropertyIsEnumerable)(value, SymbolToStringTag)) {\n    tag = \"\";\n  }\n  let base = \"\";\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n  let extrasType = kObjectType;\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      const prefix = constructor !== \"Array\" || tag !== \"\" ? getPrefix(constructor, tag, \"Array\", `(${value.length})`) : \"\";\n      keys = getOwnNonIndexProperties(value, filter);\n      braces = [`${prefix}[`, \"]\"];\n      if (value.length === 0 && keys.length === 0 && protoProps === void 0)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, \"Set\", `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === void 0)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, \"}\"];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor, tag, \"Map\", `(${size})`);\n      keys = getKeys(value, ctx.showHidden);\n      formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === void 0)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`, \"}\"];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value, filter);\n      let bound = value;\n      let fallback = \"\";\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);\n      braces = [`${prefix}[`, \"]\"];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      formatter = formatTypedArray.bind(null, bound, size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces(\"Map\", tag);\n      formatter = formatIterator.bind(null, braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value, ctx.showHidden);\n      braces = getIteratorBraces(\"Set\", tag);\n      formatter = formatIterator.bind(null, braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value, ctx.showHidden);\n    braces = [\"{\", \"}\"];\n    if (constructor === \"Object\") {\n      if (isArgumentsObject(value)) {\n        braces[0] = \"[Arguments] {\";\n      } else if (tag !== \"\") {\n        braces[0] = `${getPrefix(constructor, tag, \"Object\")}{`;\n      }\n      if (keys.length === 0 && protoProps === void 0) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === \"function\") {\n      base = getFunctionBase(value, constructor, tag);\n      if (keys.length === 0 && protoProps === void 0)\n        return ctx.stylize(base, \"special\");\n    } else if (isRegExp(value)) {\n      base = RegExpPrototypeToString(constructor !== null ? value : new RegExp(value));\n      const prefix = getPrefix(constructor, tag, \"RegExp\");\n      if (prefix !== \"RegExp \")\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {\n        return ctx.stylize(base, \"regexp\");\n      }\n    } else if (isDate(value)) {\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ? DatePrototypeToString(value) : DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor, tag, \"Date\");\n      if (prefix !== \"Date \")\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === void 0) {\n        return ctx.stylize(base, \"date\");\n      }\n    } else if (isError(value)) {\n      base = formatError(value, constructor, tag, ctx, keys);\n      if (keys.length === 0 && protoProps === void 0)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      const arrayType = isArrayBuffer(value) ? \"ArrayBuffer\" : \"SharedArrayBuffer\";\n      const prefix = getPrefix(constructor, tag, arrayType);\n      if (typedArray === void 0) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === void 0) {\n        return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys, \"byteLength\");\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor, tag, \"DataView\")}{`;\n      ArrayPrototypeUnshift(keys, \"byteLength\", \"byteOffset\", \"buffer\");\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor, tag, \"Promise\")}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor, tag, \"WeakSet\")}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor, tag, \"WeakMap\")}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor, tag, \"Module\")}{`;\n      formatter = formatNamespaceObject.bind(null, keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value, ctx, keys, constructor, tag);\n      if (keys.length === 0 && protoProps === void 0) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === void 0) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`, \"special\");\n        }\n        return `${getCtxStyle(value, constructor, tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;\n    }\n  }\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName, \"special\");\n  }\n  recurseTimes += 1;\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx, value, recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n    }\n    if (protoProps !== void 0) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);\n    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);\n  }\n  if (ctx.circular !== void 0) {\n    const index = ctx.circular.get(value);\n    if (index !== void 0) {\n      const reference = ctx.stylize(`<ref *${index}>`, \"special\");\n      if (ctx.compact !== true) {\n        base = base === \"\" ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length, keys.length, ...sorted);\n    }\n  }\n  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\nfunction getIteratorBraces(type, tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== \"\")\n      tag += \"] [\";\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`, \"}\"];\n}\nfunction getBoxedBase(value, ctx, keys, constructor, tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = \"Number\";\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = \"String\";\n    keys.splice(0, value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = \"Boolean\";\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = \"BigInt\";\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = \"Symbol\";\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += \" (null prototype)\";\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor, fn(value), ctx)}]`;\n  if (tag !== \"\" && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base, StringPrototypeToLowerCase(type));\n}\nfunction getClassBase(value, constructor, tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value, \"name\");\n  const name = hasName && value.name || \"(anonymous)\";\n  let base = `class ${name}`;\n  if (constructor !== \"Function\" && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== \"\" && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += \" extends [null prototype]\";\n  }\n  return `[${base}]`;\n}\nfunction getFunctionBase(value, constructor, tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.slice(0, 5) === \"class\" && stringified.endsWith(\"}\")) {\n    const slice = stringified.slice(5, -1);\n    const bracketIndex = slice.indexOf(\"{\");\n    if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes(\"(\") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value, constructor, tag);\n    }\n  }\n  let type = \"Function\";\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += \" (null prototype)\";\n  }\n  if (value.name === \"\") {\n    base += \" (anonymous)\";\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += \"]\";\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== \"\" && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\nfunction formatError(err, constructor, tag, ctx, keys) {\n  const name = err.name != null ? String(err.name) : \"Error\";\n  let len = name.length;\n  let stack = err.stack ? String(err.stack) : ErrorPrototypeToString(err);\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name2 of [\"name\", \"message\", \"stack\"]) {\n      const index = keys.indexOf(name2);\n      if (index !== -1 && stack.includes(err[name2])) {\n        keys.splice(index, 1);\n      }\n    }\n  }\n  if (constructor === null || name.endsWith(\"Error\") && stack.startsWith(name) && (stack.length === len || stack[len] === \":\" || stack[len] === \"\\n\")) {\n    let fallback = \"Error\";\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = start && start[1] || \"\";\n      len = fallback.length;\n      fallback = fallback || \"Error\";\n    }\n    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  let pos = err.message && stack.indexOf(err.message) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  const stackStart = stack.indexOf(\"\\n    at\", pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    let newStack = stack.slice(0, stackStart);\n    const lines = stack.slice(stackStart + 1).split(\"\\n\");\n    for (const line of lines) {\n      const core = line.match(coreModuleRegExp);\n      if (core !== null && NativeModule.exists(core[1])) {\n        newStack += `\n${ctx.stylize(line, \"undefined\")}`;\n      } else {\n        let nodeModule;\n        newStack += \"\\n\";\n        let pos2 = 0;\n        while (nodeModule = nodeModulesRegExp.exec(line)) {\n          newStack += line.slice(pos2, nodeModule.index + 14);\n          newStack += ctx.stylize(nodeModule[1], \"module\");\n          pos2 = nodeModule.index + nodeModule[0].length;\n        }\n        newStack += pos2 === 0 ? line : line.slice(pos2);\n      }\n    }\n    stack = newStack;\n  }\n  if (ctx.indentationLvl !== 0) {\n    const indentation = \" \".repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g, `\n${indentation}`);\n  }\n  return stack;\n}\nfunction groupArrayElements(ctx, output, value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    outputLength--;\n  }\n  const separatorSpace = 2;\n  const dataLen = new Array(outputLength);\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i], ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  const actualMax = maxLength + separatorSpace;\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias, 1);\n    const columns = MathMin(MathRound(MathSqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i2 = 0; i2 < columns; i2++) {\n      let lineMaxLength = 0;\n      for (let j = i2; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i2] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== void 0) {\n      for (let i2 = 0; i2 < output.length; i2++) {\n        if (typeof value[i2] !== \"number\" && typeof value[i2] !== \"bigint\") {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    for (let i2 = 0; i2 < outputLength; i2 += columns) {\n      const max = MathMin(i2 + columns, outputLength);\n      let str = \"\";\n      let j = i2;\n      for (; j < max - 1; j++) {\n        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j];\n        str += order(`${output[j]}, `, padding, \" \");\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j] - separatorSpace;\n        str += StringPrototypePadStart(output[j], padding, \" \");\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp, str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp, output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\nfunction handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(`[${constructorName}: Inspection interrupted prematurely. Maximum call stack size exceeded.]`, \"special\");\n  }\n  assert.fail(err.stack);\n}\nfunction formatNumber(fn, value) {\n  return fn(ObjectIs(value, -0) ? \"-0\" : `${value}`, \"number\");\n}\nfunction formatBigInt(fn, value) {\n  return fn(`${value}n`, \"bigint\");\n}\nfunction formatPrimitive(fn, value, ctx) {\n  if (typeof value === \"string\") {\n    let trailer = \"\";\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0, ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? \"s\" : \"\"}`;\n    }\n    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value.split(/(?<=\\n)/).map((line) => fn(strEscape(line), \"string\")).join(` +\n${\" \".repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value), \"string\") + trailer;\n  }\n  if (typeof value === \"number\")\n    return formatNumber(fn, value);\n  if (typeof value === \"bigint\")\n    return formatBigInt(fn, value);\n  if (typeof value === \"boolean\")\n    return fn(`${value}`, \"boolean\");\n  if (typeof value === \"undefined\")\n    return fn(\"undefined\", \"undefined\");\n  return fn(SymbolPrototypeToString(value), \"symbol\");\n}\nfunction formatNamespaceObject(keys, ctx, value, recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === \"ReferenceError\");\n      const tmp = { [keys[i]]: \"\" };\n      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n      const pos = output[i].lastIndexOf(\" \");\n      output[i] = output[i].slice(0, pos + 1) + ctx.stylize(\"<uninitialized>\", \"special\");\n    }\n  }\n  keys.length = 0;\n  return output;\n}\nfunction formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? \"s\" : \"\";\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, \"undefined\"));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? \"s\" : \"\";\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message, \"undefined\"));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? \"s\" : \"\"}`);\n  }\n  return output;\n}\nfunction formatArrayBuffer(ctx, value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize(\"(detached)\", \"special\")];\n  }\n  if (hexSlice === void 0)\n    hexSlice = uncurryThis(require(\"buffer\").Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(hexSlice(buffer, 0, MathMin(ctx.maxArrayLength, buffer.length)), /(.{2})/g, \"$1 \"));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? \"s\" : \"\"}`;\n  return [`${ctx.stylize(\"[Uint8Contents]\", \"special\")}: <${str}>`];\n}\nfunction formatArray(ctx, value, recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0, ctx.maxArrayLength), valLen);\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    if (!ObjectPrototypeHasOwnProperty(value, i)) {\n      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n    }\n    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? \"s\" : \"\"}`);\n  return output;\n}\nfunction formatTypedArray(value, length, ctx, ignored, recurseTimes) {\n  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === \"number\" ? formatNumber : formatBigInt;\n  for (let i = 0; i < maxLength; ++i)\n    output[i] = elementFormatter(ctx.stylize, value[i]);\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? \"s\" : \"\"}`;\n  }\n  if (ctx.showHidden) {\n    ctx.indentationLvl += 2;\n    for (const key of [\n      \"BYTES_PER_ELEMENT\",\n      \"length\",\n      \"byteLength\",\n      \"byteOffset\",\n      \"buffer\"\n    ]) {\n      const str = formatValue(ctx, value[key], recurseTimes, true);\n      ArrayPrototypePush(output, `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\nfunction formatSet(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output, formatValue(ctx, v, recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\nfunction formatMap(value, ctx, ignored, recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k, 1: v } of value) {\n    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\nfunction formatSetIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  const maxLength = MathMin(maxArrayLength, entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx, entries[i], recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output, `... ${remaining} more item${remaining > 1 ? \"s\" : \"\"}`);\n  }\n  return output;\n}\nfunction formatMapIterInner(ctx, recurseTimes, entries, state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength, len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;\n    }\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx, entries[pos], recurseTimes),\n        formatValue(ctx, entries[pos + 1], recurseTimes)\n      ];\n      output[i] = reduceToSingleString(ctx, res, \"\", [\"[\", \"]\"], kArrayExtrasType, recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? \"s\" : \"\"}`);\n  }\n  return output;\n}\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize(\"<items unknown>\", \"special\")];\n}\nfunction formatWeakSet(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n}\nfunction formatWeakMap(ctx, value, recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n}\nfunction formatIterator(braces, ctx, value, recurseTimes) {\n  const { 0: entries, 1: isKeyValue } = previewEntries(value, true);\n  if (isKeyValue) {\n    braces[0] = braces[0].replace(/ Iterator] {$/, \" Entries] {\");\n    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n  }\n  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n}\nfunction formatPromise(ctx, value, recurseTimes) {\n  let output;\n  const { 0: state, 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize(\"<pending>\", \"special\")];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx, result, recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ? `${ctx.stylize(\"<rejected>\", \"special\")} ${str}` : str\n    ];\n  }\n  return output;\n}\nfunction formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {\n  let name, str;\n  let extra = \" \";\n  desc = desc || ObjectGetOwnPropertyDescriptor(value, key) || { value: value[key], enumerable: true };\n  if (desc.value !== void 0) {\n    const diff = ctx.compact !== true || type !== kObjectType ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx, desc.value, recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {\n      extra = `\n${\" \".repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== void 0) {\n    const label = desc.set !== void 0 ? \"Getter/Setter\" : \"Getter\";\n    const s = ctx.stylize;\n    const sp = \"special\";\n    if (ctx.getters && (ctx.getters === true || ctx.getters === \"get\" && desc.set === void 0 || ctx.getters === \"set\" && desc.set !== void 0)) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get, original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`, sp)} ${s(\"null\", \"null\")}${s(\"]\", sp)}`;\n        } else if (typeof tmp === \"object\") {\n          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s, tmp, ctx);\n          str = `${s(`[${label}:`, sp)} ${primitive}${s(\"]\", sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`, sp)} ${message}${s(\"]\", sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`, sp);\n    }\n  } else if (desc.set !== void 0) {\n    str = ctx.stylize(\"[Setter]\", \"special\");\n  } else {\n    str = ctx.stylize(\"undefined\", \"undefined\");\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === \"symbol\") {\n    const tmp = StringPrototypeReplace(SymbolPrototypeToString(key), strEscapeSequencesReplacer, escapeFn);\n    name = `[${ctx.stylize(tmp, \"symbol\")}]`;\n  } else if (key === \"__proto__\") {\n    name = \"['__proto__']\";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key, strEscapeSequencesReplacer, escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp, key)) {\n    name = ctx.stylize(key, \"name\");\n  } else {\n    name = ctx.stylize(strEscape(key), \"string\");\n  }\n  return `${name}:${extra}${str}`;\n}\nfunction isBelowBreakLength(ctx, output, start, base) {\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  return base === \"\" || !StringPrototypeIncludes(base, \"\\n\");\n}\nfunction reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === \"number\" && ctx.compact >= 1) {\n      const entries = output.length;\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx, output, value);\n      }\n      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {\n        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx, output, start, base)) {\n          return `${base ? `${base} ` : \"\"}${braces[0]} ${join(output, \", \")} ${braces[1]}`;\n        }\n      }\n    }\n    const indentation2 = `\n${StringPrototypeRepeat(\" \", ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : \"\"}${braces[0]}${indentation2}  ${join(output, `,${indentation2}  `)}${indentation2}${braces[1]}`;\n  }\n  if (isBelowBreakLength(ctx, output, 0, base)) {\n    return `${braces[0]}${base ? ` ${base}` : \"\"} ${join(output, \", \")} ` + braces[1];\n  }\n  const indentation = StringPrototypeRepeat(\" \", ctx.indentationLvl);\n  const ln = base === \"\" && braces[0].length === 1 ? \" \" : `${base ? ` ${base}` : \"\"}\n${indentation}  `;\n  return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;\n}\nfunction hasBuiltInToString(value) {\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value, getFullProxy);\n  if (proxyTarget !== void 0) {\n    value = proxyTarget;\n  }\n  if (typeof value.toString !== \"function\") {\n    return true;\n  }\n  if (ObjectPrototypeHasOwnProperty(value, \"toString\")) {\n    return false;\n  }\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer, \"toString\"));\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer, \"constructor\");\n  return descriptor !== void 0 && typeof descriptor.value === \"function\" && builtInObjects.has(descriptor.value.name);\n}\nconst firstErrorLine = (error) => StringPrototypeSplit(error.message, \"\\n\", 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {};\n        a.a = a;\n        JSONStringify(a);\n      } catch (err2) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(err2);\n      }\n    }\n    if (err.name === \"TypeError\" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return \"[Circular]\";\n    }\n    throw err;\n  }\n}\nfunction format(...args) {\n  return formatWithOptionsInternal(void 0, args);\n}\nfunction formatWithOptions(inspectOptions, ...args) {\n  if (typeof inspectOptions !== \"object\" || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\"inspectOptions\", \"object\", inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions, args);\n}\nfunction formatWithOptionsInternal(inspectOptions, args) {\n  const first = args[0];\n  let a = 0;\n  let str = \"\";\n  let join2 = \"\";\n  if (typeof first === \"string\") {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first, i) === 37) {\n        const nextChar = StringPrototypeCharCodeAt(first, ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115:\n              const tempArg = args[++a];\n              if (typeof tempArg === \"number\") {\n                tempStr = formatNumber(stylizeNoColor, tempArg);\n              } else if (typeof tempArg === \"bigint\") {\n                tempStr = `${tempArg}n`;\n              } else if (typeof tempArg !== \"object\" || tempArg === null || !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg, {\n                  ...inspectOptions,\n                  compact: 3,\n                  colors: false,\n                  depth: 0\n                });\n              }\n              break;\n            case 106:\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100:\n              const tempNum = args[++a];\n              if (typeof tempNum === \"bigint\") {\n                tempStr = `${tempNum}n`;\n              } else if (typeof tempNum === \"symbol\") {\n                tempStr = \"NaN\";\n              } else {\n                tempStr = formatNumber(stylizeNoColor, Number(tempNum));\n              }\n              break;\n            case 79:\n              tempStr = inspect(args[++a], inspectOptions);\n              break;\n            case 111:\n              tempStr = inspect(args[++a], {\n                ...inspectOptions,\n                showHidden: true,\n                showProxy: true,\n                depth: 4\n              });\n              break;\n            case 105:\n              const tempInteger = args[++a];\n              if (typeof tempInteger === \"bigint\") {\n                tempStr = `${tempInteger}n`;\n              } else if (typeof tempInteger === \"symbol\") {\n                tempStr = \"NaN\";\n              } else {\n                tempStr = formatNumber(stylizeNoColor, NumberParseInt(tempInteger));\n              }\n              break;\n            case 102:\n              const tempFloat = args[++a];\n              if (typeof tempFloat === \"symbol\") {\n                tempStr = \"NaN\";\n              } else {\n                tempStr = formatNumber(stylizeNoColor, NumberParseFloat(tempFloat));\n              }\n              break;\n            case 99:\n              a += 1;\n              tempStr = \"\";\n              break;\n            case 37:\n              str += StringPrototypeSlice(first, lastPos, i);\n              lastPos = i + 1;\n              continue;\n            default:\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first, lastPos, i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first, lastPos, i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join2 = \" \";\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first, lastPos);\n      }\n    }\n  }\n  while (a < args.length) {\n    const value = args[a];\n    str += join2;\n    str += typeof value !== \"string\" ? inspect(value, inspectOptions) : value;\n    join2 = \" \";\n    a++;\n  }\n  return str;\n}\nif (internalBinding(\"config\").hasIntl) {\n  const icu = internalBinding(\"icu\");\n  getStringWidth = function getStringWidth2(str, removeControlChars = true) {\n    let width = 0;\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize(\"NFC\"));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  getStringWidth = function getStringWidth2(str, removeControlChars = true) {\n    let width = 0;\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str, \"NFC\");\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char, 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n    return width;\n  };\n  const isFullWidthCodePoint = (code) => {\n    return code >= 4352 && (code <= 4447 || code === 9001 || code === 9002 || code >= 11904 && code <= 12871 && code !== 12351 || code >= 12880 && code <= 19903 || code >= 19968 && code <= 42182 || code >= 43360 && code <= 43388 || code >= 44032 && code <= 55203 || code >= 63744 && code <= 64255 || code >= 65040 && code <= 65049 || code >= 65072 && code <= 65131 || code >= 65281 && code <= 65376 || code >= 65504 && code <= 65510 || code >= 110592 && code <= 110593 || code >= 127488 && code <= 127569 || code >= 127744 && code <= 128591 || code >= 131072 && code <= 262141);\n  };\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 31 || code >= 127 && code <= 159 || code >= 768 && code <= 879 || code >= 8203 && code <= 8207 || code >= 8400 && code <= 8447 || code >= 65024 && code <= 65039 || code >= 65056 && code <= 65071 || code >= 917760 && code <= 917999;\n  };\n}\nfunction stripVTControlCharacters(str) {\n  return str.replace(ansi, \"\");\n}\nmodule.exports = {\n  inspect,\n  format,\n  formatWithOptions,\n  getStringWidth,\n  inspectDefaultOptions,\n  stripVTControlCharacters\n};\n}"],["internal/util/inspector.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeConcat,\n  FunctionPrototypeBind,\n  ObjectDefineProperty,\n  ObjectKeys\n} = primordials;\nlet session;\nfunction sendInspectorCommand(cb, onError) {\n  const { hasInspector } = internalBinding(\"config\");\n  if (!hasInspector)\n    return onError();\n  const inspector = require(\"inspector\");\n  if (session === void 0)\n    session = new inspector.Session();\n  session.connect();\n  try {\n    return cb(session);\n  } finally {\n    session.disconnect();\n  }\n}\nfunction installConsoleExtensions(commandLineApi) {\n  if (commandLineApi.require) {\n    return;\n  }\n  const { tryGetCwd } = require(\"internal/process/execution\");\n  const CJSModule = require(\"internal/modules/cjs/loader\").Module;\n  const { makeRequireFunction } = require(\"internal/modules/cjs/helpers\");\n  const consoleAPIModule = new CJSModule(\"<inspector console>\");\n  const cwd = tryGetCwd();\n  consoleAPIModule.paths = ArrayPrototypeConcat(CJSModule._nodeModulePaths(cwd), CJSModule.globalPaths);\n  commandLineApi.require = makeRequireFunction(consoleAPIModule);\n}\nfunction wrapConsole(consoleFromNode, consoleFromVM2) {\n  const { consoleCall } = internalBinding(\"inspector\");\n  for (const key of ObjectKeys(consoleFromVM2)) {\n    if (consoleFromNode.hasOwnProperty(key)) {\n      consoleFromNode[key] = FunctionPrototypeBind(consoleCall, consoleFromNode, consoleFromVM2[key], consoleFromNode[key]);\n      ObjectDefineProperty(consoleFromNode[key], \"name\", {\n        value: key\n      });\n    } else {\n      consoleFromNode[key] = consoleFromVM2[key];\n    }\n  }\n}\nlet consoleFromVM;\nmodule.exports = {\n  installConsoleExtensions,\n  sendInspectorCommand,\n  wrapConsole,\n  get consoleFromVM() {\n    return consoleFromVM;\n  },\n  set consoleFromVM(val) {\n    consoleFromVM = val;\n  }\n};\n}"],["internal/util/iterable_weak_map.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectFreeze,\n  SafeFinalizationRegistry,\n  SafeSet,\n  SafeWeakMap,\n  SafeWeakRef,\n  SymbolIterator\n} = primordials;\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n  set(key, value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      this.#weakMap.set(key, { value, ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key, { value, ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key, {\n        set: this.#refSet,\n        ref\n      }, ref);\n    }\n  }\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n    const next = () => {\n      const result = iterator.next();\n      if (result.done)\n        return result;\n      const key = result.value.deref();\n      if (key == null)\n        return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false, value };\n    };\n    return {\n      [SymbolIterator]() {\n        return this;\n      },\n      next\n    };\n  }\n}\nfunction cleanup({ set, ref }) {\n  set.delete(ref);\n}\nObjectFreeze(IterableWeakMap.prototype);\nmodule.exports = {\n  IterableWeakMap\n};\n}"],["internal/util/types.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBufferIsView,\n  ObjectDefineProperties,\n  TypedArrayPrototypeGetSymbolToStringTag\n} = primordials;\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== void 0;\n}\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Uint8Array\";\n}\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Uint8ClampedArray\";\n}\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Uint16Array\";\n}\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Uint32Array\";\n}\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Int8Array\";\n}\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Int16Array\";\n}\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Int32Array\";\n}\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Float32Array\";\n}\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"Float64Array\";\n}\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"BigInt64Array\";\n}\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === \"BigUint64Array\";\n}\nmodule.exports = {\n  ...internalBinding(\"types\"),\n  isArrayBufferView: ArrayBufferIsView,\n  isTypedArray,\n  isUint8Array,\n  isUint8ClampedArray,\n  isUint16Array,\n  isUint32Array,\n  isInt8Array,\n  isInt16Array,\n  isInt32Array,\n  isFloat32Array,\n  isFloat64Array,\n  isBigInt64Array,\n  isBigUint64Array\n};\nlet isCryptoKey;\nlet isKeyObject;\nObjectDefineProperties(module.exports, {\n  isKeyObject: {\n    configurable: false,\n    enumerable: true,\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n      if (!isKeyObject) {\n        ({ isKeyObject } = require(\"internal/crypto/keys\"));\n      }\n      return isKeyObject(obj);\n    }\n  },\n  isCryptoKey: {\n    configurable: false,\n    enumerable: true,\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require(\"internal/crypto/keys\"));\n      }\n      return isCryptoKey(obj);\n    }\n  }\n});\n}"],["internal/vm/module.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst assert = require(\"internal/assert\");\nconst {\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeSome,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  PromiseAll,\n  ReflectApply,\n  SafeWeakMap,\n  Symbol,\n  SymbolToStringTag,\n  TypeError\n} = primordials;\nconst { isContext } = internalBinding(\"contextify\");\nconst {\n  isModuleNamespaceObject,\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  getConstructorOf,\n  customInspectSymbol,\n  emitExperimentalWarning\n} = require(\"internal/util\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_VM_MODULE_ALREADY_LINKED,\n  ERR_VM_MODULE_DIFFERENT_CONTEXT,\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA,\n  ERR_VM_MODULE_LINKING_ERRORED,\n  ERR_VM_MODULE_NOT_MODULE,\n  ERR_VM_MODULE_STATUS\n} = require(\"internal/errors\").codes;\nconst {\n  validateBoolean,\n  validateFunction,\n  validateInt32,\n  validateObject,\n  validateUint32,\n  validateString\n} = require(\"internal/validators\");\nconst binding = internalBinding(\"module_wrap\");\nconst {\n  ModuleWrap,\n  kUninstantiated,\n  kInstantiating,\n  kInstantiated,\n  kEvaluating,\n  kEvaluated,\n  kErrored\n} = binding;\nconst STATUS_MAP = {\n  [kUninstantiated]: \"unlinked\",\n  [kInstantiating]: \"linking\",\n  [kInstantiated]: \"linked\",\n  [kEvaluating]: \"evaluating\",\n  [kEvaluated]: \"evaluated\",\n  [kErrored]: \"errored\"\n};\nlet globalModuleId = 0;\nconst defaultModuleName = \"vm:module\";\nconst wrapToModuleMap = new SafeWeakMap();\nconst kWrap = Symbol(\"kWrap\");\nconst kContext = Symbol(\"kContext\");\nconst kPerContextModuleId = Symbol(\"kPerContextModuleId\");\nconst kLink = Symbol(\"kLink\");\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning(\"VM Modules\");\n    if (new.target === Module) {\n      throw new TypeError(\"Module is not a constructor\");\n    }\n    const {\n      context,\n      sourceText,\n      syntheticExportNames,\n      syntheticEvaluationSteps\n    } = options;\n    if (context !== void 0) {\n      validateObject(context, \"context\");\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE(\"options.context\", \"vm.Context\", context);\n      }\n    }\n    let { identifier } = options;\n    if (identifier !== void 0) {\n      validateString(identifier, \"options.identifier\");\n    } else if (context === void 0) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== void 0) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context, kPerContextModuleId, {\n        value: 1,\n        writable: true,\n        enumerable: false,\n        configurable: true\n      });\n    }\n    if (sourceText !== void 0) {\n      this[kWrap] = new ModuleWrap(identifier, context, sourceText, options.lineOffset, options.columnOffset, options.cachedData);\n      binding.callbackMap.set(this[kWrap], {\n        initializeImportMeta: options.initializeImportMeta,\n        importModuleDynamically: options.importModuleDynamically ? importModuleDynamicallyWrap(options.importModuleDynamically) : void 0\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier, context, syntheticExportNames, syntheticEvaluationSteps);\n    }\n    wrapToModuleMap.set(this[kWrap], this);\n    this[kContext] = context;\n  }\n  get identifier() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n  get context() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n  get namespace() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS(\"must not be unlinked or linking\");\n    }\n    return this[kWrap].getNamespace();\n  }\n  get status() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n  get error() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\"must be errored\");\n    }\n    return this[kWrap].getError();\n  }\n  async link(linker) {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker, \"linker\");\n    if (this.status === \"linked\") {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== \"unlinked\") {\n      throw new ERR_VM_MODULE_STATUS(\"must be unlinked\");\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n  async evaluate(options = {}) {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateObject(options, \"options\");\n    let timeout = options.timeout;\n    if (timeout === void 0) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout, \"options.timeout\", true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint, \"options.breakOnSigint\");\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated && status !== kEvaluated && status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\"must be one of linked, evaluated, or errored\");\n    }\n    await this[kWrap].evaluate(timeout, breakOnSigint);\n  }\n  [customInspectSymbol](depth, options) {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n    ObjectSetPrototypeOf(o, ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o, SymbolToStringTag, {\n      value: constructor.name,\n      configurable: true\n    });\n    const { inspect } = require(\"internal/util/inspect\");\n    return inspect(o, { ...options, customInspect: false });\n  }\n}\nconst kDependencySpecifiers = Symbol(\"kDependencySpecifiers\");\nconst kNoError = Symbol(\"kNoError\");\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n  constructor(sourceText, options = {}) {\n    validateString(sourceText, \"sourceText\");\n    validateObject(options, \"options\");\n    const {\n      lineOffset = 0,\n      columnOffset = 0,\n      initializeImportMeta,\n      importModuleDynamically,\n      context,\n      identifier,\n      cachedData\n    } = options;\n    validateInt32(lineOffset, \"options.lineOffset\");\n    validateInt32(columnOffset, \"options.columnOffset\");\n    if (initializeImportMeta !== void 0 && typeof initializeImportMeta !== \"function\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options.initializeImportMeta\", \"function\", initializeImportMeta);\n    }\n    if (importModuleDynamically !== void 0 && typeof importModuleDynamically !== \"function\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options.importModuleDynamically\", \"function\", importModuleDynamically);\n    }\n    if (cachedData !== void 0 && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.cachedData\", [\"Buffer\", \"TypedArray\", \"DataView\"], cachedData);\n    }\n    super({\n      sourceText,\n      context,\n      identifier,\n      lineOffset,\n      columnOffset,\n      cachedData,\n      initializeImportMeta,\n      importModuleDynamically\n    });\n    this[kLink] = async (linker) => {\n      this.#statusOverride = \"linking\";\n      const promises = this[kWrap].link(async (identifier2, assert2) => {\n        const module2 = await linker(identifier2, this, { assert: assert2 });\n        if (module2[kWrap] === void 0) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module2.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module2.status === \"errored\") {\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module2.status === \"unlinked\") {\n          await module2[kLink](linker);\n        }\n        return module2[kWrap];\n      });\n      try {\n        if (promises !== void 0) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = void 0;\n      }\n    };\n    this[kDependencySpecifiers] = void 0;\n  }\n  get dependencySpecifiers() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === void 0) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n  get status() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return \"errored\";\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n  get error() {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n  createCachedData() {\n    const { status } = this;\n    if (status === \"evaluating\" || status === \"evaluated\" || status === \"errored\") {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\nclass SyntheticModule extends Module {\n  constructor(exportNames, evaluateCallback, options = {}) {\n    if (!ArrayIsArray(exportNames) || ArrayPrototypeSome(exportNames, (e) => typeof e !== \"string\")) {\n      throw new ERR_INVALID_ARG_TYPE(\"exportNames\", \"Array of unique strings\", exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames, (name, i) => {\n        if (ArrayPrototypeIndexOf(exportNames, name, i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`, name, \"is duplicated\");\n        }\n      });\n    }\n    validateFunction(evaluateCallback, \"evaluateCallback\");\n    validateObject(options, \"options\");\n    const { context, identifier } = options;\n    super({\n      syntheticExportNames: exportNames,\n      syntheticEvaluationSteps: evaluateCallback,\n      context,\n      identifier\n    });\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail(\"link callback should not be called\");\n    });\n  }\n  setExport(name, value) {\n    if (this[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name, \"name\");\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS(\"must be linked\");\n    }\n    this[kWrap].setExport(name, value);\n  }\n}\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically, this, args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === void 0) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === \"errored\") {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\nmodule.exports = {\n  Module,\n  SourceTextModule,\n  SyntheticModule,\n  importModuleDynamicallyWrap,\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\n};\n}"],["internal/webstreams/adapters.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeMap,\n  PromiseAll,\n  PromisePrototypeThen,\n  PromisePrototypeFinally,\n  PromiseResolve,\n  Uint8Array\n} = primordials;\nconst {\n  ReadableStream,\n  isReadableStream\n} = require(\"internal/webstreams/readablestream\");\nconst {\n  WritableStream,\n  isWritableStream\n} = require(\"internal/webstreams/writablestream\");\nconst {\n  CountQueuingStrategy\n} = require(\"internal/webstreams/queuingstrategies\");\nconst {\n  Writable,\n  Readable,\n  Duplex,\n  destroy\n} = require(\"stream\");\nconst {\n  isDestroyed,\n  isReadable,\n  isReadableEnded,\n  isWritable,\n  isWritableEnded\n} = require(\"internal/streams/utils\");\nconst {\n  Buffer\n} = require(\"buffer\");\nconst {\n  errnoException,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_STATE,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require(\"internal/errors\");\nconst {\n  createDeferredPromise\n} = require(\"internal/util\");\nconst {\n  validateBoolean,\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  WriteWrap,\n  ShutdownWrap,\n  kReadBytesOrError,\n  kLastWriteWasAsync,\n  streamBaseState\n} = internalBinding(\"stream_wrap\");\nconst finished = require(\"internal/streams/end-of-stream\");\nconst { UV_EOF } = internalBinding(\"uv\");\nfunction newWritableStreamFromStreamWritable(streamWritable) {\n  if (typeof streamWritable?._writableState !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"streamWritable\", \"stream.Writable\", streamWritable);\n  }\n  if (isDestroyed(streamWritable) || !isWritable(streamWritable)) {\n    const writable = new WritableStream();\n    writable.close();\n    return writable;\n  }\n  const highWaterMark = streamWritable.writableHighWaterMark;\n  const strategy = streamWritable.writableObjectMode ? new CountQueuingStrategy({ highWaterMark }) : { highWaterMark };\n  let controller;\n  let backpressurePromise;\n  let closed;\n  function onDrain() {\n    if (backpressurePromise !== void 0)\n      backpressurePromise.resolve();\n  }\n  const cleanup = finished(streamWritable, (error) => {\n    if (error?.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n      const err = new AbortError();\n      err.cause = error;\n      error = err;\n    }\n    cleanup();\n    streamWritable.on(\"error\", () => {\n    });\n    if (error != null) {\n      if (backpressurePromise !== void 0)\n        backpressurePromise.reject(error);\n      if (closed !== void 0) {\n        closed.reject(error);\n        closed = void 0;\n      }\n      controller.error(error);\n      controller = void 0;\n      return;\n    }\n    if (closed !== void 0) {\n      closed.resolve();\n      closed = void 0;\n      return;\n    }\n    controller.error(new AbortError());\n    controller = void 0;\n  });\n  streamWritable.on(\"drain\", onDrain);\n  return new WritableStream({\n    start(c) {\n      controller = c;\n    },\n    async write(chunk) {\n      if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {\n        backpressurePromise = createDeferredPromise();\n        return PromisePrototypeFinally(backpressurePromise.promise, () => {\n          backpressurePromise = void 0;\n        });\n      }\n    },\n    abort(reason) {\n      destroy(streamWritable, reason);\n    },\n    close() {\n      if (closed === void 0 && !isWritableEnded(streamWritable)) {\n        closed = createDeferredPromise();\n        streamWritable.end();\n        return closed.promise;\n      }\n      controller = void 0;\n      return PromiseResolve();\n    }\n  }, strategy);\n}\nfunction newStreamWritableFromWritableStream(writableStream, options = {}) {\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\"writableStream\", \"WritableStream\", writableStream);\n  }\n  validateObject(options, \"options\");\n  const {\n    highWaterMark,\n    decodeStrings = true,\n    objectMode = false,\n    signal\n  } = options;\n  validateBoolean(objectMode, \"options.objectMode\");\n  validateBoolean(decodeStrings, \"options.decodeStrings\");\n  const writer = writableStream.getWriter();\n  let closed = false;\n  const writable = new Writable({\n    highWaterMark,\n    objectMode,\n    decodeStrings,\n    signal,\n    writev(chunks, callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => destroy(writable, error2));\n        }\n      }\n      PromisePrototypeThen(writer.ready, () => {\n        return PromisePrototypeThen(PromiseAll(ArrayPrototypeMap(chunks, (chunk) => writer.write(chunk))), done, done);\n      }, done);\n    },\n    write(chunk, encoding, callback) {\n      if (typeof chunk === \"string\" && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk, encoding);\n        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n      }\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          destroy(writable, error2);\n        }\n      }\n      PromisePrototypeThen(writer.ready, () => {\n        return PromisePrototypeThen(writer.write(chunk), done, done);\n      }, done);\n    },\n    destroy(error, callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => {\n            throw error2;\n          });\n        }\n      }\n      if (!closed) {\n        if (error != null) {\n          PromisePrototypeThen(writer.abort(error), done, done);\n        } else {\n          PromisePrototypeThen(writer.close(), done, done);\n        }\n        return;\n      }\n      done();\n    },\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => destroy(writable, error2));\n        }\n      }\n      if (!closed) {\n        PromisePrototypeThen(writer.close(), done, done);\n      }\n    }\n  });\n  PromisePrototypeThen(writer.closed, () => {\n    closed = true;\n    if (!isWritableEnded(writable))\n      destroy(writable, new ERR_STREAM_PREMATURE_CLOSE());\n  }, (error) => {\n    closed = true;\n    destroy(writable, error);\n  });\n  return writable;\n}\nfunction newReadableStreamFromStreamReadable(streamReadable) {\n  if (typeof streamReadable?._readableState !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"streamReadable\", \"stream.Readable\", streamReadable);\n  }\n  if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  const objectMode = streamReadable.readableObjectMode;\n  const highWaterMark = streamReadable.readableHighWaterMark;\n  const strategy = objectMode ? new CountQueuingStrategy({ highWaterMark }) : { highWaterMark };\n  let controller;\n  function onData(chunk) {\n    if (Buffer.isBuffer(chunk) && !objectMode)\n      chunk = new Uint8Array(chunk);\n    controller.enqueue(chunk);\n    if (controller.desiredSize <= 0)\n      streamReadable.pause();\n  }\n  streamReadable.pause();\n  const cleanup = finished(streamReadable, (error) => {\n    if (error?.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n      const err = new AbortError();\n      err.cause = error;\n      error = err;\n    }\n    cleanup();\n    streamReadable.on(\"error\", () => {\n    });\n    if (error)\n      return controller.error(error);\n    controller.close();\n  });\n  streamReadable.on(\"data\", onData);\n  return new ReadableStream({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      streamReadable.resume();\n    },\n    cancel(reason) {\n      destroy(streamReadable, reason);\n    }\n  }, strategy);\n}\nfunction newStreamReadableFromReadableStream(readableStream, options = {}) {\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\"readableStream\", \"ReadableStream\", readableStream);\n  }\n  validateObject(options, \"options\");\n  const {\n    highWaterMark,\n    encoding,\n    objectMode = false,\n    signal\n  } = options;\n  if (encoding !== void 0 && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n  validateBoolean(objectMode, \"options.objectMode\");\n  const reader = readableStream.getReader();\n  let closed = false;\n  const readable = new Readable({\n    objectMode,\n    highWaterMark,\n    encoding,\n    signal,\n    read() {\n      PromisePrototypeThen(reader.read(), (chunk) => {\n        if (chunk.done) {\n          readable.push(null);\n        } else {\n          readable.push(chunk.value);\n        }\n      }, (error) => destroy(readable, error));\n    },\n    destroy(error, callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => {\n            throw error2;\n          });\n        }\n      }\n      if (!closed) {\n        PromisePrototypeThen(reader.cancel(error), done, done);\n        return;\n      }\n      done();\n    }\n  });\n  PromisePrototypeThen(reader.closed, () => {\n    closed = true;\n    if (!isReadableEnded(readable))\n      readable.push(null);\n  }, (error) => {\n    closed = true;\n    destroy(readable, error);\n  });\n  return readable;\n}\nfunction newReadableWritablePairFromDuplex(duplex) {\n  if (typeof duplex?._writableState !== \"object\" || typeof duplex?._readableState !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"duplex\", \"stream.Duplex\", duplex);\n  }\n  if (isDestroyed(duplex)) {\n    const writable2 = new WritableStream();\n    const readable2 = new ReadableStream();\n    writable2.close();\n    readable2.cancel();\n    return { readable: readable2, writable: writable2 };\n  }\n  const writable = isWritable(duplex) ? newWritableStreamFromStreamWritable(duplex) : new WritableStream();\n  if (!isWritable(duplex))\n    writable.close();\n  const readable = isReadable(duplex) ? newReadableStreamFromStreamReadable(duplex) : new ReadableStream();\n  if (!isReadable(duplex))\n    readable.cancel();\n  return { writable, readable };\n}\nfunction newStreamDuplexFromReadableWritablePair(pair = {}, options = {}) {\n  validateObject(pair, \"pair\");\n  const {\n    readable: readableStream,\n    writable: writableStream\n  } = pair;\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\"pair.readable\", \"ReadableStream\", readableStream);\n  }\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\"pair.writable\", \"WritableStream\", writableStream);\n  }\n  validateObject(options, \"options\");\n  const {\n    allowHalfOpen = false,\n    objectMode = false,\n    encoding,\n    decodeStrings = true,\n    highWaterMark,\n    signal\n  } = options;\n  validateBoolean(objectMode, \"options.objectMode\");\n  if (encoding !== void 0 && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding, \"options.encoding\");\n  const writer = writableStream.getWriter();\n  const reader = readableStream.getReader();\n  let writableClosed = false;\n  let readableClosed = false;\n  const duplex = new Duplex({\n    allowHalfOpen,\n    highWaterMark,\n    objectMode,\n    encoding,\n    decodeStrings,\n    signal,\n    writev(chunks, callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => destroy(duplex, error2));\n        }\n      }\n      PromisePrototypeThen(writer.ready, () => {\n        return PromisePrototypeThen(PromiseAll(ArrayPrototypeMap(chunks, (chunk) => writer.write(chunk))), done, done);\n      }, done);\n    },\n    write(chunk, encoding2, callback) {\n      if (typeof chunk === \"string\" && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk, encoding2);\n        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n      }\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          destroy(duplex, error2);\n        }\n      }\n      PromisePrototypeThen(writer.ready, () => {\n        return PromisePrototypeThen(writer.write(chunk), done, done);\n      }, done);\n    },\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => destroy(duplex, error2));\n        }\n      }\n      if (!writableClosed) {\n        PromisePrototypeThen(writer.close(), done, done);\n      }\n    },\n    read() {\n      PromisePrototypeThen(reader.read(), (chunk) => {\n        if (chunk.done) {\n          duplex.push(null);\n        } else {\n          duplex.push(chunk.value);\n        }\n      }, (error) => destroy(duplex, error));\n    },\n    destroy(error, callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error2) {\n          process.nextTick(() => {\n            throw error2;\n          });\n        }\n      }\n      async function closeWriter() {\n        if (!writableClosed)\n          await writer.abort(error);\n      }\n      async function closeReader() {\n        if (!readableClosed)\n          await reader.cancel(error);\n      }\n      if (!writableClosed || !readableClosed) {\n        PromisePrototypeThen(PromiseAll([\n          closeWriter(),\n          closeReader()\n        ]), done, done);\n        return;\n      }\n      done();\n    }\n  });\n  PromisePrototypeThen(writer.closed, () => {\n    writableClosed = true;\n    if (!isWritableEnded(duplex))\n      destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());\n  }, (error) => {\n    writableClosed = true;\n    readableClosed = true;\n    destroy(duplex, error);\n  });\n  PromisePrototypeThen(reader.closed, () => {\n    readableClosed = true;\n    if (!isReadableEnded(duplex))\n      duplex.push(null);\n  }, (error) => {\n    writableClosed = true;\n    readableClosed = true;\n    destroy(duplex, error);\n  });\n  return duplex;\n}\nfunction newWritableStreamFromStreamBase(streamBase, strategy) {\n  validateObject(streamBase, \"streamBase\");\n  let current;\n  function createWriteWrap(controller, promise) {\n    const req = new WriteWrap();\n    req.handle = streamBase;\n    req.oncomplete = onWriteComplete;\n    req.async = false;\n    req.bytes = 0;\n    req.buffer = null;\n    req.controller = controller;\n    req.promise = promise;\n    return req;\n  }\n  function onWriteComplete(status) {\n    if (status < 0) {\n      const error = errnoException(status, \"write\", this.error);\n      this.promise.reject(error);\n      this.controller.error(error);\n      return;\n    }\n    this.promise.resolve();\n  }\n  function doWrite(chunk, controller) {\n    const promise = createDeferredPromise();\n    let ret;\n    let req;\n    try {\n      req = createWriteWrap(controller, promise);\n      ret = streamBase.writeBuffer(req, chunk);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = chunk;\n      req.async = !!streamBaseState[kLastWriteWasAsync];\n    } catch (error) {\n      promise.reject(error);\n    }\n    if (ret !== 0)\n      promise.reject(errnoException(ret, \"write\", req));\n    else if (!req.async)\n      promise.resolve();\n    return promise.promise;\n  }\n  return new WritableStream({\n    write(chunk, controller) {\n      current = current !== void 0 ? PromisePrototypeThen(current, () => doWrite(chunk, controller), (error) => controller.error(error)) : doWrite(chunk, controller);\n      return current;\n    },\n    close() {\n      const promise = createDeferredPromise();\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\n  }, strategy);\n}\nfunction newReadableStreamFromStreamBase(streamBase, strategy, options = {}) {\n  validateObject(streamBase, \"streamBase\");\n  validateObject(options, \"options\");\n  const {\n    ondone = () => {\n    }\n  } = options;\n  if (typeof streamBase.onread === \"function\")\n    throw new ERR_INVALID_STATE(\"StreamBase already has a consumer\");\n  if (typeof ondone !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(\"options.ondone\", \"Function\", ondone);\n  let controller;\n  streamBase.onread = (arrayBuffer) => {\n    const nread = streamBaseState[kReadBytesOrError];\n    if (nread === 0)\n      return;\n    try {\n      if (nread === UV_EOF) {\n        controller.close();\n        streamBase.readStop();\n        try {\n          ondone();\n        } catch (error) {\n          controller.error(error);\n        }\n        return;\n      }\n      controller.enqueue(arrayBuffer);\n      if (controller.desiredSize <= 0)\n        streamBase.readStop();\n    } catch (error) {\n      controller.error(error);\n      streamBase.readStop();\n    }\n  };\n  return new ReadableStream({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      streamBase.readStart();\n    },\n    cancel() {\n      const promise = createDeferredPromise();\n      try {\n        ondone();\n      } catch (error) {\n        promise.reject(error);\n        return promise.promise;\n      }\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\n  }, strategy);\n}\nmodule.exports = {\n  newWritableStreamFromStreamWritable,\n  newReadableStreamFromStreamReadable,\n  newStreamWritableFromWritableStream,\n  newStreamReadableFromReadableStream,\n  newReadableWritablePairFromDuplex,\n  newStreamDuplexFromReadableWritablePair,\n  newWritableStreamFromStreamBase,\n  newReadableStreamFromStreamBase\n};\n}"],["internal/webstreams/compression.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  Symbol\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst {\n  newReadableWritablePairFromDuplex\n} = require(\"internal/webstreams/adapters\");\nconst {\n  customInspect,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nlet zlib;\nfunction lazyZlib() {\n  zlib ??= require(\"zlib\");\n  return zlib;\n}\nconst kHandle = Symbol(\"kHandle\");\nconst kTransform = Symbol(\"kTransform\");\nconst kType = Symbol(\"kType\");\nfunction isCompressionStream(value) {\n  return typeof value?.[kHandle] === \"object\" && value?.[kType] === \"CompressionStream\";\n}\nfunction isDecompressionStream(value) {\n  return typeof value?.[kHandle] === \"object\" && value?.[kType] === \"DecompressionStream\";\n}\nclass CompressionStream {\n  constructor(format) {\n    this[kType] = \"CompressionStream\";\n    switch (format) {\n      case \"deflate\":\n        this[kHandle] = lazyZlib().createDeflate();\n        break;\n      case \"gzip\":\n        this[kHandle] = lazyZlib().createGzip();\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE(\"format\", format);\n    }\n    this[kTransform] = newReadableWritablePairFromDuplex(this[kHandle]);\n  }\n  get readable() {\n    if (!isCompressionStream(this))\n      throw new ERR_INVALID_THIS(\"CompressionStream\");\n    return this[kTransform].readable;\n  }\n  get writable() {\n    if (!isCompressionStream(this))\n      throw new ERR_INVALID_THIS(\"CompressionStream\");\n    return this[kTransform].writable;\n  }\n  [kInspect](depth, options) {\n    if (!isCompressionStream(this))\n      throw new ERR_INVALID_THIS(\"CompressionStream\");\n    customInspect(depth, options, \"CompressionStream\", {\n      readable: this[kTransform].readable,\n      writable: this[kTransform].writable\n    });\n  }\n}\nclass DecompressionStream {\n  constructor(format) {\n    this[kType] = \"DecompressionStream\";\n    switch (format) {\n      case \"deflate\":\n        this[kHandle] = lazyZlib().createInflate();\n        break;\n      case \"gzip\":\n        this[kHandle] = lazyZlib().createGunzip();\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE(\"format\", format);\n    }\n    this[kTransform] = newReadableWritablePairFromDuplex(this[kHandle]);\n  }\n  get readable() {\n    if (!isDecompressionStream(this))\n      throw new ERR_INVALID_THIS(\"DecompressionStream\");\n    return this[kTransform].readable;\n  }\n  get writable() {\n    if (!isDecompressionStream(this))\n      throw new ERR_INVALID_THIS(\"DecompressionStream\");\n    return this[kTransform].writable;\n  }\n  [kInspect](depth, options) {\n    if (!isDecompressionStream(this))\n      throw new ERR_INVALID_THIS(\"DecompressionStream\");\n    customInspect(depth, options, \"DecompressionStream\", {\n      readable: this[kTransform].readable,\n      writable: this[kTransform].writable\n    });\n  }\n}\nObjectDefineProperties(CompressionStream.prototype, {\n  readable: kEnumerableProperty,\n  writable: kEnumerableProperty\n});\nObjectDefineProperties(DecompressionStream.prototype, {\n  readable: kEnumerableProperty,\n  writable: kEnumerableProperty\n});\nmodule.exports = {\n  CompressionStream,\n  DecompressionStream\n};\n}"],["internal/webstreams/encoding.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  Symbol\n} = primordials;\nconst {\n  TextDecoder,\n  TextEncoder\n} = require(\"internal/encoding\");\nconst {\n  TransformStream\n} = require(\"internal/webstreams/transformstream\");\nconst {\n  customInspect,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  codes: {\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst kHandle = Symbol(\"kHandle\");\nconst kTransform = Symbol(\"kTransform\");\nconst kType = Symbol(\"kType\");\nfunction isTextEncoderStream(value) {\n  return typeof value?.[kHandle] === \"object\" && value?.[kType] === \"TextEncoderStream\";\n}\nfunction isTextDecoderStream(value) {\n  return typeof value?.[kHandle] === \"object\" && value?.[kType] === \"TextDecoderStream\";\n}\nclass TextEncoderStream {\n  constructor() {\n    this[kType] = \"TextEncoderStream\";\n    this[kHandle] = new TextEncoder();\n    this[kTransform] = new TransformStream({\n      transform: (chunk, controller) => {\n        const value = this[kHandle].encode(chunk);\n        if (value)\n          controller.enqueue(value);\n      },\n      flush: (controller) => {\n        const value = this[kHandle].encode();\n        if (value.byteLength > 0)\n          controller.enqueue(value);\n        controller.terminate();\n      }\n    });\n  }\n  get encoding() {\n    if (!isTextEncoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextEncoderStream\");\n    return this[kHandle].encoding;\n  }\n  get readable() {\n    if (!isTextEncoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextEncoderStream\");\n    return this[kTransform].readable;\n  }\n  get writable() {\n    if (!isTextEncoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextEncoderStream\");\n    return this[kTransform].writable;\n  }\n  [kInspect](depth, options) {\n    if (!isTextEncoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextEncoderStream\");\n    return customInspect(depth, options, \"TextEncoderStream\", {\n      encoding: this[kHandle].encoding,\n      readable: this[kTransform].readable,\n      writable: this[kTransform].writable\n    });\n  }\n}\nclass TextDecoderStream {\n  constructor(encoding = \"utf-8\", options = {}) {\n    this[kType] = \"TextDecoderStream\";\n    this[kHandle] = new TextDecoder(encoding, options);\n    this[kTransform] = new TransformStream({\n      transform: (chunk, controller) => {\n        const value = this[kHandle].decode(chunk, { stream: true });\n        if (value)\n          controller.enqueue(value);\n      },\n      flush: (controller) => {\n        const value = this[kHandle].decode();\n        if (value)\n          controller.enqueue(value);\n        controller.terminate();\n      }\n    });\n  }\n  get encoding() {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return this[kHandle].encoding;\n  }\n  get fatal() {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return this[kHandle].fatal;\n  }\n  get ignoreBOM() {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return this[kHandle].ignoreBOM;\n  }\n  get readable() {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return this[kTransform].readable;\n  }\n  get writable() {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return this[kTransform].writable;\n  }\n  [kInspect](depth, options) {\n    if (!isTextDecoderStream(this))\n      throw new ERR_INVALID_THIS(\"TextDecoderStream\");\n    return customInspect(depth, options, \"TextDecoderStream\", {\n      encoding: this[kHandle].encoding,\n      fatal: this[kHandle].fatal,\n      ignoreBOM: this[kHandle].ignoreBOM,\n      readable: this[kTransform].readable,\n      writable: this[kTransform].writable\n    });\n  }\n}\nObjectDefineProperties(TextEncoderStream.prototype, {\n  encoding: kEnumerableProperty,\n  readable: kEnumerableProperty,\n  writable: kEnumerableProperty\n});\nObjectDefineProperties(TextDecoderStream.prototype, {\n  encoding: kEnumerableProperty,\n  fatal: kEnumerableProperty,\n  ignoreBOM: kEnumerableProperty,\n  readable: kEnumerableProperty,\n  writable: kEnumerableProperty\n});\nmodule.exports = {\n  TextEncoderStream,\n  TextDecoderStream\n};\n}"],["internal/webstreams/queuingstrategies.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  SymbolToStringTag\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_THIS,\n    ERR_MISSING_OPTION\n  }\n} = require(\"internal/errors\");\nconst {\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  customInspect,\n  isBrandCheck,\n  kType,\n  kState,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  validateObject\n} = require(\"internal/validators\");\nconst isByteLengthQueuingStrategy = isBrandCheck(\"ByteLengthQueuingStrategy\");\nconst isCountQueuingStrategy = isBrandCheck(\"CountQueuingStrategy\");\nconst byteSizeFunction = function size(chunk) {\n  return chunk.byteLength;\n};\nconst countSizeFunction = function size2() {\n  return 1;\n};\nclass ByteLengthQueuingStrategy {\n  [kType] = \"ByteLengthQueuingStrategy\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(init) {\n    validateObject(init, \"init\");\n    if (init.highWaterMark === void 0)\n      throw new ERR_MISSING_OPTION(\"options.highWaterMark\");\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\n    };\n  }\n  get highWaterMark() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS(\"ByteLengthQueuingStrategy\");\n    return this[kState].highWaterMark;\n  }\n  get size() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS(\"ByteLengthQueuingStrategy\");\n    return byteSizeFunction;\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      highWaterMark: this.highWaterMark\n    });\n  }\n}\nObjectDefineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: kEnumerableProperty,\n  size: kEnumerableProperty\n});\nclass CountQueuingStrategy {\n  [kType] = \"CountQueuingStrategy\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(init) {\n    validateObject(init, \"init\");\n    if (init.highWaterMark === void 0)\n      throw new ERR_MISSING_OPTION(\"options.highWaterMark\");\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\n    };\n  }\n  get highWaterMark() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS(\"CountQueuingStrategy\");\n    return this[kState].highWaterMark;\n  }\n  get size() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS(\"CountQueuingStrategy\");\n    return countSizeFunction;\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      highWaterMark: this.highWaterMark\n    });\n  }\n}\nObjectDefineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: kEnumerableProperty,\n  size: kEnumerableProperty\n});\nmodule.exports = {\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy\n};\n}"],["internal/webstreams/readablestream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBuffer,\n  ArrayBufferPrototypeSlice,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  DataViewCtor,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  MathMin,\n  NumberIsInteger,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromisePrototypeCatch,\n  PromisePrototypeThen,\n  PromiseResolve,\n  PromiseReject,\n  PromiseAll,\n  ReflectConstruct,\n  Symbol,\n  SymbolAsyncIterator,\n  SymbolToStringTag,\n  Uint8Array\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_STATE,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst {\n  DOMException\n} = internalBinding(\"messaging\");\nconst {\n  isArrayBufferView,\n  isDataView\n} = require(\"internal/util/types\");\nconst {\n  createDeferredPromise,\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  serialize,\n  deserialize\n} = require(\"v8\");\nconst {\n  validateObject\n} = require(\"internal/validators\");\nconst {\n  kAborted\n} = require(\"internal/abort_controller\");\nconst {\n  MessageChannel\n} = require(\"internal/worker/io\");\nconst {\n  kDeserialize,\n  kTransfer,\n  kTransferList,\n  makeTransferable\n} = require(\"internal/worker/js_transferable\");\nconst {\n  queueMicrotask\n} = require(\"internal/process/task_queues\");\nconst {\n  kIsDisturbed\n} = require(\"internal/streams/utils\");\nconst {\n  ArrayBufferViewGetBuffer,\n  ArrayBufferViewGetByteLength,\n  ArrayBufferViewGetByteOffset,\n  ArrayBufferGetByteLength,\n  AsyncIterator,\n  copyArrayBuffer,\n  customInspect,\n  dequeueValue,\n  ensureIsPromise,\n  enqueueValueWithSize,\n  extractHighWaterMark,\n  extractSizeAlgorithm,\n  lazyTransfer,\n  isBrandCheck,\n  resetQueue,\n  setPromiseHandled,\n  transferArrayBuffer,\n  nonOpCancel,\n  nonOpPull,\n  nonOpStart,\n  kType,\n  kState,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  WritableStreamDefaultWriter,\n  isWritableStream,\n  isWritableStreamLocked,\n  isWritableStreamDefaultController,\n  isWritableStreamDefaultWriter,\n  writableStreamAbort,\n  writableStreamCloseQueuedOrInFlight,\n  writableStreamDefaultWriterCloseWithErrorPropagation,\n  writableStreamDefaultWriterRelease,\n  writableStreamDefaultWriterWrite\n} = require(\"internal/webstreams/writablestream\");\nconst assert = require(\"internal/assert\");\nconst kCancel = Symbol(\"kCancel\");\nconst kClose = Symbol(\"kClose\");\nconst kChunk = Symbol(\"kChunk\");\nconst kError = Symbol(\"kError\");\nconst kPull = Symbol(\"kPull\");\nclass ReadableStream {\n  [kType] = \"ReadableStream\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(source = {}, strategy = {}) {\n    if (source === null)\n      throw new ERR_INVALID_ARG_VALUE(\"source\", \"Object\", source);\n    this[kState] = {\n      disturbed: false,\n      state: \"readable\",\n      storedError: void 0,\n      stream: void 0,\n      transfer: {\n        writable: void 0,\n        port1: void 0,\n        port2: void 0,\n        promise: void 0\n      }\n    };\n    const size = strategy?.size;\n    const highWaterMark = strategy?.highWaterMark;\n    const type = source.type;\n    if (`${type}` === \"bytes\") {\n      if (size !== void 0)\n        throw new ERR_INVALID_ARG_VALUE.RangeError(\"strategy.size\", size);\n      setupReadableByteStreamControllerFromSource(this, source, extractHighWaterMark(highWaterMark, 0));\n      return;\n    }\n    if (type !== void 0)\n      throw new ERR_INVALID_ARG_VALUE(\"source.type\", type);\n    setupReadableStreamDefaultControllerFromSource(this, source, extractHighWaterMark(highWaterMark, 1), extractSizeAlgorithm(size));\n    return makeTransferable(this);\n  }\n  get [kIsDisturbed]() {\n    return this[kState].disturbed;\n  }\n  get locked() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    return isReadableStreamLocked(this);\n  }\n  cancel(reason = void 0) {\n    if (!isReadableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStream\"));\n    if (isReadableStreamLocked(this)) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"ReadableStream is locked\"));\n    }\n    return readableStreamCancel(this, reason);\n  }\n  getReader(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    validateObject(options, \"options\", { nullable: true, allowFunction: true });\n    const mode = options?.mode;\n    if (mode === void 0)\n      return new ReadableStreamDefaultReader(this);\n    if (`${mode}` !== \"byob\")\n      throw new ERR_INVALID_ARG_VALUE(\"options.mode\", mode);\n    return new ReadableStreamBYOBReader(this);\n  }\n  pipeThrough(transform, options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    const readable = transform?.readable;\n    if (!isReadableStream(readable)) {\n      throw new ERR_INVALID_ARG_TYPE(\"transform.readable\", \"ReadableStream\", readable);\n    }\n    const writable = transform?.writable;\n    if (!isWritableStream(writable)) {\n      throw new ERR_INVALID_ARG_TYPE(\"transform.writable\", \"WritableStream\", writable);\n    }\n    const preventAbort = options?.preventAbort;\n    const preventCancel = options?.preventCancel;\n    const preventClose = options?.preventClose;\n    const signal = options?.signal;\n    if (signal !== void 0 && signal?.[kAborted] === void 0)\n      throw new ERR_INVALID_ARG_TYPE(\"options.signal\", \"AbortSignal\", signal);\n    if (isReadableStreamLocked(this))\n      throw new ERR_INVALID_STATE.TypeError(\"The ReadableStream is locked\");\n    if (isWritableStreamLocked(writable))\n      throw new ERR_INVALID_STATE.TypeError(\"The WritableStream is locked\");\n    const promise = readableStreamPipeTo(this, writable, !!preventClose, !!preventAbort, !!preventCancel, signal);\n    setPromiseHandled(promise);\n    return readable;\n  }\n  pipeTo(destination, options = {}) {\n    try {\n      if (!isReadableStream(this))\n        throw new ERR_INVALID_THIS(\"ReadableStream\");\n      if (!isWritableStream(destination)) {\n        throw new ERR_INVALID_ARG_TYPE(\"transform.writable\", \"WritableStream\", destination);\n      }\n      const preventAbort = options?.preventAbort;\n      const preventCancel = options?.preventCancel;\n      const preventClose = options?.preventClose;\n      const signal = options?.signal;\n      if (signal !== void 0 && signal?.[kAborted] === void 0)\n        throw new ERR_INVALID_ARG_TYPE(\"options.signal\", \"AbortSignal\", signal);\n      if (isReadableStreamLocked(this))\n        throw new ERR_INVALID_STATE.TypeError(\"The ReadableStream is locked\");\n      if (isWritableStreamLocked(destination))\n        throw new ERR_INVALID_STATE.TypeError(\"The WritableStream is locked\");\n      return readableStreamPipeTo(this, destination, !!preventClose, !!preventAbort, !!preventCancel, signal);\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n  tee() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    return readableStreamTee(this, false);\n  }\n  values(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    validateObject(options, \"options\");\n    const {\n      preventCancel = false\n    } = options;\n    const reader = new ReadableStreamDefaultReader(this);\n    let done = false;\n    let started = false;\n    let current;\n    function nextSteps() {\n      if (done)\n        return PromiseResolve({ done: true, value: void 0 });\n      if (reader[kState].stream === void 0) {\n        return PromiseReject(new ERR_INVALID_STATE.TypeError(\"The reader is not bound to a ReadableStream\"));\n      }\n      const promise = createDeferredPromise();\n      readableStreamDefaultReaderRead(reader, {\n        [kChunk](chunk) {\n          current = void 0;\n          promise.resolve({ value: chunk, done: false });\n        },\n        [kClose]() {\n          current = void 0;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.resolve({ done: true, value: void 0 });\n        },\n        [kError](error) {\n          current = void 0;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.reject(error);\n        }\n      });\n      return promise.promise;\n    }\n    async function returnSteps(value) {\n      if (done)\n        return { done: true, value };\n      done = true;\n      if (reader[kState].stream === void 0) {\n        throw new ERR_INVALID_STATE.TypeError(\"The reader is not bound to a ReadableStream\");\n      }\n      assert(!reader[kState].readRequests.length);\n      if (!preventCancel) {\n        const result = readableStreamReaderGenericCancel(reader, value);\n        readableStreamReaderGenericRelease(reader);\n        await result;\n        return { done: true, value };\n      }\n      readableStreamReaderGenericRelease(reader);\n      return { done: true, value };\n    }\n    return ObjectSetPrototypeOf({\n      next() {\n        if (!started) {\n          current = PromiseResolve();\n          started = true;\n        }\n        current = current !== void 0 ? PromisePrototypeThen(current, nextSteps, nextSteps) : nextSteps();\n        return current;\n      },\n      return(error) {\n        return current ? PromisePrototypeThen(current, () => returnSteps(error), () => returnSteps(error)) : returnSteps(error);\n      },\n      [SymbolAsyncIterator]() {\n        return this;\n      }\n    }, AsyncIterator);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      locked: this.locked,\n      state: this[kState].state\n    });\n  }\n  [kTransfer]() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS(\"ReadableStream\");\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = void 0;\n      this[kState].transfer.port2 = void 0;\n      throw new DOMException(\"Cannot transfer a locked ReadableStream\", \"DataCloneError\");\n    }\n    const {\n      writable,\n      promise\n    } = lazyTransfer().newCrossRealmWritableSink(this, this[kState].transfer.port1);\n    this[kState].transfer.writable = writable;\n    this[kState].transfer.promise = promise;\n    return {\n      data: { port: this[kState].transfer.port2 },\n      deserializeInfo: \"internal/webstreams/readablestream:TransferredReadableStream\"\n    };\n  }\n  [kTransferList]() {\n    const { port1, port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [port2];\n  }\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupReadableStreamDefaultControllerFromSource(this, new transfer.CrossRealmTransformReadableSource(port), 0, () => 1);\n  }\n}\nObjectDefineProperties(ReadableStream.prototype, {\n  [SymbolAsyncIterator]: {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: ReadableStream.prototype.values\n  },\n  locked: kEnumerableProperty,\n  cancel: kEnumerableProperty,\n  getReader: kEnumerableProperty,\n  pipeThrough: kEnumerableProperty,\n  pipeTo: kEnumerableProperty,\n  tee: kEnumerableProperty\n});\nfunction TransferredReadableStream() {\n  return makeTransferable(ReflectConstruct(function() {\n    this[kType] = \"ReadableStream\";\n    this[kState] = {\n      disturbed: false,\n      state: \"readable\",\n      storedError: void 0,\n      stream: void 0,\n      transfer: {\n        writable: void 0,\n        port: void 0,\n        promise: void 0\n      }\n    };\n  }, [], ReadableStream));\n}\nTransferredReadableStream.prototype[kDeserialize] = () => {\n};\nclass ReadableStreamBYOBRequest {\n  [kType] = \"ReadableStreamBYOBRequest\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get view() {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS(\"ReadableStreamBYOBRequest\");\n    return this[kState].view;\n  }\n  respond(bytesWritten) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS(\"ReadableStreamBYOBRequest\");\n    const {\n      view,\n      controller\n    } = this[kState];\n    if (controller === void 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"This BYOB request has been invalidated\");\n    }\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"View ArrayBuffer is zero-length or detached\");\n    }\n    readableByteStreamControllerRespond(controller, bytesWritten);\n  }\n  respondWithNewView(view) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS(\"ReadableStreamBYOBRequest\");\n    const {\n      controller\n    } = this[kState];\n    if (controller === void 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"This BYOB request has been invalidated\");\n    }\n    readableByteStreamControllerRespondWithNewView(controller, view);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      view: this.view,\n      controller: this[kState].controller\n    });\n  }\n}\nObjectDefineProperties(ReadableStreamBYOBRequest.prototype, {\n  view: kEnumerableProperty,\n  respond: kEnumerableProperty,\n  respondWithNewView: kEnumerableProperty\n});\nfunction createReadableStreamBYOBRequest(controller, view) {\n  return ReflectConstruct(function() {\n    this[kType] = \"ReadableStreamBYOBRequest\";\n    this[kState] = {\n      controller,\n      view\n    };\n  }, [], ReadableStreamBYOBRequest);\n}\nclass DefaultReadRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n  [kChunk](value) {\n    this[kState].resolve?.({ value, done: false });\n  }\n  [kClose]() {\n    this[kState].resolve?.({ value: void 0, done: true });\n  }\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n  get promise() {\n    return this[kState].promise;\n  }\n}\nclass ReadIntoRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n  [kChunk](value) {\n    this[kState].resolve?.({ value, done: false });\n  }\n  [kClose](value) {\n    this[kState].resolve?.({ value, done: true });\n  }\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n  get promise() {\n    return this[kState].promise;\n  }\n}\nclass ReadableStreamDefaultReader {\n  [kType] = \"ReadableStreamDefaultReader\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"ReadableStream\", stream);\n    this[kState] = {\n      readRequests: [],\n      stream: void 0,\n      close: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      }\n    };\n    setupReadableStreamDefaultReader(this, stream);\n  }\n  read() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamDefaultReader\"));\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"The reader is not attached to a stream\"));\n    }\n    const readRequest = new DefaultReadRequest();\n    readableStreamDefaultReaderRead(this, readRequest);\n    return readRequest.promise;\n  }\n  releaseLock() {\n    if (!isReadableStreamDefaultReader(this))\n      throw new ERR_INVALID_THIS(\"ReadableStreamDefaultReader\");\n    if (this[kState].stream === void 0)\n      return;\n    if (this[kState].readRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\"Cannot release with pending read requests\");\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n  get closed() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamDefaultReader\"));\n    return this[kState].close.promise;\n  }\n  cancel(reason = void 0) {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamDefaultReader\"));\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"The reader is not attached to a stream\"));\n    }\n    return readableStreamReaderGenericCancel(this, reason);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      stream: this[kState].stream,\n      readRequests: this[kState].readRequests.length,\n      close: this[kState].close.promise\n    });\n  }\n}\nObjectDefineProperties(ReadableStreamDefaultReader.prototype, {\n  closed: kEnumerableProperty,\n  read: kEnumerableProperty,\n  releaseLock: kEnumerableProperty,\n  cancel: kEnumerableProperty\n});\nclass ReadableStreamBYOBReader {\n  [kType] = \"ReadableStreamBYOBReader\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"ReadableStream\", stream);\n    this[kState] = {\n      stream: void 0,\n      requestIntoRequests: [],\n      close: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      }\n    };\n    setupReadableStreamBYOBReader(this, stream);\n  }\n  read(view) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamBYOBReader\"));\n    if (!isArrayBufferView(view)) {\n      return PromiseReject(new ERR_INVALID_ARG_TYPE(\"view\", [\n        \"Buffer\",\n        \"TypedArray\",\n        \"DataView\"\n      ], view));\n    }\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"View ArrayBuffer is zero-length or detached\"));\n    }\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"The reader is not attached to a stream\"));\n    }\n    const readIntoRequest = new ReadIntoRequest();\n    readableStreamBYOBReaderRead(this, view, readIntoRequest);\n    return readIntoRequest.promise;\n  }\n  releaseLock() {\n    if (!isReadableStreamBYOBReader(this))\n      throw new ERR_INVALID_THIS(\"ReadableStreamBYOBReader\");\n    if (this[kState].stream === void 0)\n      return;\n    if (this[kState].readIntoRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\"Cannot release with pending read requests\");\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n  get closed() {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamBYOBReader\"));\n    return this[kState].close.promise;\n  }\n  cancel(reason = void 0) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"ReadableStreamBYOBReader\"));\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"The reader is not attached to a stream\"));\n    }\n    return readableStreamReaderGenericCancel(this, reason);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      stream: this[kState].stream,\n      requestIntoRequests: this[kState].requestIntoRequests.length,\n      close: this[kState].close.promise\n    });\n  }\n}\nObjectDefineProperties(ReadableStreamBYOBReader.prototype, {\n  closed: kEnumerableProperty,\n  read: kEnumerableProperty,\n  releaseLock: kEnumerableProperty,\n  cancel: kEnumerableProperty\n});\nclass ReadableStreamDefaultController {\n  [kType] = \"ReadableStreamDefaultController\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get desiredSize() {\n    return readableStreamDefaultControllerGetDesiredSize(this);\n  }\n  close() {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError(\"Controller is already closed\");\n    readableStreamDefaultControllerClose(this);\n  }\n  enqueue(chunk = void 0) {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError(\"Controller is already closed\");\n    readableStreamDefaultControllerEnqueue(this, chunk);\n  }\n  error(error = void 0) {\n    readableStreamDefaultControllerError(this, error);\n  }\n  [kCancel](reason) {\n    return readableStreamDefaultControllerCancelSteps(this, reason);\n  }\n  [kPull](readRequest) {\n    readableStreamDefaultControllerPullSteps(this, readRequest);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {});\n  }\n}\nObjectDefineProperties(ReadableStreamDefaultController.prototype, {\n  desiredSize: kEnumerableProperty,\n  close: kEnumerableProperty,\n  enqueue: kEnumerableProperty,\n  error: kEnumerableProperty\n});\nfunction createReadableStreamDefaultController() {\n  return ReflectConstruct(function() {\n    this[kType] = \"ReadableStreamDefaultController\";\n    this[kState] = {};\n  }, [], ReadableStreamDefaultController);\n}\nclass ReadableByteStreamController {\n  [kType] = \"ReadableByteStreamController\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get byobRequest() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS(\"ReadableByteStreamController\");\n    if (this[kState].byobRequest === null && this[kState].pendingPullIntos.length) {\n      const {\n        buffer,\n        byteOffset,\n        bytesFilled,\n        byteLength\n      } = this[kState].pendingPullIntos[0];\n      const view = new Uint8Array(buffer, byteOffset + bytesFilled, byteLength - bytesFilled);\n      this[kState].byobRequest = createReadableStreamBYOBRequest(this, view);\n    }\n    return this[kState].byobRequest;\n  }\n  get desiredSize() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS(\"ReadableByteStreamController\");\n    return readableByteStreamControllerGetDesiredSize(this);\n  }\n  close() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS(\"ReadableByteStreamController\");\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError(\"Controller is already closed\");\n    if (this[kState].stream[kState].state !== \"readable\")\n      throw new ERR_INVALID_STATE.TypeError(\"ReadableStream is already closed\");\n    readableByteStreamControllerClose(this);\n  }\n  enqueue(chunk) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS(\"ReadableByteStreamController\");\n    if (!isArrayBufferView(chunk)) {\n      throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\n        \"Buffer\",\n        \"TypedArray\",\n        \"DataView\"\n      ], chunk);\n    }\n    const chunkByteLength = ArrayBufferViewGetByteLength(chunk);\n    const chunkByteOffset = ArrayBufferViewGetByteOffset(chunk);\n    const chunkBuffer = ArrayBufferViewGetBuffer(chunk);\n    const chunkBufferByteLength = ArrayBufferGetByteLength(chunkBuffer);\n    if (chunkByteLength === 0 || chunkBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"chunk ArrayBuffer is zero-length or detached\");\n    }\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError(\"Controller is already closed\");\n    if (this[kState].stream[kState].state !== \"readable\")\n      throw new ERR_INVALID_STATE.TypeError(\"ReadableStream is already closed\");\n    readableByteStreamControllerEnqueue(this, chunkBuffer, chunkByteLength, chunkByteOffset);\n  }\n  error(error = void 0) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS(\"ReadableByteStreamController\");\n    readableByteStreamControllerError(this, error);\n  }\n  [kCancel](reason) {\n    return readableByteStreamControllerCancelSteps(this, reason);\n  }\n  [kPull](readRequest) {\n    readableByteStreamControllerPullSteps(this, readRequest);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {});\n  }\n}\nObjectDefineProperties(ReadableByteStreamController.prototype, {\n  byobRequest: kEnumerableProperty,\n  desiredSize: kEnumerableProperty,\n  close: kEnumerableProperty,\n  enqueue: kEnumerableProperty,\n  error: kEnumerableProperty\n});\nfunction createReadableByteStreamController() {\n  return ReflectConstruct(function() {\n    this[kType] = \"ReadableByteStreamController\";\n    this[kState] = {};\n  }, [], ReadableByteStreamController);\n}\nfunction createTeeReadableStream(start, pull, cancel) {\n  return ReflectConstruct(function() {\n    this[kType] = \"ReadableStream\";\n    this[kState] = {\n      disturbed: false,\n      state: \"readable\",\n      storedError: void 0,\n      stream: void 0,\n      transfer: {\n        writable: void 0,\n        port: void 0,\n        promise: void 0\n      }\n    };\n    setupReadableStreamDefaultControllerFromSource(this, ObjectCreate(null, {\n      start: { value: start },\n      pull: { value: pull },\n      cancel: { value: cancel }\n    }), 1, () => 1);\n    return makeTransferable(this);\n  }, [], ReadableStream);\n}\nconst isReadableStream = isBrandCheck(\"ReadableStream\");\nconst isReadableByteStreamController = isBrandCheck(\"ReadableByteStreamController\");\nconst isReadableStreamBYOBRequest = isBrandCheck(\"ReadableStreamBYOBRequest\");\nconst isReadableStreamDefaultReader = isBrandCheck(\"ReadableStreamDefaultReader\");\nconst isReadableStreamBYOBReader = isBrandCheck(\"ReadableStreamBYOBReader\");\nfunction readableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  let reader;\n  let writer;\n  try {\n    reader = new ReadableStreamDefaultReader(source);\n    writer = new WritableStreamDefaultWriter(dest);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n  source[kState].disturbed = true;\n  let shuttingDown = false;\n  if (signal !== void 0 && signal?.[kAborted] === void 0) {\n    return PromiseReject(new ERR_INVALID_ARG_TYPE(\"options.signal\", \"AbortSignal\", signal));\n  }\n  const promise = createDeferredPromise();\n  let currentWrite = PromiseResolve();\n  function finalize(rejected, error) {\n    writableStreamDefaultWriterRelease(writer);\n    readableStreamReaderGenericRelease(reader);\n    if (signal !== void 0)\n      signal.removeEventListener(\"abort\", abortAlgorithm);\n    if (rejected)\n      promise.reject(error);\n    else\n      promise.resolve();\n  }\n  async function waitForCurrentWrite() {\n    const write = currentWrite;\n    await write;\n    if (write !== currentWrite)\n      await waitForCurrentWrite();\n  }\n  function shutdownWithAnAction(action, rejected, originalError) {\n    if (shuttingDown)\n      return;\n    shuttingDown = true;\n    if (dest[kState].state === \"writable\" && !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(waitForCurrentWrite(), complete, (error) => finalize(true, error));\n      return;\n    }\n    complete();\n    function complete() {\n      PromisePrototypeThen(action(), () => finalize(rejected, originalError), (error) => finalize(true, error));\n    }\n  }\n  function shutdown(rejected, error) {\n    if (shuttingDown)\n      return;\n    shuttingDown = true;\n    if (dest[kState].state === \"writable\" && !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(waitForCurrentWrite(), () => finalize(rejected, error), (error2) => finalize(true, error2));\n      return;\n    }\n    finalize(rejected, error);\n  }\n  function abortAlgorithm() {\n    const error = new DOMException(\"The operation was aborted\", \"AbortError\");\n    const actions = [];\n    if (!preventAbort) {\n      ArrayPrototypePush(actions, () => {\n        if (dest[kState].state === \"writable\")\n          return writableStreamAbort(dest, error);\n        return PromiseResolve();\n      });\n    }\n    if (!preventCancel) {\n      ArrayPrototypePush(actions, () => {\n        if (source[kState].state === \"readable\")\n          return readableStreamCancel(source, error);\n        return PromiseResolve();\n      });\n    }\n    shutdownWithAnAction(async () => PromiseAll(actions.map((action) => action())), true, error);\n  }\n  function watchErrored(stream, promise2, action) {\n    if (stream[kState].state === \"errored\")\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeCatch(promise2, action);\n  }\n  function watchClosed(stream, promise2, action) {\n    if (stream[kState].state === \"closed\")\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeThen(promise2, action, () => {\n      });\n  }\n  async function step() {\n    if (shuttingDown)\n      return true;\n    await writer[kState].ready.promise;\n    return new Promise((resolve, reject) => {\n      readableStreamDefaultReaderRead(reader, {\n        [kChunk](chunk) {\n          currentWrite = writableStreamDefaultWriterWrite(writer, chunk);\n          setPromiseHandled(currentWrite);\n          resolve(false);\n        },\n        [kClose]: () => resolve(true),\n        [kError]: reject\n      });\n    });\n  }\n  async function run() {\n    while (!await step()) {\n    }\n  }\n  if (signal !== void 0) {\n    if (signal.aborted) {\n      abortAlgorithm();\n      return promise.promise;\n    }\n    signal.addEventListener(\"abort\", abortAlgorithm, { once: true });\n  }\n  setPromiseHandled(run());\n  watchErrored(source, reader[kState].close.promise, (error) => {\n    if (!preventAbort) {\n      return shutdownWithAnAction(() => writableStreamAbort(dest, error), true, error);\n    }\n    shutdown(true, error);\n  });\n  watchErrored(dest, writer[kState].close.promise, (error) => {\n    if (!preventCancel) {\n      return shutdownWithAnAction(() => readableStreamCancel(source, error), true, error);\n    }\n    shutdown(true, error);\n  });\n  watchClosed(source, reader[kState].close.promise, () => {\n    if (!preventClose) {\n      return shutdownWithAnAction(() => writableStreamDefaultWriterCloseWithErrorPropagation(writer));\n    }\n    shutdown();\n  });\n  if (writableStreamCloseQueuedOrInFlight(dest) || dest[kState].state === \"closed\") {\n    const error = new ERR_INVALID_STATE.TypeError(\"Destination WritableStream is closed\");\n    if (!preventCancel) {\n      shutdownWithAnAction(() => readableStreamCancel(source, error), true, error);\n    } else {\n      shutdown(true, error);\n    }\n  }\n  return promise.promise;\n}\nfunction readableStreamTee(stream, cloneForBranch2) {\n  const reader = new ReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n  const cancelPromise = createDeferredPromise();\n  async function pullAlgorithm() {\n    if (reading)\n      return;\n    reading = true;\n    const readRequest = {\n      [kChunk](value) {\n        queueMicrotask(() => {\n          reading = false;\n          const value1 = value;\n          let value2 = value;\n          if (!canceled2 && cloneForBranch2) {\n            value2 = deserialize(serialize(value2));\n          }\n          if (!canceled1) {\n            readableStreamDefaultControllerEnqueue(branch1[kState].controller, value1);\n          }\n          if (!canceled2) {\n            readableStreamDefaultControllerEnqueue(branch2[kState].controller, value2);\n          }\n        });\n      },\n      [kClose]() {\n        reading = false;\n        if (!canceled1)\n          readableStreamDefaultControllerClose(branch1[kState].controller);\n        if (!canceled2)\n          readableStreamDefaultControllerClose(branch2[kState].controller);\n        if (!canceled1 || !canceled2)\n          cancelPromise.resolve();\n      },\n      [kError]() {\n        reading = false;\n      }\n    };\n    readableStreamDefaultReaderRead(reader, readRequest);\n  }\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = [reason1, reason2];\n      cancelPromise.resolve(readableStreamCancel(stream, compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = [reason1, reason2];\n      cancelPromise.resolve(readableStreamCancel(stream, compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n  branch1 = createTeeReadableStream(nonOpStart, pullAlgorithm, cancel1Algorithm);\n  branch2 = createTeeReadableStream(nonOpStart, pullAlgorithm, cancel2Algorithm);\n  PromisePrototypeCatch(reader[kState].close.promise, (error) => {\n    readableStreamDefaultControllerError(branch1[kState].controller, error);\n    readableStreamDefaultControllerError(branch2[kState].controller, error);\n    if (!canceled1 || !canceled2)\n      cancelPromise.resolve();\n  });\n  return [branch1, branch2];\n}\nfunction readableByteStreamControllerConvertPullIntoDescriptor(desc) {\n  const {\n    buffer,\n    bytesFilled,\n    byteLength,\n    byteOffset,\n    ctor,\n    elementSize\n  } = desc;\n  if (bytesFilled > byteLength)\n    throw new ERR_INVALID_STATE.RangeError(\"The buffer size is invalid\");\n  assert(!(bytesFilled % elementSize));\n  const transferredBuffer = transferArrayBuffer(buffer);\n  return new ctor(transferredBuffer, byteOffset, bytesFilled / elementSize);\n}\nfunction isReadableStreamLocked(stream) {\n  return stream[kState].reader !== void 0;\n}\nfunction readableStreamCancel(stream, reason) {\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case \"closed\":\n      return PromiseResolve();\n    case \"errored\":\n      return PromiseReject(stream[kState].storedError);\n  }\n  readableStreamClose(stream);\n  const {\n    reader\n  } = stream[kState];\n  if (reader !== void 0 && readableStreamHasBYOBReader(stream)) {\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kClose]();\n    reader[kState].readIntoRequests = [];\n  }\n  return PromisePrototypeThen(ensureIsPromise(stream[kState].controller[kCancel], stream[kState].controller, reason), () => {\n  });\n}\nfunction readableStreamClose(stream) {\n  assert(stream[kState].state === \"readable\");\n  stream[kState].state = \"closed\";\n  const {\n    reader\n  } = stream[kState];\n  if (reader === void 0)\n    return;\n  reader[kState].close.resolve();\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kClose]();\n    reader[kState].readRequests = [];\n  }\n}\nfunction readableStreamError(stream, error) {\n  assert(stream[kState].state === \"readable\");\n  stream[kState].state = \"errored\";\n  stream[kState].storedError = error;\n  const {\n    reader\n  } = stream[kState];\n  if (reader === void 0)\n    return;\n  reader[kState].close.reject(error);\n  setPromiseHandled(reader[kState].close.promise);\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kError](error);\n    reader[kState].readRequests = [];\n  } else {\n    assert(readableStreamHasBYOBReader(stream));\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kError](error);\n    reader[kState].readIntoRequests = [];\n  }\n}\nfunction readableStreamHasDefaultReader(stream) {\n  const {\n    reader\n  } = stream[kState];\n  if (reader === void 0)\n    return false;\n  return reader[kState] !== void 0 && reader[kType] === \"ReadableStreamDefaultReader\";\n}\nfunction readableStreamGetNumReadRequests(stream) {\n  assert(readableStreamHasDefaultReader(stream));\n  return stream[kState].reader[kState].readRequests.length;\n}\nfunction readableStreamHasBYOBReader(stream) {\n  const {\n    reader\n  } = stream[kState];\n  if (reader === void 0)\n    return false;\n  return reader[kState] !== void 0 && reader[kType] === \"ReadableStreamBYOBReader\";\n}\nfunction readableStreamGetNumReadIntoRequests(stream) {\n  assert(readableStreamHasBYOBReader(stream));\n  return stream[kState].reader[kState].readIntoRequests.length;\n}\nfunction readableStreamFulfillReadRequest(stream, chunk, done) {\n  assert(readableStreamHasDefaultReader(stream));\n  const {\n    reader\n  } = stream[kState];\n  assert(reader[kState].readRequests.length);\n  const readRequest = ArrayPrototypeShift(reader[kState].readRequests);\n  if (done)\n    readRequest[kClose]();\n  else\n    readRequest[kChunk](chunk);\n}\nfunction readableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  assert(readableStreamHasBYOBReader(stream));\n  const {\n    reader\n  } = stream[kState];\n  assert(reader[kState].readIntoRequests.length);\n  const readIntoRequest = ArrayPrototypeShift(reader[kState].readIntoRequests);\n  if (done)\n    readIntoRequest[kClose](chunk);\n  else\n    readIntoRequest[kChunk](chunk);\n}\nfunction readableStreamAddReadRequest(stream, readRequest) {\n  assert(readableStreamHasDefaultReader(stream));\n  assert(stream[kState].state === \"readable\");\n  ArrayPrototypePush(stream[kState].reader[kState].readRequests, readRequest);\n}\nfunction readableStreamAddReadIntoRequest(stream, readIntoRequest) {\n  assert(readableStreamHasBYOBReader(stream));\n  assert(stream[kState].state !== \"errored\");\n  ArrayPrototypePush(stream[kState].reader[kState].readIntoRequests, readIntoRequest);\n}\nfunction readableStreamReaderGenericCancel(reader, reason) {\n  const {\n    stream\n  } = reader[kState];\n  assert(stream !== void 0);\n  return readableStreamCancel(stream, reason);\n}\nfunction readableStreamReaderGenericInitialize(reader, stream) {\n  reader[kState].stream = stream;\n  stream[kState].reader = reader;\n  switch (stream[kState].state) {\n    case \"readable\":\n      reader[kState].close = createDeferredPromise();\n      break;\n    case \"closed\":\n      reader[kState].close = {\n        promise: PromiseResolve(),\n        resolve: void 0,\n        reject: void 0\n      };\n      break;\n    case \"errored\":\n      reader[kState].close = {\n        promise: PromiseReject(stream[kState].storedError),\n        resolve: void 0,\n        reject: void 0\n      };\n      setPromiseHandled(reader[kState].close.promise);\n      break;\n  }\n}\nfunction readableStreamReaderGenericRelease(reader) {\n  const {\n    stream\n  } = reader[kState];\n  assert(stream !== void 0);\n  assert(stream[kState].reader === reader);\n  if (stream[kState].state === \"readable\") {\n    reader[kState].close.reject?.(new ERR_INVALID_STATE.TypeError(\"Reader released\"));\n  } else {\n    reader[kState].close = {\n      promise: PromiseReject(new ERR_INVALID_STATE.TypeError(\"Reader released\")),\n      resolve: void 0,\n      reject: void 0\n    };\n  }\n  setPromiseHandled(reader[kState].close.promise);\n  stream[kState].reader = void 0;\n  reader[kState].stream = void 0;\n}\nfunction readableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n  const {\n    stream\n  } = reader[kState];\n  assert(stream !== void 0);\n  stream[kState].disturbed = true;\n  if (stream[kState].state === \"errored\") {\n    readIntoRequest[kError](stream[kState].storedError);\n    return;\n  }\n  readableByteStreamControllerPullInto(stream[kState].controller, view, readIntoRequest);\n}\nfunction readableStreamDefaultReaderRead(reader, readRequest) {\n  const {\n    stream\n  } = reader[kState];\n  assert(stream !== void 0);\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case \"closed\":\n      readRequest[kClose]();\n      break;\n    case \"errored\":\n      readRequest[kError](stream[kState].storedError);\n      break;\n    case \"readable\":\n      stream[kState].controller[kPull](readRequest);\n  }\n}\nfunction setupReadableStreamBYOBReader(reader, stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError(\"ReadableStream is locked\");\n  const {\n    controller\n  } = stream[kState];\n  if (!isReadableByteStreamController(controller))\n    throw new ERR_INVALID_ARG_VALUE(\"reader\", reader, \"must be a byte stream\");\n  readableStreamReaderGenericInitialize(reader, stream);\n  reader[kState].readIntoRequests = [];\n}\nfunction setupReadableStreamDefaultReader(reader, stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError(\"ReadableStream is locked\");\n  readableStreamReaderGenericInitialize(reader, stream);\n  reader[kState].readRequests = [];\n}\nfunction readableStreamDefaultControllerClose(controller) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n  controller[kState].closeRequested = true;\n  if (!controller[kState].queue.length) {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamClose(controller[kState].stream);\n  }\n}\nfunction readableStreamDefaultControllerEnqueue(controller, chunk) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n  const {\n    stream\n  } = controller[kState];\n  if (isReadableStreamLocked(stream) && readableStreamGetNumReadRequests(stream)) {\n    readableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    try {\n      const chunkSize = FunctionPrototypeCall(controller[kState].sizeAlgorithm, void 0, chunk);\n      enqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (error) {\n      readableStreamDefaultControllerError(controller, error);\n      throw error;\n    }\n  }\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction readableStreamDefaultControllerHasBackpressure(controller) {\n  return !readableStreamDefaultControllerShouldCallPull(controller);\n}\nfunction readableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const {\n    stream\n  } = controller[kState];\n  return !controller[kState].closeRequested && stream[kState].state === \"readable\";\n}\nfunction readableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    stream,\n    highWaterMark,\n    queueTotalSize\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case \"errored\":\n      return null;\n    case \"closed\":\n      return 0;\n    default:\n      return highWaterMark - queueTotalSize;\n  }\n}\nfunction readableStreamDefaultControllerShouldCallPull(controller) {\n  const {\n    stream\n  } = controller[kState];\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller[kState].started)\n    return false;\n  if (isReadableStreamLocked(stream) && readableStreamGetNumReadRequests(stream)) {\n    return true;\n  }\n  const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  return desiredSize > 0;\n}\nfunction readableStreamDefaultControllerCallPullIfNeeded(controller) {\n  if (!readableStreamDefaultControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(ensureIsPromise(controller[kState].pullAlgorithm, controller), () => {\n    controller[kState].pulling = false;\n    if (controller[kState].pullAgain) {\n      controller[kState].pullAgain = false;\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n  }, (error) => readableStreamDefaultControllerError(controller, error));\n}\nfunction readableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = void 0;\n  controller[kState].cancelAlgorithm = void 0;\n  controller[kState].sizeAlgorithm = void 0;\n}\nfunction readableStreamDefaultControllerError(controller, error) {\n  const {\n    stream\n  } = controller[kState];\n  if (stream[kState].state === \"readable\") {\n    resetQueue(controller);\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamError(stream, error);\n  }\n}\nfunction readableStreamDefaultControllerCancelSteps(controller, reason) {\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableStreamDefaultControllerClearAlgorithms(controller);\n  return result;\n}\nfunction readableStreamDefaultControllerPullSteps(controller, readRequest) {\n  const {\n    stream,\n    queue\n  } = controller[kState];\n  if (queue.length) {\n    const chunk = dequeueValue(controller);\n    if (controller[kState].closeRequested && !queue.length) {\n      readableStreamDefaultControllerClearAlgorithms(controller);\n      readableStreamClose(stream);\n    } else {\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    readRequest[kChunk](chunk);\n    return;\n  }\n  readableStreamAddReadRequest(stream, readRequest);\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction setupReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream[kState].controller === void 0);\n  controller[kState] = {\n    cancelAlgorithm,\n    closeRequested: false,\n    highWaterMark,\n    pullAgain: false,\n    pullAlgorithm,\n    pulling: false,\n    queue: [],\n    queueTotalSize: 0,\n    started: false,\n    sizeAlgorithm,\n    stream\n  };\n  stream[kState].controller = controller;\n  const startResult = startAlgorithm();\n  PromisePrototypeThen(PromiseResolve(startResult), () => {\n    controller[kState].started = true;\n    assert(!controller[kState].pulling);\n    assert(!controller[kState].pullAgain);\n    readableStreamDefaultControllerCallPullIfNeeded(controller);\n  }, (error) => readableStreamDefaultControllerError(controller, error));\n}\nfunction setupReadableStreamDefaultControllerFromSource(stream, source, highWaterMark, sizeAlgorithm) {\n  const controller = createReadableStreamDefaultController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const startAlgorithm = start ? FunctionPrototypeBind(start, source, controller) : nonOpStart;\n  const pullAlgorithm = pull ? FunctionPrototypeBind(pull, source, controller) : nonOpPull;\n  const cancelAlgorithm = cancel ? FunctionPrototypeBind(cancel, source) : nonOpCancel;\n  setupReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\nfunction readableByteStreamControllerClose(controller) {\n  const {\n    closeRequested,\n    pendingPullIntos,\n    queueTotalSize,\n    stream\n  } = controller[kState];\n  if (closeRequested || stream[kState].state !== \"readable\")\n    return;\n  if (queueTotalSize) {\n    controller[kState].closeRequested = true;\n    return;\n  }\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const error = new ERR_INVALID_STATE.TypeError(\"Partial read\");\n      readableByteStreamControllerError(controller, error);\n      throw error;\n    }\n  }\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamClose(stream);\n}\nfunction readableByteStreamControllerCommitPullIntoDescriptor(stream, desc) {\n  assert(stream[kState].state !== \"errored\");\n  let done = false;\n  if (stream[kState].state === \"closed\") {\n    desc.bytesFilled = 0;\n    done = true;\n  }\n  const filledView = readableByteStreamControllerConvertPullIntoDescriptor(desc);\n  if (desc.type === \"default\") {\n    readableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(desc.type === \"byob\");\n    readableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\nfunction readableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller[kState].byobRequest === null)\n    return;\n  controller[kState].byobRequest[kState].controller = void 0;\n  controller[kState].byobRequest[kState].view = null;\n  controller[kState].byobRequest = null;\n}\nfunction readableByteStreamControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = void 0;\n  controller[kState].cancelAlgorithm = void 0;\n}\nfunction readableByteStreamControllerClearPendingPullIntos(controller) {\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller[kState].pendingPullIntos = [];\n}\nfunction readableByteStreamControllerGetDesiredSize(controller) {\n  const {\n    stream,\n    highWaterMark,\n    queueTotalSize\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case \"errored\":\n      return null;\n    case \"closed\":\n      return 0;\n    default:\n      return highWaterMark - queueTotalSize;\n  }\n}\nfunction readableByteStreamControllerShouldCallPull(controller) {\n  const {\n    stream\n  } = controller[kState];\n  if (stream[kState].state !== \"readable\" || controller[kState].closeRequested || !controller[kState].started) {\n    return false;\n  }\n  if (readableStreamHasDefaultReader(stream) && readableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n  if (readableStreamHasBYOBReader(stream) && readableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n  const desiredSize = readableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  return desiredSize > 0;\n}\nfunction readableByteStreamControllerHandleQueueDrain(controller) {\n  const {\n    closeRequested,\n    queueTotalSize,\n    stream\n  } = controller[kState];\n  assert(stream[kState].state === \"readable\");\n  if (!queueTotalSize && closeRequested) {\n    readableByteStreamControllerClearAlgorithms(controller);\n    readableStreamClose(stream);\n    return;\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction readableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n  const {\n    closeRequested,\n    stream,\n    pendingPullIntos\n  } = controller[kState];\n  let elementSize = 1;\n  let ctor = DataViewCtor;\n  if (isArrayBufferView(view) && !isDataView(view)) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n    ctor = view.constructor;\n  }\n  const buffer = ArrayBufferViewGetBuffer(view);\n  const byteOffset = ArrayBufferViewGetByteOffset(view);\n  const byteLength = ArrayBufferViewGetByteLength(view);\n  const bufferByteLength = ArrayBufferGetByteLength(buffer);\n  let transferredBuffer;\n  try {\n    transferredBuffer = transferArrayBuffer(buffer);\n  } catch (error) {\n    readIntoRequest[kError](error);\n    return;\n  }\n  const desc = {\n    buffer: transferredBuffer,\n    bufferByteLength,\n    byteOffset,\n    byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    type: \"byob\"\n  };\n  if (pendingPullIntos.length) {\n    ArrayPrototypePush(pendingPullIntos, desc);\n    readableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n  if (stream[kState].state === \"closed\") {\n    const emptyView = new ctor(desc.buffer, byteOffset, 0);\n    readIntoRequest[kClose](emptyView);\n    return;\n  }\n  if (controller[kState].queueTotalSize) {\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, desc)) {\n      const filledView = readableByteStreamControllerConvertPullIntoDescriptor(desc);\n      readableByteStreamControllerHandleQueueDrain(controller);\n      readIntoRequest[kChunk](filledView);\n      return;\n    }\n    if (closeRequested) {\n      const error = new ERR_INVALID_STATE.TypeError(\"ReadableStream closed\");\n      readableByteStreamControllerError(controller, error);\n      readIntoRequest[kError](error);\n      return;\n    }\n  }\n  ArrayPrototypePush(pendingPullIntos, desc);\n  readableStreamAddReadIntoRequest(stream, readIntoRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction readableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const {\n    stream,\n    pendingPullIntos\n  } = controller[kState];\n  const desc = pendingPullIntos[0];\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  if (stream[kState].state === \"closed\") {\n    if (bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError(\"Controller is closed but view is not zero-length\");\n    readableByteStreamControllerRespondInClosedState(controller, desc);\n  } else {\n    assert(stream[kState].state === \"readable\");\n    if (!bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError(\"View cannot be zero-length\");\n    readableByteStreamControllerRespondInReadableState(controller, bytesWritten, desc);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction readableByteStreamControllerRespond(controller, bytesWritten) {\n  const {\n    pendingPullIntos,\n    stream\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n  const desc = pendingPullIntos[0];\n  if (stream[kState].state === \"closed\") {\n    if (bytesWritten !== 0)\n      throw new ERR_INVALID_ARG_VALUE(\"bytesWritten\", bytesWritten);\n  } else {\n    assert(stream[kState].state === \"readable\");\n    if (!bytesWritten)\n      throw new ERR_INVALID_ARG_VALUE(\"bytesWritten\", bytesWritten);\n    if (desc.bytesFilled + bytesWritten > desc.byteLength)\n      throw new ERR_INVALID_ARG_VALUE.RangeError(\"bytesWritten\", bytesWritten);\n  }\n  desc.buffer = transferArrayBuffer(desc.buffer);\n  readableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction readableByteStreamControllerRespondInClosedState(controller, desc) {\n  assert(!desc.bytesFilled);\n  const {\n    stream\n  } = controller[kState];\n  if (readableStreamHasBYOBReader(stream)) {\n    while (readableStreamGetNumReadIntoRequests(stream) > 0) {\n      readableByteStreamControllerCommitPullIntoDescriptor(stream, readableByteStreamControllerShiftPendingPullInto(controller));\n    }\n  }\n}\nfunction readableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, desc) {\n  const {\n    pendingPullIntos,\n    byobRequest\n  } = controller[kState];\n  assert(!pendingPullIntos.length || pendingPullIntos[0] === desc);\n  assert(byobRequest === null);\n  desc.bytesFilled += size;\n}\nfunction readableByteStreamControllerEnqueue(controller, buffer, byteLength, byteOffset) {\n  const {\n    closeRequested,\n    pendingPullIntos,\n    queue,\n    stream\n  } = controller[kState];\n  if (closeRequested || stream[kState].state !== \"readable\")\n    return;\n  const transferredBuffer = transferArrayBuffer(buffer);\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n    const pendingBufferByteLength = ArrayBufferGetByteLength(firstPendingPullInto.buffer);\n    if (pendingBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"Destination ArrayBuffer is zero-length or detached\");\n    }\n    firstPendingPullInto.buffer = transferArrayBuffer(firstPendingPullInto.buffer);\n  }\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  if (readableStreamHasDefaultReader(stream)) {\n    if (!readableStreamGetNumReadRequests(stream)) {\n      readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(!queue.length);\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      readableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (readableStreamHasBYOBReader(stream)) {\n    readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!isReadableStreamLocked(stream));\n    readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction readableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  ArrayPrototypePush(controller[kState].queue, {\n    buffer,\n    byteOffset,\n    byteLength\n  });\n  controller[kState].queueTotalSize += byteLength;\n}\nfunction readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, desc) {\n  const {\n    buffer,\n    byteLength,\n    byteOffset,\n    bytesFilled,\n    elementSize\n  } = desc;\n  const currentAlignedBytes = bytesFilled - bytesFilled % elementSize;\n  const maxBytesToCopy = MathMin(controller[kState].queueTotalSize, byteLength - bytesFilled);\n  const maxBytesFilled = bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - bytesFilled;\n    ready = true;\n  }\n  const {\n    queue\n  } = controller[kState];\n  while (totalBytesToCopyRemaining) {\n    const headOfQueue = queue[0];\n    const bytesToCopy = MathMin(totalBytesToCopyRemaining, headOfQueue.byteLength);\n    const destStart = byteOffset + desc.bytesFilled;\n    const arrayBufferByteLength = ArrayBufferGetByteLength(buffer);\n    if (arrayBufferByteLength - destStart < bytesToCopy) {\n      throw new ERR_INVALID_STATE.RangeError(\"view ArrayBuffer size is invalid\");\n    }\n    assert(arrayBufferByteLength - destStart >= bytesToCopy);\n    copyArrayBuffer(buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n    if (headOfQueue.byteLength === bytesToCopy) {\n      ArrayPrototypeShift(queue);\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller[kState].queueTotalSize -= bytesToCopy;\n    readableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, desc);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n  if (!ready) {\n    assert(!controller[kState].queueTotalSize);\n    assert(desc.bytesFilled > 0);\n    assert(desc.bytesFilled < elementSize);\n  }\n  return ready;\n}\nfunction readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  const {\n    closeRequested,\n    pendingPullIntos,\n    stream\n  } = controller[kState];\n  assert(!closeRequested);\n  while (pendingPullIntos.length) {\n    if (!controller[kState].queueTotalSize)\n      return;\n    const desc = pendingPullIntos[0];\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, desc)) {\n      readableByteStreamControllerShiftPendingPullInto(controller);\n      readableByteStreamControllerCommitPullIntoDescriptor(stream, desc);\n    }\n  }\n}\nfunction readableByteStreamControllerRespondInReadableState(controller, bytesWritten, desc) {\n  const {\n    buffer,\n    bytesFilled,\n    byteLength\n  } = desc;\n  if (bytesFilled + bytesWritten > byteLength)\n    throw new ERR_INVALID_STATE.RangeError(\"The buffer size is invalid\");\n  readableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, desc);\n  if (desc.bytesFilled < desc.elementSize)\n    return;\n  readableByteStreamControllerShiftPendingPullInto(controller);\n  const remainderSize = desc.bytesFilled % desc.elementSize;\n  if (remainderSize) {\n    const end = desc.byteOffset + desc.bytesFilled;\n    const start = end - remainderSize;\n    const remainder = ArrayBufferPrototypeSlice(buffer, start, end);\n    readableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, ArrayBufferGetByteLength(remainder));\n  }\n  desc.bytesFilled -= remainderSize;\n  readableByteStreamControllerCommitPullIntoDescriptor(controller[kState].stream, desc);\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction readableByteStreamControllerRespondWithNewView(controller, view) {\n  const {\n    stream,\n    pendingPullIntos\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n  const desc = pendingPullIntos[0];\n  assert(stream[kState].state !== \"errored\");\n  if (!isArrayBufferView(view)) {\n    throw new ERR_INVALID_ARG_TYPE(\"view\", [\n      \"Buffer\",\n      \"TypedArray\",\n      \"DataView\"\n    ], view);\n  }\n  const viewByteLength = ArrayBufferViewGetByteLength(view);\n  const viewByteOffset = ArrayBufferViewGetByteOffset(view);\n  const viewBuffer = ArrayBufferViewGetBuffer(view);\n  const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n  const {\n    byteOffset,\n    byteLength,\n    bytesFilled,\n    bufferByteLength\n  } = desc;\n  if (byteOffset + bytesFilled !== viewByteOffset)\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"view\", view);\n  if (bytesFilled + viewByteOffset > byteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"view\", view);\n  if (bufferByteLength !== viewBufferByteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"view\", view);\n  desc.buffer = transferArrayBuffer(viewBuffer);\n  readableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\nfunction readableByteStreamControllerShiftPendingPullInto(controller) {\n  assert(controller[kState].byobRequest === null);\n  return ArrayPrototypeShift(controller[kState].pendingPullIntos);\n}\nfunction readableByteStreamControllerCallPullIfNeeded(controller) {\n  if (!readableByteStreamControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(ensureIsPromise(controller[kState].pullAlgorithm, controller), () => {\n    controller[kState].pulling = false;\n    if (controller[kState].pullAgain) {\n      controller[kState].pullAgain = false;\n      readableByteStreamControllerCallPullIfNeeded(controller);\n    }\n  }, (error) => readableByteStreamControllerError(controller, error));\n}\nfunction readableByteStreamControllerError(controller, error) {\n  const {\n    stream\n  } = controller[kState];\n  if (stream[kState].state !== \"readable\")\n    return;\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamError(stream, error);\n}\nfunction readableByteStreamControllerCancelSteps(controller, reason) {\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableByteStreamControllerClearAlgorithms(controller);\n  return result;\n}\nfunction readableByteStreamControllerPullSteps(controller, readRequest) {\n  const {\n    pendingPullIntos,\n    queue,\n    queueTotalSize,\n    stream\n  } = controller[kState];\n  assert(readableStreamHasDefaultReader(stream));\n  if (queueTotalSize) {\n    assert(!readableStreamGetNumReadRequests(stream));\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = ArrayPrototypeShift(queue);\n    controller[kState].queueTotalSize -= byteLength;\n    readableByteStreamControllerHandleQueueDrain(controller);\n    const view = new Uint8Array(buffer, byteOffset, byteLength);\n    readRequest[kChunk](view);\n    return;\n  }\n  const {\n    autoAllocateChunkSize\n  } = controller[kState];\n  if (autoAllocateChunkSize !== void 0) {\n    try {\n      const buffer = new ArrayBuffer(autoAllocateChunkSize);\n      ArrayPrototypePush(pendingPullIntos, {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        type: \"default\"\n      });\n    } catch (error) {\n      readRequest[kError](error);\n      return;\n    }\n  }\n  readableStreamAddReadRequest(stream, readRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction setupReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n  assert(stream[kState].controller === void 0);\n  if (autoAllocateChunkSize !== void 0) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n  controller[kState] = {\n    byobRequest: null,\n    closeRequested: false,\n    pullAgain: false,\n    pulling: false,\n    started: false,\n    stream,\n    queue: [],\n    queueTotalSize: 0,\n    highWaterMark,\n    pullAlgorithm,\n    cancelAlgorithm,\n    autoAllocateChunkSize,\n    pendingPullIntos: []\n  };\n  stream[kState].controller = controller;\n  const startResult = startAlgorithm();\n  PromisePrototypeThen(PromiseResolve(startResult), () => {\n    controller[kState].started = true;\n    assert(!controller[kState].pulling);\n    assert(!controller[kState].pullAgain);\n    readableByteStreamControllerCallPullIfNeeded(controller);\n  }, (error) => readableByteStreamControllerError(controller, error));\n}\nfunction setupReadableByteStreamControllerFromSource(stream, source, highWaterMark) {\n  const controller = createReadableByteStreamController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const autoAllocateChunkSize = source?.autoAllocateChunkSize;\n  const startAlgorithm = start ? FunctionPrototypeBind(start, source, controller) : nonOpStart;\n  const pullAlgorithm = pull ? FunctionPrototypeBind(pull, source, controller) : nonOpPull;\n  const cancelAlgorithm = cancel ? FunctionPrototypeBind(cancel, source) : nonOpCancel;\n  if (autoAllocateChunkSize === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"source.autoAllocateChunkSize\", autoAllocateChunkSize);\n  }\n  setupReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nmodule.exports = {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController,\n  ReadableStreamDefaultController,\n  TransferredReadableStream,\n  isReadableStream,\n  isReadableByteStreamController,\n  isReadableStreamBYOBRequest,\n  isReadableStreamDefaultReader,\n  isReadableStreamBYOBReader,\n  isWritableStreamDefaultWriter,\n  isWritableStreamDefaultController,\n  readableStreamPipeTo,\n  readableStreamTee,\n  readableByteStreamControllerConvertPullIntoDescriptor,\n  isReadableStreamLocked,\n  readableStreamCancel,\n  readableStreamClose,\n  readableStreamError,\n  readableStreamHasDefaultReader,\n  readableStreamGetNumReadRequests,\n  readableStreamHasBYOBReader,\n  readableStreamGetNumReadIntoRequests,\n  readableStreamFulfillReadRequest,\n  readableStreamFulfillReadIntoRequest,\n  readableStreamAddReadRequest,\n  readableStreamAddReadIntoRequest,\n  readableStreamReaderGenericCancel,\n  readableStreamReaderGenericInitialize,\n  readableStreamReaderGenericRelease,\n  readableStreamBYOBReaderRead,\n  readableStreamDefaultReaderRead,\n  setupReadableStreamBYOBReader,\n  setupReadableStreamDefaultReader,\n  readableStreamDefaultControllerClose,\n  readableStreamDefaultControllerEnqueue,\n  readableStreamDefaultControllerHasBackpressure,\n  readableStreamDefaultControllerCanCloseOrEnqueue,\n  readableStreamDefaultControllerGetDesiredSize,\n  readableStreamDefaultControllerShouldCallPull,\n  readableStreamDefaultControllerCallPullIfNeeded,\n  readableStreamDefaultControllerClearAlgorithms,\n  readableStreamDefaultControllerError,\n  readableStreamDefaultControllerCancelSteps,\n  readableStreamDefaultControllerPullSteps,\n  setupReadableStreamDefaultController,\n  setupReadableStreamDefaultControllerFromSource,\n  readableByteStreamControllerClose,\n  readableByteStreamControllerCommitPullIntoDescriptor,\n  readableByteStreamControllerInvalidateBYOBRequest,\n  readableByteStreamControllerClearAlgorithms,\n  readableByteStreamControllerClearPendingPullIntos,\n  readableByteStreamControllerGetDesiredSize,\n  readableByteStreamControllerShouldCallPull,\n  readableByteStreamControllerHandleQueueDrain,\n  readableByteStreamControllerPullInto,\n  readableByteStreamControllerRespondInternal,\n  readableByteStreamControllerRespond,\n  readableByteStreamControllerRespondInClosedState,\n  readableByteStreamControllerFillHeadPullIntoDescriptor,\n  readableByteStreamControllerEnqueue,\n  readableByteStreamControllerEnqueueChunkToQueue,\n  readableByteStreamControllerFillPullIntoDescriptorFromQueue,\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue,\n  readableByteStreamControllerRespondInReadableState,\n  readableByteStreamControllerRespondWithNewView,\n  readableByteStreamControllerShiftPendingPullInto,\n  readableByteStreamControllerCallPullIfNeeded,\n  readableByteStreamControllerError,\n  readableByteStreamControllerCancelSteps,\n  readableByteStreamControllerPullSteps,\n  setupReadableByteStreamController,\n  setupReadableByteStreamControllerFromSource\n};\n}"],["internal/webstreams/transfer.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperties,\n  PromiseResolve,\n  ReflectConstruct\n} = primordials;\nconst {\n  kState,\n  setPromiseHandled\n} = require(\"internal/webstreams/util\");\nconst {\n  DOMException\n} = internalBinding(\"messaging\");\nconst {\n  ReadableStream,\n  readableStreamDefaultControllerEnqueue,\n  readableStreamDefaultControllerClose,\n  readableStreamDefaultControllerError,\n  readableStreamPipeTo\n} = require(\"internal/webstreams/readablestream\");\nconst {\n  WritableStream,\n  writableStreamDefaultControllerErrorIfNeeded\n} = require(\"internal/webstreams/writablestream\");\nconst {\n  createDeferredPromise\n} = require(\"internal/util\");\nconst assert = require(\"internal/assert\");\nconst {\n  makeTransferable,\n  kClone,\n  kDeserialize\n} = require(\"internal/worker/js_transferable\");\nclass CloneableDOMException extends DOMException {\n  constructor(message, name) {\n    super(message, name);\n    this[kDeserialize]({\n      message: this.message,\n      name: this.name,\n      code: this.code\n    });\n    return makeTransferable(this);\n  }\n  [kClone]() {\n    return {\n      data: {\n        message: this.message,\n        name: this.name,\n        code: this.code\n      },\n      deserializeInfo: \"internal/webstreams/transfer:InternalCloneableDOMException\"\n    };\n  }\n  [kDeserialize]({ message, name, code }) {\n    ObjectDefineProperties(this, {\n      message: {\n        configurable: true,\n        enumerable: true,\n        get() {\n          return message;\n        }\n      },\n      name: {\n        configurable: true,\n        enumerable: true,\n        get() {\n          return name;\n        }\n      },\n      code: {\n        configurable: true,\n        enumerable: true,\n        get() {\n          return code;\n        }\n      }\n    });\n  }\n}\nfunction InternalCloneableDOMException() {\n  return makeTransferable(ReflectConstruct(CloneableDOMException, [], DOMException));\n}\nInternalCloneableDOMException[kDeserialize] = () => {\n};\nclass CrossRealmTransformReadableSource {\n  constructor(port) {\n    this[kState] = {\n      port,\n      controller: void 0\n    };\n    port.onmessage = ({ data }) => {\n      const {\n        controller\n      } = this[kState];\n      const {\n        type,\n        value\n      } = data;\n      switch (type) {\n        case \"chunk\":\n          readableStreamDefaultControllerEnqueue(controller, value);\n          break;\n        case \"close\":\n          readableStreamDefaultControllerClose(controller);\n          port.close();\n          break;\n        case \"error\":\n          readableStreamDefaultControllerError(controller, value);\n          port.close();\n          break;\n      }\n    };\n    port.onmessageerror = () => {\n      const error = new CloneableDOMException(\"Internal transferred ReadableStream error\", \"DataCloneError\");\n      port.postMessage({ type: \"error\", value: error });\n      readableStreamDefaultControllerError(this[kState].controller, error);\n      port.close();\n    };\n  }\n  start(controller) {\n    this[kState].controller = controller;\n  }\n  async pull() {\n    this[kState].port.postMessage({ type: \"pull\" });\n  }\n  async cancel(reason) {\n    try {\n      this[kState].port.postMessage({ type: \"error\", value: reason });\n    } catch (error) {\n      if (error instanceof DOMException) {\n        error = new CloneableDOMException(error.message, error.name);\n      }\n      this[kState].port.postMessage({ type: \"error\", value: error });\n      throw error;\n    } finally {\n      this[kState].port.close();\n    }\n  }\n}\nclass CrossRealmTransformWritableSink {\n  constructor(port) {\n    this[kState] = {\n      port,\n      controller: void 0,\n      backpressurePromise: createDeferredPromise()\n    };\n    port.onmessage = ({ data }) => {\n      assert(typeof data === \"object\");\n      const {\n        type,\n        value\n      } = { ...data };\n      assert(typeof type === \"string\");\n      switch (type) {\n        case \"pull\":\n          if (this[kState].backpressurePromise !== void 0)\n            this[kState].backpressurePromise.resolve?.();\n          this[kState].backpressurePromise = void 0;\n          break;\n        case \"error\":\n          writableStreamDefaultControllerErrorIfNeeded(this[kState].controller, value);\n          if (this[kState].backpressurePromise !== void 0)\n            this[kState].backpressurePromise.resolve?.();\n          this[kState].backpressurePromise = void 0;\n          break;\n      }\n    };\n    port.onmessageerror = () => {\n      const error = new CloneableDOMException(\"Internal transferred ReadableStream error\", \"DataCloneError\");\n      port.postMessage({ type: \"error\", value: error });\n      writableStreamDefaultControllerErrorIfNeeded(this[kState].controller, error);\n      port.close();\n    };\n  }\n  start(controller) {\n    this[kState].controller = controller;\n  }\n  async write(chunk) {\n    if (this[kState].backpressurePromise === void 0) {\n      this[kState].backpressurePromise = {\n        promise: PromiseResolve(),\n        resolve: void 0,\n        reject: void 0\n      };\n    }\n    await this[kState].backpressurePromise.promise;\n    this[kState].backpressurePromise = createDeferredPromise();\n    try {\n      this[kState].port.postMessage({ type: \"chunk\", value: chunk });\n    } catch (error) {\n      if (error instanceof DOMException) {\n        error = new CloneableDOMException(error.message, error.name);\n      }\n      this[kState].port.postMessage({ type: \"error\", value: error });\n      this[kState].port.close();\n      throw error;\n    }\n  }\n  close() {\n    this[kState].port.postMessage({ type: \"close\" });\n    this[kState].port.close();\n  }\n  abort(reason) {\n    try {\n      this[kState].port.postMessage({ type: \"error\", value: reason });\n    } catch (error) {\n      if (error instanceof DOMException) {\n        error = new CloneableDOMException(error.message, error.name);\n      }\n      this[kState].port.postMessage({ type: \"error\", value: error });\n      throw error;\n    } finally {\n      this[kState].port.close();\n    }\n  }\n}\nfunction newCrossRealmReadableStream(writable, port) {\n  const readable = new ReadableStream(new CrossRealmTransformReadableSource(port));\n  const promise = readableStreamPipeTo(readable, writable, false, false, false);\n  setPromiseHandled(promise);\n  return {\n    readable,\n    promise\n  };\n}\nfunction newCrossRealmWritableSink(readable, port) {\n  const writable = new WritableStream(new CrossRealmTransformWritableSink(port));\n  const promise = readableStreamPipeTo(readable, writable, false, false, false);\n  setPromiseHandled(promise);\n  return {\n    writable,\n    promise\n  };\n}\nmodule.exports = {\n  newCrossRealmReadableStream,\n  newCrossRealmWritableSink,\n  CrossRealmTransformWritableSink,\n  CrossRealmTransformReadableSource,\n  CloneableDOMException,\n  InternalCloneableDOMException\n};\n}"],["internal/webstreams/transformstream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectDefineProperties,\n  PromisePrototypeCatch,\n  PromisePrototypeThen,\n  PromiseResolve,\n  ReflectConstruct,\n  SymbolToStringTag\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_STATE,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst {\n  DOMException\n} = internalBinding(\"messaging\");\nconst {\n  createDeferredPromise,\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  kDeserialize,\n  kTransfer,\n  kTransferList,\n  makeTransferable\n} = require(\"internal/worker/js_transferable\");\nconst {\n  customInspect,\n  ensureIsPromise,\n  extractHighWaterMark,\n  extractSizeAlgorithm,\n  isBrandCheck,\n  nonOpFlush,\n  kType,\n  kState,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  ReadableStream,\n  readableStreamDefaultControllerCanCloseOrEnqueue,\n  readableStreamDefaultControllerClose,\n  readableStreamDefaultControllerEnqueue,\n  readableStreamDefaultControllerError,\n  readableStreamDefaultControllerGetDesiredSize,\n  readableStreamDefaultControllerHasBackpressure\n} = require(\"internal/webstreams/readablestream\");\nconst {\n  WritableStream,\n  writableStreamDefaultControllerErrorIfNeeded\n} = require(\"internal/webstreams/writablestream\");\nconst assert = require(\"internal/assert\");\nclass TransformStream {\n  [kType] = \"TransformStream\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(transformer = null, writableStrategy = {}, readableStrategy = {}) {\n    const readableType = transformer?.readableType;\n    const writableType = transformer?.writableType;\n    const start = transformer?.start;\n    if (readableType !== void 0) {\n      throw new ERR_INVALID_ARG_VALUE.RangeError(\"transformer.readableType\", readableType);\n    }\n    if (writableType !== void 0) {\n      throw new ERR_INVALID_ARG_VALUE.RangeError(\"transformer.writableType\", writableType);\n    }\n    const readableHighWaterMark = readableStrategy?.highWaterMark;\n    const readableSize = readableStrategy?.size;\n    const writableHighWaterMark = writableStrategy?.highWaterMark;\n    const writableSize = writableStrategy?.size;\n    const actualReadableHighWaterMark = extractHighWaterMark(readableHighWaterMark, 0);\n    const actualReadableSize = extractSizeAlgorithm(readableSize);\n    const actualWritableHighWaterMark = extractHighWaterMark(writableHighWaterMark, 1);\n    const actualWritableSize = extractSizeAlgorithm(writableSize);\n    const startPromise = createDeferredPromise();\n    initializeTransformStream(this, startPromise, actualWritableHighWaterMark, actualWritableSize, actualReadableHighWaterMark, actualReadableSize);\n    setupTransformStreamDefaultControllerFromTransformer(this, transformer);\n    if (start !== void 0) {\n      startPromise.resolve(FunctionPrototypeCall(start, transformer, this[kState].controller));\n    } else {\n      startPromise.resolve();\n    }\n    return makeTransferable(this);\n  }\n  get readable() {\n    if (!isTransformStream(this))\n      throw new ERR_INVALID_THIS(\"TransformStream\");\n    return this[kState].readable;\n  }\n  get writable() {\n    if (!isTransformStream(this))\n      throw new ERR_INVALID_THIS(\"TransformStream\");\n    return this[kState].writable;\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      readable: this.readable,\n      writable: this.writable,\n      backpressure: this[kState].backpressure\n    });\n  }\n  [kTransfer]() {\n    if (!isTransformStream(this))\n      throw new ERR_INVALID_THIS(\"TransformStream\");\n    const {\n      readable,\n      writable\n    } = this[kState];\n    if (readable.locked) {\n      throw new DOMException(\"Cannot transfer a locked ReadableStream\", \"DataCloneError\");\n    }\n    if (writable.locked) {\n      throw new DOMException(\"Cannot transfer a locked WritableStream\", \"DataCloneError\");\n    }\n    return {\n      data: {\n        readable,\n        writable\n      },\n      deserializeInfo: \"internal/webstreams/transformstream:TransferredTransformStream\"\n    };\n  }\n  [kTransferList]() {\n    return [this[kState].readable, this[kState].writable];\n  }\n  [kDeserialize]({ readable, writable }) {\n    this[kState].readable = readable;\n    this[kState].writable = writable;\n  }\n}\nObjectDefineProperties(TransformStream.prototype, {\n  readable: kEnumerableProperty,\n  writable: kEnumerableProperty\n});\nfunction TransferredTransformStream() {\n  return makeTransferable(ReflectConstruct(function() {\n    this[kType] = \"TransformStream\";\n    this[kState] = {\n      readable: void 0,\n      writable: void 0,\n      backpressure: void 0,\n      backpressureChange: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      controller: void 0\n    };\n  }, [], TransformStream));\n}\nTransferredTransformStream.prototype[kDeserialize] = () => {\n};\nclass TransformStreamDefaultController {\n  [kType] = \"TransformStreamDefaultController\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  get desiredSize() {\n    if (!isTransformStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"TransformStreamDefaultController\");\n    const {\n      stream\n    } = this[kState];\n    const {\n      readable\n    } = stream[kState];\n    const {\n      controller: readableController\n    } = readable[kState];\n    return readableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n  enqueue(chunk = void 0) {\n    if (!isTransformStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"TransformStreamDefaultController\");\n    transformStreamDefaultControllerEnqueue(this, chunk);\n  }\n  error(reason = void 0) {\n    if (!isTransformStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"TransformStreamDefaultController\");\n    transformStreamDefaultControllerError(this, reason);\n  }\n  terminate() {\n    if (!isTransformStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"TransformStreamDefaultController\");\n    transformStreamDefaultControllerTerminate(this);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      stream: this[kState].stream\n    });\n  }\n}\nObjectDefineProperties(TransformStreamDefaultController.prototype, {\n  desiredSize: kEnumerableProperty,\n  enqueue: kEnumerableProperty,\n  error: kEnumerableProperty,\n  terminate: kEnumerableProperty\n});\nfunction createTransformStreamDefaultController() {\n  return ReflectConstruct(function() {\n    this[kType] = \"TransformStreamDefaultController\";\n  }, [], TransformStreamDefaultController);\n}\nconst isTransformStream = isBrandCheck(\"TransformStream\");\nconst isTransformStreamDefaultController = isBrandCheck(\"TransformStreamDefaultController\");\nasync function defaultTransformAlgorithm(chunk, controller) {\n  transformStreamDefaultControllerEnqueue(controller, chunk);\n}\nfunction initializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  const writable = new WritableStream({\n    start() {\n      return startPromise.promise;\n    },\n    write(chunk) {\n      return transformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    },\n    abort(reason) {\n      return transformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    },\n    close() {\n      return transformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n  }, {\n    highWaterMark: writableHighWaterMark,\n    size: writableSizeAlgorithm\n  });\n  const readable = new ReadableStream({\n    start() {\n      return startPromise.promise;\n    },\n    pull() {\n      return transformStreamDefaultSourcePullAlgorithm(stream);\n    },\n    cancel(reason) {\n      transformStreamErrorWritableAndUnblockWrite(stream, reason);\n      return PromiseResolve();\n    }\n  }, {\n    highWaterMark: readableHighWaterMark,\n    size: readableSizeAlgorithm\n  });\n  stream[kState] = {\n    readable,\n    writable,\n    controller: void 0,\n    backpressure: void 0,\n    backpressureChange: {\n      promise: void 0,\n      resolve: void 0,\n      reject: void 0\n    }\n  };\n  transformStreamSetBackpressure(stream, true);\n}\nfunction transformStreamError(stream, error) {\n  const {\n    readable\n  } = stream[kState];\n  const {\n    controller\n  } = readable[kState];\n  readableStreamDefaultControllerError(controller, error);\n  transformStreamErrorWritableAndUnblockWrite(stream, error);\n}\nfunction transformStreamErrorWritableAndUnblockWrite(stream, error) {\n  const {\n    controller,\n    writable\n  } = stream[kState];\n  transformStreamDefaultControllerClearAlgorithms(controller);\n  writableStreamDefaultControllerErrorIfNeeded(writable[kState].controller, error);\n  if (stream[kState].backpressure)\n    transformStreamSetBackpressure(stream, false);\n}\nfunction transformStreamSetBackpressure(stream, backpressure) {\n  assert(stream[kState].backpressure !== backpressure);\n  if (stream[kState].backpressureChange.promise !== void 0)\n    stream[kState].backpressureChange.resolve?.();\n  stream[kState].backpressureChange = createDeferredPromise();\n  stream[kState].backpressure = backpressure;\n}\nfunction setupTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(isTransformStream(stream));\n  assert(stream[kState].controller === void 0);\n  controller[kState] = {\n    stream,\n    transformAlgorithm,\n    flushAlgorithm\n  };\n  stream[kState].controller = controller;\n}\nfunction setupTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  const controller = createTransformStreamDefaultController();\n  const transform = transformer?.transform || defaultTransformAlgorithm;\n  const flush = transformer?.flush || nonOpFlush;\n  const transformAlgorithm = FunctionPrototypeBind(transform, transformer);\n  const flushAlgorithm = FunctionPrototypeBind(flush, transformer);\n  setupTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction transformStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].transformAlgorithm = void 0;\n  controller[kState].flushAlgorithm = void 0;\n}\nfunction transformStreamDefaultControllerEnqueue(controller, chunk) {\n  const {\n    stream\n  } = controller[kState];\n  const {\n    readable\n  } = stream[kState];\n  const {\n    controller: readableController\n  } = readable[kState];\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(readableController))\n    throw new ERR_INVALID_STATE.TypeError(\"Unable to enqueue\");\n  try {\n    readableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (error) {\n    transformStreamErrorWritableAndUnblockWrite(stream, error);\n    throw readable[kState].storedError;\n  }\n  const backpressure = readableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream[kState].backpressure) {\n    assert(backpressure);\n    transformStreamSetBackpressure(stream, true);\n  }\n}\nfunction transformStreamDefaultControllerError(controller, error) {\n  transformStreamError(controller[kState].stream, error);\n}\nfunction transformStreamDefaultControllerPerformTransform(controller, chunk) {\n  const transformPromise = ensureIsPromise(controller[kState].transformAlgorithm, controller, chunk, controller);\n  return PromisePrototypeCatch(transformPromise, (error) => {\n    transformStreamError(controller[kState].stream, error);\n    throw error;\n  });\n}\nfunction transformStreamDefaultControllerTerminate(controller) {\n  const {\n    stream\n  } = controller[kState];\n  const {\n    readable\n  } = stream[kState];\n  assert(readable !== void 0);\n  const {\n    controller: readableController\n  } = readable[kState];\n  readableStreamDefaultControllerClose(readableController);\n  transformStreamErrorWritableAndUnblockWrite(stream, new ERR_INVALID_STATE.TypeError(\"TransformStream has been terminated\"));\n}\nfunction transformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  const {\n    writable,\n    controller\n  } = stream[kState];\n  assert(writable[kState].state === \"writable\");\n  if (stream[kState].backpressure) {\n    const backpressureChange = stream[kState].backpressureChange.promise;\n    return PromisePrototypeThen(backpressureChange, () => {\n      const {\n        writable: writable2\n      } = stream[kState];\n      if (writable2[kState].state === \"erroring\")\n        throw writable2[kState].storedError;\n      assert(writable2[kState].state === \"writable\");\n      return transformStreamDefaultControllerPerformTransform(controller, chunk);\n    });\n  }\n  return transformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nasync function transformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  transformStreamError(stream, reason);\n}\nfunction transformStreamDefaultSinkCloseAlgorithm(stream) {\n  const {\n    readable,\n    controller\n  } = stream[kState];\n  const flushPromise = ensureIsPromise(controller[kState].flushAlgorithm, controller, controller);\n  transformStreamDefaultControllerClearAlgorithms(controller);\n  return PromisePrototypeThen(flushPromise, () => {\n    if (readable[kState].state === \"errored\")\n      throw readable[kState].storedError;\n    readableStreamDefaultControllerClose(readable[kState].controller);\n  }, (error) => {\n    transformStreamError(stream, error);\n    throw readable[kState].storedError;\n  });\n}\nfunction transformStreamDefaultSourcePullAlgorithm(stream) {\n  assert(stream[kState].backpressure);\n  assert(stream[kState].backpressureChange.promise !== void 0);\n  transformStreamSetBackpressure(stream, false);\n  return stream[kState].backpressureChange.promise;\n}\nmodule.exports = {\n  TransformStream,\n  TransformStreamDefaultController,\n  TransferredTransformStream,\n  isTransformStream,\n  isTransformStreamDefaultController\n};\n}"],["internal/webstreams/util.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBufferPrototype,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  AsyncIteratorPrototype,\n  FunctionPrototypeCall,\n  MathMax,\n  NumberIsNaN,\n  ObjectCreate,\n  PromisePrototypeThen,\n  PromiseResolve,\n  PromiseReject,\n  ReflectGet,\n  Symbol\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_OPERATION_FAILED\n  }\n} = require(\"internal/errors\");\nconst {\n  copyArrayBuffer,\n  detachArrayBuffer\n} = internalBinding(\"buffer\");\nconst {\n  isPromise\n} = require(\"internal/util/types\");\nconst {\n  inspect\n} = require(\"util\");\nconst {\n  getPromiseDetails,\n  kPending\n} = internalBinding(\"util\");\nconst assert = require(\"internal/assert\");\nconst kState = Symbol(\"kState\");\nconst kType = Symbol(\"kType\");\nconst AsyncIterator = ObjectCreate(AsyncIteratorPrototype, {\n  next: {\n    configurable: true,\n    enumerable: true,\n    writable: true\n  },\n  return: {\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }\n});\nfunction extractHighWaterMark(value, defaultHWM) {\n  if (value === void 0)\n    return defaultHWM;\n  value = +value;\n  if (typeof value !== \"number\" || NumberIsNaN(value) || value < 0)\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"strategy.highWaterMark\", value);\n  return value;\n}\nfunction extractSizeAlgorithm(size) {\n  if (size === void 0)\n    return () => 1;\n  if (typeof size !== \"function\")\n    throw new ERR_INVALID_ARG_TYPE(\"strategy.size\", \"Function\", size);\n  return size;\n}\nfunction customInspect(depth, options, name, data) {\n  if (depth < 0)\n    return this;\n  const opts = {\n    ...options,\n    depth: options.depth == null ? null : options.depth - 1\n  };\n  return `${name} ${inspect(data, opts)}`;\n}\nfunction ArrayBufferViewGetBuffer(view) {\n  return ReflectGet(view.constructor.prototype, \"buffer\", view);\n}\nfunction ArrayBufferViewGetByteLength(view) {\n  return ReflectGet(view.constructor.prototype, \"byteLength\", view);\n}\nfunction ArrayBufferViewGetByteOffset(view) {\n  return ReflectGet(view.constructor.prototype, \"byteOffset\", view);\n}\nfunction ArrayBufferGetByteLength(view) {\n  return ReflectGet(ArrayBufferPrototype, \"byteLength\", view);\n}\nfunction isBrandCheck(brand) {\n  return (value) => {\n    return value != null && value[kState] !== void 0 && value[kType] === brand;\n  };\n}\nfunction transferArrayBuffer(buffer) {\n  const res = detachArrayBuffer(buffer);\n  if (res === void 0) {\n    throw new ERR_OPERATION_FAILED.TypeError(\"The ArrayBuffer could not be transferred\");\n  }\n  return res;\n}\nfunction dequeueValue(controller) {\n  assert(controller[kState].queue !== void 0);\n  assert(controller[kState].queueTotalSize !== void 0);\n  assert(controller[kState].queue.length);\n  const {\n    value,\n    size\n  } = ArrayPrototypeShift(controller[kState].queue);\n  controller[kState].queueTotalSize = MathMax(0, controller[kState].queueTotalSize - size);\n  return value;\n}\nfunction resetQueue(controller) {\n  assert(controller[kState].queue !== void 0);\n  assert(controller[kState].queueTotalSize !== void 0);\n  controller[kState].queue = [];\n  controller[kState].queueTotalSize = 0;\n}\nfunction peekQueueValue(controller) {\n  assert(controller[kState].queue !== void 0);\n  assert(controller[kState].queueTotalSize !== void 0);\n  assert(controller[kState].queue.length);\n  return controller[kState].queue[0].value;\n}\nfunction enqueueValueWithSize(controller, value, size) {\n  assert(controller[kState].queue !== void 0);\n  assert(controller[kState].queueTotalSize !== void 0);\n  size = +size;\n  if (typeof size !== \"number\" || size < 0 || NumberIsNaN(size) || size === Infinity) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"size\", size);\n  }\n  ArrayPrototypePush(controller[kState].queue, { value, size });\n  controller[kState].queueTotalSize += size;\n}\nfunction ensureIsPromise(fn, thisArg, ...args) {\n  try {\n    const value = FunctionPrototypeCall(fn, thisArg, ...args);\n    return isPromise(value) ? value : PromiseResolve(value);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n}\nfunction isPromisePending(promise) {\n  if (promise === void 0)\n    return false;\n  const details = getPromiseDetails(promise);\n  return details?.[0] === kPending;\n}\nfunction setPromiseHandled(promise) {\n  PromisePrototypeThen(promise, () => {\n  }, () => {\n  });\n}\nasync function nonOpFlush() {\n}\nfunction nonOpStart() {\n}\nasync function nonOpPull() {\n}\nasync function nonOpCancel() {\n}\nasync function nonOpWrite() {\n}\nlet transfer;\nfunction lazyTransfer() {\n  if (transfer === void 0)\n    transfer = require(\"internal/webstreams/transfer\");\n  return transfer;\n}\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nmodule.exports = {\n  ArrayBufferViewGetBuffer,\n  ArrayBufferViewGetByteLength,\n  ArrayBufferViewGetByteOffset,\n  ArrayBufferGetByteLength,\n  AsyncIterator,\n  copyArrayBuffer,\n  customInspect,\n  dequeueValue,\n  ensureIsPromise,\n  enqueueValueWithSize,\n  extractHighWaterMark,\n  extractSizeAlgorithm,\n  lazyTransfer,\n  isBrandCheck,\n  isPromisePending,\n  peekQueueValue,\n  resetQueue,\n  setPromiseHandled,\n  transferArrayBuffer,\n  nonOpCancel,\n  nonOpFlush,\n  nonOpPull,\n  nonOpStart,\n  nonOpWrite,\n  kType,\n  kState,\n  kEnumerableProperty\n};\n}"],["internal/webstreams/writablestream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectDefineProperties,\n  PromisePrototypeThen,\n  PromiseResolve,\n  PromiseReject,\n  ReflectConstruct,\n  Symbol,\n  SymbolToStringTag\n} = primordials;\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_STATE,\n    ERR_INVALID_THIS\n  }\n} = require(\"internal/errors\");\nconst {\n  DOMException\n} = internalBinding(\"messaging\");\nconst {\n  createDeferredPromise,\n  customInspectSymbol: kInspect\n} = require(\"internal/util\");\nconst {\n  MessageChannel\n} = require(\"internal/worker/io\");\nconst {\n  kDeserialize,\n  kTransfer,\n  kTransferList,\n  makeTransferable\n} = require(\"internal/worker/js_transferable\");\nconst {\n  customInspect,\n  dequeueValue,\n  ensureIsPromise,\n  enqueueValueWithSize,\n  extractHighWaterMark,\n  extractSizeAlgorithm,\n  lazyTransfer,\n  isBrandCheck,\n  isPromisePending,\n  peekQueueValue,\n  resetQueue,\n  setPromiseHandled,\n  nonOpCancel,\n  nonOpStart,\n  nonOpWrite,\n  kType,\n  kState,\n  kEnumerableProperty\n} = require(\"internal/webstreams/util\");\nconst {\n  AbortController\n} = require(\"internal/abort_controller\");\nconst assert = require(\"internal/assert\");\nconst kAbort = Symbol(\"kAbort\");\nconst kCloseSentinel = Symbol(\"kCloseSentinel\");\nconst kError = Symbol(\"kError\");\nclass WritableStream {\n  [kType] = \"WritableStream\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(sink = null, strategy = {}) {\n    const type = sink?.type;\n    if (type !== void 0)\n      throw new ERR_INVALID_ARG_VALUE.RangeError(\"type\", type);\n    this[kState] = {\n      close: createDeferredPromise(),\n      closeRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      inFlightWriteRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      inFlightCloseRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      pendingAbortRequest: {\n        abort: {\n          promise: void 0,\n          resolve: void 0,\n          reject: void 0\n        },\n        reason: void 0,\n        wasAlreadyErroring: false\n      },\n      backpressure: false,\n      controller: void 0,\n      state: \"writable\",\n      storedError: void 0,\n      writeRequests: [],\n      writer: void 0,\n      transfer: {\n        readable: void 0,\n        port1: void 0,\n        port2: void 0,\n        promise: void 0\n      }\n    };\n    const size = extractSizeAlgorithm(strategy?.size);\n    const highWaterMark = extractHighWaterMark(strategy?.highWaterMark, 1);\n    setupWritableStreamDefaultControllerFromSink(this, sink, highWaterMark, size);\n    return makeTransferable(this);\n  }\n  get locked() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS(\"WritableStream\");\n    return isWritableStreamLocked(this);\n  }\n  abort(reason = void 0) {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStream\"));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"WritableStream is locked\"));\n    }\n    return writableStreamAbort(this, reason);\n  }\n  close() {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStream\"));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"WritableStream is locked\"));\n    }\n    if (writableStreamCloseQueuedOrInFlight(this)) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Failure closing WritableStream\"));\n    }\n    return writableStreamClose(this);\n  }\n  getWriter() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS(\"WritableStream\");\n    return new WritableStreamDefaultWriter(this);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      locked: this.locked,\n      state: this[kState].state\n    });\n  }\n  [kTransfer]() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS(\"WritableStream\");\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = void 0;\n      this[kState].transfer.port2 = void 0;\n      throw new DOMException(\"Cannot transfer a locked WritableStream\", \"DataCloneError\");\n    }\n    const {\n      readable,\n      promise\n    } = lazyTransfer().newCrossRealmReadableStream(this, this[kState].transfer.port1);\n    this[kState].transfer.readable = readable;\n    this[kState].transfer.promise = promise;\n    setPromiseHandled(this[kState].transfer.promise);\n    return {\n      data: { port: this[kState].transfer.port2 },\n      deserializeInfo: \"internal/webstreams/writablestream:TransferredWritableStream\"\n    };\n  }\n  [kTransferList]() {\n    const { port1, port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [port2];\n  }\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupWritableStreamDefaultControllerFromSink(this, new transfer.CrossRealmTransformWritableSink(port), 1, () => 1);\n  }\n}\nObjectDefineProperties(WritableStream.prototype, {\n  locked: kEnumerableProperty,\n  abort: kEnumerableProperty,\n  close: kEnumerableProperty,\n  getWriter: kEnumerableProperty\n});\nfunction TransferredWritableStream() {\n  return makeTransferable(ReflectConstruct(function() {\n    this[kType] = \"WritableStream\";\n    this[kState] = {\n      close: createDeferredPromise(),\n      closeRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      inFlightWriteRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      inFlightCloseRequest: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      pendingAbortRequest: {\n        abort: {\n          promise: void 0,\n          resolve: void 0,\n          reject: void 0\n        },\n        reason: void 0,\n        wasAlreadyErroring: false\n      },\n      backpressure: false,\n      controller: void 0,\n      state: \"writable\",\n      storedError: void 0,\n      writeRequests: [],\n      writer: void 0,\n      transfer: {\n        promise: void 0,\n        port1: void 0,\n        port2: void 0,\n        readable: void 0\n      }\n    };\n  }, [], WritableStream));\n}\nTransferredWritableStream.prototype[kDeserialize] = () => {\n};\nclass WritableStreamDefaultWriter {\n  [kType] = \"WritableStreamDefaultWriter\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor(stream) {\n    if (!isWritableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE(\"stream\", \"WritableStream\", stream);\n    this[kState] = {\n      stream: void 0,\n      close: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      ready: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      }\n    };\n    setupWritableStreamDefaultWriter(this, stream);\n  }\n  get closed() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\"));\n    return this[kState].close.promise;\n  }\n  get desiredSize() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\");\n    if (this[kState].stream === void 0) {\n      throw new ERR_INVALID_STATE.TypeError(\"Writer is not bound to a WritableStream\");\n    }\n    return writableStreamDefaultWriterGetDesiredSize(this);\n  }\n  get ready() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\"));\n    return this[kState].ready.promise;\n  }\n  abort(reason = void 0) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\"));\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Writer is not bound to a WritableStream\"));\n    }\n    return writableStreamDefaultWriterAbort(this, reason);\n  }\n  close() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\"));\n    const {\n      stream\n    } = this[kState];\n    if (stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Writer is not bound to a WritableStream\"));\n    }\n    if (writableStreamCloseQueuedOrInFlight(stream)) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Failure to close WritableStream\"));\n    }\n    return writableStreamDefaultWriterClose(this);\n  }\n  releaseLock() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\");\n    const {\n      stream\n    } = this[kState];\n    if (stream === void 0)\n      return;\n    assert(stream[kState].writer !== void 0);\n    writableStreamDefaultWriterRelease(this);\n  }\n  write(chunk = void 0) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS(\"WritableStreamDefaultWriter\"));\n    if (this[kState].stream === void 0) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Writer is not bound to a WritableStream\"));\n    }\n    return writableStreamDefaultWriterWrite(this, chunk);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      stream: this[kState].stream,\n      close: this[kState].close.promise,\n      ready: this[kState].ready.promise,\n      desiredSize: this.desiredSize\n    });\n  }\n}\nObjectDefineProperties(WritableStreamDefaultWriter.prototype, {\n  closed: kEnumerableProperty,\n  ready: kEnumerableProperty,\n  desiredSize: kEnumerableProperty,\n  abort: kEnumerableProperty,\n  close: kEnumerableProperty,\n  releaseLock: kEnumerableProperty,\n  write: kEnumerableProperty\n});\nclass WritableStreamDefaultController {\n  [kType] = \"WritableStreamDefaultController\";\n  get [SymbolToStringTag]() {\n    return this[kType];\n  }\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n  [kAbort](reason) {\n    const result = this[kState].abortAlgorithm(reason);\n    writableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n  [kError]() {\n    resetQueue(this);\n  }\n  get abortReason() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"WritableStreamDefaultController\");\n    return this[kState].abortReason;\n  }\n  get signal() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"WritableStreamDefaultController\");\n    return this[kState].abortController.signal;\n  }\n  error(error = void 0) {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS(\"WritableStreamDefaultController\");\n    if (this[kState].stream[kState].state !== \"writable\")\n      return;\n    writableStreamDefaultControllerError(this, error);\n  }\n  [kInspect](depth, options) {\n    return customInspect(depth, options, this[kType], {\n      stream: this[kState].stream\n    });\n  }\n}\nObjectDefineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  error: kEnumerableProperty\n});\nfunction createWritableStreamDefaultController() {\n  return ReflectConstruct(function() {\n    this[kType] = \"WritableStreamDefaultController\";\n  }, [], WritableStreamDefaultController);\n}\nconst isWritableStream = isBrandCheck(\"WritableStream\");\nconst isWritableStreamDefaultWriter = isBrandCheck(\"WritableStreamDefaultWriter\");\nconst isWritableStreamDefaultController = isBrandCheck(\"WritableStreamDefaultController\");\nfunction isWritableStreamLocked(stream) {\n  return stream[kState].writer !== void 0;\n}\nfunction setupWritableStreamDefaultWriter(writer, stream) {\n  if (isWritableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError(\"WritableStream is locked\");\n  writer[kState].stream = stream;\n  stream[kState].writer = writer;\n  switch (stream[kState].state) {\n    case \"writable\":\n      if (!writableStreamCloseQueuedOrInFlight(stream) && stream[kState].backpressure) {\n        writer[kState].ready = createDeferredPromise();\n      } else {\n        writer[kState].ready = {\n          promise: PromiseResolve(),\n          resolve: void 0,\n          reject: void 0\n        };\n      }\n      setClosedPromiseToNewPromise();\n      break;\n    case \"erroring\":\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError),\n        resolve: void 0,\n        reject: void 0\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setClosedPromiseToNewPromise();\n      break;\n    case \"closed\":\n      writer[kState].ready = {\n        promise: PromiseResolve(),\n        resolve: void 0,\n        reject: void 0\n      };\n      writer[kState].close = {\n        promise: PromiseResolve(),\n        resolve: void 0,\n        reject: void 0\n      };\n      break;\n    default:\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError),\n        resolve: void 0,\n        reject: void 0\n      };\n      writer[kState].close = {\n        promise: PromiseReject(stream[kState].storedError),\n        resolve: void 0,\n        reject: void 0\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setPromiseHandled(writer[kState].close.promise);\n  }\n  function setClosedPromiseToNewPromise() {\n    writer[kState].close = createDeferredPromise();\n  }\n}\nfunction writableStreamAbort(stream, reason) {\n  const {\n    state,\n    controller\n  } = stream[kState];\n  if (state === \"closed\" || state === \"errored\")\n    return PromiseResolve();\n  controller[kState].abortReason = reason;\n  controller[kState].abortController.abort();\n  if (stream[kState].pendingAbortRequest.abort.promise !== void 0)\n    return stream[kState].pendingAbortRequest.abort.promise;\n  assert(state === \"writable\" || state === \"erroring\");\n  let wasAlreadyErroring = false;\n  if (state === \"erroring\") {\n    wasAlreadyErroring = true;\n    reason = void 0;\n  }\n  const abort = createDeferredPromise();\n  stream[kState].pendingAbortRequest = {\n    abort,\n    reason,\n    wasAlreadyErroring\n  };\n  if (!wasAlreadyErroring)\n    writableStreamStartErroring(stream, reason);\n  return abort.promise;\n}\nfunction writableStreamClose(stream) {\n  const {\n    state,\n    writer,\n    backpressure,\n    controller\n  } = stream[kState];\n  if (state === \"closed\" || state === \"errored\") {\n    return PromiseReject(new ERR_INVALID_STATE.TypeError(\"WritableStream is closed\"));\n  }\n  assert(state === \"writable\" || state === \"erroring\");\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  stream[kState].closeRequest = createDeferredPromise();\n  const { promise } = stream[kState].closeRequest;\n  if (writer !== void 0 && backpressure && state === \"writable\")\n    writer[kState].ready.resolve?.();\n  writableStreamDefaultControllerClose(controller);\n  return promise;\n}\nfunction writableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream[kState].state === \"writable\");\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  const {\n    writer\n  } = stream[kState];\n  if (writer !== void 0 && stream[kState].backpressure !== backpressure) {\n    if (backpressure) {\n      writer[kState].ready = createDeferredPromise();\n    } else {\n      writer[kState].ready.resolve?.();\n    }\n  }\n  stream[kState].backpressure = backpressure;\n}\nfunction writableStreamStartErroring(stream, reason) {\n  assert(stream[kState].storedError === void 0);\n  assert(stream[kState].state === \"writable\");\n  const {\n    controller,\n    writer\n  } = stream[kState];\n  assert(controller !== void 0);\n  stream[kState].state = \"erroring\";\n  stream[kState].storedError = reason;\n  if (writer !== void 0) {\n    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n  if (!writableStreamHasOperationMarkedInFlight(stream) && controller[kState].started) {\n    writableStreamFinishErroring(stream);\n  }\n}\nfunction writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  assert(stream[kState].state === \"errored\");\n  if (stream[kState].closeRequest.promise !== void 0) {\n    assert(stream[kState].inFlightCloseRequest.promise === void 0);\n    stream[kState].closeRequest.reject?.(stream[kState].storedError);\n    stream[kState].closeRequest = {\n      promise: void 0,\n      reject: void 0,\n      resolve: void 0\n    };\n  }\n  const {\n    writer\n  } = stream[kState];\n  if (writer !== void 0) {\n    writer[kState].close.reject?.(stream[kState].storedError);\n    setPromiseHandled(writer[kState].close.promise);\n  }\n}\nfunction writableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === void 0);\n  assert(stream[kState].writeRequests.length);\n  const writeRequest = ArrayPrototypeShift(stream[kState].writeRequests);\n  stream[kState].inFlightWriteRequest = writeRequest;\n}\nfunction writableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === void 0);\n  assert(stream[kState].closeRequest.promise !== void 0);\n  stream[kState].inFlightCloseRequest = stream[kState].closeRequest;\n  stream[kState].closeRequest = {\n    promise: void 0,\n    resolve: void 0,\n    reject: void 0\n  };\n}\nfunction writableStreamHasOperationMarkedInFlight(stream) {\n  const {\n    inFlightWriteRequest,\n    inFlightCloseRequest\n  } = stream[kState];\n  if (inFlightWriteRequest.promise === void 0 && inFlightCloseRequest.promise === void 0) {\n    return false;\n  }\n  return true;\n}\nfunction writableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream[kState].inFlightWriteRequest.promise !== void 0);\n  stream[kState].inFlightWriteRequest.reject?.(error);\n  stream[kState].inFlightWriteRequest = {\n    promise: void 0,\n    resolve: void 0,\n    reject: void 0\n  };\n  assert(stream[kState].state === \"writable\" || stream[kState].state === \"erroring\");\n  writableStreamDealWithRejection(stream, error);\n}\nfunction writableStreamFinishInFlightWrite(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise !== void 0);\n  stream[kState].inFlightWriteRequest.resolve?.();\n  stream[kState].inFlightWriteRequest = {\n    promise: void 0,\n    resolve: void 0,\n    reject: void 0\n  };\n}\nfunction writableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream[kState].inFlightCloseRequest.promise !== void 0);\n  stream[kState].inFlightCloseRequest.reject?.(error);\n  stream[kState].inFlightCloseRequest = {\n    promise: void 0,\n    resolve: void 0,\n    reject: void 0\n  };\n  assert(stream[kState].state === \"writable\" || stream[kState].state === \"erroring\");\n  if (stream[kState].pendingAbortRequest.abort.promise !== void 0) {\n    stream[kState].pendingAbortRequest.abort.reject?.(error);\n    stream[kState].pendingAbortRequest = {\n      abort: {\n        promise: void 0,\n        resolve: void 0,\n        reject: void 0\n      },\n      reason: void 0,\n      wasAlreadyErroring: false\n    };\n  }\n  writableStreamDealWithRejection(stream, error);\n}\nfunction writableStreamFinishInFlightClose(stream) {\n  assert(stream[kState].inFlightCloseRequest.promise !== void 0);\n  stream[kState].inFlightCloseRequest.resolve?.();\n  stream[kState].inFlightCloseRequest = {\n    promise: void 0,\n    resolve: void 0,\n    reject: void 0\n  };\n  if (stream[kState].state === \"erroring\") {\n    stream[kState].storedError = void 0;\n    if (stream[kState].pendingAbortRequest.abort.promise !== void 0) {\n      stream[kState].pendingAbortRequest.abort.resolve?.();\n      stream[kState].pendingAbortRequest = {\n        abort: {\n          promise: void 0,\n          resolve: void 0,\n          reject: void 0\n        },\n        reason: void 0,\n        wasAlreadyErroring: false\n      };\n    }\n  }\n  stream[kState].state = \"closed\";\n  if (stream[kState].writer !== void 0)\n    stream[kState].writer[kState].close.resolve?.();\n  assert(stream[kState].pendingAbortRequest.abort.promise === void 0);\n  assert(stream[kState].storedError === void 0);\n}\nfunction writableStreamFinishErroring(stream) {\n  assert(stream[kState].state === \"erroring\");\n  assert(!writableStreamHasOperationMarkedInFlight(stream));\n  stream[kState].state = \"errored\";\n  stream[kState].controller[kError]();\n  const storedError = stream[kState].storedError;\n  for (let n = 0; n < stream[kState].writeRequests.length; n++)\n    stream[kState].writeRequests[n].reject?.(storedError);\n  stream[kState].writeRequests = [];\n  if (stream[kState].pendingAbortRequest.abort.promise === void 0) {\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  const abortRequest = stream[kState].pendingAbortRequest;\n  stream[kState].pendingAbortRequest = {\n    abort: {\n      promise: void 0,\n      resolve: void 0,\n      reject: void 0\n    },\n    reason: void 0,\n    wasAlreadyErroring: false\n  };\n  if (abortRequest.wasAlreadyErroring) {\n    abortRequest.abort.reject?.(storedError);\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  PromisePrototypeThen(ensureIsPromise(stream[kState].controller[kAbort], stream[kState].controller, abortRequest.reason), () => {\n    abortRequest.abort.resolve?.();\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  }, (error) => {\n    abortRequest.abort.reject?.(error);\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  });\n}\nfunction writableStreamDealWithRejection(stream, error) {\n  const {\n    state\n  } = stream[kState];\n  if (state === \"writable\") {\n    writableStreamStartErroring(stream, error);\n    return;\n  }\n  assert(state === \"erroring\");\n  writableStreamFinishErroring(stream);\n}\nfunction writableStreamCloseQueuedOrInFlight(stream) {\n  if (stream[kState].closeRequest.promise === void 0 && stream[kState].inFlightCloseRequest.promise === void 0) {\n    return false;\n  }\n  return true;\n}\nfunction writableStreamAddWriteRequest(stream) {\n  assert(isWritableStreamLocked(stream));\n  assert(stream[kState].state === \"writable\");\n  const {\n    promise,\n    resolve,\n    reject\n  } = createDeferredPromise();\n  ArrayPrototypePush(stream[kState].writeRequests, {\n    promise,\n    resolve,\n    reject\n  });\n  return promise;\n}\nfunction writableStreamDefaultWriterWrite(writer, chunk) {\n  const {\n    stream\n  } = writer[kState];\n  assert(stream !== void 0);\n  const {\n    controller\n  } = stream[kState];\n  const chunkSize = writableStreamDefaultControllerGetChunkSize(controller, chunk);\n  if (stream !== writer[kState].stream) {\n    return PromiseReject(new ERR_INVALID_STATE.TypeError(\"Mismatched WritableStreams\"));\n  }\n  const {\n    state\n  } = stream[kState];\n  if (state === \"errored\")\n    return PromiseReject(stream[kState].storedError);\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n    return PromiseReject(new ERR_INVALID_STATE.TypeError(\"WritableStream is closed\"));\n  }\n  if (state === \"erroring\")\n    return PromiseReject(stream[kState].storedError);\n  assert(state === \"writable\");\n  const promise = writableStreamAddWriteRequest(stream);\n  writableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n}\nfunction writableStreamDefaultWriterRelease(writer) {\n  const {\n    stream\n  } = writer[kState];\n  assert(stream !== void 0);\n  assert(stream[kState].writer === writer);\n  const releasedError = new ERR_INVALID_STATE.TypeError(\"Writer has been released\");\n  writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  writableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream[kState].writer = void 0;\n  writer[kState].stream = void 0;\n}\nfunction writableStreamDefaultWriterGetDesiredSize(writer) {\n  const {\n    stream\n  } = writer[kState];\n  switch (stream[kState].state) {\n    case \"errored\":\n    case \"erroring\":\n      return null;\n    case \"closed\":\n      return 0;\n  }\n  return writableStreamDefaultControllerGetDesiredSize(stream[kState].controller);\n}\nfunction writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (isPromisePending(writer[kState].ready.promise)) {\n    writer[kState].ready.reject?.(error);\n  } else {\n    writer[kState].ready = {\n      promise: PromiseReject(error),\n      resolve: void 0,\n      reject: void 0\n    };\n  }\n  setPromiseHandled(writer[kState].ready.promise);\n}\nfunction writableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (isPromisePending(writer[kState].close.promise)) {\n    writer[kState].close.reject?.(error);\n  } else {\n    writer[kState].close = {\n      promise: PromiseReject(error),\n      resolve: void 0,\n      reject: void 0\n    };\n  }\n  setPromiseHandled(writer[kState].close.promise);\n}\nfunction writableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const {\n    stream\n  } = writer[kState];\n  assert(stream !== void 0);\n  const {\n    state\n  } = stream[kState];\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === \"closed\")\n    return PromiseResolve();\n  if (state === \"errored\")\n    return PromiseReject(stream[kState].storedError);\n  assert(state === \"writable\" || state === \"erroring\");\n  return writableStreamDefaultWriterClose(writer);\n}\nfunction writableStreamDefaultWriterClose(writer) {\n  const {\n    stream\n  } = writer[kState];\n  assert(stream !== void 0);\n  return writableStreamClose(stream);\n}\nfunction writableStreamDefaultWriterAbort(writer, reason) {\n  const {\n    stream\n  } = writer[kState];\n  assert(stream !== void 0);\n  return writableStreamAbort(stream, reason);\n}\nfunction writableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  try {\n    enqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller, error);\n    return;\n  }\n  const {\n    stream\n  } = controller[kState];\n  if (!writableStreamCloseQueuedOrInFlight(stream) && stream[kState].state === \"writable\") {\n    writableStreamUpdateBackpressure(stream, writableStreamDefaultControllerGetBackpressure(controller));\n  }\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction writableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const {\n    stream,\n    writeAlgorithm\n  } = controller[kState];\n  writableStreamMarkFirstWriteRequestInFlight(stream);\n  PromisePrototypeThen(ensureIsPromise(writeAlgorithm, controller, chunk, controller), () => {\n    writableStreamFinishInFlightWrite(stream);\n    const {\n      state\n    } = stream[kState];\n    assert(state === \"writable\" || state === \"erroring\");\n    dequeueValue(controller);\n    if (!writableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n      writableStreamUpdateBackpressure(stream, writableStreamDefaultControllerGetBackpressure(controller));\n    }\n    writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, (error) => {\n    if (stream[kState].state === \"writable\")\n      writableStreamDefaultControllerClearAlgorithms(controller);\n    writableStreamFinishInFlightWriteWithError(stream, error);\n  });\n}\nfunction writableStreamDefaultControllerProcessClose(controller) {\n  const {\n    closeAlgorithm,\n    queue,\n    stream\n  } = controller[kState];\n  writableStreamMarkCloseRequestInFlight(stream);\n  dequeueValue(controller);\n  assert(!queue.length);\n  const sinkClosePromise = ensureIsPromise(closeAlgorithm, controller);\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  PromisePrototypeThen(sinkClosePromise, () => writableStreamFinishInFlightClose(stream), (error) => writableStreamFinishInFlightCloseWithError(stream, error));\n}\nfunction writableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    highWaterMark,\n    queueTotalSize\n  } = controller[kState];\n  return highWaterMark - queueTotalSize;\n}\nfunction writableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return FunctionPrototypeCall(controller[kState].sizeAlgorithm, void 0, chunk);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller, error);\n    return 1;\n  }\n}\nfunction writableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  const {\n    stream\n  } = controller[kState];\n  if (stream[kState].state === \"writable\")\n    writableStreamDefaultControllerError(controller, error);\n}\nfunction writableStreamDefaultControllerError(controller, error) {\n  const {\n    stream\n  } = controller[kState];\n  assert(stream[kState].state === \"writable\");\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  writableStreamStartErroring(stream, error);\n}\nfunction writableStreamDefaultControllerClose(controller) {\n  enqueueValueWithSize(controller, kCloseSentinel, 0);\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction writableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].writeAlgorithm = void 0;\n  controller[kState].closeAlgorithm = void 0;\n  controller[kState].abortAlgorithm = void 0;\n  controller[kState].sizeAlgorithm = void 0;\n}\nfunction writableStreamDefaultControllerGetBackpressure(controller) {\n  return writableStreamDefaultControllerGetDesiredSize(controller) <= 0;\n}\nfunction writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  const {\n    queue,\n    started,\n    stream\n  } = controller[kState];\n  if (!started || stream[kState].inFlightWriteRequest.promise !== void 0)\n    return;\n  if (stream[kState].state === \"erroring\") {\n    writableStreamFinishErroring(stream);\n    return;\n  }\n  if (!queue.length)\n    return;\n  const value = peekQueueValue(controller);\n  if (value === kCloseSentinel)\n    writableStreamDefaultControllerProcessClose(controller);\n  else\n    writableStreamDefaultControllerProcessWrite(controller, value);\n}\nfunction setupWritableStreamDefaultControllerFromSink(stream, sink, highWaterMark, sizeAlgorithm) {\n  const controller = createWritableStreamDefaultController();\n  const start = sink?.start;\n  const write = sink?.write;\n  const close = sink?.close;\n  const abort = sink?.abort;\n  const startAlgorithm = start ? FunctionPrototypeBind(start, sink, controller) : nonOpStart;\n  const writeAlgorithm = write ? FunctionPrototypeBind(write, sink) : nonOpWrite;\n  const closeAlgorithm = close ? FunctionPrototypeBind(close, sink) : nonOpCancel;\n  const abortAlgorithm = abort ? FunctionPrototypeBind(abort, sink) : nonOpCancel;\n  setupWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\nfunction setupWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(isWritableStream(stream));\n  assert(stream[kState].controller === void 0);\n  controller[kState] = {\n    abortAlgorithm,\n    abortReason: void 0,\n    closeAlgorithm,\n    highWaterMark,\n    queue: [],\n    queueTotalSize: 0,\n    abortController: new AbortController(),\n    sizeAlgorithm,\n    started: false,\n    stream,\n    writeAlgorithm\n  };\n  stream[kState].controller = controller;\n  writableStreamUpdateBackpressure(stream, writableStreamDefaultControllerGetBackpressure(controller));\n  const startResult = startAlgorithm();\n  PromisePrototypeThen(PromiseResolve(startResult), () => {\n    assert(stream[kState].state === \"writable\" || stream[kState].state === \"erroring\");\n    controller[kState].started = true;\n    writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, (error) => {\n    assert(stream[kState].state === \"writable\" || stream[kState].state === \"erroring\");\n    controller[kState].started = true;\n    writableStreamDealWithRejection(stream, error);\n  });\n}\nmodule.exports = {\n  WritableStream,\n  WritableStreamDefaultWriter,\n  WritableStreamDefaultController,\n  TransferredWritableStream,\n  isWritableStream,\n  isWritableStreamDefaultController,\n  isWritableStreamDefaultWriter,\n  isWritableStreamLocked,\n  setupWritableStreamDefaultWriter,\n  writableStreamAbort,\n  writableStreamClose,\n  writableStreamUpdateBackpressure,\n  writableStreamStartErroring,\n  writableStreamRejectCloseAndClosedPromiseIfNeeded,\n  writableStreamMarkFirstWriteRequestInFlight,\n  writableStreamMarkCloseRequestInFlight,\n  writableStreamHasOperationMarkedInFlight,\n  writableStreamFinishInFlightWriteWithError,\n  writableStreamFinishInFlightWrite,\n  writableStreamFinishInFlightCloseWithError,\n  writableStreamFinishInFlightClose,\n  writableStreamFinishErroring,\n  writableStreamDealWithRejection,\n  writableStreamCloseQueuedOrInFlight,\n  writableStreamAddWriteRequest,\n  writableStreamDefaultWriterWrite,\n  writableStreamDefaultWriterRelease,\n  writableStreamDefaultWriterGetDesiredSize,\n  writableStreamDefaultWriterEnsureReadyPromiseRejected,\n  writableStreamDefaultWriterEnsureClosedPromiseRejected,\n  writableStreamDefaultWriterCloseWithErrorPropagation,\n  writableStreamDefaultWriterClose,\n  writableStreamDefaultWriterAbort,\n  writableStreamDefaultControllerWrite,\n  writableStreamDefaultControllerProcessWrite,\n  writableStreamDefaultControllerProcessClose,\n  writableStreamDefaultControllerGetDesiredSize,\n  writableStreamDefaultControllerGetChunkSize,\n  writableStreamDefaultControllerErrorIfNeeded,\n  writableStreamDefaultControllerError,\n  writableStreamDefaultControllerClose,\n  writableStreamDefaultControllerClearAlgorithms,\n  writableStreamDefaultControllerGetBackpressure,\n  writableStreamDefaultControllerAdvanceQueueIfNeeded,\n  setupWritableStreamDefaultControllerFromSink,\n  setupWritableStreamDefaultController\n};\n}"],["internal/worker/io.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  Symbol,\n  SymbolFor\n} = primordials;\nconst {\n  handle_onclose: handleOnCloseSymbol,\n  oninit: onInitSymbol,\n  no_message_symbol: noMessageSymbol\n} = internalBinding(\"symbols\");\nconst {\n  MessagePort,\n  MessageChannel,\n  broadcastChannel,\n  drainMessagePort,\n  moveMessagePortToContext,\n  receiveMessageOnPort: receiveMessageOnPort_,\n  stopMessagePort,\n  checkMessagePort,\n  DOMException\n} = internalBinding(\"messaging\");\nconst {\n  getEnvMessagePort\n} = internalBinding(\"worker\");\nconst { Readable, Writable } = require(\"stream\");\nconst {\n  Event,\n  EventTarget,\n  NodeEventTarget,\n  defineEventHandler,\n  initNodeEventTarget,\n  kCreateEvent,\n  kNewListener,\n  kRemoveListener\n} = require(\"internal/event_target\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_THIS,\n    ERR_MISSING_ARGS\n  }\n} = require(\"internal/errors\");\nconst kData = Symbol(\"kData\");\nconst kHandle = Symbol(\"kHandle\");\nconst kIncrementsPortRef = Symbol(\"kIncrementsPortRef\");\nconst kLastEventId = Symbol(\"kLastEventId\");\nconst kName = Symbol(\"kName\");\nconst kOrigin = Symbol(\"kOrigin\");\nconst kOnMessage = Symbol(\"kOnMessage\");\nconst kOnMessageError = Symbol(\"kOnMessageError\");\nconst kPort = Symbol(\"kPort\");\nconst kPorts = Symbol(\"kPorts\");\nconst kWaitingStreams = Symbol(\"kWaitingStreams\");\nconst kWritableCallbacks = Symbol(\"kWritableCallbacks\");\nconst kSource = Symbol(\"kSource\");\nconst kStartedReading = Symbol(\"kStartedReading\");\nconst kStdioWantsMoreDataCallback = Symbol(\"kStdioWantsMoreDataCallback\");\nconst kCurrentlyReceivingPorts = SymbolFor(\"nodejs.internal.kCurrentlyReceivingPorts\");\nconst kType = Symbol(\"kType\");\nconst messageTypes = {\n  UP_AND_RUNNING: \"upAndRunning\",\n  COULD_NOT_SERIALIZE_ERROR: \"couldNotSerializeError\",\n  ERROR_MESSAGE: \"errorMessage\",\n  STDIO_PAYLOAD: \"stdioPayload\",\n  STDIO_WANTS_MORE_DATA: \"stdioWantsMoreData\",\n  LOAD_SCRIPT: \"loadScript\"\n};\nconst MessagePortPrototype = ObjectCreate(ObjectGetPrototypeOf(MessagePort.prototype), ObjectGetOwnPropertyDescriptors(MessagePort.prototype));\nObjectSetPrototypeOf(MessagePort, NodeEventTarget);\nObjectSetPrototypeOf(MessagePort.prototype, NodeEventTarget.prototype);\nMessagePort.prototype.ref = MessagePortPrototype.ref;\nMessagePort.prototype.unref = MessagePortPrototype.unref;\nfunction validateMessagePort(port, name) {\n  if (!checkMessagePort(port))\n    throw new ERR_INVALID_ARG_TYPE(name, \"MessagePort\", port);\n}\nfunction isMessageEvent(value) {\n  return value != null && kData in value;\n}\nclass MessageEvent extends Event {\n  constructor(type, {\n    data = null,\n    origin = \"\",\n    lastEventId = \"\",\n    source = null,\n    ports = []\n  } = {}) {\n    super(type);\n    this[kData] = data;\n    this[kOrigin] = `${origin}`;\n    this[kLastEventId] = `${lastEventId}`;\n    this[kSource] = source;\n    this[kPorts] = [...ports];\n    if (this[kSource] !== null)\n      validateMessagePort(this[kSource], \"init.source\");\n    for (let i = 0; i < this[kPorts].length; i++)\n      validateMessagePort(this[kPorts][i], `init.ports[${i}]`);\n  }\n}\nObjectDefineProperties(MessageEvent.prototype, {\n  data: {\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS(\"MessageEvent\");\n      return this[kData];\n    },\n    enumerable: true,\n    configurable: true,\n    set: void 0\n  },\n  origin: {\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS(\"MessageEvent\");\n      return this[kOrigin];\n    },\n    enumerable: true,\n    configurable: true,\n    set: void 0\n  },\n  lastEventId: {\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS(\"MessageEvent\");\n      return this[kLastEventId];\n    },\n    enumerable: true,\n    configurable: true,\n    set: void 0\n  },\n  source: {\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS(\"MessageEvent\");\n      return this[kSource];\n    },\n    enumerable: true,\n    configurable: true,\n    set: void 0\n  },\n  ports: {\n    get() {\n      if (!isMessageEvent(this))\n        throw new ERR_INVALID_THIS(\"MessageEvent\");\n      return this[kPorts];\n    },\n    enumerable: true,\n    configurable: true,\n    set: void 0\n  }\n});\nconst originalCreateEvent = EventTarget.prototype[kCreateEvent];\nObjectDefineProperty(MessagePort.prototype, kCreateEvent, {\n  value: function(data, type) {\n    if (type !== \"message\" && type !== \"messageerror\") {\n      return ReflectApply(originalCreateEvent, this, arguments);\n    }\n    const ports = this[kCurrentlyReceivingPorts];\n    this[kCurrentlyReceivingPorts] = void 0;\n    return new MessageEvent(type, { data, ports });\n  },\n  configurable: false,\n  writable: false,\n  enumerable: false\n});\nfunction oninit() {\n  initNodeEventTarget(this);\n  setupPortReferencing(this, this, \"message\");\n  this[kCurrentlyReceivingPorts] = void 0;\n}\ndefineEventHandler(MessagePort.prototype, \"message\");\ndefineEventHandler(MessagePort.prototype, \"messageerror\");\nObjectDefineProperty(MessagePort.prototype, onInitSymbol, {\n  enumerable: true,\n  writable: false,\n  value: oninit\n});\nclass MessagePortCloseEvent extends Event {\n  constructor() {\n    super(\"close\");\n  }\n}\nfunction onclose() {\n  this.dispatchEvent(new MessagePortCloseEvent());\n}\nObjectDefineProperty(MessagePort.prototype, handleOnCloseSymbol, {\n  enumerable: false,\n  writable: false,\n  value: onclose\n});\nMessagePort.prototype.close = function(cb) {\n  if (typeof cb === \"function\")\n    this.once(\"close\", cb);\n  FunctionPrototypeCall(MessagePortPrototype.close, this);\n};\nObjectDefineProperty(MessagePort.prototype, inspect.custom, {\n  enumerable: false,\n  writable: false,\n  value: function inspect2() {\n    let ref;\n    try {\n      ref = FunctionPrototypeCall(MessagePortPrototype.hasRef, this);\n    } catch {\n      return this;\n    }\n    return ObjectAssign(ObjectCreate(MessagePort.prototype), ref === void 0 ? {\n      active: false\n    } : {\n      active: true,\n      refed: ref\n    }, this);\n  }\n});\nfunction setupPortReferencing(port, eventEmitter, eventName) {\n  port.unref();\n  eventEmitter.on(\"newListener\", function(name) {\n    if (name === eventName)\n      newListener(eventEmitter.listenerCount(name));\n  });\n  eventEmitter.on(\"removeListener\", function(name) {\n    if (name === eventName)\n      removeListener(eventEmitter.listenerCount(name));\n  });\n  const origNewListener = eventEmitter[kNewListener];\n  eventEmitter[kNewListener] = function(size, type, ...args) {\n    if (type === eventName)\n      newListener(size - 1);\n    return ReflectApply(origNewListener, this, arguments);\n  };\n  const origRemoveListener = eventEmitter[kRemoveListener];\n  eventEmitter[kRemoveListener] = function(size, type, ...args) {\n    if (type === eventName)\n      removeListener(size);\n    return ReflectApply(origRemoveListener, this, arguments);\n  };\n  function newListener(size) {\n    if (size === 0) {\n      port.ref();\n      FunctionPrototypeCall(MessagePortPrototype.start, port);\n    }\n  }\n  function removeListener(size) {\n    if (size === 0) {\n      stopMessagePort(port);\n      port.unref();\n    }\n  }\n}\nclass ReadableWorkerStdio extends Readable {\n  constructor(port, name) {\n    super();\n    this[kPort] = port;\n    this[kName] = name;\n    this[kIncrementsPortRef] = true;\n    this[kStartedReading] = false;\n    this.on(\"end\", () => {\n      if (this[kStartedReading] && this[kIncrementsPortRef]) {\n        if (--this[kPort][kWaitingStreams] === 0)\n          this[kPort].unref();\n      }\n    });\n  }\n  _read() {\n    if (!this[kStartedReading] && this[kIncrementsPortRef]) {\n      this[kStartedReading] = true;\n      if (this[kPort][kWaitingStreams]++ === 0)\n        this[kPort].ref();\n    }\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_WANTS_MORE_DATA,\n      stream: this[kName]\n    });\n  }\n}\nclass WritableWorkerStdio extends Writable {\n  constructor(port, name) {\n    super({ decodeStrings: false });\n    this[kPort] = port;\n    this[kName] = name;\n    this[kWritableCallbacks] = [];\n  }\n  _writev(chunks, cb) {\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_PAYLOAD,\n      stream: this[kName],\n      chunks: ArrayPrototypeMap(chunks, ({ chunk, encoding }) => ({ chunk, encoding }))\n    });\n    ArrayPrototypePush(this[kWritableCallbacks], cb);\n    if (this[kPort][kWaitingStreams]++ === 0)\n      this[kPort].ref();\n  }\n  _final(cb) {\n    this[kPort].postMessage({\n      type: messageTypes.STDIO_PAYLOAD,\n      stream: this[kName],\n      chunks: [{ chunk: null, encoding: \"\" }]\n    });\n    cb();\n  }\n  [kStdioWantsMoreDataCallback]() {\n    const cbs = this[kWritableCallbacks];\n    this[kWritableCallbacks] = [];\n    ArrayPrototypeForEach(cbs, (cb) => cb());\n    if ((this[kPort][kWaitingStreams] -= cbs.length) === 0)\n      this[kPort].unref();\n  }\n}\nfunction createWorkerStdio() {\n  const port = getEnvMessagePort();\n  port[kWaitingStreams] = 0;\n  return {\n    stdin: new ReadableWorkerStdio(port, \"stdin\"),\n    stdout: new WritableWorkerStdio(port, \"stdout\"),\n    stderr: new WritableWorkerStdio(port, \"stderr\")\n  };\n}\nfunction receiveMessageOnPort(port) {\n  const message = receiveMessageOnPort_(port?.[kHandle] ?? port);\n  if (message === noMessageSymbol)\n    return void 0;\n  return { message };\n}\nfunction onMessageEvent(type, data) {\n  this.dispatchEvent(new MessageEvent(type, { data }));\n}\nfunction isBroadcastChannel(value) {\n  return value?.[kType] === \"BroadcastChannel\";\n}\nclass BroadcastChannel extends EventTarget {\n  constructor(name) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS(\"name\");\n    super();\n    this[kType] = \"BroadcastChannel\";\n    this[kName] = `${name}`;\n    this[kHandle] = broadcastChannel(this[kName]);\n    this[kOnMessage] = FunctionPrototypeBind(onMessageEvent, this, \"message\");\n    this[kOnMessageError] = FunctionPrototypeBind(onMessageEvent, this, \"messageerror\");\n    this[kHandle].on(\"message\", this[kOnMessage]);\n    this[kHandle].on(\"messageerror\", this[kOnMessageError]);\n  }\n  [inspect.custom](depth, options) {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    if (depth < 0)\n      return \"BroadcastChannel\";\n    const opts = {\n      ...options,\n      depth: options.depth == null ? null : options.depth - 1\n    };\n    return `BroadcastChannel ${inspect({\n      name: this[kName],\n      active: this[kHandle] !== void 0\n    }, opts)}`;\n  }\n  get name() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    return this[kName];\n  }\n  close() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    if (this[kHandle] === void 0)\n      return;\n    this[kHandle].off(\"message\", this[kOnMessage]);\n    this[kHandle].off(\"messageerror\", this[kOnMessageError]);\n    this[kOnMessage] = void 0;\n    this[kOnMessageError] = void 0;\n    this[kHandle].close();\n    this[kHandle] = void 0;\n  }\n  postMessage(message) {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS(\"message\");\n    if (this[kHandle] === void 0)\n      throw new DOMException(\"BroadcastChannel is closed.\");\n    if (this[kHandle].postMessage(message) === void 0)\n      throw new DOMException(\"Message could not be posted.\");\n  }\n  ref() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    if (this[kHandle])\n      this[kHandle].ref();\n    return this;\n  }\n  unref() {\n    if (!isBroadcastChannel(this))\n      throw new ERR_INVALID_THIS(\"BroadcastChannel\");\n    if (this[kHandle])\n      this[kHandle].unref();\n    return this;\n  }\n}\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nObjectDefineProperties(BroadcastChannel.prototype, {\n  name: kEnumerableProperty,\n  close: kEnumerableProperty,\n  postMessage: kEnumerableProperty\n});\ndefineEventHandler(BroadcastChannel.prototype, \"message\");\ndefineEventHandler(BroadcastChannel.prototype, \"messageerror\");\nmodule.exports = {\n  drainMessagePort,\n  messageTypes,\n  kPort,\n  kIncrementsPortRef,\n  kWaitingStreams,\n  kStdioWantsMoreDataCallback,\n  moveMessagePortToContext,\n  MessagePort,\n  MessageChannel,\n  MessageEvent,\n  receiveMessageOnPort,\n  setupPortReferencing,\n  ReadableWorkerStdio,\n  WritableWorkerStdio,\n  createWorkerStdio,\n  BroadcastChannel\n};\n}"],["internal/worker/js_transferable.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Error,\n  ObjectDefineProperties,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  ReflectConstruct,\n  StringPrototypeSplit\n} = primordials;\nconst {\n  messaging_deserialize_symbol,\n  messaging_transfer_symbol,\n  messaging_clone_symbol,\n  messaging_transfer_list_symbol\n} = internalBinding(\"symbols\");\nconst {\n  JSTransferable,\n  setDeserializerCreateObjectFunction\n} = internalBinding(\"messaging\");\nfunction setup() {\n  setDeserializerCreateObjectFunction((deserializeInfo) => {\n    const { 0: module2, 1: ctor } = StringPrototypeSplit(deserializeInfo, \":\");\n    const Ctor = require(module2)[ctor];\n    if (typeof Ctor !== \"function\" || typeof Ctor.prototype[messaging_deserialize_symbol] !== \"function\") {\n      throw new Error(`Unknown deserialize spec ${deserializeInfo}`);\n    }\n    return new Ctor();\n  });\n}\nfunction makeTransferable(obj) {\n  const inst = ReflectConstruct(JSTransferable, [], obj.constructor);\n  ObjectDefineProperties(inst, ObjectGetOwnPropertyDescriptors(obj));\n  ObjectSetPrototypeOf(inst, ObjectGetPrototypeOf(obj));\n  return inst;\n}\nmodule.exports = {\n  makeTransferable,\n  setup,\n  JSTransferable,\n  kClone: messaging_clone_symbol,\n  kDeserialize: messaging_deserialize_symbol,\n  kTransfer: messaging_transfer_symbol,\n  kTransferList: messaging_transfer_list_symbol\n};\n}"],["internal/bootstrap/switches/does_not_own_process_state.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst credentials = internalBinding(\"credentials\");\nconst rawMethods = internalBinding(\"process_methods\");\nconst { unavailable } = require(\"internal/process/worker_thread_only\");\nprocess.abort = unavailable(\"process.abort()\");\nprocess.chdir = unavailable(\"process.chdir()\");\nprocess.umask = wrappedUmask;\nprocess.cwd = rawMethods.cwd;\nif (credentials.implementsPosixCredentials) {\n  process.initgroups = unavailable(\"process.initgroups()\");\n  process.setgroups = unavailable(\"process.setgroups()\");\n  process.setegid = unavailable(\"process.setegid()\");\n  process.seteuid = unavailable(\"process.seteuid()\");\n  process.setgid = unavailable(\"process.setgid()\");\n  process.setuid = unavailable(\"process.setuid()\");\n}\nconst {\n  codes: { ERR_WORKER_UNSUPPORTED_OPERATION }\n} = require(\"internal/errors\");\nfunction wrappedUmask(mask) {\n  if (mask !== void 0) {\n    throw new ERR_WORKER_UNSUPPORTED_OPERATION(\"Setting process.umask()\");\n  }\n  return rawMethods.umask(mask);\n}\n}"],["internal/bootstrap/switches/does_own_process_state.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst credentials = internalBinding(\"credentials\");\nconst rawMethods = internalBinding(\"process_methods\");\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\nconst {\n  parseFileMode,\n  validateArray,\n  validateString\n} = require(\"internal/validators\");\nfunction wrapPosixCredentialSetters(credentials2) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE,\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require(\"internal/errors\");\n  const {\n    validateUint32\n  } = require(\"internal/validators\");\n  const {\n    initgroups: _initgroups,\n    setgroups: _setgroups,\n    setegid: _setegid,\n    seteuid: _seteuid,\n    setgid: _setgid,\n    setuid: _setuid\n  } = credentials2;\n  function initgroups(user, extraGroup) {\n    validateId(user, \"user\");\n    validateId(extraGroup, \"extraGroup\");\n    const result = _initgroups(user, extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL(\"User\", user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL(\"Group\", extraGroup);\n    }\n  }\n  function setgroups(groups) {\n    validateArray(groups, \"groups\");\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i], `groups[${i}]`);\n    }\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL(\"Group\", groups[result - 1]);\n    }\n  }\n  function wrapIdSetter(type, method) {\n    return function(id) {\n      validateId(id, \"id\");\n      if (typeof id === \"number\")\n        id |= 0;\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type, id);\n      }\n    };\n  }\n  function validateId(id, name) {\n    if (typeof id === \"number\") {\n      validateUint32(id, name);\n    } else if (typeof id !== \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(name, [\"number\", \"string\"], id);\n    }\n  }\n  return {\n    initgroups,\n    setgroups,\n    setegid: wrapIdSetter(\"Group\", _setegid),\n    seteuid: wrapIdSetter(\"User\", _seteuid),\n    setgid: wrapIdSetter(\"Group\", _setgid),\n    setuid: wrapIdSetter(\"User\", _setuid)\n  };\n}\nlet cachedCwd = \"\";\nfunction wrappedChdir(directory) {\n  validateString(directory, \"directory\");\n  rawMethods.chdir(directory);\n  cachedCwd = \"\";\n}\nfunction wrappedUmask(mask) {\n  if (mask !== void 0) {\n    mask = parseFileMode(mask, \"mask\");\n  }\n  return rawMethods.umask(mask);\n}\nfunction wrappedCwd() {\n  if (cachedCwd === \"\")\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n}"],["internal/bootstrap/switches/is_main_thread.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { ObjectDefineProperty } = primordials;\nconst rawMethods = internalBinding(\"process_methods\");\nprocess._debugProcess = rawMethods._debugProcess;\nprocess._debugEnd = rawMethods._debugEnd;\nprocess._startProfilerIdleNotifier = () => {\n};\nprocess._stopProfilerIdleNotifier = () => {\n};\nfunction defineStream(name, getter) {\n  ObjectDefineProperty(process, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\ndefineStream(\"stdout\", getStdout);\ndefineStream(\"stdin\", getStdin);\ndefineStream(\"stderr\", getStderr);\nconst {\n  startListeningIfSignal,\n  stopListeningIfSignal\n} = require(\"internal/process/signal\");\nprocess.on(\"newListener\", startListeningIfSignal);\nprocess.on(\"removeListener\", stopListeningIfSignal);\nconst { guessHandleType } = internalBinding(\"util\");\nfunction createWritableStdioStream(fd) {\n  let stream;\n  switch (guessHandleType(fd)) {\n    case \"TTY\":\n      const tty = require(\"tty\");\n      stream = new tty.WriteStream(fd);\n      stream._type = \"tty\";\n      break;\n    case \"FILE\":\n      const SyncWriteStream = require(\"internal/fs/sync_write_stream\");\n      stream = new SyncWriteStream(fd, { autoClose: false });\n      stream._type = \"fs\";\n      break;\n    case \"PIPE\":\n    case \"TCP\":\n      const net = require(\"net\");\n      if (process.channel && process.channel.fd === fd) {\n        const { kChannelHandle } = require(\"internal/child_process\");\n        stream = new net.Socket({\n          handle: process[kChannelHandle],\n          readable: false,\n          writable: true\n        });\n      } else {\n        stream = new net.Socket({\n          fd,\n          readable: false,\n          writable: true\n        });\n      }\n      stream._type = \"pipe\";\n      break;\n    default:\n      const { Writable } = require(\"stream\");\n      stream = new Writable({\n        write(buf, enc, cb) {\n          cb();\n        }\n      });\n  }\n  stream.fd = fd;\n  stream._isStdio = true;\n  return stream;\n}\nfunction dummyDestroy(err, cb) {\n  cb(err);\n  this._undestroy();\n  if (!this._writableState.emitClose) {\n    process.nextTick(() => {\n      this.emit(\"close\");\n    });\n  }\n}\nlet stdin;\nlet stdout;\nlet stderr;\nfunction getStdout() {\n  if (stdout)\n    return stdout;\n  stdout = createWritableStdioStream(1);\n  stdout.destroySoon = stdout.destroy;\n  stdout._destroy = dummyDestroy;\n  if (stdout.isTTY) {\n    process.on(\"SIGWINCH\", () => stdout._refreshSize());\n  }\n  return stdout;\n}\nfunction getStderr() {\n  if (stderr)\n    return stderr;\n  stderr = createWritableStdioStream(2);\n  stderr.destroySoon = stderr.destroy;\n  stderr._destroy = dummyDestroy;\n  if (stderr.isTTY) {\n    process.on(\"SIGWINCH\", () => stderr._refreshSize());\n  }\n  return stderr;\n}\nfunction getStdin() {\n  if (stdin)\n    return stdin;\n  const fd = 0;\n  switch (guessHandleType(fd)) {\n    case \"TTY\":\n      const tty = require(\"tty\");\n      stdin = new tty.ReadStream(fd);\n      break;\n    case \"FILE\":\n      const fs = require(\"fs\");\n      stdin = new fs.ReadStream(null, { fd, autoClose: false });\n      break;\n    case \"PIPE\":\n    case \"TCP\":\n      const net = require(\"net\");\n      if (process.channel && process.channel.fd === fd) {\n        stdin = new net.Socket({\n          handle: process.channel,\n          readable: true,\n          writable: false,\n          manualStart: true\n        });\n      } else {\n        stdin = new net.Socket({\n          fd,\n          readable: true,\n          writable: false,\n          manualStart: true\n        });\n      }\n      stdin._writableState.ended = true;\n      break;\n    default:\n      const { Readable } = require(\"stream\");\n      stdin = new Readable({ read() {\n      } });\n      stdin.push(null);\n  }\n  stdin.fd = fd;\n  if (stdin._handle && stdin._handle.readStop) {\n    stdin._handle.reading = false;\n    stdin._readableState.reading = false;\n    stdin._handle.readStop();\n  }\n  stdin.on(\"pause\", () => {\n    process.nextTick(onpause);\n  });\n  function onpause() {\n    if (!stdin._handle)\n      return;\n    if (stdin._handle.reading && !stdin.readableFlowing) {\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    }\n  }\n  return stdin;\n}\nrawMethods.resetStdioForTesting = function() {\n  stdin = void 0;\n  stdout = void 0;\n  stderr = void 0;\n};\n}"],["internal/bootstrap/switches/is_not_main_thread.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { ObjectDefineProperty } = primordials;\ndelete process._debugProcess;\ndelete process._debugEnd;\nfunction defineStream(name, getter) {\n  ObjectDefineProperty(process, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\ndefineStream(\"stdout\", getStdout);\ndefineStream(\"stdin\", getStdin);\ndefineStream(\"stderr\", getStderr);\nconst {\n  startListeningIfSignal,\n  stopListeningIfSignal\n} = require(\"internal/process/signal\");\nprocess.removeListener(\"newListener\", startListeningIfSignal);\nprocess.removeListener(\"removeListener\", stopListeningIfSignal);\nconst {\n  createWorkerStdio\n} = require(\"internal/worker/io\");\nlet workerStdio;\nfunction lazyWorkerStdio() {\n  if (!workerStdio)\n    workerStdio = createWorkerStdio();\n  return workerStdio;\n}\nfunction getStdout() {\n  return lazyWorkerStdio().stdout;\n}\nfunction getStderr() {\n  return lazyWorkerStdio().stderr;\n}\nfunction getStdin() {\n  return lazyWorkerStdio().stdin;\n}\n}"],["internal/fs/cp/cp-sync.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { areIdentical, isSrcSubdir } = require(\"internal/fs/cp/cp\");\nconst { codes } = require(\"internal/errors\");\nconst {\n  os: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = internalBinding(\"constants\");\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_RETURN_VALUE\n} = codes;\nconst {\n  chmodSync,\n  copyFileSync,\n  existsSync,\n  lstatSync,\n  mkdirSync,\n  readdirSync,\n  readlinkSync,\n  statSync,\n  symlinkSync,\n  unlinkSync,\n  utimesSync\n} = require(\"fs\");\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve\n} = require(\"path\");\nconst { isPromise } = require(\"util/types\");\nfunction cpSyncFn(src, dest, opts) {\n  if (opts.preserveTimestamps && process.arch === \"ia32\") {\n    const warning = \"Using the preserveTimestamps option in 32-bit node is not recommended\";\n    process.emitWarning(warning, \"TimestampPrecisionWarning\");\n  }\n  const { srcStat, destStat } = checkPathsSync(src, dest, opts);\n  checkParentPathsSync(src, srcStat, dest);\n  return handleFilterAndCopy(destStat, src, dest, opts);\n}\nfunction checkPathsSync(src, dest, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: \"src and dest cannot be the same\",\n        path: dest,\n        syscall: \"cp\",\n        errno: EINVAL\n      });\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} with non-directory ${dest}`,\n        path: dest,\n        syscall: \"cp\",\n        errno: EISDIR\n      });\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} with directory ${dest}`,\n        path: dest,\n        syscall: \"cp\",\n        errno: ENOTDIR\n      });\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return { srcStat, destStat };\n}\nfunction getStatsSync(src, dest, opts) {\n  let destStat;\n  const statFunc = opts.dereference ? (file) => statSync(file, { bigint: true }) : (file) => lstatSync(file, { bigint: true });\n  const srcStat = statFunc(src);\n  try {\n    destStat = statFunc(dest);\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return { srcStat, destStat: null };\n    throw err;\n  }\n  return { srcStat, destStat };\n}\nfunction checkParentPathsSync(src, srcStat, dest) {\n  const srcParent = resolve(dirname(src));\n  const destParent = resolve(dirname(dest));\n  if (destParent === srcParent || destParent === parse(destParent).root)\n    return;\n  let destStat;\n  try {\n    destStat = statSync(destParent, { bigint: true });\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return checkParentPathsSync(src, srcStat, destParent);\n}\nfunction handleFilterAndCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    const shouldCopy = opts.filter(src, dest);\n    if (isPromise(shouldCopy)) {\n      throw new ERR_INVALID_RETURN_VALUE(\"boolean\", \"filter\", shouldCopy);\n    }\n    if (!shouldCopy)\n      return;\n  }\n  const destParent = dirname(dest);\n  if (!existsSync(destParent))\n    mkdirSync(destParent, { recursive: true });\n  return getStats(destStat, src, dest, opts);\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest))\n    return;\n  return getStats(destStat, src, dest, opts);\n}\nfunction getStats(destStat, src, dest, opts) {\n  const statSyncFn = opts.dereference ? statSync : lstatSync;\n  const srcStat = statSyncFn(src);\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest);\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: \"cp\",\n    errno: EINVAL\n  });\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat)\n    return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.force) {\n    unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EEXIST\n    });\n  }\n}\nfunction copyFile(srcStat, src, dest, opts) {\n  copyFileSync(src, dest);\n  if (opts.preserveTimestamps)\n    handleTimestamps(srcStat.mode, src, dest);\n  return setDestMode(dest, srcStat.mode);\n}\nfunction handleTimestamps(srcMode, src, dest) {\n  if (fileIsNotWritable(srcMode))\n    makeFileWritable(dest, srcMode);\n  return setDestTimestamps(src, dest);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 128) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 128);\n}\nfunction setDestMode(dest, srcMode) {\n  return chmodSync(dest, srcMode);\n}\nfunction setDestTimestamps(src, dest) {\n  const updatedSrcStat = statSync(src);\n  return utimesSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat)\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}\nfunction mkDirAndCopy(srcMode, src, dest, opts) {\n  mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\nfunction copyDir(src, dest, opts) {\n  readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));\n}\nfunction copyDirItem(item, src, dest, opts) {\n  const srcItem = join(src, item);\n  const destItem = join(dest, item);\n  const { destStat } = checkPathsSync(srcItem, destItem, opts);\n  return startCopy(destStat, srcItem, destItem, opts);\n}\nfunction onLink(destStat, src, dest) {\n  let resolvedSrc = readlinkSync(src);\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc);\n  }\n  if (!destStat) {\n    return symlinkSync(resolvedSrc, dest);\n  }\n  let resolvedDest;\n  try {\n    resolvedDest = readlinkSync(dest);\n  } catch (err) {\n    if (err.code === \"EINVAL\" || err.code === \"UNKNOWN\") {\n      return symlinkSync(resolvedSrc, dest);\n    }\n    throw err;\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest);\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  if (statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return copyLink(resolvedSrc, dest);\n}\nfunction copyLink(resolvedSrc, dest) {\n  unlinkSync(dest);\n  return symlinkSync(resolvedSrc, dest);\n}\nmodule.exports = { cpSyncFn };\n}"],["internal/fs/cp/cp.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeEvery,\n  ArrayPrototypeFilter,\n  Boolean,\n  PromiseAll,\n  PromisePrototypeCatch,\n  PromisePrototypeThen,\n  PromiseReject,\n  SafeArrayIterator,\n  StringPrototypeSplit\n} = primordials;\nconst {\n  codes: {\n    ERR_FS_CP_DIR_TO_NON_DIR,\n    ERR_FS_CP_EEXIST,\n    ERR_FS_CP_EINVAL,\n    ERR_FS_CP_FIFO_PIPE,\n    ERR_FS_CP_NON_DIR_TO_DIR,\n    ERR_FS_CP_SOCKET,\n    ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n    ERR_FS_CP_UNKNOWN,\n    ERR_FS_EISDIR\n  }\n} = require(\"internal/errors\");\nconst {\n  os: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = internalBinding(\"constants\");\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes\n} = require(\"fs/promises\");\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep\n} = require(\"path\");\nasync function cpFn(src, dest, opts) {\n  if (opts.preserveTimestamps && process.arch === \"ia32\") {\n    const warning = \"Using the preserveTimestamps option in 32-bit node is not recommended\";\n    process.emitWarning(warning, \"TimestampPrecisionWarning\");\n  }\n  const stats = await checkPaths(src, dest, opts);\n  const { srcStat, destStat } = stats;\n  await checkParentPaths(src, srcStat, dest);\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts);\n  }\n  return checkParentDir(destStat, src, dest, opts);\n}\nasync function checkPaths(src, dest, opts) {\n  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: \"src and dest cannot be the same\",\n        path: dest,\n        syscall: \"cp\",\n        errno: EINVAL\n      });\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} with non-directory ${dest}`,\n        path: dest,\n        syscall: \"cp\",\n        errno: EISDIR\n      });\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} with directory ${dest}`,\n        path: dest,\n        syscall: \"cp\",\n        errno: ENOTDIR\n      });\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return { srcStat, destStat };\n}\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? (file) => stat(file, { bigint: true }) : (file) => lstat(file, { bigint: true });\n  return PromiseAll(new SafeArrayIterator([\n    statFunc(src),\n    PromisePrototypeCatch(statFunc(dest), (err) => {\n      if (err.code === \"ENOENT\")\n        return null;\n      throw err;\n    })\n  ]));\n}\nasync function checkParentDir(destStat, src, dest, opts) {\n  const destParent = dirname(dest);\n  const dirExists = await pathExists(destParent);\n  if (dirExists)\n    return getStatsForCopy(destStat, src, dest, opts);\n  await mkdir(destParent, { recursive: true });\n  return getStatsForCopy(destStat, src, dest, opts);\n}\nfunction pathExists(dest) {\n  return PromisePrototypeThen(stat(dest), () => true, (err) => err.code === \"ENOENT\" ? false : PromiseReject(err));\n}\nasync function checkParentPaths(src, srcStat, dest) {\n  const srcParent = resolve(dirname(src));\n  const destParent = resolve(dirname(dest));\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return;\n  }\n  let destStat;\n  try {\n    destStat = await stat(destParent, { bigint: true });\n  } catch (err) {\n    if (err.code === \"ENOENT\")\n      return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return checkParentPaths(src, srcStat, destParent);\n}\nconst normalizePathToArray = (path) => ArrayPrototypeFilter(StringPrototypeSplit(resolve(path), sep), Boolean);\nfunction isSrcSubdir(src, dest) {\n  const srcArr = normalizePathToArray(src);\n  const destArr = normalizePathToArray(dest);\n  return ArrayPrototypeEvery(srcArr, (cur, i) => destArr[i] === cur);\n}\nasync function handleFilter(onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest);\n  if (include)\n    return onInclude(destStat, src, dest, opts, cb);\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts);\n  }\n  return getStatsForCopy(destStat, src, dest, opts);\n}\nasync function getStatsForCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat;\n  const srcStat = await statFn(src);\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest);\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: \"cp\",\n    errno: EINVAL\n  });\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat)\n    return _copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nasync function mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest);\n    return _copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EEXIST\n    });\n  }\n}\nasync function _copyFile(srcStat, src, dest, opts) {\n  await copyFile(src, dest);\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest);\n  }\n  return setDestMode(dest, srcStat.mode);\n}\nasync function handleTimestampsAndMode(srcMode, src, dest) {\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode);\n    return setDestTimestampsAndMode(srcMode, src, dest);\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 128) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 128);\n}\nasync function setDestTimestampsAndMode(srcMode, src, dest) {\n  await setDestTimestamps(src, dest);\n  return setDestMode(dest, srcMode);\n}\nfunction setDestMode(dest, srcMode) {\n  return chmod(dest, srcMode);\n}\nasync function setDestTimestamps(src, dest) {\n  const updatedSrcStat = await stat(src);\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat)\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}\nasync function mkDirAndCopy(srcMode, src, dest, opts) {\n  await mkdir(dest);\n  await copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\nasync function copyDir(src, dest, opts) {\n  const dir = await readdir(src);\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i];\n    const srcItem = join(src, item);\n    const destItem = join(dest, item);\n    const { destStat } = await checkPaths(srcItem, destItem, opts);\n    await startCopy(destStat, srcItem, destItem, opts);\n  }\n}\nasync function onLink(destStat, src, dest) {\n  let resolvedSrc = await readlink(src);\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc);\n  }\n  if (!destStat) {\n    return symlink(resolvedSrc, dest);\n  }\n  let resolvedDest;\n  try {\n    resolvedDest = await readlink(dest);\n  } catch (err) {\n    if (err.code === \"EINVAL\" || err.code === \"UNKNOWN\") {\n      return symlink(resolvedSrc, dest);\n    }\n    throw err;\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest);\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  const srcStat = await stat(src);\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: \"cp\",\n      errno: EINVAL\n    });\n  }\n  return copyLink(resolvedSrc, dest);\n}\nasync function copyLink(resolvedSrc, dest) {\n  await unlink(dest);\n  return symlink(resolvedSrc, dest);\n}\nmodule.exports = {\n  areIdentical,\n  cpFn,\n  isSrcSubdir\n};\n}"],["internal/modules/cjs/helpers.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeJoin,\n  ArrayPrototypeSome,\n  ObjectDefineProperty,\n  ObjectPrototypeHasOwnProperty,\n  SafeMap,\n  SafeSet,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIncludes,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require(\"internal/errors\").codes;\nconst { NativeModule } = require(\"internal/bootstrap/loaders\");\nconst { validateString } = require(\"internal/validators\");\nconst path = require(\"path\");\nconst { pathToFileURL, fileURLToPath, URL } = require(\"internal/url\");\nconst { getOptionValue } = require(\"internal/options\");\nconst userConditions = getOptionValue(\"--conditions\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"module\", (fn) => {\n  debug = fn;\n});\nconst noAddons = getOptionValue(\"--no-addons\");\nconst addonConditions = noAddons ? [] : [\"node-addons\"];\nconst cjsConditions = new SafeSet([\n  \"require\",\n  \"node\",\n  ...addonConditions,\n  ...userConditions\n]);\nfunction loadNativeModule(filename, request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug(\"load native module %s\", request);\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod, redirects) {\n  const Module = mod.constructor;\n  let require2;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve: resolve2, reaction } = redirects;\n    require2 = function require3(specifier) {\n      let missing = true;\n      const destination = resolve2(specifier, conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === \"node:\") {\n          const specifier2 = destination.pathname;\n          const mod2 = loadNativeModule(specifier2, href);\n          if (mod2 && mod2.canBeRequiredByUsers) {\n            return mod2.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier2);\n        } else if (destination.protocol === \"file:\") {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href, filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(id, specifier, ArrayPrototypeJoin([...conditions], \", \")));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require2 = function require3(path2) {\n      return mod.require(path2);\n    };\n  }\n  function resolve(request, options) {\n    validateString(request, \"request\");\n    return Module._resolveFilename(request, mod, false, options);\n  }\n  require2.resolve = resolve;\n  function paths(request) {\n    validateString(request, \"request\");\n    return Module._resolveLookupPaths(request, mod);\n  }\n  resolve.paths = paths;\n  require2.main = process.mainModule;\n  require2.extensions = Module._extensions;\n  require2.cache = Module._cache;\n  return require2;\n}\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 65279) {\n    content = StringPrototypeSlice(content, 1);\n  }\n  return content;\n}\nfunction addBuiltinLibsToObject(object, dummyModuleName) {\n  const Module = require(\"internal/modules/cjs/loader\").Module;\n  const { builtinModules } = Module;\n  const dummyModule = new Module(dummyModuleName);\n  ArrayPrototypeForEach(builtinModules, (name) => {\n    if (StringPrototypeStartsWith(name, \"_\") || StringPrototypeIncludes(name, \"/\") || ObjectPrototypeHasOwnProperty(object, name)) {\n      return;\n    }\n    const setReal = (val) => {\n      delete object[name];\n      object[name] = val;\n    };\n    ObjectDefineProperty(object, name, {\n      get: () => {\n        const lib = dummyModule.require(name);\n        delete object[name];\n        ObjectDefineProperty(object, name, {\n          get: () => lib,\n          set: setReal,\n          configurable: true,\n          enumerable: false\n        });\n        return lib;\n      },\n      set: setReal,\n      configurable: true,\n      enumerable: false\n    });\n  });\n}\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === \"string\" && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\nfunction hasEsmSyntax(code) {\n  debug(\"Checking for ESM syntax\");\n  const parser = require(\"internal/deps/acorn/acorn/dist/acorn\").Parser;\n  let root;\n  try {\n    root = parser.parse(code, { sourceType: \"module\", ecmaVersion: \"latest\" });\n  } catch {\n    return false;\n  }\n  return ArrayPrototypeSome(root.body, (stmt) => stmt.type === \"ExportDefaultDeclaration\" || stmt.type === \"ExportNamedDeclaration\" || stmt.type === \"ImportDeclaration\" || stmt.type === \"ExportAllDeclaration\");\n}\nmodule.exports = {\n  addBuiltinLibsToObject,\n  cjsConditions,\n  hasEsmSyntax,\n  loadNativeModule,\n  makeRequireFunction,\n  normalizeReferrerURL,\n  stripBOM\n};\n}"],["internal/modules/cjs/loader.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeConcat,\n  ArrayPrototypeFilter,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  ArrayPrototypeUnshiftApply,\n  Boolean,\n  Error,\n  JSONParse,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ObjectPrototype,\n  ObjectPrototypeHasOwnProperty,\n  ObjectSetPrototypeOf,\n  Proxy,\n  ReflectApply,\n  ReflectSet,\n  RegExpPrototypeExec,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeWeakMap,\n  String,\n  StringPrototypeCharAt,\n  StringPrototypeCharCodeAt,\n  StringPrototypeEndsWith,\n  StringPrototypeLastIndexOf,\n  StringPrototypeIndexOf,\n  StringPrototypeMatch,\n  StringPrototypeRepeat,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst cjsParseCache = new SafeWeakMap();\nmodule.exports = {\n  wrapSafe,\n  Module,\n  toRealPath,\n  readPackageScope,\n  cjsParseCache,\n  get hasLoadedAnyUserCJSModule() {\n    return hasLoadedAnyUserCJSModule;\n  }\n};\nconst { NativeModule } = require(\"internal/bootstrap/loaders\");\nconst {\n  maybeCacheSourceMap\n} = require(\"internal/source_map/source_map_cache\");\nconst { pathToFileURL, fileURLToPath, isURLInstance } = require(\"internal/url\");\nconst { deprecate } = require(\"internal/util\");\nconst vm = require(\"vm\");\nconst assert = require(\"internal/assert\");\nconst fs = require(\"fs\");\nconst internalFS = require(\"internal/fs/utils\");\nconst path = require(\"path\");\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding(\"fs\");\nconst packageJsonReader = require(\"internal/modules/package_json_reader\");\nconst { safeGetenv } = internalBinding(\"credentials\");\nconst {\n  cjsConditions,\n  hasEsmSyntax,\n  loadNativeModule,\n  makeRequireFunction,\n  normalizeReferrerURL,\n  stripBOM\n} = require(\"internal/modules/cjs/helpers\");\nconst { getOptionValue } = require(\"internal/options\");\nconst preserveSymlinks = getOptionValue(\"--preserve-symlinks\");\nconst preserveSymlinksMain = getOptionValue(\"--preserve-symlinks-main\");\nconst policy = getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\") : null;\nlet hasLoadedAnyUserCJSModule = false;\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_MODULE_SPECIFIER,\n    ERR_REQUIRE_ESM,\n    ERR_UNKNOWN_BUILTIN_MODULE\n  },\n  setArrowMessage\n} = require(\"internal/errors\");\nconst { validateString } = require(\"internal/validators\");\nconst pendingDeprecation = getOptionValue(\"--pending-deprecation\");\nconst {\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON\n} = require(\"internal/constants\");\nconst {\n  isProxy\n} = require(\"internal/util/types\");\nconst asyncESM = require(\"internal/process/esm_loader\");\nconst { enrichCJSError } = require(\"internal/modules/esm/translators\");\nconst { kEvaluated } = internalBinding(\"module_wrap\");\nconst {\n  encodedSepRegEx,\n  packageExportsResolve,\n  packageImportsResolve\n} = require(\"internal/modules/esm/resolve\");\nconst isWindows = process.platform === \"win32\";\nconst relativeResolveCache = ObjectCreate(null);\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result2 = statCache.get(filename);\n    if (result2 !== void 0)\n      return result2;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    statCache.set(filename, result);\n  }\n  return result;\n}\nfunction updateChildren(parent, child, scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children, child)))\n    ArrayPrototypePush(children, child);\n}\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = \"\", parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this, parent);\n  updateChildren(parent, this, false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nconst builtinModules = [];\nfor (const { 0: id, 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules, id);\n  }\n}\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\nlet patched = false;\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\nconst wrapper = [\n  \"(function (exports, require, module, __filename, __dirname) { \",\n  \"\\n});\"\n];\nlet wrapperProxy = new Proxy(wrapper, {\n  set(target, property, value, receiver) {\n    patched = true;\n    return ReflectSet(target, property, value, receiver);\n  },\n  defineProperty(target, property, descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target, property, descriptor);\n  }\n});\nObjectDefineProperty(Module, \"wrap\", {\n  get() {\n    return wrap;\n  },\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\nObjectDefineProperty(Module, \"wrapper\", {\n  get() {\n    return wrapperProxy;\n  },\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\nconst isPreloadingDesc = { get() {\n  return isPreloading;\n} };\nObjectDefineProperty(Module.prototype, \"isPreloading\", isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype, \"isPreloading\", isPreloadingDesc);\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\nfunction setModuleParent(value) {\n  moduleParentCache.set(this, value);\n}\nObjectDefineProperty(Module.prototype, \"parent\", {\n  get: pendingDeprecation ? deprecate(getModuleParent, \"module.parent is deprecated due to accuracy issues. Please use require.main to find program entry point instead.\", \"DEP0144\") : getModuleParent,\n  set: pendingDeprecation ? deprecate(setModuleParent, \"module.parent is deprecated due to accuracy issues. Please use require.main to find program entry point instead.\", \"DEP0144\") : setModuleParent\n});\nlet debug = require(\"internal/util/debuglog\").debuglog(\"module\", (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug, \"Module._debug is deprecated.\", \"DEP0077\");\nconst packageJsonCache = new SafeMap();\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath, \"package.json\");\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== void 0)\n    return existing;\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? \"{}\" : result.string;\n  if (json === void 0) {\n    packageJsonCache.set(jsonPath, false);\n    return false;\n  }\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath, filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = \"Error parsing \" + jsonPath + \": \" + e.message;\n    throw e;\n  }\n}\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);\n    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);\n    if (StringPrototypeEndsWith(checkPath, sep + \"node_modules\"))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson)\n      return {\n        data: pjson,\n        path: checkPath\n      };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\nfunction tryPackage(requestPath, exts, isMain, originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath, \"index\"), exts, isMain);\n  }\n  const filename = path.resolve(requestPath, pkg);\n  let actual = tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(path.resolve(filename, \"index\"), exts, isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath, \"index\"), exts, isMain);\n    if (!actual) {\n      const err = new Error(`Cannot find module '${filename}'. Please verify that the package.json has a valid \"main\" entry`);\n      err.code = \"MODULE_NOT_FOUND\";\n      err.path = path.resolve(requestPath, \"package.json\");\n      err.requestPath = originalPath;\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath, \"package.json\");\n      process.emitWarning(`Invalid 'main' field in '${jsonPath}' of '${pkg}'. Please either fix that or report it to the module author`, \"DeprecationWarning\", \"DEP0128\");\n    }\n  }\n  return actual;\n}\nconst realpathCache = new SafeMap();\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0)\n    return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\nfunction tryExtensions(p, exts, isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name, \".\", startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0)\n      continue;\n    currentExtension = StringPrototypeSlice(name, index);\n    if (Module._extensions[currentExtension])\n      return currentExtension;\n  }\n  return \".js\";\n}\nfunction trySelfParentPath(parent) {\n  if (!parent)\n    return false;\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === \"<repl>\" || parent.id === \"internal/preload\") {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\nfunction trySelf(parentPath, request) {\n  if (!parentPath)\n    return false;\n  const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === void 0)\n    return false;\n  if (typeof pkg.name !== \"string\")\n    return false;\n  let expansion;\n  if (request === pkg.name) {\n    expansion = \".\";\n  } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {\n    expansion = \".\" + StringPrototypeSlice(request, pkg.name.length);\n  } else {\n    return false;\n  }\n  try {\n    return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + \"/package.json\"), expansion, pkg, pathToFileURL(parentPath), cjsConditions), parentPath, pkgPath);\n  } catch (e) {\n    if (e.code === \"ERR_MODULE_NOT_FOUND\")\n      throw createEsmNotFoundErr(request, pkgPath + \"/package.json\");\n    throw e;\n  }\n}\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath, request) {\n  const { 1: name, 2: expansion = \"\" } = StringPrototypeMatch(request, EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath, name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + \"/package.json\"), \".\" + expansion, pkg, null, cjsConditions), null, pkgPath);\n    } catch (e) {\n      if (e.code === \"ERR_MODULE_NOT_FOUND\")\n        throw createEsmNotFoundErr(request, pkgPath + \"/package.json\");\n      throw e;\n    }\n  }\n}\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request, paths, isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [\"\"];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n  const cacheKey = request + \"\\0\" + ArrayPrototypeJoin(paths, \"\\0\");\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n  let exts;\n  let trailingSlash = request.length > 0 && StringPrototypeCharCodeAt(request, request.length - 1) === CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);\n  }\n  for (let i = 0; i < paths.length; i++) {\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1)\n      continue;\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath, request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n    const basePath = path.resolve(curPath, request);\n    let filename;\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n      if (!filename) {\n        if (exts === void 0)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n    if (!filename && rc === 1) {\n      if (exts === void 0)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain, request);\n    }\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n  return false;\n};\nconst nmChars = [115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  Module._nodeModulePaths = function(from) {\n    from = path.resolve(from);\n    if (StringPrototypeCharCodeAt(from, from.length - 1) === CHAR_BACKWARD_SLASH && StringPrototypeCharCodeAt(from, from.length - 2) === CHAR_COLON)\n      return [from + \"node_modules\"];\n    const paths = [];\n    for (let i = from.length - 1, p = 0, last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from, i);\n      if (code === CHAR_BACKWARD_SLASH || code === CHAR_FORWARD_SLASH || code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(paths, StringPrototypeSlice(from, 0, last) + \"\\\\node_modules\");\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n    return paths;\n  };\n} else {\n  Module._nodeModulePaths = function(from) {\n    from = path.resolve(from);\n    if (from === \"/\")\n      return [\"/node_modules\"];\n    const paths = [];\n    for (let i = from.length - 1, p = 0, last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(paths, StringPrototypeSlice(from, 0, last) + \"/node_modules\");\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n    ArrayPrototypePush(paths, \"/node_modules\");\n    return paths;\n  };\n}\nModule._resolveLookupPaths = function(request, parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug(\"looking for %j in []\", request);\n    return null;\n  }\n  if (StringPrototypeCharAt(request, 0) !== \".\" || request.length > 1 && StringPrototypeCharAt(request, 1) !== \".\" && StringPrototypeCharAt(request, 1) !== \"/\" && (!isWindows || StringPrototypeCharAt(request, 1) !== \"\\\\\")) {\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths, paths);\n    }\n    debug(\"looking for %j in %j\", request, paths);\n    return paths.length > 0 ? paths : null;\n  }\n  if (!parent || !parent.id || !parent.filename) {\n    const mainPaths = [\".\"];\n    debug(\"looking for %j in %j\", request, mainPaths);\n    return mainPaths;\n  }\n  debug(\"RELATIVE: requested: %s from parent.id %s\", request, parent.id);\n  const parentDir = [path.dirname(parent.filename)];\n  debug(\"looking for %j\", parentDir);\n  return parentDir;\n};\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(`Accessing non-existent property '${String(prop)}' of module exports inside circular dependency`);\n}\nconst CircularRequirePrototypeWarningProxy = new Proxy({}, {\n  get(target, prop) {\n    if (prop in target || prop === \"__esModule\")\n      return target[prop];\n    emitCircularRequireWarning(prop);\n    return void 0;\n  },\n  getOwnPropertyDescriptor(target, prop) {\n    if (ObjectPrototypeHasOwnProperty(target, prop) || prop === \"__esModule\")\n      return ObjectGetOwnPropertyDescriptor(target, prop);\n    emitCircularRequireWarning(prop);\n    return void 0;\n  }\n});\nfunction getExportsForCircularRequire(module2) {\n  if (module2.exports && !isProxy(module2.exports) && ObjectGetPrototypeOf(module2.exports) === ObjectPrototype && !module2.exports.__esModule) {\n    ObjectSetPrototypeOf(module2.exports, CircularRequirePrototypeWarningProxy);\n  }\n  return module2.exports;\n}\nModule._load = function(request, parent, isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug(\"Module._load REQUEST %s parent: %s\", request, parent.id);\n    relResolveCacheIdentifier = `${parent.path}\\0${request}`;\n    const filename2 = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename2 !== void 0) {\n      const cachedModule2 = Module._cache[filename2];\n      if (cachedModule2 !== void 0) {\n        updateChildren(parent, cachedModule2, true);\n        if (!cachedModule2.loaded)\n          return getExportsForCircularRequire(cachedModule2);\n        return cachedModule2.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n  const filename = Module._resolveFilename(request, parent, isMain);\n  if (StringPrototypeStartsWith(filename, \"node:\")) {\n    const id = StringPrototypeSlice(filename, 5);\n    const module3 = loadNativeModule(id, request);\n    if (!module3?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n    return module3.exports;\n  }\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== void 0) {\n    updateChildren(parent, cachedModule, true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n  const mod = loadNativeModule(filename, request);\n  if (mod?.canBeRequiredByUsers)\n    return mod.exports;\n  const module2 = cachedModule || new Module(filename, parent);\n  if (isMain) {\n    process.mainModule = module2;\n    module2.id = \".\";\n  }\n  Module._cache[filename] = module2;\n  if (parent !== void 0) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n  let threw = true;\n  try {\n    module2.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== void 0) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children, module2);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children, index, 1);\n          }\n        }\n      }\n    } else if (module2.exports && !isProxy(module2.exports) && ObjectGetPrototypeOf(module2.exports) === CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module2.exports, ObjectPrototype);\n    }\n  }\n  return module2.exports;\n};\nModule._resolveFilename = function(request, parent, isMain, options) {\n  if (StringPrototypeStartsWith(request, \"node:\") || NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n  let paths;\n  if (typeof options === \"object\" && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request, \"./\") || StringPrototypeStartsWith(request, \"../\") || (isWindows && StringPrototypeStartsWith(request, \".\\\\\") || StringPrototypeStartsWith(request, \"..\\\\\"));\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(\"\", null);\n        paths = [];\n        for (let i = 0; i < options.paths.length; i++) {\n          const path2 = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path2);\n          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths, lookupPaths[j]))\n              ArrayPrototypePush(paths, lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === void 0) {\n      paths = Module._resolveLookupPaths(request, parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE(\"options.paths\", options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request, parent);\n  }\n  if (parent?.filename) {\n    if (request[0] === \"#\") {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(packageImportsResolve(request, pathToFileURL(parent.filename), cjsConditions), parent.filename, pkg.path);\n        } catch (e) {\n          if (e.code === \"ERR_MODULE_NOT_FOUND\")\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath, request);\n  if (selfResolved) {\n    const cacheKey = request + \"\\0\" + (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, \"\\0\"));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n  const filename = Module._findPath(request, paths, isMain, false);\n  if (filename)\n    return filename;\n  const requireStack = [];\n  for (let cursor = parent; cursor; cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack, cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + \"\\nRequire stack:\\n- \" + ArrayPrototypeJoin(requireStack, \"\\n- \");\n  }\n  const err = new Error(message);\n  err.code = \"MODULE_NOT_FOUND\";\n  err.requireStack = requireStack;\n  throw err;\n};\nfunction finalizeEsmResolution(resolved, parentPath, pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(resolved, 'must not include encoded \"/\" or \"\\\\\" characters', parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename, path.resolve(pkgPath, \"package.json\"));\n  throw err;\n}\nfunction createEsmNotFoundErr(request, path2) {\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = \"MODULE_NOT_FOUND\";\n  if (path2)\n    err.path = path2;\n  return err;\n}\nModule.prototype.load = function(filename) {\n  debug(\"load %j for module %j\", filename, this.id);\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n  const extension = findLongestRegisteredExtension(filename);\n  if (StringPrototypeEndsWith(filename, \".mjs\") && !Module._extensions[\".mjs\"])\n    throw new ERR_REQUIRE_ESM(filename, true);\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n  const esmLoader = asyncESM.esmLoader;\n  const exports = this.exports;\n  if ((module?.module === void 0 || module.module.getStatus() < kEvaluated) && !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this, exports);\n};\nModule.prototype.require = function(id) {\n  validateString(id, \"id\");\n  if (id === \"\") {\n    throw new ERR_INVALID_ARG_VALUE(\"id\", id, \"must be a non-empty string\");\n  }\n  requireDepth++;\n  try {\n    return Module._load(id, this, false);\n  } finally {\n    requireDepth--;\n  }\n};\nlet resolvedArgv;\nlet hasPausedEntry = false;\nfunction wrapSafe(filename, content, cjsModuleInstance) {\n  if (patched) {\n    const wrapper2 = Module.wrap(content);\n    return vm.runInThisContext(wrapper2, {\n      filename,\n      lineOffset: 0,\n      displayErrors: true,\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier, normalizeReferrerURL(filename));\n      }\n    });\n  }\n  try {\n    return vm.compileFunction(content, [\n      \"exports\",\n      \"require\",\n      \"module\",\n      \"__filename\",\n      \"__dirname\"\n    ], {\n      filename,\n      importModuleDynamically(specifier) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier, normalizeReferrerURL(filename));\n      }\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err, content);\n    throw err;\n  }\n}\nModule.prototype._compile = function(content, filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  maybeCacheSourceMap(filename, content, this);\n  const compiledWrapper = wrapSafe(filename, content, this);\n  let inspectorWrapper = null;\n  if (getOptionValue(\"--inspect-brk\") && process._eval == null) {\n    if (!resolvedArgv) {\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1], null, false);\n        } catch {\n          assert(ArrayIsArray(getOptionValue(\"--require\")));\n        }\n      } else {\n        resolvedArgv = \"repl\";\n      }\n    }\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding(\"inspector\").callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require2 = makeRequireFunction(this, redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module2 = this;\n  if (requireDepth === 0)\n    statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper, thisValue, exports, require2, module2, filename, dirname);\n  } else {\n    result = ReflectApply(compiledWrapper, thisValue, [exports, require2, module2, filename, dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0)\n    statCache = null;\n  return result;\n};\nModule._extensions[\".js\"] = function(module2, filename) {\n  const cached = cjsParseCache.get(module2);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = void 0;\n  } else {\n    content = fs.readFileSync(filename, \"utf8\");\n  }\n  if (StringPrototypeEndsWith(filename, \".js\")) {\n    const pkg = readPackageScope(filename);\n    if (pkg?.data?.type === \"module\") {\n      const parent = moduleParentCache.get(module2);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path, \"package.json\");\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename, usesEsm, parentPath, packageJsonPath);\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath, \"utf8\");\n        } catch {\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(StringPrototypeSlice(err.stack, StringPrototypeIndexOf(err.stack, \"    at \")), \"\\n\", 1)[0];\n          const { 1: line, 2: col } = RegExpPrototypeExec(/(\\d+):(\\d+)\\)/, errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource, \"\\n\")[line - 1];\n            const frame = `${parentPath}:${line}\n${srcLine}\n${StringPrototypeRepeat(\" \", col - 1)}^\n`;\n            setArrowMessage(err, frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module2._compile(content, filename);\n};\nModule._extensions[\".json\"] = function(module2, filename) {\n  const content = fs.readFileSync(filename, \"utf8\");\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  try {\n    module2.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + \": \" + err.message;\n    throw err;\n  }\n};\nModule._extensions[\".node\"] = function(module2, filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  return process.dlopen(module2, path.toNamespacedPath(filename));\n};\nfunction createRequireFromPath(filename) {\n  const trailingSlash = StringPrototypeEndsWith(filename, \"/\") || isWindows && StringPrototypeEndsWith(filename, \"\\\\\");\n  const proxyPath = trailingSlash ? path.join(filename, \"noop.js\") : filename;\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m, null);\n}\nconst createRequireError = \"must be a file URL object, file URL string, or absolute path string\";\nfunction createRequire(filename) {\n  let filepath;\n  if (isURLInstance(filename) || typeof filename === \"string\" && !path.isAbsolute(filename)) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE(\"filename\", filename, createRequireError);\n    }\n  } else if (typeof filename !== \"string\") {\n    throw new ERR_INVALID_ARG_VALUE(\"filename\", filename, createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\nModule.createRequire = createRequire;\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv(\"HOME\");\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv(\"NODE_PATH\");\n  const prefixDir = isWindows ? path.resolve(process.execPath, \"..\") : path.resolve(process.execPath, \"..\", \"..\");\n  const paths = [path.resolve(prefixDir, \"lib\", \"node\")];\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths, path.resolve(homeDir, \".node_libraries\"));\n    ArrayPrototypeUnshift(paths, path.resolve(homeDir, \".node_modules\"));\n  }\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths, ArrayPrototypeFilter(StringPrototypeSplit(nodePath, path.delimiter), Boolean));\n  }\n  modulePaths = paths;\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n  isPreloading = true;\n  const parent = new Module(\"internal/preload\", null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== \"ENOENT\") {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\nModule.Module = Module;\n}"],["internal/modules/esm/create_dynamic_module.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  JSONStringify,\n  ObjectCreate,\n  SafeSet\n} = primordials;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"esm\", (fn) => {\n  debug = fn;\n});\nfunction createImport(impt, index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name},\n  set: (v) => $${name} = v,\n};`;\n}\nconst createDynamicModule = (imports, exports, url = \"\", evaluate) => {\n  debug(\"creating ESM facade for %s with exports: %j\", url, exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports, createImport), \"\\n\")}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports, createExport), \"\\n\")}\nimport.meta.done();\n`;\n  const { ModuleWrap, callbackMap } = internalBinding(\"module_wrap\");\n  const m = new ModuleWrap(`${url}`, void 0, source, 0, 0);\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null),\n    onReady: (cb) => {\n      readyfns.add(cb);\n    }\n  };\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n  callbackMap.set(m, {\n    initializeImportMeta: (meta, wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\n  });\n  return {\n    module: m,\n    reflect\n  };\n};\nmodule.exports = createDynamicModule;\n}"],["internal/modules/esm/get_format.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectAssign,\n  ObjectCreate,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeExec\n} = primordials;\nconst { extname } = require(\"path\");\nconst { getOptionValue } = require(\"internal/options\");\nconst experimentalJsonModules = getOptionValue(\"--experimental-json-modules\");\nconst experimentalSpecifierResolution = getOptionValue(\"--experimental-specifier-resolution\");\nconst experimentalWasmModules = getOptionValue(\"--experimental-wasm-modules\");\nconst { getPackageType } = require(\"internal/modules/esm/resolve\");\nconst { URL, fileURLToPath } = require(\"internal/url\");\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require(\"internal/errors\").codes;\nconst extensionFormatMap = {\n  \"__proto__\": null,\n  \".cjs\": \"commonjs\",\n  \".js\": \"module\",\n  \".mjs\": \"module\"\n};\nconst legacyExtensionFormatMap = {\n  \"__proto__\": null,\n  \".cjs\": \"commonjs\",\n  \".js\": \"commonjs\",\n  \".json\": \"commonjs\",\n  \".mjs\": \"module\",\n  \".node\": \"commonjs\"\n};\nif (experimentalWasmModules)\n  extensionFormatMap[\".wasm\"] = legacyExtensionFormatMap[\".wasm\"] = \"wasm\";\nif (experimentalJsonModules)\n  extensionFormatMap[\".json\"] = legacyExtensionFormatMap[\".json\"] = \"json\";\nconst protocolHandlers = ObjectAssign(ObjectCreate(null), {\n  \"data:\"(parsed) {\n    const { 1: mime } = RegExpPrototypeExec(/^([^/]+\\/[^;,]+)(?:[^,]*?)(;base64)?,/, parsed.pathname) || [, null];\n    const format = {\n      \"__proto__\": null,\n      \"text/javascript\": \"module\",\n      \"application/json\": experimentalJsonModules ? \"json\" : null,\n      \"application/wasm\": experimentalWasmModules ? \"wasm\" : null\n    }[mime] || null;\n    return format;\n  },\n  \"file:\"(parsed, url) {\n    const ext = extname(parsed.pathname);\n    let format;\n    if (ext === \".js\") {\n      format = getPackageType(parsed.href) === \"module\" ? \"module\" : \"commonjs\";\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpecifierResolution === \"node\") {\n        process.emitWarning(\"The Node.js specifier resolution in ESM is experimental.\", \"ExperimentalWarning\");\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext, fileURLToPath(url));\n      }\n    }\n    return format || null;\n  },\n  \"node:\"() {\n    return \"builtin\";\n  }\n});\nfunction defaultGetFormat(url, context) {\n  const parsed = new URL(url);\n  return ObjectPrototypeHasOwnProperty(protocolHandlers, parsed.protocol) ? protocolHandlers[parsed.protocol](parsed, url) : null;\n}\nmodule.exports = {\n  defaultGetFormat,\n  extensionFormatMap,\n  legacyExtensionFormatMap\n};\n}"],["internal/modules/esm/get_source.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  RegExpPrototypeExec,\n  decodeURIComponent\n} = primordials;\nconst { getOptionValue } = require(\"internal/options\");\nconst policy = getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\") : null;\nconst { Buffer } = require(\"buffer\");\nconst fs = require(\"internal/fs/promises\").exports;\nconst { URL } = require(\"internal/url\");\nconst {\n  ERR_INVALID_URL,\n  ERR_INVALID_URL_SCHEME\n} = require(\"internal/errors\").codes;\nconst readFileAsync = fs.readFile;\nconst DATA_URL_PATTERN = /^[^/]+\\/[^,;]+(?:[^,]*?)(;base64)?,([\\s\\S]*)$/;\nasync function defaultGetSource(url, { format } = {}, defaultGetSource2) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === \"file:\") {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === \"data:\") {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN, parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64, 2: body } = match;\n    source = Buffer.from(decodeURIComponent(body), base64 ? \"base64\" : \"utf8\");\n  } else {\n    throw new ERR_INVALID_URL_SCHEME([\"file\", \"data\"]);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed, source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n}"],["internal/modules/esm/load.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { defaultGetFormat } = require(\"internal/modules/esm/get_format\");\nconst { defaultGetSource } = require(\"internal/modules/esm/get_source\");\nconst { translators } = require(\"internal/modules/esm/translators\");\nasync function defaultLoad(url, context) {\n  let {\n    format,\n    source\n  } = context;\n  if (!translators.has(format))\n    format = defaultGetFormat(url);\n  if (format === \"builtin\" || format === \"commonjs\") {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url, { format });\n  }\n  return {\n    format,\n    source\n  };\n}\nmodule.exports = {\n  defaultLoad\n};\n}"],["internal/modules/esm/loader.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nrequire(\"internal/modules/cjs/loader\");\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectCreate,\n  ObjectSetPrototypeOf,\n  PromiseAll,\n  RegExpPrototypeExec,\n  SafeArrayIterator,\n  SafeWeakMap,\n  globalThis\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_RETURN_PROPERTY_VALUE,\n  ERR_INVALID_RETURN_VALUE,\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require(\"internal/errors\").codes;\nconst { pathToFileURL, isURLInstance } = require(\"internal/url\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst ModuleMap = require(\"internal/modules/esm/module_map\");\nconst ModuleJob = require(\"internal/modules/esm/module_job\");\nconst {\n  defaultResolve,\n  DEFAULT_CONDITIONS\n} = require(\"internal/modules/esm/resolve\");\nconst { defaultLoad } = require(\"internal/modules/esm/load\");\nconst { translators } = require(\"internal/modules/esm/translators\");\nconst { getOptionValue } = require(\"internal/options\");\nclass ESMLoader {\n  #globalPreloaders = [];\n  #loaders = [\n    defaultLoad\n  ];\n  #resolvers = [\n    defaultResolve\n  ];\n  cjsCache = new SafeWeakMap();\n  evalIndex = 0;\n  moduleMap = new ModuleMap();\n  translators = translators;\n  static pluckHooks({\n    globalPreload,\n    resolve,\n    load,\n    dynamicInstantiate,\n    getFormat,\n    getGlobalPreloadCode,\n    getSource,\n    transformSource\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n      process.emitWarning('Loader hook \"getGlobalPreloadCode\" has been renamed to \"globalPreload\"');\n    }\n    if (dynamicInstantiate)\n      ArrayPrototypePush(obsoleteHooks, \"dynamicInstantiate\");\n    if (getFormat)\n      ArrayPrototypePush(obsoleteHooks, \"getFormat\");\n    if (getSource)\n      ArrayPrototypePush(obsoleteHooks, \"getSource\");\n    if (transformSource)\n      ArrayPrototypePush(obsoleteHooks, \"transformSource\");\n    if (obsoleteHooks.length)\n      process.emitWarning(`Obsolete loader hook(s) supplied and will be ignored: ${ArrayPrototypeJoin(obsoleteHooks, \", \")}`, \"DeprecationWarning\");\n    if (globalPreload) {\n      acceptedHooks.globalPreloader = FunctionPrototypeBind(globalPreload, null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve, null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load, null);\n    }\n    return acceptedHooks;\n  }\n  async addCustomLoaders(customLoaders = []) {\n    if (!ArrayIsArray(customLoaders))\n      customLoaders = [customLoaders];\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports2 = customLoaders[i];\n      const {\n        globalPreloader,\n        resolver,\n        loader\n      } = ESMLoader.pluckHooks(exports2);\n      if (globalPreloader)\n        ArrayPrototypePush(this.#globalPreloaders, FunctionPrototypeBind(globalPreloader, null));\n      if (resolver)\n        ArrayPrototypePush(this.#resolvers, FunctionPrototypeBind(resolver, null));\n      if (loader)\n        ArrayPrototypePush(this.#loaders, FunctionPrototypeBind(loader, null));\n    }\n    this.preload();\n  }\n  async eval(source, url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href) {\n    const evalInstance = (url2) => {\n      const { ModuleWrap, callbackMap } = internalBinding(\"module_wrap\");\n      const module2 = new ModuleWrap(url2, void 0, source, 0, 0);\n      callbackMap.set(module2, {\n        importModuleDynamically: (specifier, { url: url3 }) => {\n          return this.import(specifier, url3);\n        }\n      });\n      return module2;\n    };\n    const job = new ModuleJob(this, url, evalInstance, false, false);\n    this.moduleMap.set(url, job);\n    const { module } = await job.run();\n    return {\n      namespace: module.getNamespace()\n    };\n  }\n  async getModuleJob(specifier, parentURL) {\n    const { format, url } = await this.resolve(specifier, parentURL);\n    let job = this.moduleMap.get(url);\n    if (typeof job === \"function\")\n      this.moduleMap.set(url, job = job());\n    if (job !== void 0)\n      return job;\n    const moduleProvider = async (url2, isMain) => {\n      const { format: finalFormat, source } = await this.load(url2, { format });\n      const translator = translators.get(finalFormat);\n      if (!translator)\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat);\n      return FunctionPrototypeCall(translator, this, url2, source, isMain);\n    };\n    const inspectBrk = parentURL === void 0 && getOptionValue(\"--inspect-brk\");\n    job = new ModuleJob(this, url, moduleProvider, parentURL === void 0, inspectBrk);\n    this.moduleMap.set(url, job);\n    return job;\n  }\n  async import(specifiers, parentURL) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr)\n      specifiers = [specifiers];\n    const count = specifiers.length;\n    const jobs = new Array(count);\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i], parentURL).then((job) => job.run()).then(({ module }) => module.getNamespace());\n    }\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n    return wasArr ? namespaces : namespaces[0];\n  }\n  async load(url, context = {}) {\n    const defaultLoader = this.#loaders[0];\n    const loader = this.#loaders.length === 1 ? defaultLoader : this.#loaders[1];\n    const loaded = await loader(url, context, defaultLoader);\n    if (typeof loaded !== \"object\") {\n      throw new ERR_INVALID_RETURN_VALUE(\"object\", \"loader load\", loaded);\n    }\n    const {\n      format,\n      source\n    } = loaded;\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(/^data:([^/]+\\/[^;,]+)(?:[^,]*?)(;base64)?,/, url);\n      throw new ERR_INVALID_MODULE_SPECIFIER(url, dataUrl ? `has an unsupported MIME type \"${dataUrl[1]}\"` : \"\");\n    }\n    if (typeof format !== \"string\") {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\"string\", \"loader resolve\", \"format\", format);\n    }\n    if (source != null && typeof source !== \"string\" && !isAnyArrayBuffer(source) && !isArrayBufferView(source))\n      throw ERR_INVALID_RETURN_PROPERTY_VALUE(\"string, an ArrayBuffer, or a TypedArray\", \"loader load\", \"source\", source);\n    return {\n      format,\n      source\n    };\n  }\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count)\n      return;\n    for (let i = 0; i < count; i++) {\n      const preload = this.#globalPreloaders[i]();\n      if (preload == null)\n        return;\n      if (typeof preload !== \"string\") {\n        throw new ERR_INVALID_RETURN_VALUE(\"string\", \"loader globalPreloadCode\", preload);\n      }\n      const { compileFunction } = require(\"vm\");\n      const preloadInit = compileFunction(preload, [\"getBuiltin\"], {\n        filename: \"<preload>\"\n      });\n      const { NativeModule } = require(\"internal/bootstrap/loaders\");\n      FunctionPrototypeCall(preloadInit, globalThis, (builtinName) => {\n        if (NativeModule.canBeRequiredByUsers(builtinName)) {\n          return require(builtinName);\n        }\n        throw new ERR_INVALID_ARG_VALUE(\"builtinName\", builtinName);\n      });\n    }\n  }\n  async resolve(originalSpecifier, parentURL) {\n    const isMain = parentURL === void 0;\n    if (!isMain && typeof parentURL !== \"string\" && !isURLInstance(parentURL))\n      throw new ERR_INVALID_ARG_TYPE(\"parentURL\", [\"string\", \"URL\"], parentURL);\n    const conditions = DEFAULT_CONDITIONS;\n    const defaultResolver = this.#resolvers[0];\n    const resolver = this.#resolvers.length === 1 ? defaultResolver : this.#resolvers[1];\n    const resolution = await resolver(originalSpecifier, {\n      conditions,\n      parentURL\n    }, defaultResolver);\n    if (typeof resolution !== \"object\") {\n      throw new ERR_INVALID_RETURN_VALUE(\"object\", \"loader resolve\", resolution);\n    }\n    const { format, url } = resolution;\n    if (format != null && typeof format !== \"string\") {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\"string\", \"loader resolve\", \"format\", format);\n    }\n    if (typeof url !== \"string\") {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\"string\", \"loader resolve\", \"url\", url);\n    }\n    return {\n      format,\n      url\n    };\n  }\n}\nObjectSetPrototypeOf(ESMLoader.prototype, null);\nexports.ESMLoader = ESMLoader;\n}"],["internal/modules/esm/module_job.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  ArrayPrototypeSome,\n  FunctionPrototype,\n  ObjectSetPrototypeOf,\n  PromiseAll,\n  PromiseResolve,\n  PromisePrototypeCatch,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeArrayIterator,\n  SafeSet,\n  StringPrototypeIncludes,\n  StringPrototypeMatch,\n  StringPrototypeReplace,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst { ModuleWrap } = internalBinding(\"module_wrap\");\nconst { decorateErrorStack } = require(\"internal/util\");\nconst {\n  getSourceMapsEnabled\n} = require(\"internal/source_map/source_map_cache\");\nconst assert = require(\"internal/assert\");\nconst resolvedPromise = PromiseResolve();\nconst noop = FunctionPrototype;\nlet hasPausedEntry = false;\nconst CJSGlobalLike = [\n  \"require\",\n  \"module\",\n  \"exports\",\n  \"__filename\",\n  \"__dirname\"\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) => ArrayPrototypeSome(CJSGlobalLike, (globalLike) => errorMessage === `${globalLike} is not defined`);\nclass ModuleJob {\n  constructor(loader, url, moduleProvider, isMain, inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n    this.module = void 0;\n    this.modulePromise = ReflectApply(moduleProvider, loader, [url, isMain]);\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier, url);\n        ArrayPrototypePush(dependencyJobs, jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n      if (promises !== void 0)\n        await PromiseAll(new SafeArrayIterator(promises));\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    this.linked = link();\n    PromisePrototypeCatch(this.linked, noop);\n    this.instantiated = void 0;\n  }\n  instantiate() {\n    if (this.instantiated === void 0) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(ArrayPrototypeMap(dependencyJobs, addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding(\"inspector\").callAndPauseOnStart;\n        initWrapper(this.module.instantiate, this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      if (!getSourceMapsEnabled() && StringPrototypeIncludes(e.message, \" does not provide an export named\")) {\n        const splitStack = StringPrototypeSplit(e.stack, \"\\n\");\n        const parentFileUrl = StringPrototypeReplace(splitStack[0], /:\\d+$/, \"\");\n        const { 1: childSpecifier, 2: name } = StringPrototypeMatch(e.message, /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(childSpecifier, parentFileUrl);\n        const { format } = await this.loader.load(childFileURL);\n        if (format === \"commonjs\") {\n          const importStatement = splitStack[1];\n          const oneLineNamedImports = StringPrototypeMatch(importStatement, /{.*}/);\n          const destructuringAssignment = oneLineNamedImports && StringPrototypeReplace(oneLineNamedImports, /\\s+as\\s+/g, \": \");\n          e.message = `Named export '${name}' not found. The requested module '${childSpecifier}' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export, for example using:\n\nimport pkg from '${childSpecifier}';\n${destructuringAssignment ? `const ${destructuringAssignment} = pkg;\n` : \"\"}`;\n          const newStack = StringPrototypeSplit(e.stack, \"\\n\");\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack, \"\\n\");\n        }\n      }\n      throw e;\n    }\n    for (const dependencyJob of jobsInGraph) {\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout, breakOnSigint);\n    } catch (e) {\n      if (e?.name === \"ReferenceError\" && isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += \" in ES module scope\";\n        if (StringPrototypeStartsWith(e.message, \"require \")) {\n          e.message += \", you can use import instead\";\n        }\n        const packageConfig = StringPrototypeStartsWith(this.module.url, \"file://\") && RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/, this.module.url) && require(\"internal/modules/esm/resolve\").getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === \"module\") {\n          e.message += `\nThis file is being treated as an ES module because it has a '.js' file extension and '${packageConfig.pjsonPath}' contains \"type\": \"module\". To treat it as a CommonJS script, rename it to use the '.cjs' file extension.`;\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype, null);\nmodule.exports = ModuleJob;\n}"],["internal/modules/esm/module_map.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst ModuleJob = require(\"internal/modules/esm/module_job\");\nconst {\n  SafeMap\n} = primordials;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"esm\", (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require(\"internal/errors\").codes;\nconst { validateString } = require(\"internal/validators\");\nclass ModuleMap extends SafeMap {\n  constructor(i) {\n    super(i);\n  }\n  get(url) {\n    validateString(url, \"url\");\n    return super.get(url);\n  }\n  set(url, job) {\n    validateString(url, \"url\");\n    if (job instanceof ModuleJob !== true && typeof job !== \"function\") {\n      throw new ERR_INVALID_ARG_TYPE(\"job\", \"ModuleJob\", job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url, job);\n  }\n  has(url) {\n    validateString(url, \"url\");\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n}"],["internal/modules/esm/resolve.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExp,\n  RegExpPrototypeSymbolReplace,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  String,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst internalFS = require(\"internal/fs/utils\");\nconst { NativeModule } = require(\"internal/bootstrap/loaders\");\nconst {\n  realpathSync,\n  statSync,\n  Stats\n} = require(\"fs\");\nconst { getOptionValue } = require(\"internal/options\");\nconst policy = getOptionValue(\"--experimental-policy\") ? require(\"internal/process/policy\") : null;\nconst { sep, relative, resolve } = require(\"path\");\nconst preserveSymlinks = getOptionValue(\"--preserve-symlinks\");\nconst preserveSymlinksMain = getOptionValue(\"--preserve-symlinks-main\");\nconst typeFlag = getOptionValue(\"--input-type\");\nconst { URL, pathToFileURL, fileURLToPath } = require(\"internal/url\");\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\n} = require(\"internal/errors\").codes;\nconst { Module: CJSModule } = require(\"internal/modules/cjs/loader\");\nconst packageJsonReader = require(\"internal/modules/package_json_reader\");\nconst userConditions = getOptionValue(\"--conditions\");\nconst noAddons = getOptionValue(\"--no-addons\");\nconst addonConditions = noAddons ? [] : [\"node-addons\"];\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  \"node\",\n  \"import\",\n  ...addonConditions,\n  ...userConditions\n]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\nconst emittedPackageWarnings = new SafeSet();\nfunction emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + \"|\" + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + \"|\" + match);\n  process.emitWarning(`Use of deprecated trailing slash pattern mapping \"${match}\" in the \"exports\" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : \"\"}. Mapping specifiers ending in \"/\" is no longer supported.`, \"DeprecationWarning\", \"DEP0155\");\n}\nfunction emitLegacyIndexDeprecation(url, packageJSONUrl, base, main) {\n  const format = defaultGetFormat(url);\n  if (format !== \"module\")\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL(\".\", packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(`Package ${pkgPath} has a \"main\" field set to ${JSONStringify(main)}, excluding the full filename and extension to the resolved file at \"${StringPrototypeSlice(path, pkgPath.length)}\", imported from ${basePath}.\n Automatic extension resolution of the \"main\" field is deprecated for ES modules.`, \"DeprecationWarning\", \"DEP0151\");\n  else\n    process.emitWarning(`No \"main\" or \"exports\" field defined in the package.json for ${pkgPath} resolving the main entry point \"${StringPrototypeSlice(path, pkgPath.length)}\", imported from ${basePath}.\nDefault \"index\" lookups for the main are deprecated for ES modules.`, \"DeprecationWarning\", \"DEP0151\");\n}\nfunction getConditionsSet(conditions) {\n  if (conditions !== void 0 && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE(\"conditions\", conditions, \"expected an array\");\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();\nconst tryStatSync = (path) => statSync(path, { throwIfNoEntry: false }) ?? new Stats();\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== void 0) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === void 0) {\n    const packageConfig2 = {\n      pjsonPath: path,\n      exists: false,\n      main: void 0,\n      name: void 0,\n      type: \"none\",\n      exports: void 0,\n      imports: void 0\n    };\n    packageJSONCache.set(path, packageConfig2);\n    return packageConfig2;\n  }\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `\"${specifier}\" from ` : \"\") + fileURLToPath(base || specifier), error.message);\n  }\n  let { imports, main, name, type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== \"object\" || imports === null)\n    imports = void 0;\n  if (typeof main !== \"string\")\n    main = void 0;\n  if (typeof name !== \"string\")\n    name = void 0;\n  if (type !== \"module\" && type !== \"commonjs\")\n    type = \"none\";\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main,\n    name,\n    type,\n    exports,\n    imports\n  };\n  packageJSONCache.set(path, packageConfig);\n  return packageConfig;\n}\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL(\"./package.json\", resolved);\n  while (true) {\n    const packageJSONPath2 = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath2, \"node_modules/package.json\"))\n      break;\n    const packageConfig2 = getPackageConfig(fileURLToPath(packageJSONUrl), resolved);\n    if (packageConfig2.exists)\n      return packageConfig2;\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL(\"../package.json\", packageJSONUrl);\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname)\n      break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: void 0,\n    name: void 0,\n    type: \"none\",\n    exports: void 0,\n    imports: void 0\n  };\n  packageJSONCache.set(packageJSONPath, packageConfig);\n  return packageConfig;\n}\nfunction fileExists(url) {\n  return statSync(url, { throwIfNoEntry: false })?.isFile() ?? false;\n}\nfunction legacyMainResolve(packageJSONUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== void 0) {\n    if (fileExists(guess = new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`, packageJSONUrl)))\n      ;\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`, packageJSONUrl)))\n      ;\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`, packageJSONUrl)))\n      ;\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`, packageJSONUrl)))\n      ;\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`, packageJSONUrl)))\n      ;\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`, packageJSONUrl)))\n      ;\n    else\n      guess = void 0;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess, packageJSONUrl, base, packageConfig.main);\n      return guess;\n    }\n  }\n  if (fileExists(guess = new URL(\"./index.js\", packageJSONUrl)))\n    ;\n  else if (fileExists(guess = new URL(\"./index.json\", packageJSONUrl)))\n    ;\n  else if (fileExists(guess = new URL(\"./index.node\", packageJSONUrl)))\n    ;\n  else\n    guess = void 0;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess, packageJSONUrl, base, packageConfig.main);\n    return guess;\n  }\n  throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL(\".\", packageJSONUrl)), fileURLToPath(base));\n}\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search))\n    return search;\n  return resolveExtensions(search);\n}\nconst extensions = [\".js\", \".json\", \".node\", \".mjs\"];\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`, search);\n    if (fileExists(guess))\n      return guess;\n  }\n  return void 0;\n}\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath, \"package.json\");\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath, main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL(\"index\", search));\n}\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved, base) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters', fileURLToPath(base));\n  const path = fileURLToPath(resolved);\n  if (getOptionValue(\"--experimental-specifier-resolution\") === \"node\") {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== void 0)\n      return file;\n    if (!StringPrototypeEndsWith(path, \"/\")) {\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\n      if (file !== void 0)\n        return file;\n    } else {\n      return resolveDirectoryEntry(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(resolved.pathname, fileURLToPath(base), \"module\");\n  }\n  const stats = tryStatSync(StringPrototypeEndsWith(path, \"/\") ? StringPrototypeSlice(path, -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, base && fileURLToPath(base), \"module\");\n  }\n  return resolved;\n}\nfunction throwImportNotDefined(specifier, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJSONUrl && fileURLToPath(new URL(\".\", packageJSONUrl)), fileURLToPath(base));\n}\nfunction throwExportsNotFound(subpath, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL(\".\", packageJSONUrl)), subpath, base && fileURLToPath(base));\n}\nfunction throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ? \"imports\" : \"exports\"}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && fileURLToPath(base));\n}\nfunction throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {\n  if (typeof target === \"object\" && target !== null) {\n    target = JSONStringify(target, null, \"\");\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL(\".\", packageJSONUrl)), subpath, target, internal, base && fileURLToPath(base));\n}\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\nfunction resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n  if (subpath !== \"\" && !pattern && target[target.length - 1] !== \"/\")\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  if (!StringPrototypeStartsWith(target, \"./\")) {\n    if (internal && !StringPrototypeStartsWith(target, \"../\") && !StringPrototypeStartsWith(target, \"/\")) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {\n      }\n      if (!isURL) {\n        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;\n        return packageResolve(exportTarget, packageJSONUrl, conditions);\n      }\n    }\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  }\n  if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  const resolved = new URL(target, packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL(\".\", packageJSONUrl).pathname;\n  if (!StringPrototypeStartsWith(resolvedPath, packagePath))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  if (subpath === \"\")\n    return resolved;\n  if (RegExpPrototypeTest(invalidSegmentRegEx, subpath)) {\n    const request = pattern ? StringPrototypeReplace(match, \"*\", () => subpath) : match + subpath;\n    throwInvalidSubpath(request, packageJSONUrl, internal, base);\n  }\n  if (pattern)\n    return new URL(RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath));\n  return new URL(subpath, resolved);\n}\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key)\n    return false;\n  return keyNum >= 0 && keyNum < 4294967295;\n}\nfunction resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {\n  if (typeof target === \"string\") {\n    return resolvePackageTargetString(target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal, conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === \"ERR_INVALID_PACKAGE_TARGET\")\n          continue;\n        throw e;\n      }\n      if (resolved === void 0)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === void 0 || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === \"object\" && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === \"default\" || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(packageJSONUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);\n        if (resolved === void 0)\n          continue;\n        return resolved;\n      }\n    }\n    return void 0;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal, base);\n}\nfunction isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n  if (typeof exports === \"string\" || ArrayIsArray(exports))\n    return true;\n  if (typeof exports !== \"object\" || exports === null)\n    return false;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === \"\" || key[0] !== \".\";\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, `\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);\n    }\n  }\n  return isConditionalSugar;\n}\nfunction packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))\n    exports = { \".\": exports };\n  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath) && !StringPrototypeIncludes(packageSubpath, \"*\") && !StringPrototypeEndsWith(packageSubpath, \"/\")) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(packageJSONUrl, target, \"\", packageSubpath, base, false, false, conditions);\n    if (resolved === null || resolved === void 0)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return resolved;\n  }\n  let bestMatch = \"\";\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key, \"*\");\n    if (patternIndex !== -1 && StringPrototypeStartsWith(packageSubpath, StringPrototypeSlice(key, 0, patternIndex))) {\n      if (StringPrototypeEndsWith(packageSubpath, \"/\"))\n        emitTrailingSlashPatternDeprecation(packageSubpath, packageJSONUrl, base);\n      const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);\n      if (packageSubpath.length >= key.length && StringPrototypeEndsWith(packageSubpath, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, \"*\") === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(packageSubpath, patternIndex, packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolved = resolvePackageTarget(packageJSONUrl, target, bestMatchSubpath, bestMatch, base, true, false, conditions);\n    if (resolved === null || resolved === void 0)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return resolved;\n  }\n  throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n}\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = StringPrototypeIndexOf(a, \"*\");\n  const bPatternIndex = StringPrototypeIndexOf(b, \"*\");\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB)\n    return -1;\n  if (baseLenB > baseLenA)\n    return 1;\n  if (aPatternIndex === -1)\n    return 1;\n  if (bPatternIndex === -1)\n    return -1;\n  if (a.length > b.length)\n    return -1;\n  if (b.length > a.length)\n    return 1;\n  return 0;\n}\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === \"#\" || StringPrototypeStartsWith(name, \"#/\") || StringPrototypeEndsWith(name, \"/\")) {\n    const reason = \"is not a valid internal imports specifier name\";\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, \"*\")) {\n        const resolved = resolvePackageTarget(packageJSONUrl, imports[name], \"\", name, base, false, true, conditions);\n        if (resolved !== null && resolved !== void 0)\n          return resolved;\n      } else {\n        let bestMatch = \"\";\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key, \"*\");\n          if (patternIndex !== -1 && StringPrototypeStartsWith(name, StringPrototypeSlice(key, 0, patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);\n            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, \"*\") === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(name, patternIndex, name.length - patternTrailer.length);\n            }\n          }\n        }\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolved = resolvePackageTarget(packageJSONUrl, target, bestMatchSubpath, bestMatch, base, true, true, conditions);\n          if (resolved !== null && resolved !== void 0)\n            return resolved;\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name, packageJSONUrl, base);\n}\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier, \"/\");\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === \"@\") {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(specifier, \"/\", separatorIndex + 1);\n    }\n  }\n  const packageName = separatorIndex === -1 ? specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === \"%\" || packageName[i] === \"\\\\\") {\n      validPackageName = false;\n      break;\n    }\n  }\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, \"is not a valid package name\", fileURLToPath(base));\n  }\n  const packageSubpath = \".\" + (separatorIndex === -1 ? \"\" : StringPrototypeSlice(specifier, separatorIndex));\n  return { packageName, packageSubpath, isScoped };\n}\nfunction packageResolve(specifier, base, conditions) {\n  const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl2 = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {\n      return packageExportsResolve(packageJSONUrl2, packageSubpath, packageConfig, base, conditions);\n    }\n  }\n  let packageJSONUrl = new URL(\"./node_modules/\" + packageName + \"/package.json\", base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0, packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ? \"../../../../node_modules/\" : \"../../../node_modules/\") + packageName + \"/package.json\", packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n    const packageConfig2 = getPackageConfig(packageJSONPath, specifier, base);\n    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null)\n      return packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig2, base, conditions);\n    if (packageSubpath === \".\")\n      return legacyMainResolve(packageJSONUrl, packageConfig2, base);\n    return new URL(packageSubpath, packageJSONUrl);\n  } while (packageJSONPath.length !== lastPath.length);\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n}\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== \"/\" && specifier[0] !== \".\";\n}\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === \".\") {\n    if (specifier.length === 1 || specifier[1] === \"/\")\n      return true;\n    if (specifier[1] === \".\") {\n      if (specifier.length === 2 || specifier[2] === \"/\")\n        return true;\n    }\n  }\n  return false;\n}\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === \"\")\n    return false;\n  if (specifier[0] === \"/\")\n    return true;\n  return isRelativeSpecifier(specifier);\n}\nfunction moduleResolve(specifier, base, conditions) {\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base);\n  } else if (specifier[0] === \"#\") {\n    resolved = packageImportsResolve(specifier, base, conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n  return finalizeResolution(resolved, base);\n}\nfunction resolveAsCommonJS(specifier, parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent, null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n    let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent, found);\n      if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      const pkg = StringPrototypeSplit(specifier, \"/\")[0];\n      const index = StringPrototypeIndexOf(found, pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found, index);\n      }\n    }\n    if (process.platform === \"win32\") {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`, \"g\"), found, \"/\");\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\nfunction defaultResolve(specifier, context = {}, defaultResolveUnused) {\n  let { parentURL, conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve: resolve2, reaction } = redirects;\n      const destination = resolve2(specifier, new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(parentURL, specifier, ArrayPrototypeJoin([...conditions], \", \")));\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === \"data:\") {\n      return {\n        url: specifier\n      };\n    }\n  } catch {\n  }\n  if (parsed && parsed.protocol === \"node:\")\n    return { url: specifier };\n  if (parsed && parsed.protocol !== \"file:\" && parsed.protocol !== \"data:\")\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: \"node:\" + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL, \"data:\")) {\n    new URL(specifier, parentURL);\n  }\n  const isMain = parentURL === void 0;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier, parentURL, conditions);\n  } catch (error) {\n    if (error.code === \"ERR_MODULE_NOT_FOUND\" || error.code === \"ERR_UNSUPPORTED_DIR_IMPORT\") {\n      if (StringPrototypeStartsWith(specifier, \"file://\")) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier, parentURL);\n      if (found) {\n        const lines = StringPrototypeSplit(error.stack, \"\\n\");\n        const hint = `Did you mean to import ${found}?`;\n        error.stack = ArrayPrototypeShift(lines) + \"\\n\" + hint + \"\\n\" + ArrayPrototypeJoin(lines, \"\\n\");\n        error.message += `\n${hint}`;\n      }\n    }\n    throw error;\n  }\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath, {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(real + (StringPrototypeEndsWith(urlPath, sep) ? \"/\" : \"\"));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n  return { url: `${url}` };\n}\nmodule.exports = {\n  DEFAULT_CONDITIONS,\n  defaultResolve,\n  encodedSepRegEx,\n  getPackageScopeConfig,\n  getPackageType,\n  packageExportsResolve,\n  packageImportsResolve\n};\nconst { defaultGetFormat } = require(\"internal/modules/esm/get_format\");\n}"],["internal/modules/esm/translators.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeMap,\n  Boolean,\n  JSONParse,\n  ObjectGetPrototypeOf,\n  ObjectPrototypeHasOwnProperty,\n  ObjectKeys,\n  PromisePrototypeThen,\n  PromiseReject,\n  SafeArrayIterator,\n  SafeMap,\n  SafeSet,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n  SyntaxErrorPrototype,\n  globalThis: { WebAssembly }\n} = primordials;\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null)\n    return _TYPES;\n  return _TYPES = require(\"internal/util/types\");\n}\nconst { readFileSync } = require(\"fs\");\nconst { extname, isAbsolute } = require(\"path\");\nconst {\n  hasEsmSyntax,\n  loadNativeModule,\n  stripBOM\n} = require(\"internal/modules/cjs/helpers\");\nconst {\n  Module: CJSModule,\n  cjsParseCache\n} = require(\"internal/modules/cjs/loader\");\nconst internalURLModule = require(\"internal/url\");\nconst createDynamicModule = require(\"internal/modules/esm/create_dynamic_module\");\nconst { fileURLToPath, URL } = require(\"url\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"esm\", (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require(\"internal/util\");\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE,\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require(\"internal/errors\").codes;\nconst { maybeCacheSourceMap } = require(\"internal/source_map/source_map_cache\");\nconst moduleWrap = internalBinding(\"module_wrap\");\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require(\"internal/options\");\nconst experimentalImportMetaResolve = getOptionValue(\"--experimental-import-meta-resolve\");\nconst asyncESM = require(\"internal/process/esm_loader\");\nconst { emitWarningSync } = require(\"internal/process/warning\");\nconst { TextDecoder } = require(\"internal/encoding\");\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === \"undefined\") {\n    cjsParse = require(\"internal/deps/cjs-module-lexer/lexer\").parse;\n  } else {\n    const { parse, init } = require(\"internal/deps/cjs-module-lexer/dist/lexer\");\n    await init();\n    cjsParse = parse;\n  }\n}\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\nlet DECODER = null;\nfunction assertBufferSource(body, allowString, hookName) {\n  if (allowString && typeof body === \"string\") {\n    return;\n  }\n  const { isArrayBufferView, isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(`${allowString ? \"string, \" : \"\"}array buffer, or typed array`, hookName, \"source\", body);\n}\nfunction stringify(body) {\n  if (typeof body === \"string\")\n    return body;\n  assertBufferSource(body, false, \"transformSource\");\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === \"file:\") {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\nasync function importModuleDynamically(specifier, { url }) {\n  return asyncESM.esmLoader.import(specifier, url);\n}\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier, parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(asyncESM.esmLoader.resolve(specifier, parentUrl), ({ url }) => url, (error) => error.code === \"ERR_UNSUPPORTED_DIR_IMPORT\" ? error.url : PromiseReject(error));\n  };\n}\nfunction initializeImportMeta(meta, { url }) {\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\ntranslators.set(\"module\", async function moduleStrategy(url, source, isMain) {\n  assertBufferSource(source, true, \"load\");\n  source = stringify(source);\n  maybeCacheSourceMap(url, source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url, void 0, source, 0, 0);\n  moduleWrap.callbackMap.set(module, {\n    initializeImportMeta,\n    importModuleDynamically\n  });\n  return module;\n});\nfunction enrichCJSError(err, content, filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype && hasEsmSyntax(content || readFileSync(filename, \"utf-8\"))) {\n    emitWarningSync('To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.');\n  }\n}\nconst isWindows = process.platform === \"win32\";\nconst winSepRegEx = /\\//g;\ntranslators.set(\"commonjs\", async function commonjsStrategy(url, source, isMain) {\n  debug(`Translating CJSModule ${url}`);\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename, winSepRegEx, \"\\\\\");\n  if (!cjsParse)\n    await initCJSParse();\n  const { module, exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has(\"default\") ? [...exportNames] : [\"default\", ...exportNames];\n  return new ModuleWrap(url, void 0, namesWithDefault, function() {\n    debug(`Loading CJSModule ${url}`);\n    let exports2;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports2 = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports2 = CJSModule._load(filename, void 0, isMain);\n      } catch (err) {\n        enrichCJSError(err, void 0, filename);\n        throw err;\n      }\n    }\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports2, exportName) || exportName === \"default\")\n        continue;\n      let value;\n      try {\n        value = exports2[exportName];\n      } catch {\n      }\n      this.setExport(exportName, value);\n    }\n    this.setExport(\"default\", exports2);\n  });\n});\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module, exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n  let source;\n  try {\n    source = readFileSync(filename, \"utf8\");\n  } catch {\n  }\n  let exports2, reexports;\n  try {\n    ({ exports: exports2, reexports } = cjsParse(source || \"\"));\n  } catch {\n    exports2 = [];\n    reexports = [];\n  }\n  const exportNames = new SafeSet(new SafeArrayIterator(exports2));\n  cjsParseCache.set(module, { source, exportNames, loaded });\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports, (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport, module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === \".js\" || ext === \".cjs\" || !CJSModule._extensions[ext]) && isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n  return { module, exportNames };\n}\ntranslators.set(\"builtin\", async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  const id = StringPrototypeSlice(url, 5);\n  const module = loadNativeModule(id, url);\n  if (!StringPrototypeStartsWith(url, \"node:\") || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\ntranslators.set(\"json\", async function jsonStrategy(url, source) {\n  emitExperimentalWarning(\"Importing JSON modules\");\n  assertBufferSource(source, true, \"load\");\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url, \"file:\") ? fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ? StringPrototypeReplace(pathname, winSepRegEx, \"\\\\\") : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports2 = module.exports;\n      return new ModuleWrap(url, void 0, [\"default\"], function() {\n        this.setExport(\"default\", exports2);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports2 = module.exports;\n      return new ModuleWrap(url, void 0, [\"default\"], function() {\n        this.setExport(\"default\", exports2);\n      });\n    }\n  }\n  try {\n    const exports2 = JSONParse(stripBOM(source));\n    module = {\n      exports: exports2,\n      loaded: true\n    };\n  } catch (err) {\n    err.message = errPath(url) + \": \" + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url, void 0, [\"default\"], function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport(\"default\", module.exports);\n  });\n});\ntranslators.set(\"wasm\", async function(url, source) {\n  emitExperimentalWarning(\"Importing Web Assembly modules\");\n  assertBufferSource(source, false, \"load\");\n  debug(`Translating WASMModule ${url}`);\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + \": \" + err.message;\n    throw err;\n  }\n  const imports = ArrayPrototypeMap(WebAssembly.Module.imports(compiled), ({ module }) => module);\n  const exports2 = ArrayPrototypeMap(WebAssembly.Module.exports(compiled), ({ name }) => name);\n  return createDynamicModule(imports, exports2, url, (reflect) => {\n    const { exports: exports3 } = new WebAssembly.Instance(compiled, reflect.imports);\n    for (const expt of ObjectKeys(exports3))\n      reflect.exports[expt].set(exports3[expt]);\n  }).module;\n});\n}"],["_http_agent.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  ArrayPrototypeSome,\n  ArrayPrototypeSplice,\n  FunctionPrototypeCall,\n  NumberIsNaN,\n  ObjectCreate,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  ObjectValues,\n  StringPrototypeIndexOf,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr,\n  Symbol\n} = primordials;\nconst net = require(\"net\");\nconst EventEmitter = require(\"events\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http\", (fn) => {\n  debug = fn;\n});\nconst { AsyncResource } = require(\"async_hooks\");\nconst { async_id_symbol } = require(\"internal/async_hooks\").symbols;\nconst {\n  codes: {\n    ERR_OUT_OF_RANGE\n  }\n} = require(\"internal/errors\");\nconst { once } = require(\"internal/util\");\nconst {\n  validateNumber,\n  validateOneOf,\n  validateString\n} = require(\"internal/validators\");\nconst kOnKeylog = Symbol(\"onkeylog\");\nconst kRequestOptions = Symbol(\"requestOptions\");\nconst kRequestAsyncResource = Symbol(\"requestAsyncResource\");\nclass ReusedHandle {\n  constructor(type, handle) {\n    this.type = type;\n    this.handle = handle;\n  }\n}\nfunction freeSocketErrorListener(err) {\n  const socket = this;\n  debug(\"SOCKET ERROR on FREE socket:\", err.message, err.stack);\n  socket.destroy();\n  socket.emit(\"agentRemove\");\n}\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n  FunctionPrototypeCall(EventEmitter, this);\n  this.defaultPort = 80;\n  this.protocol = \"http:\";\n  this.options = { __proto__: null, ...options };\n  this.options.path = null;\n  this.requests = ObjectCreate(null);\n  this.sockets = ObjectCreate(null);\n  this.freeSockets = ObjectCreate(null);\n  this.keepAliveMsecs = this.options.keepAliveMsecs || 1e3;\n  this.keepAlive = this.options.keepAlive || false;\n  this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;\n  this.maxFreeSockets = this.options.maxFreeSockets || 256;\n  this.scheduling = this.options.scheduling || \"lifo\";\n  this.maxTotalSockets = this.options.maxTotalSockets;\n  this.totalSocketCount = 0;\n  validateOneOf(this.scheduling, \"scheduling\", [\"fifo\", \"lifo\"]);\n  if (this.maxTotalSockets !== void 0) {\n    validateNumber(this.maxTotalSockets, \"maxTotalSockets\");\n    if (this.maxTotalSockets <= 0 || NumberIsNaN(this.maxTotalSockets))\n      throw new ERR_OUT_OF_RANGE(\"maxTotalSockets\", \"> 0\", this.maxTotalSockets);\n  } else {\n    this.maxTotalSockets = Infinity;\n  }\n  this.on(\"free\", (socket, options2) => {\n    const name = this.getName(options2);\n    debug(\"agent.on(free)\", name);\n    if (!socket.writable) {\n      socket.destroy();\n      return;\n    }\n    const requests = this.requests[name];\n    if (requests && requests.length) {\n      const req2 = ArrayPrototypeShift(requests);\n      const reqAsyncRes = req2[kRequestAsyncResource];\n      if (reqAsyncRes) {\n        reqAsyncRes.runInAsyncScope(() => {\n          asyncResetHandle(socket);\n          setRequestSocket(this, req2, socket);\n        });\n        req2[kRequestAsyncResource] = null;\n      } else {\n        setRequestSocket(this, req2, socket);\n      }\n      if (requests.length === 0) {\n        delete this.requests[name];\n      }\n      return;\n    }\n    const req = socket._httpMessage;\n    if (!req || !req.shouldKeepAlive || !this.keepAlive) {\n      socket.destroy();\n      return;\n    }\n    const freeSockets = this.freeSockets[name] || [];\n    const freeLen = freeSockets.length;\n    let count = freeLen;\n    if (this.sockets[name])\n      count += this.sockets[name].length;\n    if (this.totalSocketCount > this.maxTotalSockets || count > this.maxSockets || freeLen >= this.maxFreeSockets || !this.keepSocketAlive(socket)) {\n      socket.destroy();\n      return;\n    }\n    this.freeSockets[name] = freeSockets;\n    socket[async_id_symbol] = -1;\n    socket._httpMessage = null;\n    this.removeSocket(socket, options2);\n    socket.once(\"error\", freeSocketErrorListener);\n    ArrayPrototypePush(freeSockets, socket);\n  });\n  this.on(\"newListener\", maybeEnableKeylog);\n}\nObjectSetPrototypeOf(Agent.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(Agent, EventEmitter);\nfunction maybeEnableKeylog(eventName) {\n  if (eventName === \"keylog\") {\n    this.removeListener(\"newListener\", maybeEnableKeylog);\n    const agent = this;\n    this[kOnKeylog] = function onkeylog(keylog) {\n      agent.emit(\"keylog\", keylog, this);\n    };\n    const sockets = ObjectValues(this.sockets);\n    for (let i = 0; i < sockets.length; i++) {\n      sockets[i].on(\"keylog\", this[kOnKeylog]);\n    }\n  }\n}\nAgent.defaultMaxSockets = Infinity;\nAgent.prototype.createConnection = net.createConnection;\nAgent.prototype.getName = function getName(options) {\n  let name = options.host || \"localhost\";\n  name += \":\";\n  if (options.port)\n    name += options.port;\n  name += \":\";\n  if (options.localAddress)\n    name += options.localAddress;\n  if (options.family === 4 || options.family === 6)\n    name += `:${options.family}`;\n  if (options.socketPath)\n    name += `:${options.socketPath}`;\n  return name;\n};\nAgent.prototype.addRequest = function addRequest(req, options, port, localAddress) {\n  if (typeof options === \"string\") {\n    options = {\n      __proto__: null,\n      host: options,\n      port,\n      localAddress\n    };\n  }\n  options = { __proto__: null, ...options, ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n  if (!options.servername && options.servername !== \"\")\n    options.servername = calculateServerName(options, req);\n  const name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n  const freeSockets = this.freeSockets[name];\n  let socket;\n  if (freeSockets) {\n    while (freeSockets.length && freeSockets[0].destroyed) {\n      ArrayPrototypeShift(freeSockets);\n    }\n    socket = this.scheduling === \"fifo\" ? ArrayPrototypeShift(freeSockets) : ArrayPrototypePop(freeSockets);\n    if (!freeSockets.length)\n      delete this.freeSockets[name];\n  }\n  const freeLen = freeSockets ? freeSockets.length : 0;\n  const sockLen = freeLen + this.sockets[name].length;\n  if (socket) {\n    asyncResetHandle(socket);\n    this.reuseSocket(socket, req);\n    setRequestSocket(this, req, socket);\n    ArrayPrototypePush(this.sockets[name], socket);\n    this.totalSocketCount++;\n  } else if (sockLen < this.maxSockets && this.totalSocketCount < this.maxTotalSockets) {\n    debug(\"call onSocket\", sockLen, freeLen);\n    this.createSocket(req, options, (err, socket2) => {\n      if (err)\n        req.onSocket(socket2, err);\n      else\n        setRequestSocket(this, req, socket2);\n    });\n  } else {\n    debug(\"wait for socket\");\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n    req[kRequestOptions] = options;\n    req[kRequestAsyncResource] = new AsyncResource(\"QueuedRequest\");\n    ArrayPrototypePush(this.requests[name], req);\n  }\n};\nAgent.prototype.createSocket = function createSocket(req, options, cb) {\n  options = { __proto__: null, ...options, ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n  if (!options.servername && options.servername !== \"\")\n    options.servername = calculateServerName(options, req);\n  const name = this.getName(options);\n  options._agentKey = name;\n  debug(\"createConnection\", name, options);\n  options.encoding = null;\n  const oncreate = once((err, s) => {\n    if (err)\n      return cb(err);\n    if (!this.sockets[name]) {\n      this.sockets[name] = [];\n    }\n    ArrayPrototypePush(this.sockets[name], s);\n    this.totalSocketCount++;\n    debug(\"sockets\", name, this.sockets[name].length, this.totalSocketCount);\n    installListeners(this, s, options);\n    cb(null, s);\n  });\n  const newSocket = this.createConnection(options, oncreate);\n  if (newSocket)\n    oncreate(null, newSocket);\n};\nfunction calculateServerName(options, req) {\n  let servername = options.host;\n  const hostHeader = req.getHeader(\"host\");\n  if (hostHeader) {\n    validateString(hostHeader, \"options.headers.host\");\n    if (StringPrototypeStartsWith(hostHeader, \"[\")) {\n      const index = StringPrototypeIndexOf(hostHeader, \"]\");\n      if (index === -1) {\n        servername = hostHeader;\n      } else {\n        servername = StringPrototypeSubstr(hostHeader, 1, index - 1);\n      }\n    } else {\n      servername = StringPrototypeSplit(hostHeader, \":\", 1)[0];\n    }\n  }\n  if (net.isIP(servername))\n    servername = \"\";\n  return servername;\n}\nfunction installListeners(agent, s, options) {\n  function onFree() {\n    debug(\"CLIENT socket onFree\");\n    agent.emit(\"free\", s, options);\n  }\n  s.on(\"free\", onFree);\n  function onClose(err) {\n    debug(\"CLIENT socket onClose\");\n    agent.removeSocket(s, options);\n  }\n  s.on(\"close\", onClose);\n  function onTimeout() {\n    debug(\"CLIENT socket onTimeout\");\n    const sockets = agent.freeSockets;\n    if (ArrayPrototypeSome(ObjectKeys(sockets), (name) => ArrayPrototypeIncludes(sockets[name], s))) {\n      return s.destroy();\n    }\n  }\n  s.on(\"timeout\", onTimeout);\n  function onRemove() {\n    debug(\"CLIENT socket onRemove\");\n    agent.removeSocket(s, options);\n    s.removeListener(\"close\", onClose);\n    s.removeListener(\"free\", onFree);\n    s.removeListener(\"timeout\", onTimeout);\n    s.removeListener(\"agentRemove\", onRemove);\n  }\n  s.on(\"agentRemove\", onRemove);\n  if (agent[kOnKeylog]) {\n    s.on(\"keylog\", agent[kOnKeylog]);\n  }\n}\nAgent.prototype.removeSocket = function removeSocket(s, options) {\n  const name = this.getName(options);\n  debug(\"removeSocket\", name, \"writable:\", s.writable);\n  const sets = [this.sockets];\n  if (!s.writable)\n    ArrayPrototypePush(sets, this.freeSockets);\n  for (let sk = 0; sk < sets.length; sk++) {\n    const sockets = sets[sk];\n    if (sockets[name]) {\n      const index = ArrayPrototypeIndexOf(sockets[name], s);\n      if (index !== -1) {\n        ArrayPrototypeSplice(sockets[name], index, 1);\n        if (sockets[name].length === 0)\n          delete sockets[name];\n        this.totalSocketCount--;\n      }\n    }\n  }\n  let req;\n  if (this.requests[name] && this.requests[name].length) {\n    debug(\"removeSocket, have a request, make a socket\");\n    req = this.requests[name][0];\n  } else {\n    const keys = ObjectKeys(this.requests);\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i];\n      if (this.sockets[prop] && this.sockets[prop].length)\n        break;\n      debug(\"removeSocket, have a request with different origin, make a socket\");\n      req = this.requests[prop][0];\n      options = req[kRequestOptions];\n      break;\n    }\n  }\n  if (req && options) {\n    req[kRequestOptions] = void 0;\n    this.createSocket(req, options, (err, socket) => {\n      if (err)\n        req.onSocket(socket, err);\n      else\n        socket.emit(\"free\");\n    });\n  }\n};\nAgent.prototype.keepSocketAlive = function keepSocketAlive(socket) {\n  socket.setKeepAlive(true, this.keepAliveMsecs);\n  socket.unref();\n  const agentTimeout = this.options.timeout || 0;\n  if (socket.timeout !== agentTimeout) {\n    socket.setTimeout(agentTimeout);\n  }\n  return true;\n};\nAgent.prototype.reuseSocket = function reuseSocket(socket, req) {\n  debug(\"have free socket\");\n  socket.removeListener(\"error\", freeSocketErrorListener);\n  req.reusedSocket = true;\n  socket.ref();\n};\nAgent.prototype.destroy = function destroy() {\n  const sets = [this.freeSockets, this.sockets];\n  for (let s = 0; s < sets.length; s++) {\n    const set = sets[s];\n    const keys = ObjectKeys(set);\n    for (let v = 0; v < keys.length; v++) {\n      const setName = set[keys[v]];\n      for (let n = 0; n < setName.length; n++) {\n        setName[n].destroy();\n      }\n    }\n  }\n};\nfunction setRequestSocket(agent, req, socket) {\n  req.onSocket(socket);\n  const agentTimeout = agent.options.timeout || 0;\n  if (req.timeout === void 0 || req.timeout === agentTimeout) {\n    return;\n  }\n  socket.setTimeout(req.timeout);\n}\nfunction asyncResetHandle(socket) {\n  const handle = socket._handle;\n  if (handle && typeof handle.asyncReset === \"function\") {\n    handle.asyncReset(new ReusedHandle(handle.getProviderType(), socket));\n    socket[async_id_symbol] = handle.getAsyncId();\n  }\n}\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};\n}"],["_http_client.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  Boolean,\n  Error,\n  FunctionPrototypeCall,\n  NumberIsFinite,\n  ObjectAssign,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  RegExpPrototypeTest,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeToUpperCase,\n  Symbol,\n  TypedArrayPrototypeSlice\n} = primordials;\nconst net = require(\"net\");\nconst assert = require(\"internal/assert\");\nconst { once } = require(\"internal/util\");\nconst {\n  _checkIsHttpToken: checkIsHttpToken,\n  freeParser,\n  parsers,\n  HTTPParser,\n  isLenient,\n  prepareError\n} = require(\"_http_common\");\nconst { OutgoingMessage } = require(\"_http_outgoing\");\nconst Agent = require(\"_http_agent\");\nconst { Buffer } = require(\"buffer\");\nconst { defaultTriggerAsyncIdScope } = require(\"internal/async_hooks\");\nconst { URL, urlToHttpOptions, searchParamsSymbol } = require(\"internal/url\");\nconst { kOutHeaders, kNeedDrain } = require(\"internal/http\");\nconst { connResetException, codes } = require(\"internal/errors\");\nconst {\n  ERR_HTTP_HEADERS_SENT,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_HTTP_TOKEN,\n  ERR_INVALID_PROTOCOL,\n  ERR_UNESCAPED_CHARACTERS\n} = codes;\nconst {\n  validateInteger\n} = require(\"internal/validators\");\nconst { getTimerDuration } = require(\"internal/timers\");\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST,\n  DTRACE_HTTP_CLIENT_RESPONSE\n} = require(\"internal/dtrace\");\nconst { addAbortSignal, finished } = require(\"stream\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http\", (fn) => {\n  debug = fn;\n});\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst kError = Symbol(\"kError\");\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\nfunction validateHost(host, name) {\n  if (host !== null && host !== void 0 && typeof host !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(`options.${name}`, [\"string\", \"undefined\", \"null\"], host);\n  }\n  return host;\n}\nclass HTTPClientAsyncResource {\n  constructor(type, req) {\n    this.type = type;\n    this.req = req;\n  }\n}\nfunction ClientRequest(input, options, cb) {\n  FunctionPrototypeCall(OutgoingMessage, this);\n  if (typeof input === \"string\") {\n    const urlStr = input;\n    input = urlToHttpOptions(new URL(urlStr));\n  } else if (input && input[searchParamsSymbol] && input[searchParamsSymbol][searchParamsSymbol]) {\n    input = urlToHttpOptions(input);\n  } else {\n    cb = options;\n    options = input;\n    input = null;\n  }\n  if (typeof options === \"function\") {\n    cb = options;\n    options = input || {};\n  } else {\n    options = ObjectAssign(input || {}, options);\n  }\n  let agent = options.agent;\n  const defaultAgent = options._defaultAgent || Agent.globalAgent;\n  if (agent === false) {\n    agent = new defaultAgent.constructor();\n  } else if (agent === null || agent === void 0) {\n    if (typeof options.createConnection !== \"function\") {\n      agent = defaultAgent;\n    }\n  } else if (typeof agent.addRequest !== \"function\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.agent\", [\"Agent-like Object\", \"undefined\", \"false\"], agent);\n  }\n  this.agent = agent;\n  const protocol = options.protocol || defaultAgent.protocol;\n  let expectedProtocol = defaultAgent.protocol;\n  if (this.agent && this.agent.protocol)\n    expectedProtocol = this.agent.protocol;\n  if (options.path) {\n    const path = String(options.path);\n    if (RegExpPrototypeTest(INVALID_PATH_REGEX, path))\n      throw new ERR_UNESCAPED_CHARACTERS(\"Request path\");\n  }\n  if (protocol !== expectedProtocol) {\n    throw new ERR_INVALID_PROTOCOL(protocol, expectedProtocol);\n  }\n  const defaultPort = options.defaultPort || this.agent && this.agent.defaultPort;\n  const port = options.port = options.port || defaultPort || 80;\n  const host = options.host = validateHost(options.hostname, \"hostname\") || validateHost(options.host, \"host\") || \"localhost\";\n  const setHost = options.setHost === void 0 || Boolean(options.setHost);\n  this.socketPath = options.socketPath;\n  if (options.timeout !== void 0)\n    this.timeout = getTimerDuration(options.timeout, \"timeout\");\n  const signal = options.signal;\n  if (signal) {\n    addAbortSignal(signal, this);\n  }\n  let method = options.method;\n  const methodIsString = typeof method === \"string\";\n  if (method !== null && method !== void 0 && !methodIsString) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.method\", \"string\", method);\n  }\n  if (methodIsString && method) {\n    if (!checkIsHttpToken(method)) {\n      throw new ERR_INVALID_HTTP_TOKEN(\"Method\", method);\n    }\n    method = this.method = StringPrototypeToUpperCase(method);\n  } else {\n    method = this.method = \"GET\";\n  }\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== void 0)\n    validateInteger(maxHeaderSize, \"maxHeaderSize\", 0);\n  this.maxHeaderSize = maxHeaderSize;\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== void 0 && typeof insecureHTTPParser !== \"boolean\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.insecureHTTPParser\", \"boolean\", insecureHTTPParser);\n  }\n  this.insecureHTTPParser = insecureHTTPParser;\n  this.path = options.path || \"/\";\n  if (cb) {\n    this.once(\"response\", cb);\n  }\n  if (method === \"GET\" || method === \"HEAD\" || method === \"DELETE\" || method === \"OPTIONS\" || method === \"TRACE\" || method === \"CONNECT\") {\n    this.useChunkedEncodingByDefault = false;\n  } else {\n    this.useChunkedEncodingByDefault = true;\n  }\n  this._ended = false;\n  this.res = null;\n  this.aborted = false;\n  this.timeoutCb = null;\n  this.upgradeOrConnect = false;\n  this.parser = null;\n  this.maxHeadersCount = null;\n  this.reusedSocket = false;\n  this.host = host;\n  this.protocol = protocol;\n  if (this.agent) {\n    if (!this.agent.keepAlive && !NumberIsFinite(this.agent.maxSockets)) {\n      this._last = true;\n      this.shouldKeepAlive = false;\n    } else {\n      this._last = false;\n      this.shouldKeepAlive = true;\n    }\n  }\n  const headersArray = ArrayIsArray(options.headers);\n  if (!headersArray) {\n    if (options.headers) {\n      const keys = ObjectKeys(options.headers);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        this.setHeader(key, options.headers[key]);\n      }\n    }\n    if (host && !this.getHeader(\"host\") && setHost) {\n      let hostHeader = host;\n      const posColon = StringPrototypeIndexOf(hostHeader, \":\");\n      if (posColon !== -1 && StringPrototypeIncludes(hostHeader, \":\", posColon + 1) && StringPrototypeCharCodeAt(hostHeader, 0) !== 91) {\n        hostHeader = `[${hostHeader}]`;\n      }\n      if (port && +port !== defaultPort) {\n        hostHeader += \":\" + port;\n      }\n      this.setHeader(\"Host\", hostHeader);\n    }\n    if (options.auth && !this.getHeader(\"Authorization\")) {\n      this.setHeader(\"Authorization\", \"Basic \" + Buffer.from(options.auth).toString(\"base64\"));\n    }\n    if (this.getHeader(\"expect\")) {\n      if (this._header) {\n        throw new ERR_HTTP_HEADERS_SENT(\"render\");\n      }\n      this._storeHeader(this.method + \" \" + this.path + \" HTTP/1.1\\r\\n\", this[kOutHeaders]);\n    }\n  } else {\n    this._storeHeader(this.method + \" \" + this.path + \" HTTP/1.1\\r\\n\", options.headers);\n  }\n  let optsWithoutSignal = options;\n  if (optsWithoutSignal.signal) {\n    optsWithoutSignal = ObjectAssign({}, options);\n    delete optsWithoutSignal.signal;\n  }\n  if (this.agent) {\n    this.agent.addRequest(this, optsWithoutSignal);\n  } else {\n    this._last = true;\n    this.shouldKeepAlive = false;\n    if (typeof optsWithoutSignal.createConnection === \"function\") {\n      const oncreate = once((err, socket) => {\n        if (err) {\n          process.nextTick(() => this.emit(\"error\", err));\n        } else {\n          this.onSocket(socket);\n        }\n      });\n      try {\n        const newSocket = optsWithoutSignal.createConnection(optsWithoutSignal, oncreate);\n        if (newSocket) {\n          oncreate(null, newSocket);\n        }\n      } catch (err) {\n        oncreate(err);\n      }\n    } else {\n      debug(\"CLIENT use net.createConnection\", optsWithoutSignal);\n      this.onSocket(net.createConnection(optsWithoutSignal));\n    }\n  }\n}\nObjectSetPrototypeOf(ClientRequest.prototype, OutgoingMessage.prototype);\nObjectSetPrototypeOf(ClientRequest, OutgoingMessage);\nClientRequest.prototype._finish = function _finish() {\n  DTRACE_HTTP_CLIENT_REQUEST(this, this.socket);\n  FunctionPrototypeCall(OutgoingMessage.prototype._finish, this);\n};\nClientRequest.prototype._implicitHeader = function _implicitHeader() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT(\"render\");\n  }\n  this._storeHeader(this.method + \" \" + this.path + \" HTTP/1.1\\r\\n\", this[kOutHeaders]);\n};\nClientRequest.prototype.abort = function abort() {\n  if (this.aborted) {\n    return;\n  }\n  this.aborted = true;\n  process.nextTick(emitAbortNT, this);\n  this.destroy();\n};\nClientRequest.prototype.destroy = function destroy(err) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n  if (this.res) {\n    this.res._dump();\n  }\n  this[kError] = err;\n  this.socket?.destroy(err);\n  return this;\n};\nfunction emitAbortNT(req) {\n  req.emit(\"abort\");\n}\nfunction ondrain() {\n  const msg = this._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit(\"drain\");\n  }\n}\nfunction socketCloseListener() {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug(\"HTTP socket close\");\n  socket.read();\n  const parser = socket.parser;\n  const res = req.res;\n  req.destroyed = true;\n  if (res) {\n    if (!res.complete) {\n      res.destroy(connResetException(\"aborted\"));\n    }\n    req._closed = true;\n    req.emit(\"close\");\n    if (!res.aborted && res.readable) {\n      res.push(null);\n    }\n  } else {\n    if (!req.socket._hadError) {\n      req.socket._hadError = true;\n      req.emit(\"error\", connResetException(\"socket hang up\"));\n    }\n    req._closed = true;\n    req.emit(\"close\");\n  }\n  if (req.outputData)\n    req.outputData.length = 0;\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n}\nfunction socketErrorListener(err) {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug(\"SOCKET ERROR:\", err.message, err.stack);\n  if (req) {\n    req.socket._hadError = true;\n    req.emit(\"error\", err);\n  }\n  const parser = socket.parser;\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n  socket.removeListener(\"data\", socketOnData);\n  socket.removeListener(\"end\", socketOnEnd);\n  socket.destroy();\n}\nfunction socketOnEnd() {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n  if (!req.res && !req.socket._hadError) {\n    req.socket._hadError = true;\n    req.emit(\"error\", connResetException(\"socket hang up\"));\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n  socket.destroy();\n}\nfunction socketOnData(d) {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n  assert(parser && parser.socket === socket);\n  const ret = parser.execute(d);\n  if (ret instanceof Error) {\n    prepareError(ret, parser, d);\n    debug(\"parse error\", ret);\n    freeParser(parser, req, socket);\n    socket.destroy();\n    req.socket._hadError = true;\n    req.emit(\"error\", ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    const bytesParsed = ret;\n    const res = parser.incoming;\n    req.res = res;\n    socket.removeListener(\"data\", socketOnData);\n    socket.removeListener(\"end\", socketOnEnd);\n    socket.removeListener(\"drain\", ondrain);\n    if (req.timeoutCb)\n      socket.removeListener(\"timeout\", req.timeoutCb);\n    socket.removeListener(\"timeout\", responseOnTimeout);\n    parser.finish();\n    freeParser(parser, req, socket);\n    const bodyHead = TypedArrayPrototypeSlice(d, bytesParsed, d.length);\n    const eventName = req.method === \"CONNECT\" ? \"connect\" : \"upgrade\";\n    if (req.listenerCount(eventName) > 0) {\n      req.upgradeOrConnect = true;\n      socket.emit(\"agentRemove\");\n      socket.removeListener(\"close\", socketCloseListener);\n      socket.removeListener(\"error\", socketErrorListener);\n      socket._httpMessage = null;\n      socket.readableFlowing = null;\n      req.emit(eventName, res, socket, bodyHead);\n      req.destroyed = true;\n      req._closed = true;\n      req.emit(\"close\");\n    } else {\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.complete && !statusIsInformational(parser.incoming.statusCode)) {\n    socket.removeListener(\"data\", socketOnData);\n    socket.removeListener(\"end\", socketOnEnd);\n    socket.removeListener(\"drain\", ondrain);\n    freeParser(parser, req, socket);\n  }\n}\nfunction statusIsInformational(status) {\n  return status < 200 && status >= 100 && status !== 101;\n}\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\n  const socket = this.socket;\n  const req = socket._httpMessage;\n  debug(\"AGENT incoming response!\");\n  if (req.res) {\n    socket.destroy();\n    return 0;\n  }\n  req.res = res;\n  if (res.upgrade)\n    return 2;\n  const method = req.method;\n  if (method === \"CONNECT\") {\n    res.upgrade = true;\n    return 2;\n  }\n  if (statusIsInformational(res.statusCode)) {\n    req.res = null;\n    if (res.statusCode === 100) {\n      req.emit(\"continue\");\n    }\n    req.emit(\"information\", {\n      statusCode: res.statusCode,\n      statusMessage: res.statusMessage,\n      httpVersion: res.httpVersion,\n      httpVersionMajor: res.httpVersionMajor,\n      httpVersionMinor: res.httpVersionMinor,\n      headers: res.headers,\n      rawHeaders: res.rawHeaders\n    });\n    return 1;\n  }\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    req.shouldKeepAlive = false;\n  }\n  DTRACE_HTTP_CLIENT_RESPONSE(socket, req);\n  req.res = res;\n  res.req = req;\n  res.on(\"end\", responseOnEnd);\n  req.on(\"prefinish\", requestOnPrefinish);\n  socket.on(\"timeout\", responseOnTimeout);\n  if (req.aborted || !req.emit(\"response\", res))\n    res._dump();\n  if (method === \"HEAD\")\n    return 1;\n  if (res.statusCode === 304) {\n    res.complete = true;\n    return 1;\n  }\n  return 0;\n}\nfunction responseKeepAlive(req) {\n  const socket = req.socket;\n  debug(\"AGENT socket keep-alive\");\n  if (req.timeoutCb) {\n    socket.setTimeout(0, req.timeoutCb);\n    req.timeoutCb = null;\n  }\n  socket.removeListener(\"close\", socketCloseListener);\n  socket.removeListener(\"error\", socketErrorListener);\n  socket.removeListener(\"data\", socketOnData);\n  socket.removeListener(\"end\", socketOnEnd);\n  const asyncId = socket._handle ? socket._handle.getAsyncId() : void 0;\n  defaultTriggerAsyncIdScope(asyncId, process.nextTick, emitFreeNT, req);\n  req.destroyed = true;\n  if (req.res) {\n    req.res.socket = null;\n  }\n}\nfunction responseOnEnd() {\n  const req = this.req;\n  const socket = req.socket;\n  if (socket) {\n    if (req.timeoutCb)\n      socket.removeListener(\"timeout\", emitRequestTimeout);\n    socket.removeListener(\"timeout\", responseOnTimeout);\n  }\n  req._ended = true;\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug(\"AGENT socket.destroySoon()\");\n      if (typeof socket.destroySoon === \"function\")\n        socket.destroySoon();\n      else\n        socket.end();\n    }\n    assert(!socket.writable);\n  } else if (req.finished && !this.aborted) {\n    responseKeepAlive(req);\n  }\n}\nfunction responseOnTimeout() {\n  const req = this._httpMessage;\n  if (!req)\n    return;\n  const res = req.res;\n  if (!res)\n    return;\n  res.emit(\"timeout\");\n}\nfunction requestOnPrefinish() {\n  const req = this;\n  if (req.shouldKeepAlive && req._ended)\n    responseKeepAlive(req);\n}\nfunction emitFreeNT(req) {\n  req._closed = true;\n  req.emit(\"close\");\n  if (req.socket) {\n    req.socket.emit(\"free\");\n  }\n}\nfunction tickOnSocket(req, socket) {\n  const parser = parsers.alloc();\n  req.socket = socket;\n  const lenient = req.insecureHTTPParser === void 0 ? isLenient() : req.insecureHTTPParser;\n  parser.initialize(HTTPParser.RESPONSE, new HTTPClientAsyncResource(\"HTTPINCOMINGMESSAGE\", req), req.maxHeaderSize || 0, lenient ? kLenientAll : kLenientNone, 0);\n  parser.socket = socket;\n  parser.outgoing = req;\n  req.parser = parser;\n  socket.parser = parser;\n  socket._httpMessage = req;\n  if (typeof req.maxHeadersCount === \"number\") {\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\n  }\n  parser.onIncoming = parserOnIncomingClient;\n  socket.on(\"error\", socketErrorListener);\n  socket.on(\"data\", socketOnData);\n  socket.on(\"end\", socketOnEnd);\n  socket.on(\"close\", socketCloseListener);\n  socket.on(\"drain\", ondrain);\n  if (req.timeout !== void 0 || req.agent && req.agent.options && req.agent.options.timeout) {\n    listenSocketTimeout(req);\n  }\n  req.emit(\"socket\", socket);\n}\nfunction emitRequestTimeout() {\n  const req = this._httpMessage;\n  if (req) {\n    req.emit(\"timeout\");\n  }\n}\nfunction listenSocketTimeout(req) {\n  if (req.timeoutCb) {\n    return;\n  }\n  req.timeoutCb = emitRequestTimeout;\n  if (req.socket) {\n    req.socket.once(\"timeout\", emitRequestTimeout);\n  } else {\n    req.on(\"socket\", (socket) => {\n      socket.once(\"timeout\", emitRequestTimeout);\n    });\n  }\n}\nClientRequest.prototype.onSocket = function onSocket(socket, err) {\n  process.nextTick(onSocketNT, this, socket, err);\n};\nfunction onSocketNT(req, socket, err) {\n  if (req.destroyed || err) {\n    let _destroy = function(req2, err2) {\n      if (!req2.aborted && !err2) {\n        err2 = connResetException(\"socket hang up\");\n      }\n      if (err2) {\n        req2.emit(\"error\", err2);\n      }\n      req2._closed = true;\n      req2.emit(\"close\");\n    };\n    req.destroyed = true;\n    if (socket) {\n      if (!err && req.agent && !socket.destroyed) {\n        socket.emit(\"free\");\n      } else {\n        finished(socket.destroy(err || req[kError]), (er) => {\n          if (er?.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n            er = null;\n          }\n          _destroy(req, er || err);\n        });\n        return;\n      }\n    }\n    _destroy(req, err || req[kError]);\n  } else {\n    tickOnSocket(req, socket);\n    req._flush();\n  }\n}\nClientRequest.prototype._deferToConnect = _deferToConnect;\nfunction _deferToConnect(method, arguments_) {\n  const callSocketMethod = () => {\n    if (method)\n      ReflectApply(this.socket[method], this.socket, arguments_);\n  };\n  const onSocket2 = () => {\n    if (this.socket.writable) {\n      callSocketMethod();\n    } else {\n      this.socket.once(\"connect\", callSocketMethod);\n    }\n  };\n  if (!this.socket) {\n    this.once(\"socket\", onSocket2);\n  } else {\n    onSocket2();\n  }\n}\nClientRequest.prototype.setTimeout = function setTimeout(msecs, callback) {\n  if (this._ended) {\n    return this;\n  }\n  listenSocketTimeout(this);\n  msecs = getTimerDuration(msecs, \"msecs\");\n  if (callback)\n    this.once(\"timeout\", callback);\n  if (this.socket) {\n    setSocketTimeout(this.socket, msecs);\n  } else {\n    this.once(\"socket\", (sock) => setSocketTimeout(sock, msecs));\n  }\n  return this;\n};\nfunction setSocketTimeout(sock, msecs) {\n  if (sock.connecting) {\n    sock.once(\"connect\", function() {\n      sock.setTimeout(msecs);\n    });\n  } else {\n    sock.setTimeout(msecs);\n  }\n}\nClientRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  this._deferToConnect(\"setNoDelay\", [noDelay]);\n};\nClientRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(enable, initialDelay) {\n  this._deferToConnect(\"setKeepAlive\", [enable, initialDelay]);\n};\nClientRequest.prototype.clearTimeout = function clearTimeout(cb) {\n  this.setTimeout(0, cb);\n};\nmodule.exports = {\n  ClientRequest\n};\n}"],["_http_common.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  MathMin,\n  Symbol,\n  RegExpPrototypeTest\n} = primordials;\nconst { setImmediate } = require(\"timers\");\nconst { methods, HTTPParser } = internalBinding(\"http_parser\");\nconst { getOptionValue } = require(\"internal/options\");\nconst insecureHTTPParser = getOptionValue(\"--insecure-http-parser\");\nconst FreeList = require(\"internal/freelist\");\nconst incoming = require(\"_http_incoming\");\nconst {\n  IncomingMessage,\n  readStart,\n  readStop\n} = incoming;\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http\", (fn) => {\n  debug = fn;\n});\nconst kIncomingMessage = Symbol(\"IncomingMessage\");\nconst kRequestTimeout = Symbol(\"RequestTimeout\");\nconst kOnMessageBegin = HTTPParser.kOnMessageBegin | 0;\nconst kOnHeaders = HTTPParser.kOnHeaders | 0;\nconst kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\nconst kOnBody = HTTPParser.kOnBody | 0;\nconst kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\nconst MAX_HEADER_PAIRS = 2e3;\nfunction parserOnHeaders(headers, url) {\n  if (this.maxHeaderPairs <= 0 || this._headers.length < this.maxHeaderPairs) {\n    this._headers.push(...headers);\n  }\n  this._url += url;\n}\nfunction parserOnHeadersComplete(versionMajor, versionMinor, headers, method, url, statusCode, statusMessage, upgrade, shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n  if (headers === void 0) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n  if (url === void 0) {\n    url = parser._url;\n    parser._url = \"\";\n  }\n  const ParserIncomingMessage = socket && socket.server && socket.server[kIncomingMessage] || IncomingMessage;\n  const incoming2 = parser.incoming = new ParserIncomingMessage(socket);\n  incoming2.httpVersionMajor = versionMajor;\n  incoming2.httpVersionMinor = versionMinor;\n  incoming2.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming2.url = url;\n  incoming2.upgrade = upgrade;\n  if (socket) {\n    debug(\"requestTimeout timer moved to req\");\n    incoming2[kRequestTimeout] = incoming2.socket[kRequestTimeout];\n    incoming2.socket[kRequestTimeout] = void 0;\n  }\n  let n = headers.length;\n  if (parser.maxHeaderPairs > 0)\n    n = MathMin(n, parser.maxHeaderPairs);\n  incoming2._addHeaderLines(headers, n);\n  if (typeof method === \"number\") {\n    incoming2.method = methods[method];\n  } else {\n    incoming2.statusCode = statusCode;\n    incoming2.statusMessage = statusMessage;\n  }\n  return parser.onIncoming(incoming2, shouldKeepAlive);\n}\nfunction parserOnBody(b, start, len) {\n  const stream = this.incoming;\n  if (stream === null)\n    return;\n  if (len > 0 && !stream._dumped) {\n    const slice = b.slice(start, start + len);\n    const ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n}\nfunction parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n  if (stream !== null) {\n    stream.complete = true;\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = \"\";\n    }\n    stream.push(null);\n  }\n  readStart(parser.socket);\n}\nconst parsers = new FreeList(\"parsers\", 1e3, function parsersCb() {\n  const parser = new HTTPParser();\n  cleanParser(parser);\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n  return parser;\n});\nfunction closeParserInstance(parser) {\n  parser.close();\n}\nfunction freeParser(parser, req, socket) {\n  if (parser) {\n    if (parser._consumed)\n      parser.unconsume();\n    cleanParser(parser);\n    if (parsers.free(parser) === false) {\n      setImmediate(closeParserInstance, parser);\n    } else {\n      parser.free();\n    }\n  }\n  if (req) {\n    req.parser = null;\n  }\n  if (socket) {\n    socket.parser = null;\n  }\n}\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\nfunction checkIsHttpToken(val) {\n  return RegExpPrototypeTest(tokenRegExp, val);\n}\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction checkInvalidHeaderChar(val) {\n  return RegExpPrototypeTest(headerCharRegex, val);\n}\nfunction cleanParser(parser) {\n  parser._headers = [];\n  parser._url = \"\";\n  parser.socket = null;\n  parser.incoming = null;\n  parser.outgoing = null;\n  parser.maxHeaderPairs = MAX_HEADER_PAIRS;\n  parser[kOnMessageBegin] = null;\n  parser[kOnExecute] = null;\n  parser[kOnTimeout] = null;\n  parser._consumed = false;\n  parser.onIncoming = null;\n}\nfunction prepareError(err, parser, rawPacket) {\n  err.rawPacket = rawPacket || parser.getCurrentBuffer();\n  if (typeof err.reason === \"string\")\n    err.message = `Parse Error: ${err.reason}`;\n}\nlet warnedLenient = false;\nfunction isLenient() {\n  if (insecureHTTPParser && !warnedLenient) {\n    warnedLenient = true;\n    process.emitWarning(\"Using insecure HTTP parsing\");\n  }\n  return insecureHTTPParser;\n}\nmodule.exports = {\n  _checkInvalidHeaderChar: checkInvalidHeaderChar,\n  _checkIsHttpToken: checkIsHttpToken,\n  chunkExpression: /(?:^|\\W)chunked(?:$|\\W)/i,\n  continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i,\n  CRLF: \"\\r\\n\",\n  freeParser,\n  methods,\n  parsers,\n  kIncomingMessage,\n  kRequestTimeout,\n  HTTPParser,\n  isLenient,\n  prepareError\n};\n}"],["_http_incoming.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  StringPrototypeCharCodeAt,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase,\n  Symbol\n} = primordials;\nconst { Readable, finished } = require(\"stream\");\nconst kHeaders = Symbol(\"kHeaders\");\nconst kHeadersCount = Symbol(\"kHeadersCount\");\nconst kTrailers = Symbol(\"kTrailers\");\nconst kTrailersCount = Symbol(\"kTrailersCount\");\nfunction readStart(socket) {\n  if (socket && !socket._paused && socket.readable)\n    socket.resume();\n}\nfunction readStop(socket) {\n  if (socket)\n    socket.pause();\n}\nfunction IncomingMessage(socket) {\n  let streamOptions;\n  if (socket) {\n    streamOptions = {\n      highWaterMark: socket.readableHighWaterMark\n    };\n  }\n  Readable.call(this, streamOptions);\n  this._readableState.readingMore = true;\n  this.socket = socket;\n  this.httpVersionMajor = null;\n  this.httpVersionMinor = null;\n  this.httpVersion = null;\n  this.complete = false;\n  this[kHeaders] = null;\n  this[kHeadersCount] = 0;\n  this.rawHeaders = [];\n  this[kTrailers] = null;\n  this[kTrailersCount] = 0;\n  this.rawTrailers = [];\n  this.aborted = false;\n  this.upgrade = null;\n  this.url = \"\";\n  this.method = null;\n  this.statusCode = null;\n  this.statusMessage = null;\n  this.client = socket;\n  this._consuming = false;\n  this._dumped = false;\n}\nObjectSetPrototypeOf(IncomingMessage.prototype, Readable.prototype);\nObjectSetPrototypeOf(IncomingMessage, Readable);\nObjectDefineProperty(IncomingMessage.prototype, \"connection\", {\n  get: function() {\n    return this.socket;\n  },\n  set: function(val) {\n    this.socket = val;\n  }\n});\nObjectDefineProperty(IncomingMessage.prototype, \"headers\", {\n  get: function() {\n    if (!this[kHeaders]) {\n      this[kHeaders] = {};\n      const src = this.rawHeaders;\n      const dst = this[kHeaders];\n      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0], src[n + 1], dst);\n      }\n    }\n    return this[kHeaders];\n  },\n  set: function(val) {\n    this[kHeaders] = val;\n  }\n});\nObjectDefineProperty(IncomingMessage.prototype, \"trailers\", {\n  get: function() {\n    if (!this[kTrailers]) {\n      this[kTrailers] = {};\n      const src = this.rawTrailers;\n      const dst = this[kTrailers];\n      for (let n = 0; n < this[kTrailersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0], src[n + 1], dst);\n      }\n    }\n    return this[kTrailers];\n  },\n  set: function(val) {\n    this[kTrailers] = val;\n  }\n});\nIncomingMessage.prototype.setTimeout = function setTimeout(msecs, callback) {\n  if (callback)\n    this.on(\"timeout\", callback);\n  this.socket.setTimeout(msecs);\n  return this;\n};\nIncomingMessage.prototype._read = function _read(n) {\n  if (!this._consuming) {\n    this._readableState.readingMore = false;\n    this._consuming = true;\n  }\n  if (this.socket.readable)\n    readStart(this.socket);\n};\nIncomingMessage.prototype._destroy = function _destroy(err, cb) {\n  if (!this.readableEnded || !this.complete) {\n    this.aborted = true;\n    this.emit(\"aborted\");\n  }\n  if (this.socket && !this.socket.destroyed && this.aborted) {\n    this.socket.destroy(err);\n    const cleanup = finished(this.socket, (e) => {\n      if (e?.code === \"ERR_STREAM_PREMATURE_CLOSE\") {\n        e = null;\n      }\n      cleanup();\n      process.nextTick(onError, this, e || err, cb);\n    });\n  } else {\n    process.nextTick(onError, this, err, cb);\n  }\n};\nIncomingMessage.prototype._addHeaderLines = _addHeaderLines;\nfunction _addHeaderLines(headers, n) {\n  if (headers && headers.length) {\n    let dest;\n    if (this.complete) {\n      this.rawTrailers = headers;\n      this[kTrailersCount] = n;\n      dest = this[kTrailers];\n    } else {\n      this.rawHeaders = headers;\n      this[kHeadersCount] = n;\n      dest = this[kHeaders];\n    }\n    if (dest) {\n      for (let i = 0; i < n; i += 2) {\n        this._addHeaderLine(headers[i], headers[i + 1], dest);\n      }\n    }\n  }\n}\nfunction matchKnownFields(field, lowercased) {\n  switch (field.length) {\n    case 3:\n      if (field === \"Age\" || field === \"age\")\n        return \"age\";\n      break;\n    case 4:\n      if (field === \"Host\" || field === \"host\")\n        return \"host\";\n      if (field === \"From\" || field === \"from\")\n        return \"from\";\n      if (field === \"ETag\" || field === \"etag\")\n        return \"etag\";\n      if (field === \"Date\" || field === \"date\")\n        return \"\\0date\";\n      if (field === \"Vary\" || field === \"vary\")\n        return \"\\0vary\";\n      break;\n    case 6:\n      if (field === \"Server\" || field === \"server\")\n        return \"server\";\n      if (field === \"Cookie\" || field === \"cookie\")\n        return \"\u0002cookie\";\n      if (field === \"Origin\" || field === \"origin\")\n        return \"\\0origin\";\n      if (field === \"Expect\" || field === \"expect\")\n        return \"\\0expect\";\n      if (field === \"Accept\" || field === \"accept\")\n        return \"\\0accept\";\n      break;\n    case 7:\n      if (field === \"Referer\" || field === \"referer\")\n        return \"referer\";\n      if (field === \"Expires\" || field === \"expires\")\n        return \"expires\";\n      if (field === \"Upgrade\" || field === \"upgrade\")\n        return \"\\0upgrade\";\n      break;\n    case 8:\n      if (field === \"Location\" || field === \"location\")\n        return \"location\";\n      if (field === \"If-Match\" || field === \"if-match\")\n        return \"\\0if-match\";\n      break;\n    case 10:\n      if (field === \"User-Agent\" || field === \"user-agent\")\n        return \"user-agent\";\n      if (field === \"Set-Cookie\" || field === \"set-cookie\")\n        return \"\u0001\";\n      if (field === \"Connection\" || field === \"connection\")\n        return \"\\0connection\";\n      break;\n    case 11:\n      if (field === \"Retry-After\" || field === \"retry-after\")\n        return \"retry-after\";\n      break;\n    case 12:\n      if (field === \"Content-Type\" || field === \"content-type\")\n        return \"content-type\";\n      if (field === \"Max-Forwards\" || field === \"max-forwards\")\n        return \"max-forwards\";\n      break;\n    case 13:\n      if (field === \"Authorization\" || field === \"authorization\")\n        return \"authorization\";\n      if (field === \"Last-Modified\" || field === \"last-modified\")\n        return \"last-modified\";\n      if (field === \"Cache-Control\" || field === \"cache-control\")\n        return \"\\0cache-control\";\n      if (field === \"If-None-Match\" || field === \"if-none-match\")\n        return \"\\0if-none-match\";\n      break;\n    case 14:\n      if (field === \"Content-Length\" || field === \"content-length\")\n        return \"content-length\";\n      break;\n    case 15:\n      if (field === \"Accept-Encoding\" || field === \"accept-encoding\")\n        return \"\\0accept-encoding\";\n      if (field === \"Accept-Language\" || field === \"accept-language\")\n        return \"\\0accept-language\";\n      if (field === \"X-Forwarded-For\" || field === \"x-forwarded-for\")\n        return \"\\0x-forwarded-for\";\n      break;\n    case 16:\n      if (field === \"Content-Encoding\" || field === \"content-encoding\")\n        return \"\\0content-encoding\";\n      if (field === \"X-Forwarded-Host\" || field === \"x-forwarded-host\")\n        return \"\\0x-forwarded-host\";\n      break;\n    case 17:\n      if (field === \"If-Modified-Since\" || field === \"if-modified-since\")\n        return \"if-modified-since\";\n      if (field === \"Transfer-Encoding\" || field === \"transfer-encoding\")\n        return \"\\0transfer-encoding\";\n      if (field === \"X-Forwarded-Proto\" || field === \"x-forwarded-proto\")\n        return \"\\0x-forwarded-proto\";\n      break;\n    case 19:\n      if (field === \"Proxy-Authorization\" || field === \"proxy-authorization\")\n        return \"proxy-authorization\";\n      if (field === \"If-Unmodified-Since\" || field === \"if-unmodified-since\")\n        return \"if-unmodified-since\";\n      break;\n  }\n  if (lowercased) {\n    return \"\\0\" + field;\n  }\n  return matchKnownFields(StringPrototypeToLowerCase(field), true);\n}\nIncomingMessage.prototype._addHeaderLine = _addHeaderLine;\nfunction _addHeaderLine(field, value, dest) {\n  field = matchKnownFields(field);\n  const flag = StringPrototypeCharCodeAt(field, 0);\n  if (flag === 0 || flag === 2) {\n    field = StringPrototypeSlice(field, 1);\n    if (typeof dest[field] === \"string\") {\n      dest[field] += (flag === 0 ? \", \" : \"; \") + value;\n    } else {\n      dest[field] = value;\n    }\n  } else if (flag === 1) {\n    if (dest[\"set-cookie\"] !== void 0) {\n      dest[\"set-cookie\"].push(value);\n    } else {\n      dest[\"set-cookie\"] = [value];\n    }\n  } else if (dest[field] === void 0) {\n    dest[field] = value;\n  }\n}\nIncomingMessage.prototype._dump = function _dump() {\n  if (!this._dumped) {\n    this._dumped = true;\n    this.removeAllListeners(\"data\");\n    this.resume();\n  }\n};\nfunction onError(self, error, cb) {\n  if (self.listenerCount(\"error\") === 0) {\n    cb();\n  } else {\n    cb(error);\n  }\n}\nmodule.exports = {\n  IncomingMessage,\n  readStart,\n  readStop\n};\n}"],["_http_outgoing.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  MathFloor,\n  NumberPrototypeToString,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectKeys,\n  ObjectValues,\n  ObjectPrototypeHasOwnProperty,\n  ObjectSetPrototypeOf,\n  RegExpPrototypeTest,\n  StringPrototypeToLowerCase,\n  Symbol\n} = primordials;\nconst { getDefaultHighWaterMark } = require(\"internal/streams/state\");\nconst assert = require(\"internal/assert\");\nconst EE = require(\"events\");\nconst Stream = require(\"stream\");\nconst internalUtil = require(\"internal/util\");\nconst { kOutHeaders, utcDate, kNeedDrain } = require(\"internal/http\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  _checkIsHttpToken: checkIsHttpToken,\n  _checkInvalidHeaderChar: checkInvalidHeaderChar,\n  chunkExpression: RE_TE_CHUNKED\n} = require(\"_http_common\");\nconst {\n  defaultTriggerAsyncIdScope,\n  symbols: { async_id_symbol }\n} = require(\"internal/async_hooks\");\nconst {\n  codes: {\n    ERR_HTTP_HEADERS_SENT,\n    ERR_HTTP_INVALID_HEADER_VALUE,\n    ERR_HTTP_TRAILER_INVALID,\n    ERR_INVALID_HTTP_TOKEN,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_CHAR,\n    ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_ALREADY_FINISHED,\n    ERR_STREAM_WRITE_AFTER_END,\n    ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_DESTROYED\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst { validateString } = require(\"internal/validators\");\nconst { isUint8Array } = require(\"internal/util/types\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http\", (fn) => {\n  debug = fn;\n});\nconst HIGH_WATER_MARK = getDefaultHighWaterMark();\nconst kCorked = Symbol(\"corked\");\nconst nop = () => {\n};\nconst RE_CONN_CLOSE = /(?:^|\\W)close(?:$|\\W)/i;\nfunction isCookieField(s) {\n  return s.length === 6 && StringPrototypeToLowerCase(s) === \"cookie\";\n}\nfunction OutgoingMessage() {\n  Stream.call(this);\n  this.outputData = [];\n  this.outputSize = 0;\n  this.writable = true;\n  this.destroyed = false;\n  this._last = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.maxRequestsOnConnectionReached = false;\n  this._defaultKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n  this._removedConnection = false;\n  this._removedContLen = false;\n  this._removedTE = false;\n  this._contentLength = null;\n  this._hasBody = true;\n  this._trailer = \"\";\n  this[kNeedDrain] = false;\n  this.finished = false;\n  this._headerSent = false;\n  this[kCorked] = 0;\n  this._closed = false;\n  this.socket = null;\n  this._header = null;\n  this[kOutHeaders] = null;\n  this._keepAliveTimeout = 0;\n  this._onPendingData = nop;\n}\nObjectSetPrototypeOf(OutgoingMessage.prototype, Stream.prototype);\nObjectSetPrototypeOf(OutgoingMessage, Stream);\nObjectDefineProperty(OutgoingMessage.prototype, \"writableFinished\", {\n  get() {\n    return this.finished && this.outputSize === 0 && (!this.socket || this.socket.writableLength === 0);\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableObjectMode\", {\n  get() {\n    return false;\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableLength\", {\n  get() {\n    return this.outputSize + (this.socket ? this.socket.writableLength : 0);\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableHighWaterMark\", {\n  get() {\n    return this.socket ? this.socket.writableHighWaterMark : HIGH_WATER_MARK;\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableCorked\", {\n  get() {\n    const corked = this.socket ? this.socket.writableCorked : 0;\n    return corked + this[kCorked];\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"_headers\", {\n  get: internalUtil.deprecate(function() {\n    return this.getHeaders();\n  }, \"OutgoingMessage.prototype._headers is deprecated\", \"DEP0066\"),\n  set: internalUtil.deprecate(function(val) {\n    if (val == null) {\n      this[kOutHeaders] = null;\n    } else if (typeof val === \"object\") {\n      const headers = this[kOutHeaders] = ObjectCreate(null);\n      const keys = ObjectKeys(val);\n      for (let i = 0; i < keys.length; ++i) {\n        const name = keys[i];\n        headers[StringPrototypeToLowerCase(name)] = [name, val[name]];\n      }\n    }\n  }, \"OutgoingMessage.prototype._headers is deprecated\", \"DEP0066\")\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"connection\", {\n  get: function() {\n    return this.socket;\n  },\n  set: function(val) {\n    this.socket = val;\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"_headerNames\", {\n  get: internalUtil.deprecate(function() {\n    const headers = this[kOutHeaders];\n    if (headers !== null) {\n      const out = ObjectCreate(null);\n      const keys = ObjectKeys(headers);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const val = headers[key][0];\n        out[key] = val;\n      }\n      return out;\n    }\n    return null;\n  }, \"OutgoingMessage.prototype._headerNames is deprecated\", \"DEP0066\"),\n  set: internalUtil.deprecate(function(val) {\n    if (typeof val === \"object\" && val !== null) {\n      const headers = this[kOutHeaders];\n      if (!headers)\n        return;\n      const keys = ObjectKeys(val);\n      for (let i = 0; i < keys.length; ++i) {\n        const header = headers[keys[i]];\n        if (header)\n          header[0] = val[keys[i]];\n      }\n    }\n  }, \"OutgoingMessage.prototype._headerNames is deprecated\", \"DEP0066\")\n});\nOutgoingMessage.prototype._renderHeaders = function _renderHeaders() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT(\"render\");\n  }\n  const headersMap = this[kOutHeaders];\n  const headers = {};\n  if (headersMap !== null) {\n    const keys = ObjectKeys(headersMap);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const key = keys[i];\n      headers[headersMap[key][0]] = headersMap[key][1];\n    }\n  }\n  return headers;\n};\nOutgoingMessage.prototype.cork = function() {\n  if (this.socket) {\n    this.socket.cork();\n  } else {\n    this[kCorked]++;\n  }\n};\nOutgoingMessage.prototype.uncork = function() {\n  if (this.socket) {\n    this.socket.uncork();\n  } else if (this[kCorked]) {\n    this[kCorked]--;\n  }\n};\nOutgoingMessage.prototype.setTimeout = function setTimeout(msecs, callback) {\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n  if (!this.socket) {\n    this.once(\"socket\", function socketSetTimeoutOnConnect(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else {\n    this.socket.setTimeout(msecs);\n  }\n  return this;\n};\nOutgoingMessage.prototype.destroy = function destroy(error) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n  if (this.socket) {\n    this.socket.destroy(error);\n  } else {\n    this.once(\"socket\", function socketDestroyOnConnect(socket) {\n      socket.destroy(error);\n    });\n  }\n  return this;\n};\nOutgoingMessage.prototype._send = function _send(data, encoding, callback) {\n  if (!this._headerSent) {\n    if (typeof data === \"string\" && (encoding === \"utf8\" || encoding === \"latin1\" || !encoding)) {\n      data = this._header + data;\n    } else {\n      const header = this._header;\n      this.outputData.unshift({\n        data: header,\n        encoding: \"latin1\",\n        callback: null\n      });\n      this.outputSize += header.length;\n      this._onPendingData(header.length);\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data, encoding, callback);\n};\nOutgoingMessage.prototype._writeRaw = _writeRaw;\nfunction _writeRaw(data, encoding, callback) {\n  const conn = this.socket;\n  if (conn && conn.destroyed) {\n    return false;\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n  if (conn && conn._httpMessage === this && conn.writable) {\n    if (this.outputData.length) {\n      this._flushOutput(conn);\n    }\n    return conn.write(data, encoding, callback);\n  }\n  this.outputData.push({ data, encoding, callback });\n  this.outputSize += data.length;\n  this._onPendingData(data.length);\n  return this.outputSize < HIGH_WATER_MARK;\n}\nOutgoingMessage.prototype._storeHeader = _storeHeader;\nfunction _storeHeader(firstLine, headers) {\n  const state = {\n    connection: false,\n    contLen: false,\n    te: false,\n    date: false,\n    expect: false,\n    trailer: false,\n    header: firstLine\n  };\n  if (headers) {\n    if (headers === this[kOutHeaders]) {\n      for (const key in headers) {\n        const entry = headers[key];\n        processHeader(this, state, entry[0], entry[1], false);\n      }\n    } else if (ArrayIsArray(headers)) {\n      if (headers.length && ArrayIsArray(headers[0])) {\n        for (let i = 0; i < headers.length; i++) {\n          const entry = headers[i];\n          processHeader(this, state, entry[0], entry[1], true);\n        }\n      } else {\n        if (headers.length % 2 !== 0) {\n          throw new ERR_INVALID_ARG_VALUE(\"headers\", headers);\n        }\n        for (let n = 0; n < headers.length; n += 2) {\n          processHeader(this, state, headers[n + 0], headers[n + 1], true);\n        }\n      }\n    } else {\n      for (const key in headers) {\n        if (ObjectPrototypeHasOwnProperty(headers, key)) {\n          processHeader(this, state, key, headers[key], true);\n        }\n      }\n    }\n  }\n  let { header } = state;\n  if (this.sendDate && !state.date) {\n    header += \"Date: \" + utcDate() + \"\\r\\n\";\n  }\n  if (this.chunkedEncoding && (this.statusCode === 204 || this.statusCode === 304)) {\n    debug(this.statusCode + \" response should not use chunked encoding, closing connection.\");\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n  if (this._removedConnection) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n  } else if (!state.connection) {\n    const shouldSendKeepAlive = this.shouldKeepAlive && (state.contLen || this.useChunkedEncodingByDefault || this.agent);\n    if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {\n      header += \"Connection: close\\r\\n\";\n    } else if (shouldSendKeepAlive) {\n      header += \"Connection: keep-alive\\r\\n\";\n      if (this._keepAliveTimeout && this._defaultKeepAlive) {\n        const timeoutSeconds = MathFloor(this._keepAliveTimeout / 1e3);\n        header += `Keep-Alive: timeout=${timeoutSeconds}\\r\n`;\n      }\n    } else {\n      this._last = true;\n      header += \"Connection: close\\r\\n\";\n    }\n  }\n  if (!state.contLen && !state.te) {\n    if (!this._hasBody) {\n      this.chunkedEncoding = false;\n    } else if (!this.useChunkedEncodingByDefault) {\n      this._last = true;\n    } else if (!state.trailer && !this._removedContLen && typeof this._contentLength === \"number\") {\n      header += \"Content-Length: \" + this._contentLength + \"\\r\\n\";\n    } else if (!this._removedTE) {\n      header += \"Transfer-Encoding: chunked\\r\\n\";\n      this.chunkedEncoding = true;\n    } else {\n      debug(\"Both Content-Length and Transfer-Encoding are removed\");\n    }\n  }\n  if (this.chunkedEncoding !== true && state.trailer) {\n    throw new ERR_HTTP_TRAILER_INVALID();\n  }\n  this._header = header + \"\\r\\n\";\n  this._headerSent = false;\n  if (state.expect)\n    this._send(\"\");\n}\nfunction processHeader(self, state, key, value, validate) {\n  if (validate)\n    validateHeaderName(key);\n  if (ArrayIsArray(value)) {\n    if (value.length < 2 || !isCookieField(key)) {\n      for (let i = 0; i < value.length; i++)\n        storeHeader(self, state, key, value[i], validate);\n      return;\n    }\n    value = ArrayPrototypeJoin(value, \"; \");\n  }\n  storeHeader(self, state, key, value, validate);\n}\nfunction storeHeader(self, state, key, value, validate) {\n  if (validate)\n    validateHeaderValue(key, value);\n  state.header += key + \": \" + value + \"\\r\\n\";\n  matchHeader(self, state, key, value);\n}\nfunction matchHeader(self, state, field, value) {\n  if (field.length < 4 || field.length > 17)\n    return;\n  field = StringPrototypeToLowerCase(field);\n  switch (field) {\n    case \"connection\":\n      state.connection = true;\n      self._removedConnection = false;\n      if (RegExpPrototypeTest(RE_CONN_CLOSE, value))\n        self._last = true;\n      else\n        self.shouldKeepAlive = true;\n      break;\n    case \"transfer-encoding\":\n      state.te = true;\n      self._removedTE = false;\n      if (RegExpPrototypeTest(RE_TE_CHUNKED, value))\n        self.chunkedEncoding = true;\n      break;\n    case \"content-length\":\n      state.contLen = true;\n      self._removedContLen = false;\n      break;\n    case \"date\":\n    case \"expect\":\n    case \"trailer\":\n      state[field] = true;\n      break;\n    case \"keep-alive\":\n      self._defaultKeepAlive = false;\n      break;\n  }\n}\nconst validateHeaderName = hideStackFrames((name) => {\n  if (typeof name !== \"string\" || !name || !checkIsHttpToken(name)) {\n    throw new ERR_INVALID_HTTP_TOKEN(\"Header name\", name);\n  }\n});\nconst validateHeaderValue = hideStackFrames((name, value) => {\n  if (value === void 0) {\n    throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n  }\n  if (checkInvalidHeaderChar(value)) {\n    debug('Header \"%s\" contains invalid characters', name);\n    throw new ERR_INVALID_CHAR(\"header content\", name);\n  }\n});\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT(\"set\");\n  }\n  validateHeaderName(name);\n  validateHeaderValue(name, value);\n  let headers = this[kOutHeaders];\n  if (headers === null)\n    this[kOutHeaders] = headers = ObjectCreate(null);\n  headers[StringPrototypeToLowerCase(name)] = [name, value];\n  return this;\n};\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  validateString(name, \"name\");\n  const headers = this[kOutHeaders];\n  if (headers === null)\n    return;\n  const entry = headers[StringPrototypeToLowerCase(name)];\n  return entry && entry[1];\n};\nOutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {\n  return this[kOutHeaders] !== null ? ObjectKeys(this[kOutHeaders]) : [];\n};\nOutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {\n  const headersMap = this[kOutHeaders];\n  if (headersMap === null)\n    return [];\n  const values = ObjectValues(headersMap);\n  const headers = Array(values.length);\n  for (let i = 0, l = values.length; i < l; i++) {\n    headers[i] = values[i][0];\n  }\n  return headers;\n};\nOutgoingMessage.prototype.getHeaders = function getHeaders() {\n  const headers = this[kOutHeaders];\n  const ret = ObjectCreate(null);\n  if (headers) {\n    const keys = ObjectKeys(headers);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const val = headers[key][1];\n      ret[key] = val;\n    }\n  }\n  return ret;\n};\nOutgoingMessage.prototype.hasHeader = function hasHeader(name) {\n  validateString(name, \"name\");\n  return this[kOutHeaders] !== null && !!this[kOutHeaders][StringPrototypeToLowerCase(name)];\n};\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  validateString(name, \"name\");\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT(\"remove\");\n  }\n  const key = StringPrototypeToLowerCase(name);\n  switch (key) {\n    case \"connection\":\n      this._removedConnection = true;\n      break;\n    case \"content-length\":\n      this._removedContLen = true;\n      break;\n    case \"transfer-encoding\":\n      this._removedTE = true;\n      break;\n    case \"date\":\n      this.sendDate = false;\n      break;\n  }\n  if (this[kOutHeaders] !== null) {\n    delete this[kOutHeaders][key];\n  }\n};\nOutgoingMessage.prototype._implicitHeader = function _implicitHeader() {\n  throw new ERR_METHOD_NOT_IMPLEMENTED(\"_implicitHeader()\");\n};\nObjectDefineProperty(OutgoingMessage.prototype, \"headersSent\", {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return !!this._header;\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableEnded\", {\n  get: function() {\n    return this.finished;\n  }\n});\nObjectDefineProperty(OutgoingMessage.prototype, \"writableNeedDrain\", {\n  get: function() {\n    return !this.destroyed && !this.finished && this[kNeedDrain];\n  }\n});\nconst crlf_buf = Buffer.from(\"\\r\\n\");\nOutgoingMessage.prototype.write = function write(chunk, encoding, callback) {\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n  const ret = write_(this, chunk, encoding, callback, false);\n  if (!ret)\n    this[kNeedDrain] = true;\n  return ret;\n};\nfunction onError(msg, err, callback) {\n  const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol] : void 0;\n  defaultTriggerAsyncIdScope(triggerAsyncId, process.nextTick, emitErrorNt, msg, err, callback);\n}\nfunction emitErrorNt(msg, err, callback) {\n  callback(err);\n  if (typeof msg.emit === \"function\" && !msg._closed) {\n    msg.emit(\"error\", err);\n  }\n}\nfunction write_(msg, chunk, encoding, callback, fromEnd) {\n  if (typeof callback !== \"function\")\n    callback = nop;\n  let len;\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk === \"string\") {\n    len = Buffer.byteLength(chunk, encoding);\n  } else if (isUint8Array(chunk)) {\n    len = chunk.length;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n  }\n  let err;\n  if (msg.finished) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (msg.destroyed) {\n    err = new ERR_STREAM_DESTROYED(\"write\");\n  }\n  if (err) {\n    if (!msg.destroyed) {\n      onError(msg, err, callback);\n    } else {\n      process.nextTick(callback, err);\n    }\n    return false;\n  }\n  if (!msg._header) {\n    if (fromEnd) {\n      msg._contentLength = len;\n    }\n    msg._implicitHeader();\n  }\n  if (!msg._hasBody) {\n    debug(\"This type of response MUST NOT have a body. Ignoring write() calls.\");\n    process.nextTick(callback);\n    return true;\n  }\n  if (!fromEnd && msg.socket && !msg.socket.writableCorked) {\n    msg.socket.cork();\n    process.nextTick(connectionCorkNT, msg.socket);\n  }\n  let ret;\n  if (msg.chunkedEncoding && chunk.length !== 0) {\n    msg._send(NumberPrototypeToString(len, 16), \"latin1\", null);\n    msg._send(crlf_buf, null, null);\n    msg._send(chunk, encoding, null);\n    ret = msg._send(crlf_buf, null, callback);\n  } else {\n    ret = msg._send(chunk, encoding, callback);\n  }\n  debug(\"write ret = \" + ret);\n  return ret;\n}\nfunction connectionCorkNT(conn) {\n  conn.uncork();\n}\nOutgoingMessage.prototype.addTrailers = function addTrailers(headers) {\n  this._trailer = \"\";\n  const keys = ObjectKeys(headers);\n  const isArray = ArrayIsArray(headers);\n  for (let i = 0, l = keys.length; i < l; i++) {\n    let field, value;\n    const key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n    if (typeof field !== \"string\" || !field || !checkIsHttpToken(field)) {\n      throw new ERR_INVALID_HTTP_TOKEN(\"Trailer name\", field);\n    }\n    if (checkInvalidHeaderChar(value)) {\n      debug('Trailer \"%s\" contains invalid characters', field);\n      throw new ERR_INVALID_CHAR(\"trailer content\", field);\n    }\n    this._trailer += field + \": \" + value + \"\\r\\n\";\n  }\n};\nfunction onFinish(outmsg) {\n  if (outmsg && outmsg.socket && outmsg.socket._hadError)\n    return;\n  outmsg.emit(\"finish\");\n}\nOutgoingMessage.prototype.end = function end(chunk, encoding, callback) {\n  if (typeof chunk === \"function\") {\n    callback = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n  if (chunk) {\n    if (this.finished) {\n      onError(this, new ERR_STREAM_WRITE_AFTER_END(), typeof callback !== \"function\" ? nop : callback);\n      return this;\n    }\n    if (this.socket) {\n      this.socket.cork();\n    }\n    write_(this, chunk, encoding, null, true);\n  } else if (this.finished) {\n    if (typeof callback === \"function\") {\n      if (!this.writableFinished) {\n        this.on(\"finish\", callback);\n      } else {\n        callback(new ERR_STREAM_ALREADY_FINISHED(\"end\"));\n      }\n    }\n    return this;\n  } else if (!this._header) {\n    if (this.socket) {\n      this.socket.cork();\n    }\n    this._contentLength = 0;\n    this._implicitHeader();\n  }\n  if (typeof callback === \"function\")\n    this.once(\"finish\", callback);\n  const finish = onFinish.bind(void 0, this);\n  if (this._hasBody && this.chunkedEncoding) {\n    this._send(\"0\\r\\n\" + this._trailer + \"\\r\\n\", \"latin1\", finish);\n  } else {\n    this._send(\"\", \"latin1\", finish);\n  }\n  if (this.socket) {\n    this.socket._writableState.corked = 1;\n    this.socket.uncork();\n  }\n  this[kCorked] = 0;\n  this.finished = true;\n  debug(\"outgoing message end.\");\n  if (this.outputData.length === 0 && this.socket && this.socket._httpMessage === this) {\n    this._finish();\n  }\n  return this;\n};\nOutgoingMessage.prototype._finish = function _finish() {\n  assert(this.socket);\n  this.emit(\"prefinish\");\n};\nOutgoingMessage.prototype._flush = function _flush() {\n  const socket = this.socket;\n  if (socket && socket.writable) {\n    const ret = this._flushOutput(socket);\n    if (this.finished) {\n      this._finish();\n    } else if (ret && this[kNeedDrain]) {\n      this[kNeedDrain] = false;\n      this.emit(\"drain\");\n    }\n  }\n};\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\n  while (this[kCorked]) {\n    this[kCorked]--;\n    socket.cork();\n  }\n  const outputLength = this.outputData.length;\n  if (outputLength <= 0)\n    return void 0;\n  const outputData = this.outputData;\n  socket.cork();\n  let ret;\n  for (let i = 0; i < outputLength; i++) {\n    const { data, encoding, callback } = outputData[i];\n    ret = socket.write(data, encoding, callback);\n  }\n  socket.uncork();\n  this.outputData = [];\n  this._onPendingData(-this.outputSize);\n  this.outputSize = 0;\n  return ret;\n};\nOutgoingMessage.prototype.flushHeaders = function flushHeaders() {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n  this._send(\"\");\n};\nOutgoingMessage.prototype.pipe = function pipe() {\n  this.emit(\"error\", new ERR_STREAM_CANNOT_PIPE());\n};\nOutgoingMessage.prototype[EE.captureRejectionSymbol] = function(err, event) {\n  this.destroy(err);\n};\nmodule.exports = {\n  validateHeaderName,\n  validateHeaderValue,\n  OutgoingMessage\n};\n}"],["_http_server.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  Error,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  RegExpPrototypeTest,\n  Symbol,\n  SymbolFor\n} = primordials;\nconst net = require(\"net\");\nconst EE = require(\"events\");\nconst assert = require(\"internal/assert\");\nconst {\n  parsers,\n  freeParser,\n  continueExpression,\n  chunkExpression,\n  kIncomingMessage,\n  kRequestTimeout,\n  HTTPParser,\n  isLenient,\n  _checkInvalidHeaderChar: checkInvalidHeaderChar,\n  prepareError\n} = require(\"_http_common\");\nconst { OutgoingMessage } = require(\"_http_outgoing\");\nconst {\n  kOutHeaders,\n  kNeedDrain,\n  emitStatistics\n} = require(\"internal/http\");\nconst {\n  defaultTriggerAsyncIdScope,\n  getOrSetAsyncId\n} = require(\"internal/async_hooks\");\nconst { IncomingMessage } = require(\"_http_incoming\");\nconst {\n  connResetException,\n  codes\n} = require(\"internal/errors\");\nconst {\n  ERR_HTTP_REQUEST_TIMEOUT,\n  ERR_HTTP_HEADERS_SENT,\n  ERR_HTTP_INVALID_STATUS_CODE,\n  ERR_HTTP_SOCKET_ENCODING,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_CHAR\n} = codes;\nconst {\n  validateInteger,\n  validateBoolean\n} = require(\"internal/validators\");\nconst Buffer = require(\"buffer\").Buffer;\nconst {\n  DTRACE_HTTP_SERVER_REQUEST,\n  DTRACE_HTTP_SERVER_RESPONSE\n} = require(\"internal/dtrace\");\nconst { setTimeout, clearTimeout } = require(\"timers\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"http\", (fn) => {\n  debug = fn;\n});\nconst dc = require(\"diagnostics_channel\");\nconst onRequestStartChannel = dc.channel(\"http.server.request.start\");\nconst onResponseFinishChannel = dc.channel(\"http.server.response.finish\");\nconst kServerResponse = Symbol(\"ServerResponse\");\nconst kServerResponseStatistics = Symbol(\"ServerResponseStatistics\");\nconst {\n  hasObserver\n} = require(\"internal/perf/observe\");\nconst STATUS_CODES = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\"\n};\nconst kOnMessageBegin = HTTPParser.kOnMessageBegin | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\nclass HTTPServerAsyncResource {\n  constructor(type, socket) {\n    this.type = type;\n    this.socket = socket;\n  }\n}\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n  if (req.method === \"HEAD\")\n    this._hasBody = false;\n  this.req = req;\n  this.sendDate = true;\n  this._sent100 = false;\n  this._expect_continue = false;\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = RegExpPrototypeTest(chunkExpression, req.headers.te);\n    this.shouldKeepAlive = false;\n  }\n  if (hasObserver(\"http\")) {\n    this[kServerResponseStatistics] = {\n      startTime: process.hrtime()\n    };\n  }\n}\nObjectSetPrototypeOf(ServerResponse.prototype, OutgoingMessage.prototype);\nObjectSetPrototypeOf(ServerResponse, OutgoingMessage);\nServerResponse.prototype._finish = function _finish() {\n  DTRACE_HTTP_SERVER_RESPONSE(this.socket);\n  emitStatistics(this[kServerResponseStatistics]);\n  OutgoingMessage.prototype._finish.call(this);\n};\nServerResponse.prototype.statusCode = 200;\nServerResponse.prototype.statusMessage = void 0;\nfunction onServerResponseClose() {\n  if (this._httpMessage) {\n    emitCloseNT(this._httpMessage);\n  }\n}\nServerResponse.prototype.assignSocket = function assignSocket(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on(\"close\", onServerResponseClose);\n  this.socket = socket;\n  this.emit(\"socket\", socket);\n  this._flush();\n};\nServerResponse.prototype.detachSocket = function detachSocket(socket) {\n  assert(socket._httpMessage === this);\n  socket.removeListener(\"close\", onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = null;\n};\nServerResponse.prototype.writeContinue = function writeContinue(cb) {\n  this._writeRaw(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\", \"ascii\", cb);\n  this._sent100 = true;\n};\nServerResponse.prototype.writeProcessing = function writeProcessing(cb) {\n  this._writeRaw(\"HTTP/1.1 102 Processing\\r\\n\\r\\n\", \"ascii\", cb);\n};\nServerResponse.prototype._implicitHeader = function _implicitHeader() {\n  this.writeHead(this.statusCode);\n};\nServerResponse.prototype.writeHead = writeHead;\nfunction writeHead(statusCode, reason, obj) {\n  const originalStatusCode = statusCode;\n  statusCode |= 0;\n  if (statusCode < 100 || statusCode > 999) {\n    throw new ERR_HTTP_INVALID_STATUS_CODE(originalStatusCode);\n  }\n  if (typeof reason === \"string\") {\n    this.statusMessage = reason;\n  } else {\n    if (!this.statusMessage)\n      this.statusMessage = STATUS_CODES[statusCode] || \"unknown\";\n    obj = reason;\n  }\n  this.statusCode = statusCode;\n  let headers;\n  if (this[kOutHeaders]) {\n    let k;\n    if (ArrayIsArray(obj)) {\n      if (obj.length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"headers\", obj);\n      }\n      for (let n = 0; n < obj.length; n += 2) {\n        k = obj[n + 0];\n        if (k)\n          this.setHeader(k, obj[n + 1]);\n      }\n    } else if (obj) {\n      const keys = ObjectKeys(obj);\n      for (let i = 0; i < keys.length; i++) {\n        k = keys[i];\n        if (k)\n          this.setHeader(k, obj[k]);\n      }\n    }\n    if (k === void 0 && this._header) {\n      throw new ERR_HTTP_HEADERS_SENT(\"render\");\n    }\n    headers = this[kOutHeaders];\n  } else {\n    headers = obj;\n  }\n  if (checkInvalidHeaderChar(this.statusMessage))\n    throw new ERR_INVALID_CHAR(\"statusMessage\");\n  const statusLine = `HTTP/1.1 ${statusCode} ${this.statusMessage}\\r\n`;\n  if (statusCode === 204 || statusCode === 304 || statusCode >= 100 && statusCode <= 199) {\n    this._hasBody = false;\n  }\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n  this._storeHeader(statusLine, headers);\n  return this;\n}\nServerResponse.prototype.writeHeader = ServerResponse.prototype.writeHead;\nfunction storeHTTPOptions(options) {\n  this[kIncomingMessage] = options.IncomingMessage || IncomingMessage;\n  this[kServerResponse] = options.ServerResponse || ServerResponse;\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== void 0)\n    validateInteger(maxHeaderSize, \"maxHeaderSize\", 0);\n  this.maxHeaderSize = maxHeaderSize;\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== void 0)\n    validateBoolean(insecureHTTPParser, \"options.insecureHTTPParser\");\n  this.insecureHTTPParser = insecureHTTPParser;\n}\nfunction Server(options, requestListener) {\n  if (!(this instanceof Server))\n    return new Server(options, requestListener);\n  if (typeof options === \"function\") {\n    requestListener = options;\n    options = {};\n  } else if (options == null || typeof options === \"object\") {\n    options = { ...options };\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"object\", options);\n  }\n  storeHTTPOptions.call(this, options);\n  net.Server.call(this, { allowHalfOpen: true });\n  if (requestListener) {\n    this.on(\"request\", requestListener);\n  }\n  this.httpAllowHalfOpen = false;\n  this.on(\"connection\", connectionListener);\n  this.timeout = 0;\n  this.keepAliveTimeout = 5e3;\n  this.maxHeadersCount = null;\n  this.maxRequestsPerSocket = null;\n  this.headersTimeout = 60 * 1e3;\n  this.requestTimeout = 0;\n}\nObjectSetPrototypeOf(Server.prototype, net.Server.prototype);\nObjectSetPrototypeOf(Server, net.Server);\nServer.prototype.setTimeout = function setTimeout2(msecs, callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on(\"timeout\", callback);\n  return this;\n};\nServer.prototype[EE.captureRejectionSymbol] = function(err, event, ...args) {\n  switch (event) {\n    case \"request\":\n      const { 1: res } = args;\n      if (!res.headersSent && !res.writableEnded) {\n        const names = res.getHeaderNames();\n        for (let i = 0; i < names.length; i++) {\n          res.removeHeader(names[i]);\n        }\n        res.statusCode = 500;\n        res.end(STATUS_CODES[500]);\n      } else {\n        res.destroy();\n      }\n      break;\n    default:\n      net.Server.prototype[SymbolFor(\"nodejs.rejection\")].apply(this, arguments);\n  }\n};\nfunction connectionListener(socket) {\n  defaultTriggerAsyncIdScope(getOrSetAsyncId(socket), connectionListenerInternal, this, socket);\n}\nfunction connectionListenerInternal(server, socket) {\n  debug(\"SERVER new http connection\");\n  socket.server = server;\n  if (server.timeout && typeof socket.setTimeout === \"function\")\n    socket.setTimeout(server.timeout);\n  socket.on(\"timeout\", socketOnTimeout);\n  const parser = parsers.alloc();\n  const lenient = server.insecureHTTPParser === void 0 ? isLenient() : server.insecureHTTPParser;\n  parser.initialize(HTTPParser.REQUEST, new HTTPServerAsyncResource(\"HTTPINCOMINGMESSAGE\", socket), server.maxHeaderSize || 0, lenient ? kLenientAll : kLenientNone, server.headersTimeout || 0);\n  parser.socket = socket;\n  socket.parser = parser;\n  if (typeof server.maxHeadersCount === \"number\") {\n    parser.maxHeaderPairs = server.maxHeadersCount << 1;\n  }\n  const state = {\n    onData: null,\n    onEnd: null,\n    onClose: null,\n    onDrain: null,\n    outgoing: [],\n    incoming: [],\n    outgoingData: 0,\n    requestsCount: 0,\n    keepAliveTimeoutSet: false\n  };\n  state.onData = socketOnData.bind(void 0, server, socket, parser, state);\n  state.onEnd = socketOnEnd.bind(void 0, server, socket, parser, state);\n  state.onClose = socketOnClose.bind(void 0, socket, state);\n  state.onDrain = socketOnDrain.bind(void 0, socket, state);\n  socket.on(\"data\", state.onData);\n  socket.on(\"error\", socketOnError);\n  socket.on(\"end\", state.onEnd);\n  socket.on(\"close\", state.onClose);\n  socket.on(\"drain\", state.onDrain);\n  parser.onIncoming = parserOnIncoming.bind(void 0, server, socket, state);\n  socket.on(\"resume\", onSocketResume);\n  socket.on(\"pause\", onSocketPause);\n  socket.on = generateSocketListenerWrapper(\"on\");\n  socket.addListener = generateSocketListenerWrapper(\"addListener\");\n  socket.prependListener = generateSocketListenerWrapper(\"prependListener\");\n  socket.setEncoding = socketSetEncoding;\n  if (socket._handle && socket._handle.isStreamBase && !socket._handle._consumed) {\n    parser._consumed = true;\n    socket._handle._consumed = true;\n    parser.consume(socket._handle);\n  }\n  parser[kOnExecute] = onParserExecute.bind(void 0, server, socket, parser, state);\n  parser[kOnTimeout] = onParserTimeout.bind(void 0, server, socket);\n  parser[kOnMessageBegin] = setRequestTimeout.bind(void 0, server, socket);\n  setRequestTimeout(server, socket);\n  socket._paused = false;\n}\nfunction socketSetEncoding() {\n  throw new ERR_HTTP_SOCKET_ENCODING();\n}\nfunction updateOutgoingData(socket, state, delta) {\n  state.outgoingData += delta;\n  socketOnDrain(socket, state);\n}\nfunction socketOnDrain(socket, state) {\n  const needPause = state.outgoingData > socket.writableHighWaterMark;\n  if (socket._paused && !needPause) {\n    socket._paused = false;\n    if (socket.parser)\n      socket.parser.resume();\n    socket.resume();\n  }\n  const msg = socket._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit(\"drain\");\n  }\n}\nfunction socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit(\"timeout\", this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit(\"timeout\", this);\n  const serverTimeout = this.server.emit(\"timeout\", this);\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n}\nfunction socketOnClose(socket, state) {\n  debug(\"server socket close\");\n  freeParser(socket.parser, null, socket);\n  abortIncoming(state.incoming);\n}\nfunction abortIncoming(incoming) {\n  while (incoming.length) {\n    const req = incoming.shift();\n    req.destroy(connResetException(\"aborted\"));\n  }\n}\nfunction socketOnEnd(server, socket, parser, state) {\n  const ret = parser.finish();\n  if (ret instanceof Error) {\n    debug(\"parse error\");\n    socketOnError.call(socket, ret);\n  } else if (!server.httpAllowHalfOpen) {\n    socket.end();\n  } else if (state.outgoing.length) {\n    state.outgoing[state.outgoing.length - 1]._last = true;\n  } else if (socket._httpMessage) {\n    socket._httpMessage._last = true;\n  } else {\n    socket.end();\n  }\n}\nfunction socketOnData(server, socket, parser, state, d) {\n  assert(!socket._paused);\n  debug(\"SERVER socketOnData %d\", d.length);\n  const ret = parser.execute(d);\n  onParserExecuteCommon(server, socket, parser, state, ret, d);\n}\nfunction onRequestTimeout(socket) {\n  socket[kRequestTimeout] = void 0;\n  socketOnError.call(socket, new ERR_HTTP_REQUEST_TIMEOUT());\n}\nfunction onParserExecute(server, socket, parser, state, ret) {\n  socket._unrefTimer();\n  debug(\"SERVER socketOnParserExecute %d\", ret);\n  onParserExecuteCommon(server, socket, parser, state, ret, void 0);\n}\nfunction onParserTimeout(server, socket) {\n  const serverTimeout = server.emit(\"timeout\", socket);\n  if (!serverTimeout)\n    socket.destroy();\n}\nconst noop = () => {\n};\nconst badRequestResponse = Buffer.from(`HTTP/1.1 400 ${STATUS_CODES[400]}\\r\nConnection: close\\r\n\\r\n`, \"ascii\");\nconst requestTimeoutResponse = Buffer.from(`HTTP/1.1 408 ${STATUS_CODES[408]}\\r\nConnection: close\\r\n\\r\n`, \"ascii\");\nconst requestHeaderFieldsTooLargeResponse = Buffer.from(`HTTP/1.1 431 ${STATUS_CODES[431]}\\r\nConnection: close\\r\n\\r\n`, \"ascii\");\nfunction socketOnError(e) {\n  this.removeListener(\"error\", socketOnError);\n  this.on(\"error\", noop);\n  if (!this.server.emit(\"clientError\", e, this)) {\n    if (this.writable && this.bytesWritten === 0) {\n      let response;\n      switch (e.code) {\n        case \"HPE_HEADER_OVERFLOW\":\n          response = requestHeaderFieldsTooLargeResponse;\n          break;\n        case \"ERR_HTTP_REQUEST_TIMEOUT\":\n          response = requestTimeoutResponse;\n          break;\n        default:\n          response = badRequestResponse;\n          break;\n      }\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n}\nfunction onParserExecuteCommon(server, socket, parser, state, ret, d) {\n  resetSocketTimeout(server, socket, state);\n  if (ret instanceof Error) {\n    prepareError(ret, parser, d);\n    ret.rawPacket = d || parser.getCurrentBuffer();\n    debug(\"parse error\", ret);\n    socketOnError.call(socket, ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    const req = parser.incoming;\n    debug(\"SERVER upgrade or connect\", req.method);\n    if (!d)\n      d = parser.getCurrentBuffer();\n    socket.removeListener(\"data\", state.onData);\n    socket.removeListener(\"end\", state.onEnd);\n    socket.removeListener(\"close\", state.onClose);\n    socket.removeListener(\"drain\", state.onDrain);\n    socket.removeListener(\"error\", socketOnError);\n    socket.removeListener(\"timeout\", socketOnTimeout);\n    unconsume(parser, socket);\n    parser.finish();\n    freeParser(parser, req, socket);\n    parser = null;\n    const eventName = req.method === \"CONNECT\" ? \"connect\" : \"upgrade\";\n    if (eventName === \"upgrade\" || server.listenerCount(eventName) > 0) {\n      debug(\"SERVER have listener for %s\", eventName);\n      const bodyHead = d.slice(ret, d.length);\n      socket.readableFlowing = null;\n      clearRequestTimeout(req);\n      server.emit(eventName, req, socket, bodyHead);\n    } else {\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.method === \"PRI\") {\n    debug(\"SERVER got PRI request\");\n    socket.destroy();\n  } else {\n    parser[kOnMessageBegin] = setRequestTimeout.bind(void 0, server, socket);\n  }\n  if (socket._paused && socket.parser) {\n    debug(\"pause parser\");\n    socket.parser.pause();\n  }\n}\nfunction clearIncoming(req) {\n  req = req || this;\n  const parser = req.socket && req.socket.parser;\n  if (parser && parser.incoming === req) {\n    if (req.readableEnded) {\n      parser.incoming = null;\n    } else {\n      req.on(\"end\", clearIncoming);\n    }\n  }\n}\nfunction setRequestTimeout(server, socket) {\n  if (!socket[kRequestTimeout] && server.requestTimeout && server.requestTimeout > 0) {\n    debug(\"requestTimeout timer set\");\n    socket[kRequestTimeout] = setTimeout(onRequestTimeout, server.requestTimeout, socket).unref();\n  }\n}\nfunction clearRequestTimeout(req) {\n  if (!req) {\n    req = this;\n  }\n  if (!req[kRequestTimeout]) {\n    return;\n  }\n  debug(\"requestTimeout timer cleared\");\n  clearTimeout(req[kRequestTimeout]);\n  req[kRequestTimeout] = void 0;\n}\nfunction resOnFinish(req, res, socket, state, server) {\n  if (onResponseFinishChannel.hasSubscribers) {\n    onResponseFinishChannel.publish({\n      request: req,\n      response: res,\n      socket,\n      server\n    });\n  }\n  assert(state.incoming.length === 0 || state.incoming[0] === req);\n  state.incoming.shift();\n  if (!req._consuming && !req._readableState.resumeScheduled)\n    req._dump();\n  clearRequestTimeout(req);\n  res.detachSocket(socket);\n  clearIncoming(req);\n  process.nextTick(emitCloseNT, res);\n  if (res._last) {\n    if (typeof socket.destroySoon === \"function\") {\n      socket.destroySoon();\n    } else {\n      socket.end();\n    }\n  } else if (state.outgoing.length === 0) {\n    if (server.keepAliveTimeout && typeof socket.setTimeout === \"function\") {\n      socket.setTimeout(server.keepAliveTimeout);\n      state.keepAliveTimeoutSet = true;\n    }\n  } else {\n    const m = state.outgoing.shift();\n    if (m) {\n      m.assignSocket(socket);\n    }\n  }\n}\nfunction emitCloseNT(self) {\n  if (!self.destroyed) {\n    self.destroyed = true;\n    self._closed = true;\n    self.emit(\"close\");\n  }\n}\nfunction parserOnIncoming(server, socket, state, req, keepAlive) {\n  resetSocketTimeout(server, socket, state);\n  if (req.upgrade) {\n    req.upgrade = req.method === \"CONNECT\" || server.listenerCount(\"upgrade\") > 0;\n    if (req.upgrade)\n      return 2;\n  }\n  state.incoming.push(req);\n  if (!socket._paused) {\n    const ws = socket._writableState;\n    if (ws.needDrain || state.outgoingData >= socket.writableHighWaterMark) {\n      socket._paused = true;\n      socket.pause();\n    }\n  }\n  const res = new server[kServerResponse](req);\n  res._keepAliveTimeout = server.keepAliveTimeout;\n  res._onPendingData = updateOutgoingData.bind(void 0, socket, state);\n  res.shouldKeepAlive = keepAlive;\n  DTRACE_HTTP_SERVER_REQUEST(req, socket);\n  if (onRequestStartChannel.hasSubscribers) {\n    onRequestStartChannel.publish({\n      request: req,\n      response: res,\n      socket,\n      server\n    });\n  }\n  if (socket._httpMessage) {\n    state.outgoing.push(res);\n  } else {\n    res.assignSocket(socket);\n  }\n  res.on(\"finish\", resOnFinish.bind(void 0, req, res, socket, state, server));\n  let handled = false;\n  if (req.httpVersionMajor === 1 && req.httpVersionMinor === 1) {\n    if (typeof server.maxRequestsPerSocket === \"number\") {\n      state.requestsCount++;\n      res.maxRequestsOnConnectionReached = server.maxRequestsPerSocket <= state.requestsCount;\n    }\n    if (typeof server.maxRequestsPerSocket === \"number\" && server.maxRequestsPerSocket < state.requestsCount) {\n      handled = true;\n      res.writeHead(503);\n      res.end();\n    } else if (req.headers.expect !== void 0) {\n      handled = true;\n      if (RegExpPrototypeTest(continueExpression, req.headers.expect)) {\n        res._expect_continue = true;\n        if (server.listenerCount(\"checkContinue\") > 0) {\n          server.emit(\"checkContinue\", req, res);\n        } else {\n          res.writeContinue();\n          server.emit(\"request\", req, res);\n        }\n      } else if (server.listenerCount(\"checkExpectation\") > 0) {\n        server.emit(\"checkExpectation\", req, res);\n      } else {\n        res.writeHead(417);\n        res.end();\n      }\n    }\n  }\n  if (!handled) {\n    req.on(\"end\", clearRequestTimeout);\n    server.emit(\"request\", req, res);\n  }\n  return 0;\n}\nfunction resetSocketTimeout(server, socket, state) {\n  if (!state.keepAliveTimeoutSet)\n    return;\n  socket.setTimeout(server.timeout || 0);\n  state.keepAliveTimeoutSet = false;\n}\nfunction onSocketResume() {\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n}\nfunction onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}\nfunction unconsume(parser, socket) {\n  if (socket._handle) {\n    if (parser._consumed)\n      parser.unconsume();\n    parser._consumed = false;\n    socket.removeListener(\"pause\", onSocketPause);\n    socket.removeListener(\"resume\", onSocketResume);\n  }\n}\nfunction generateSocketListenerWrapper(originalFnName) {\n  return function socketListenerWrap(ev, fn) {\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\n    if (!this.parser) {\n      this.on = net.Socket.prototype.on;\n      this.addListener = net.Socket.prototype.addListener;\n      this.prependListener = net.Socket.prototype.prependListener;\n      return res;\n    }\n    if (ev === \"data\" || ev === \"readable\")\n      unconsume(this.parser, this);\n    return res;\n  };\n}\nmodule.exports = {\n  STATUS_CODES,\n  Server,\n  ServerResponse,\n  storeHTTPOptions,\n  _connectionListener: connectionListener,\n  kServerResponse\n};\n}"],["_stream_duplex.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"stream\").Duplex;\n}"],["_stream_passthrough.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"stream\").PassThrough;\n}"],["_stream_readable.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"stream\").Readable;\n}"],["_stream_transform.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"stream\").Transform;\n}"],["_stream_wrap.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"internal/js_stream_socket\");\nprocess.emitWarning(\"The _stream_wrap module is deprecated.\", \"DeprecationWarning\", \"DEP0125\");\n}"],["_stream_writable.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"stream\").Writable;\n}"],["_tls_common.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst tls = require(\"tls\");\nconst {\n  ArrayPrototypePush,\n  ObjectCreate,\n  StringPrototypeReplace\n} = primordials;\nconst {\n  codes: {\n    ERR_TLS_INVALID_PROTOCOL_VERSION,\n    ERR_TLS_PROTOCOL_VERSION_CONFLICT\n  }\n} = require(\"internal/errors\");\nconst {\n  crypto: {\n    SSL_OP_CIPHER_SERVER_PREFERENCE,\n    TLS1_VERSION,\n    TLS1_1_VERSION,\n    TLS1_2_VERSION,\n    TLS1_3_VERSION\n  }\n} = internalBinding(\"constants\");\nconst {\n  validateInteger\n} = require(\"internal/validators\");\nconst {\n  configSecureContext\n} = require(\"internal/tls/secure-context\");\nconst {\n  parseCertString\n} = require(\"internal/tls/parse-cert-string\");\nfunction toV(which, v, def) {\n  if (v == null)\n    v = def;\n  if (v === \"TLSv1\")\n    return TLS1_VERSION;\n  if (v === \"TLSv1.1\")\n    return TLS1_1_VERSION;\n  if (v === \"TLSv1.2\")\n    return TLS1_2_VERSION;\n  if (v === \"TLSv1.3\")\n    return TLS1_3_VERSION;\n  throw new ERR_TLS_INVALID_PROTOCOL_VERSION(v, which);\n}\nconst {\n  SecureContext: NativeSecureContext\n} = internalBinding(\"crypto\");\nfunction SecureContext(secureProtocol, secureOptions, minVersion, maxVersion) {\n  if (!(this instanceof SecureContext)) {\n    return new SecureContext(secureProtocol, secureOptions, minVersion, maxVersion);\n  }\n  if (secureProtocol) {\n    if (minVersion != null)\n      throw new ERR_TLS_PROTOCOL_VERSION_CONFLICT(minVersion, secureProtocol);\n    if (maxVersion != null)\n      throw new ERR_TLS_PROTOCOL_VERSION_CONFLICT(maxVersion, secureProtocol);\n  }\n  this.context = new NativeSecureContext();\n  this.context.init(secureProtocol, toV(\"minimum\", minVersion, tls.DEFAULT_MIN_VERSION), toV(\"maximum\", maxVersion, tls.DEFAULT_MAX_VERSION));\n  if (secureOptions) {\n    validateInteger(secureOptions, \"secureOptions\");\n    this.context.setOptions(secureOptions);\n  }\n}\nfunction createSecureContext(options) {\n  if (!options)\n    options = {};\n  const {\n    honorCipherOrder,\n    minVersion,\n    maxVersion,\n    secureProtocol\n  } = options;\n  let { secureOptions } = options;\n  if (honorCipherOrder)\n    secureOptions |= SSL_OP_CIPHER_SERVER_PREFERENCE;\n  const c = new SecureContext(secureProtocol, secureOptions, minVersion, maxVersion);\n  configSecureContext(c.context, options);\n  return c;\n}\nfunction translatePeerCertificate(c) {\n  if (!c)\n    return null;\n  if (c.issuer != null)\n    c.issuer = parseCertString(c.issuer);\n  if (c.issuerCertificate != null && c.issuerCertificate !== c) {\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  }\n  if (c.subject != null)\n    c.subject = parseCertString(c.subject);\n  if (c.infoAccess != null) {\n    const info = c.infoAccess;\n    c.infoAccess = ObjectCreate(null);\n    StringPrototypeReplace(info, /([^\\n:]*):([^\\n]*)(?:\\n|$)/g, (all, key, val) => {\n      if (key in c.infoAccess)\n        ArrayPrototypePush(c.infoAccess[key], val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n}\nmodule.exports = {\n  SecureContext,\n  createSecureContext,\n  translatePeerCertificate\n};\n}"],["_tls_wrap.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectAssign,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  RegExp,\n  RegExpPrototypeTest,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  Symbol,\n  SymbolFor\n} = primordials;\nconst {\n  assertCrypto,\n  deprecate\n} = require(\"internal/util\");\nassertCrypto();\nconst { setImmediate } = require(\"timers\");\nconst assert = require(\"internal/assert\");\nconst crypto = require(\"crypto\");\nconst EE = require(\"events\");\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst common = require(\"_tls_common\");\nconst JSStreamSocket = require(\"internal/js_stream_socket\");\nconst { Buffer } = require(\"buffer\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"tls\", (fn) => {\n  debug = fn;\n});\nconst { TCP, constants: TCPConstants } = internalBinding(\"tcp_wrap\");\nconst tls_wrap = internalBinding(\"tls_wrap\");\nconst { Pipe, constants: PipeConstants } = internalBinding(\"pipe_wrap\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst { SecureContext: NativeSecureContext } = internalBinding(\"crypto\");\nconst { connResetException, codes } = require(\"internal/errors\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_MULTIPLE_CALLBACK,\n  ERR_SOCKET_CLOSED,\n  ERR_TLS_DH_PARAM_SIZE,\n  ERR_TLS_HANDSHAKE_TIMEOUT,\n  ERR_TLS_INVALID_CONTEXT,\n  ERR_TLS_RENEGOTIATION_DISABLED,\n  ERR_TLS_REQUIRED_SERVER_NAME,\n  ERR_TLS_SESSION_ATTACK,\n  ERR_TLS_SNI_FROM_SERVER,\n  ERR_TLS_INVALID_STATE\n} = codes;\nconst { onpskexchange: kOnPskExchange } = internalBinding(\"symbols\");\nconst {\n  getOptionValue,\n  getAllowUnauthorized\n} = require(\"internal/options\");\nconst {\n  validateBoolean,\n  validateBuffer,\n  validateCallback,\n  validateFunction,\n  validateInt32,\n  validateNumber,\n  validateObject,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  InternalX509Certificate\n} = require(\"internal/crypto/x509\");\nconst traceTls = getOptionValue(\"--trace-tls\");\nconst tlsKeylog = getOptionValue(\"--tls-keylog\");\nconst { appendFile } = require(\"fs\");\nconst kConnectOptions = Symbol(\"connect-options\");\nconst kDisableRenegotiation = Symbol(\"disable-renegotiation\");\nconst kErrorEmitted = Symbol(\"error-emitted\");\nconst kHandshakeTimeout = Symbol(\"handshake-timeout\");\nconst kRes = Symbol(\"res\");\nconst kSNICallback = Symbol(\"snicallback\");\nconst kEnableTrace = Symbol(\"enableTrace\");\nconst kPskCallback = Symbol(\"pskcallback\");\nconst kPskIdentityHint = Symbol(\"pskidentityhint\");\nconst kPendingSession = Symbol(\"pendingSession\");\nconst kIsVerified = Symbol(\"verified\");\nconst noop = FunctionPrototype;\nlet ipServernameWarned = false;\nlet tlsTracingWarned = false;\nfunction onhandshakestart(now) {\n  debug(\"server onhandshakestart\");\n  const { lastHandshakeTime } = this;\n  assert(now >= lastHandshakeTime, `now (${now}) < lastHandshakeTime (${lastHandshakeTime})`);\n  this.lastHandshakeTime = now;\n  if (lastHandshakeTime === 0)\n    return;\n  if (now - lastHandshakeTime >= tls.CLIENT_RENEG_WINDOW * 1e3)\n    this.handshakes = 1;\n  else\n    this.handshakes++;\n  const owner = this[owner_symbol];\n  assert(owner._tlsOptions.isServer);\n  if (this.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    owner._emitTLSError(new ERR_TLS_SESSION_ATTACK());\n    return;\n  }\n  if (owner[kDisableRenegotiation])\n    owner._emitTLSError(new ERR_TLS_RENEGOTIATION_DISABLED());\n}\nfunction onhandshakedone() {\n  debug(\"server onhandshakedone\");\n  const owner = this[owner_symbol];\n  assert(owner._tlsOptions.isServer);\n  if (owner._newSessionPending) {\n    owner._securePending = true;\n    return;\n  }\n  owner._finishInit();\n}\nfunction loadSession(hello) {\n  debug(\"server onclienthello\", \"sessionid.len\", hello.sessionId.length, \"ticket?\", hello.tlsTicket);\n  const owner = this[owner_symbol];\n  let once = false;\n  function onSession(err, session) {\n    debug(\"server resumeSession callback(err %j, sess? %s)\", err, !!session);\n    if (once)\n      return owner.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n    if (err)\n      return owner.destroy(err);\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n    owner._handle.loadSession(session);\n    owner._handle.endParser();\n  }\n  if (hello.sessionId.length <= 0 || hello.tlsTicket || owner.server && !owner.server.emit(\"resumeSession\", hello.sessionId, onSession)) {\n    owner._handle.endParser();\n  }\n}\nfunction loadSNI(info) {\n  const owner = this[owner_symbol];\n  const servername = info.servername;\n  if (!servername || !owner._SNICallback)\n    return requestOCSP(owner, info);\n  let once = false;\n  owner._SNICallback(servername, (err, context) => {\n    if (once)\n      return owner.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n    if (err)\n      return owner.destroy(err);\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n    if (context)\n      owner._handle.sni_context = context.context || context;\n    requestOCSP(owner, info);\n  });\n}\nfunction requestOCSP(socket, info) {\n  if (!info.OCSPRequest || !socket.server)\n    return requestOCSPDone(socket);\n  let ctx = socket._handle.sni_context;\n  if (!ctx) {\n    ctx = socket.server._sharedCreds;\n    if (!ctx)\n      return requestOCSPDone(socket);\n  }\n  if (ctx.context)\n    ctx = ctx.context;\n  if (socket.server.listenerCount(\"OCSPRequest\") === 0) {\n    return requestOCSPDone(socket);\n  }\n  let once = false;\n  const onOCSP = (err, response) => {\n    debug(\"server OCSPRequest done\", \"handle?\", !!socket._handle, \"once?\", once, \"response?\", !!response, \"err?\", err);\n    if (once)\n      return socket.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n    if (err)\n      return socket.destroy(err);\n    if (socket._handle === null)\n      return socket.destroy(new ERR_SOCKET_CLOSED());\n    if (response)\n      socket._handle.setOCSPResponse(response);\n    requestOCSPDone(socket);\n  };\n  debug(\"server oncertcb emit OCSPRequest\");\n  socket.server.emit(\"OCSPRequest\", ctx.getCertificate(), ctx.getIssuer(), onOCSP);\n}\nfunction requestOCSPDone(socket) {\n  debug(\"server certcb done\");\n  try {\n    socket._handle.certCbDone();\n  } catch (e) {\n    debug(\"server certcb done errored\", e);\n    socket.destroy(e);\n  }\n}\nfunction onnewsessionclient(sessionId, session) {\n  debug(\"client emit session\");\n  const owner = this[owner_symbol];\n  if (owner[kIsVerified]) {\n    owner.emit(\"session\", session);\n  } else {\n    owner[kPendingSession] = session;\n  }\n}\nfunction onnewsession(sessionId, session) {\n  debug(\"onnewsession\");\n  const owner = this[owner_symbol];\n  if (!owner.server)\n    return;\n  let once = false;\n  const done = () => {\n    debug(\"onnewsession done\");\n    if (once)\n      return;\n    once = true;\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n    this.newSessionDone();\n    owner._newSessionPending = false;\n    if (owner._securePending)\n      owner._finishInit();\n    owner._securePending = false;\n  };\n  owner._newSessionPending = true;\n  if (!owner.server.emit(\"newSession\", sessionId, session, done))\n    done();\n}\nfunction onPskServerCallback(identity, maxPskLen) {\n  const owner = this[owner_symbol];\n  const ret = owner[kPskCallback](owner, identity);\n  if (ret == null)\n    return void 0;\n  let psk;\n  if (isArrayBufferView(ret)) {\n    psk = ret;\n  } else {\n    if (typeof ret !== \"object\") {\n      throw new ERR_INVALID_ARG_TYPE(\"ret\", [\"Object\", \"Buffer\", \"TypedArray\", \"DataView\"], ret);\n    }\n    psk = ret.psk;\n    validateBuffer(psk, \"psk\");\n  }\n  if (psk.length > maxPskLen) {\n    throw new ERR_INVALID_ARG_VALUE(\"psk\", psk, `Pre-shared key exceeds ${maxPskLen} bytes`);\n  }\n  return psk;\n}\nfunction onPskClientCallback(hint, maxPskLen, maxIdentityLen) {\n  const owner = this[owner_symbol];\n  const ret = owner[kPskCallback](hint);\n  if (ret == null)\n    return void 0;\n  validateObject(ret, \"ret\");\n  validateBuffer(ret.psk, \"psk\");\n  if (ret.psk.length > maxPskLen) {\n    throw new ERR_INVALID_ARG_VALUE(\"psk\", ret.psk, `Pre-shared key exceeds ${maxPskLen} bytes`);\n  }\n  validateString(ret.identity, \"identity\");\n  if (Buffer.byteLength(ret.identity) > maxIdentityLen) {\n    throw new ERR_INVALID_ARG_VALUE(\"identity\", ret.identity, `PSK identity exceeds ${maxIdentityLen} bytes`);\n  }\n  return { psk: ret.psk, identity: ret.identity };\n}\nfunction onkeylog(line) {\n  debug(\"onkeylog\");\n  this[owner_symbol].emit(\"keylog\", line);\n}\nfunction onocspresponse(resp) {\n  debug(\"client onocspresponse\");\n  this[owner_symbol].emit(\"OCSPResponse\", resp);\n}\nfunction onerror(err) {\n  const owner = this[owner_symbol];\n  debug(\"%s onerror %s had? %j\", owner._tlsOptions.isServer ? \"server\" : \"client\", err, owner._hadError);\n  if (owner._hadError)\n    return;\n  owner._hadError = true;\n  if (!owner._secureEstablished) {\n    owner.destroy(err);\n  } else if (owner._tlsOptions.isServer && owner._rejectUnauthorized && RegExpPrototypeTest(/peer did not return a certificate/, err.message)) {\n    owner.destroy();\n  } else {\n    owner._emitTLSError(err);\n  }\n}\nfunction initRead(tlsSocket, socket) {\n  debug(\"%s initRead\", tlsSocket._tlsOptions.isServer ? \"server\" : \"client\", \"handle?\", !!tlsSocket._handle, \"buffered?\", !!socket && socket.readableLength);\n  if (!tlsSocket._handle)\n    return;\n  if (socket && socket.readableLength) {\n    let buf;\n    while ((buf = socket.read()) !== null)\n      tlsSocket._handle.receive(buf);\n  }\n  tlsSocket.read(0);\n}\nfunction TLSSocket(socket, opts) {\n  const tlsOptions = { ...opts };\n  let enableTrace = tlsOptions.enableTrace;\n  if (enableTrace == null) {\n    enableTrace = traceTls;\n    if (enableTrace && !tlsTracingWarned) {\n      tlsTracingWarned = true;\n      process.emitWarning(\"Enabling --trace-tls can expose sensitive data in the resulting log.\");\n    }\n  } else {\n    validateBoolean(enableTrace, \"options.enableTrace\");\n  }\n  if (tlsOptions.ALPNProtocols)\n    tls.convertALPNProtocols(tlsOptions.ALPNProtocols, tlsOptions);\n  this._tlsOptions = tlsOptions;\n  this._secureEstablished = false;\n  this._securePending = false;\n  this._newSessionPending = false;\n  this._controlReleased = false;\n  this.secureConnecting = true;\n  this._SNICallback = null;\n  this.servername = null;\n  this.alpnProtocol = null;\n  this.authorized = false;\n  this.authorizationError = null;\n  this[kRes] = null;\n  this[kIsVerified] = false;\n  this[kPendingSession] = null;\n  let wrap;\n  if (socket instanceof net.Socket && socket._handle || !socket) {\n    wrap = socket;\n  } else {\n    wrap = new JSStreamSocket(socket);\n  }\n  this.encrypted = true;\n  ReflectApply(net.Socket, this, [{\n    handle: this._wrapHandle(wrap),\n    allowHalfOpen: socket ? socket.allowHalfOpen : tlsOptions.allowHalfOpen,\n    pauseOnCreate: tlsOptions.pauseOnConnect,\n    manualStart: true,\n    highWaterMark: tlsOptions.highWaterMark,\n    onread: !socket ? tlsOptions.onread : null,\n    signal: tlsOptions.signal\n  }]);\n  this.ssl = this._handle;\n  this.on(\"error\", this._tlsError);\n  this._init(socket, wrap);\n  if (enableTrace && this._handle)\n    this._handle.enableTrace();\n  process.nextTick(initRead, this, socket);\n}\nObjectSetPrototypeOf(TLSSocket.prototype, net.Socket.prototype);\nObjectSetPrototypeOf(TLSSocket, net.Socket);\nexports.TLSSocket = TLSSocket;\nconst proxiedMethods = [\n  \"ref\",\n  \"unref\",\n  \"open\",\n  \"bind\",\n  \"listen\",\n  \"connect\",\n  \"bind6\",\n  \"connect6\",\n  \"getsockname\",\n  \"getpeername\",\n  \"setNoDelay\",\n  \"setKeepAlive\",\n  \"setSimultaneousAccepts\",\n  \"setBlocking\",\n  \"setPendingInstances\"\n];\nfunction makeMethodProxy(name) {\n  return function methodProxy(...args) {\n    if (this._parent[name])\n      return ReflectApply(this._parent[name], this._parent, args);\n  };\n}\nfor (const proxiedMethod of proxiedMethods) {\n  tls_wrap.TLSWrap.prototype[proxiedMethod] = makeMethodProxy(proxiedMethod);\n}\ntls_wrap.TLSWrap.prototype.close = function close(cb) {\n  let ssl;\n  if (this[owner_symbol]) {\n    ssl = this[owner_symbol].ssl;\n    this[owner_symbol].ssl = null;\n  }\n  const done = () => {\n    if (ssl) {\n      ssl.destroySSL();\n      if (ssl._secureContext.singleUse) {\n        ssl._secureContext.context.close();\n        ssl._secureContext.context = null;\n      }\n    }\n    if (cb)\n      cb();\n  };\n  if (this._parentWrap && this._parentWrap._handle === this._parent) {\n    this._parentWrap.once(\"close\", done);\n    return this._parentWrap.destroy();\n  }\n  return this._parent.close(done);\n};\nTLSSocket.prototype.disableRenegotiation = function disableRenegotiation() {\n  this[kDisableRenegotiation] = true;\n};\nTLSSocket.prototype._wrapHandle = function(wrap) {\n  let handle;\n  if (wrap)\n    handle = wrap._handle;\n  const options = this._tlsOptions;\n  if (!handle) {\n    handle = options.pipe ? new Pipe(PipeConstants.SOCKET) : new TCP(TCPConstants.SOCKET);\n    handle[owner_symbol] = this;\n  }\n  const context = options.secureContext || options.credentials || tls.createSecureContext(options);\n  assert(handle.isStreamBase, \"handle must be a StreamBase\");\n  if (!(context.context instanceof NativeSecureContext)) {\n    throw new ERR_TLS_INVALID_CONTEXT(\"context\");\n  }\n  const res = tls_wrap.wrap(handle, context.context, !!options.isServer);\n  res._parent = handle;\n  res._parentWrap = wrap;\n  res._secureContext = context;\n  res.reading = handle.reading;\n  this[kRes] = res;\n  defineHandleReading(this, handle);\n  this.on(\"close\", onSocketCloseDestroySSL);\n  return res;\n};\nfunction defineHandleReading(socket, handle) {\n  ObjectDefineProperty(handle, \"reading\", {\n    get: () => {\n      return socket[kRes].reading;\n    },\n    set: (value) => {\n      socket[kRes].reading = value;\n    }\n  });\n}\nfunction onSocketCloseDestroySSL() {\n  setImmediate(destroySSL, this);\n  this[kRes] = null;\n}\nfunction destroySSL(self) {\n  self._destroySSL();\n}\nTLSSocket.prototype._destroySSL = function _destroySSL() {\n  if (!this.ssl)\n    return;\n  this.ssl.destroySSL();\n  if (this.ssl._secureContext.singleUse) {\n    this.ssl._secureContext.context.close();\n    this.ssl._secureContext.context = null;\n  }\n  this.ssl = null;\n  this[kPendingSession] = null;\n  this[kIsVerified] = false;\n};\nlet warnOnTlsKeylog = true;\nlet warnOnTlsKeylogError = true;\nTLSSocket.prototype._init = function(socket, wrap) {\n  const options = this._tlsOptions;\n  const ssl = this._handle;\n  this.server = options.server;\n  debug(\"%s _init\", options.isServer ? \"server\" : \"client\", \"handle?\", !!ssl);\n  const requestCert = !!options.requestCert || !options.isServer;\n  const rejectUnauthorized = !!options.rejectUnauthorized;\n  this._requestCert = requestCert;\n  this._rejectUnauthorized = rejectUnauthorized;\n  if (requestCert || rejectUnauthorized)\n    ssl.setVerifyMode(requestCert, rejectUnauthorized);\n  ssl.onkeylog = onkeylog;\n  this.on(\"newListener\", keylogNewListener);\n  function keylogNewListener(event) {\n    if (event !== \"keylog\")\n      return;\n    if (!this._handle)\n      return;\n    this._handle.enableKeylogCallback();\n    this.removeListener(\"newListener\", keylogNewListener);\n  }\n  if (options.isServer) {\n    ssl.onhandshakestart = onhandshakestart;\n    ssl.onhandshakedone = onhandshakedone;\n    ssl.onclienthello = loadSession;\n    ssl.oncertcb = loadSNI;\n    ssl.onnewsession = onnewsession;\n    ssl.lastHandshakeTime = 0;\n    ssl.handshakes = 0;\n    if (this.server) {\n      if (this.server.listenerCount(\"resumeSession\") > 0 || this.server.listenerCount(\"newSession\") > 0) {\n        ssl.enableSessionCallbacks();\n      }\n      if (this.server.listenerCount(\"OCSPRequest\") > 0)\n        ssl.enableCertCb();\n    }\n  } else {\n    let newListener = function(event) {\n      if (event !== \"session\")\n        return;\n      if (!this._handle)\n        return;\n      this._handle.enableSessionCallbacks();\n      this.removeListener(\"newListener\", newListener);\n    };\n    ssl.onhandshakestart = noop;\n    ssl.onhandshakedone = () => {\n      debug(\"client onhandshakedone\");\n      this._finishInit();\n    };\n    ssl.onocspresponse = onocspresponse;\n    if (options.session)\n      ssl.setSession(options.session);\n    ssl.onnewsession = onnewsessionclient;\n    this.on(\"newListener\", newListener);\n  }\n  if (tlsKeylog) {\n    if (warnOnTlsKeylog) {\n      warnOnTlsKeylog = false;\n      process.emitWarning(\"Using --tls-keylog makes TLS connections insecure by writing secret key material to file \" + tlsKeylog);\n    }\n    this.on(\"keylog\", (line) => {\n      appendFile(tlsKeylog, line, { mode: 384 }, (err) => {\n        if (err && warnOnTlsKeylogError) {\n          warnOnTlsKeylogError = false;\n          process.emitWarning(\"Failed to write TLS keylog (this warning will not be repeated): \" + err);\n        }\n      });\n    });\n  }\n  ssl.onerror = onerror;\n  if (options.isServer && options.SNICallback && (options.SNICallback !== SNICallback || options.server && options.server._contexts.length)) {\n    assert(typeof options.SNICallback === \"function\");\n    this._SNICallback = options.SNICallback;\n    ssl.enableCertCb();\n  }\n  if (options.ALPNProtocols) {\n    ssl._secureContext.alpnBuffer = options.ALPNProtocols;\n    ssl.setALPNProtocols(ssl._secureContext.alpnBuffer);\n  }\n  if (options.pskCallback && ssl.enablePskCallback) {\n    validateFunction(options.pskCallback, \"pskCallback\");\n    ssl[kOnPskExchange] = options.isServer ? onPskServerCallback : onPskClientCallback;\n    this[kPskCallback] = options.pskCallback;\n    ssl.enablePskCallback();\n    if (options.pskIdentityHint) {\n      validateString(options.pskIdentityHint, \"options.pskIdentityHint\");\n      ssl.setPskIdentityHint(options.pskIdentityHint);\n    }\n  }\n  if (options.handshakeTimeout > 0)\n    this.setTimeout(options.handshakeTimeout, this._handleTimeout);\n  if (socket instanceof net.Socket) {\n    this._parent = socket;\n    this.connecting = socket.connecting || !socket._handle;\n    socket.once(\"connect\", () => {\n      this.connecting = false;\n      this.emit(\"connect\");\n    });\n  }\n  if (wrap) {\n    wrap.on(\"error\", (err) => this._emitTLSError(err));\n  } else {\n    assert(!socket);\n    this.connecting = true;\n  }\n};\nTLSSocket.prototype.renegotiate = function(options, callback) {\n  validateObject(options, \"options\");\n  if (callback !== void 0) {\n    validateCallback(callback);\n  }\n  debug(\"%s renegotiate()\", this._tlsOptions.isServer ? \"server\" : \"client\", \"destroyed?\", this.destroyed);\n  if (this.destroyed)\n    return;\n  let requestCert = !!this._requestCert;\n  let rejectUnauthorized = !!this._rejectUnauthorized;\n  if (options.requestCert !== void 0)\n    requestCert = !!options.requestCert;\n  if (options.rejectUnauthorized !== void 0)\n    rejectUnauthorized = !!options.rejectUnauthorized;\n  if (requestCert !== this._requestCert || rejectUnauthorized !== this._rejectUnauthorized) {\n    this._handle.setVerifyMode(requestCert, rejectUnauthorized);\n    this._requestCert = requestCert;\n    this._rejectUnauthorized = rejectUnauthorized;\n  }\n  this.write(\"\");\n  try {\n    this._handle.renegotiate();\n  } catch (err) {\n    if (callback) {\n      process.nextTick(callback, err);\n    }\n    return false;\n  }\n  this.write(\"\");\n  if (callback) {\n    this.once(\"secure\", () => callback(null));\n  }\n  return true;\n};\nTLSSocket.prototype.exportKeyingMaterial = function(length, label, context) {\n  validateUint32(length, \"length\", true);\n  validateString(label, \"label\");\n  if (context !== void 0)\n    validateBuffer(context, \"context\");\n  if (!this._secureEstablished)\n    throw new ERR_TLS_INVALID_STATE();\n  return this._handle.exportKeyingMaterial(length, label, context);\n};\nTLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(size) {\n  validateInt32(size, \"size\");\n  return this._handle.setMaxSendFragment(size) === 1;\n};\nTLSSocket.prototype._handleTimeout = function() {\n  this._emitTLSError(new ERR_TLS_HANDSHAKE_TIMEOUT());\n};\nTLSSocket.prototype._emitTLSError = function(err) {\n  const e = this._tlsError(err);\n  if (e)\n    this.emit(\"error\", e);\n};\nTLSSocket.prototype._tlsError = function(err) {\n  this.emit(\"_tlsError\", err);\n  if (this._controlReleased)\n    return err;\n  return null;\n};\nTLSSocket.prototype._releaseControl = function() {\n  if (this._controlReleased)\n    return false;\n  this._controlReleased = true;\n  this.removeListener(\"error\", this._tlsError);\n  return true;\n};\nTLSSocket.prototype._finishInit = function() {\n  if (!this._handle)\n    return;\n  this.alpnProtocol = this._handle.getALPNNegotiatedProtocol();\n  if (this.servername === null) {\n    this.servername = this._handle.getServername();\n  }\n  debug(\"%s _finishInit\", this._tlsOptions.isServer ? \"server\" : \"client\", \"handle?\", !!this._handle, \"alpn\", this.alpnProtocol, \"servername\", this.servername);\n  this._secureEstablished = true;\n  if (this._tlsOptions.handshakeTimeout > 0)\n    this.setTimeout(0, this._handleTimeout);\n  this.emit(\"secure\");\n};\nTLSSocket.prototype._start = function() {\n  debug(\"%s _start\", this._tlsOptions.isServer ? \"server\" : \"client\", \"handle?\", !!this._handle, \"connecting?\", this.connecting, \"requestOCSP?\", !!this._tlsOptions.requestOCSP);\n  if (this.connecting) {\n    this.once(\"connect\", this._start);\n    return;\n  }\n  if (!this._handle)\n    return;\n  if (this._tlsOptions.requestOCSP)\n    this._handle.requestOCSP();\n  this._handle.start();\n};\nTLSSocket.prototype.setServername = function(name) {\n  validateString(name, \"name\");\n  if (this._tlsOptions.isServer) {\n    throw new ERR_TLS_SNI_FROM_SERVER();\n  }\n  this._handle.setServername(name);\n};\nTLSSocket.prototype.setSession = function(session) {\n  if (typeof session === \"string\")\n    session = Buffer.from(session, \"latin1\");\n  this._handle.setSession(session);\n};\nTLSSocket.prototype.getPeerCertificate = function(detailed) {\n  if (this._handle) {\n    return common.translatePeerCertificate(this._handle.getPeerCertificate(detailed)) || {};\n  }\n  return null;\n};\nTLSSocket.prototype.getCertificate = function() {\n  if (this._handle) {\n    return common.translatePeerCertificate(this._handle.getCertificate()) || {};\n  }\n  return null;\n};\nTLSSocket.prototype.getPeerX509Certificate = function(detailed) {\n  const cert = this._handle?.getPeerX509Certificate();\n  return cert ? new InternalX509Certificate(cert) : void 0;\n};\nTLSSocket.prototype.getX509Certificate = function() {\n  const cert = this._handle?.getX509Certificate();\n  return cert ? new InternalX509Certificate(cert) : void 0;\n};\nfunction makeSocketMethodProxy(name) {\n  return function socketMethodProxy(...args) {\n    if (this._handle)\n      return ReflectApply(this._handle[name], this._handle, args);\n    return null;\n  };\n}\nArrayPrototypeForEach([\n  \"getCipher\",\n  \"getSharedSigalgs\",\n  \"getEphemeralKeyInfo\",\n  \"getFinished\",\n  \"getPeerFinished\",\n  \"getProtocol\",\n  \"getSession\",\n  \"getTLSTicket\",\n  \"isSessionReused\",\n  \"enableTrace\"\n], (method) => {\n  TLSSocket.prototype[method] = makeSocketMethodProxy(method);\n});\nfunction onServerSocketSecure() {\n  if (this._requestCert) {\n    const verifyError = this._handle.verifyError();\n    if (verifyError) {\n      this.authorizationError = verifyError.code;\n      if (this._rejectUnauthorized)\n        this.destroy();\n    } else {\n      this.authorized = true;\n    }\n  }\n  if (!this.destroyed && this._releaseControl()) {\n    debug(\"server emit secureConnection\");\n    this.secureConnecting = false;\n    this._tlsOptions.server.emit(\"secureConnection\", this);\n  }\n}\nfunction onSocketTLSError(err) {\n  if (!this._controlReleased && !this[kErrorEmitted]) {\n    this[kErrorEmitted] = true;\n    debug(\"server emit tlsClientError:\", err);\n    this._tlsOptions.server.emit(\"tlsClientError\", err, this);\n  }\n}\nfunction onSocketKeylog(line) {\n  this._tlsOptions.server.emit(\"keylog\", line, this);\n}\nfunction onSocketClose(err) {\n  if (err)\n    return;\n  if (!this._controlReleased && !this[kErrorEmitted]) {\n    this[kErrorEmitted] = true;\n    const connReset = connResetException(\"socket hang up\");\n    this._tlsOptions.server.emit(\"tlsClientError\", connReset, this);\n  }\n}\nfunction tlsConnectionListener(rawSocket) {\n  debug(\"net.Server.on(connection): new TLSSocket\");\n  const socket = new TLSSocket(rawSocket, {\n    secureContext: this._sharedCreds,\n    isServer: true,\n    server: this,\n    requestCert: this.requestCert,\n    rejectUnauthorized: this.rejectUnauthorized,\n    handshakeTimeout: this[kHandshakeTimeout],\n    ALPNProtocols: this.ALPNProtocols,\n    SNICallback: this[kSNICallback] || SNICallback,\n    enableTrace: this[kEnableTrace],\n    pauseOnConnect: this.pauseOnConnect,\n    pskCallback: this[kPskCallback],\n    pskIdentityHint: this[kPskIdentityHint]\n  });\n  socket.on(\"secure\", onServerSocketSecure);\n  if (this.listenerCount(\"keylog\") > 0)\n    socket.on(\"keylog\", onSocketKeylog);\n  socket[kErrorEmitted] = false;\n  socket.on(\"close\", onSocketClose);\n  socket.on(\"_tlsError\", onSocketTLSError);\n}\nfunction Server(options, listener) {\n  if (!(this instanceof Server))\n    return new Server(options, listener);\n  if (typeof options === \"function\") {\n    listener = options;\n    options = {};\n  } else if (options == null || typeof options === \"object\") {\n    options = options || {};\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n  }\n  this._contexts = [];\n  this.requestCert = options.requestCert === true;\n  this.rejectUnauthorized = options.rejectUnauthorized !== false;\n  if (options.sessionTimeout)\n    this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys)\n    this.ticketKeys = options.ticketKeys;\n  if (options.ALPNProtocols)\n    tls.convertALPNProtocols(options.ALPNProtocols, this);\n  this.setSecureContext(options);\n  this[kHandshakeTimeout] = options.handshakeTimeout || 120 * 1e3;\n  this[kSNICallback] = options.SNICallback;\n  this[kPskCallback] = options.pskCallback;\n  this[kPskIdentityHint] = options.pskIdentityHint;\n  validateNumber(this[kHandshakeTimeout], \"options.handshakeTimeout\");\n  if (this[kSNICallback] && typeof this[kSNICallback] !== \"function\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.SNICallback\", \"function\", options.SNICallback);\n  }\n  if (this[kPskCallback] && typeof this[kPskCallback] !== \"function\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.pskCallback\", \"function\", options.pskCallback);\n  }\n  if (this[kPskIdentityHint] && typeof this[kPskIdentityHint] !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.pskIdentityHint\", \"string\", options.pskIdentityHint);\n  }\n  ReflectApply(net.Server, this, [options, tlsConnectionListener]);\n  if (listener) {\n    this.on(\"secureConnection\", listener);\n  }\n  this[kEnableTrace] = options.enableTrace;\n}\nObjectSetPrototypeOf(Server.prototype, net.Server.prototype);\nObjectSetPrototypeOf(Server, net.Server);\nexports.Server = Server;\nexports.createServer = function createServer(options, listener) {\n  return new Server(options, listener);\n};\nServer.prototype.setSecureContext = function(options) {\n  validateObject(options, \"options\");\n  if (options.pfx)\n    this.pfx = options.pfx;\n  else\n    this.pfx = void 0;\n  if (options.key)\n    this.key = options.key;\n  else\n    this.key = void 0;\n  if (options.passphrase)\n    this.passphrase = options.passphrase;\n  else\n    this.passphrase = void 0;\n  if (options.cert)\n    this.cert = options.cert;\n  else\n    this.cert = void 0;\n  if (options.clientCertEngine)\n    this.clientCertEngine = options.clientCertEngine;\n  else\n    this.clientCertEngine = void 0;\n  if (options.ca)\n    this.ca = options.ca;\n  else\n    this.ca = void 0;\n  if (options.minVersion)\n    this.minVersion = options.minVersion;\n  else\n    this.minVersion = void 0;\n  if (options.maxVersion)\n    this.maxVersion = options.maxVersion;\n  else\n    this.maxVersion = void 0;\n  if (options.secureProtocol)\n    this.secureProtocol = options.secureProtocol;\n  else\n    this.secureProtocol = void 0;\n  if (options.crl)\n    this.crl = options.crl;\n  else\n    this.crl = void 0;\n  this.sigalgs = options.sigalgs;\n  if (options.ciphers)\n    this.ciphers = options.ciphers;\n  else\n    this.ciphers = void 0;\n  this.ecdhCurve = options.ecdhCurve;\n  if (options.dhparam)\n    this.dhparam = options.dhparam;\n  else\n    this.dhparam = void 0;\n  if (options.honorCipherOrder !== void 0)\n    this.honorCipherOrder = !!options.honorCipherOrder;\n  else\n    this.honorCipherOrder = true;\n  const secureOptions = options.secureOptions || 0;\n  if (secureOptions)\n    this.secureOptions = secureOptions;\n  else\n    this.secureOptions = void 0;\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = StringPrototypeSlice(crypto.createHash(\"sha1\").update(ArrayPrototypeJoin(process.argv, \" \")).digest(\"hex\"), 0, 32);\n  }\n  if (options.sessionTimeout)\n    this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys)\n    this.ticketKeys = options.ticketKeys;\n  this.privateKeyIdentifier = options.privateKeyIdentifier;\n  this.privateKeyEngine = options.privateKeyEngine;\n  this._sharedCreds = tls.createSecureContext({\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    clientCertEngine: this.clientCertEngine,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    sigalgs: this.sigalgs,\n    ecdhCurve: this.ecdhCurve,\n    dhparam: this.dhparam,\n    minVersion: this.minVersion,\n    maxVersion: this.maxVersion,\n    secureProtocol: this.secureProtocol,\n    secureOptions: this.secureOptions,\n    honorCipherOrder: this.honorCipherOrder,\n    crl: this.crl,\n    sessionIdContext: this.sessionIdContext,\n    ticketKeys: this.ticketKeys,\n    sessionTimeout: this.sessionTimeout,\n    privateKeyIdentifier: this.privateKeyIdentifier,\n    privateKeyEngine: this.privateKeyEngine\n  });\n};\nServer.prototype._getServerData = function() {\n  return {\n    ticketKeys: this.getTicketKeys().toString(\"hex\")\n  };\n};\nServer.prototype._setServerData = function(data) {\n  this.setTicketKeys(Buffer.from(data.ticketKeys, \"hex\"));\n};\nServer.prototype.getTicketKeys = function getTicketKeys() {\n  return this._sharedCreds.context.getTicketKeys();\n};\nServer.prototype.setTicketKeys = function setTicketKeys(keys) {\n  validateBuffer(keys);\n  assert(keys.byteLength === 48, \"Session ticket keys must be a 48-byte buffer\");\n  this._sharedCreds.context.setTicketKeys(keys);\n};\nServer.prototype.setOptions = deprecate(function(options) {\n  this.requestCert = options.requestCert === true;\n  this.rejectUnauthorized = options.rejectUnauthorized !== false;\n  if (options.pfx)\n    this.pfx = options.pfx;\n  if (options.key)\n    this.key = options.key;\n  if (options.passphrase)\n    this.passphrase = options.passphrase;\n  if (options.cert)\n    this.cert = options.cert;\n  if (options.clientCertEngine)\n    this.clientCertEngine = options.clientCertEngine;\n  if (options.ca)\n    this.ca = options.ca;\n  if (options.minVersion)\n    this.minVersion = options.minVersion;\n  if (options.maxVersion)\n    this.maxVersion = options.maxVersion;\n  if (options.secureProtocol)\n    this.secureProtocol = options.secureProtocol;\n  if (options.crl)\n    this.crl = options.crl;\n  if (options.ciphers)\n    this.ciphers = options.ciphers;\n  if (options.ecdhCurve !== void 0)\n    this.ecdhCurve = options.ecdhCurve;\n  if (options.dhparam)\n    this.dhparam = options.dhparam;\n  if (options.sessionTimeout)\n    this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys)\n    this.ticketKeys = options.ticketKeys;\n  const secureOptions = options.secureOptions || 0;\n  if (options.honorCipherOrder !== void 0)\n    this.honorCipherOrder = !!options.honorCipherOrder;\n  else\n    this.honorCipherOrder = true;\n  if (secureOptions)\n    this.secureOptions = secureOptions;\n  if (options.ALPNProtocols)\n    tls.convertALPNProtocols(options.ALPNProtocols, this);\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = StringPrototypeSlice(crypto.createHash(\"sha1\").update(ArrayPrototypeJoin(process.argv, \" \")).digest(\"hex\"), 0, 32);\n  }\n  if (options.pskCallback)\n    this[kPskCallback] = options.pskCallback;\n  if (options.pskIdentityHint)\n    this[kPskIdentityHint] = options.pskIdentityHint;\n  if (options.sigalgs)\n    this.sigalgs = options.sigalgs;\n  if (options.privateKeyIdentifier !== void 0)\n    this.privateKeyIdentifier = options.privateKeyIdentifier;\n  if (options.privateKeyEngine !== void 0)\n    this.privateKeyEngine = options.privateKeyEngine;\n}, \"Server.prototype.setOptions() is deprecated\", \"DEP0122\");\nServer.prototype.addContext = function(servername, context) {\n  if (!servername) {\n    throw new ERR_TLS_REQUIRED_SERVER_NAME();\n  }\n  const re = new RegExp(\"^\" + StringPrototypeReplace(StringPrototypeReplace(servername, /([.^$+?\\-\\\\[\\]{}])/g, \"\\\\$1\"), /\\*/g, \"[^.]*\") + \"$\");\n  ArrayPrototypePush(this._contexts, [re, tls.createSecureContext(context).context]);\n};\nServer.prototype[EE.captureRejectionSymbol] = function(err, event, sock) {\n  switch (event) {\n    case \"secureConnection\":\n      sock.destroy(err);\n      break;\n    default:\n      ReflectApply(net.Server.prototype[SymbolFor(\"nodejs.rejection\")], this, [err, event, sock]);\n  }\n};\nfunction SNICallback(servername, callback) {\n  const contexts = this.server._contexts;\n  for (let i = contexts.length - 1; i >= 0; --i) {\n    const elem = contexts[i];\n    if (RegExpPrototypeTest(elem[0], servername)) {\n      callback(null, elem[1]);\n      return;\n    }\n  }\n  callback(null, void 0);\n}\nfunction normalizeConnectArgs(listArgs) {\n  const args = net._normalizeArgs(listArgs);\n  const options = args[0];\n  const cb = args[1];\n  if (listArgs[1] !== null && typeof listArgs[1] === \"object\") {\n    ObjectAssign(options, listArgs[1]);\n  } else if (listArgs[2] !== null && typeof listArgs[2] === \"object\") {\n    ObjectAssign(options, listArgs[2]);\n  }\n  return cb ? [options, cb] : [options];\n}\nfunction onConnectSecure() {\n  const options = this[kConnectOptions];\n  const ekeyinfo = this.getEphemeralKeyInfo();\n  if (ekeyinfo.type === \"DH\" && ekeyinfo.size < options.minDHSize) {\n    const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);\n    debug(\"client emit:\", err);\n    this.emit(\"error\", err);\n    this.destroy();\n    return;\n  }\n  let verifyError = this._handle.verifyError();\n  if (!verifyError && !this.isSessionReused()) {\n    const hostname = options.servername || options.host || options.socket && options.socket._host || \"localhost\";\n    const cert = this.getPeerCertificate(true);\n    verifyError = options.checkServerIdentity(hostname, cert);\n  }\n  if (verifyError) {\n    this.authorized = false;\n    this.authorizationError = verifyError.code || verifyError.message;\n    if (options.rejectUnauthorized !== false) {\n      this.destroy(verifyError);\n      return;\n    }\n    debug(\"client emit secureConnect. rejectUnauthorized: %s, authorizationError: %s\", options.rejectUnauthorized, this.authorizationError);\n    this.secureConnecting = false;\n    this.emit(\"secureConnect\");\n  } else {\n    this.authorized = true;\n    debug(\"client emit secureConnect. authorized:\", this.authorized);\n    this.secureConnecting = false;\n    this.emit(\"secureConnect\");\n  }\n  this[kIsVerified] = true;\n  const session = this[kPendingSession];\n  this[kPendingSession] = null;\n  if (session)\n    this.emit(\"session\", session);\n  this.removeListener(\"end\", onConnectEnd);\n}\nfunction onConnectEnd() {\n  if (!this._hadError) {\n    const options = this[kConnectOptions];\n    this._hadError = true;\n    const error = connResetException(\"Client network socket disconnected before secure TLS connection was established\");\n    error.path = options.path;\n    error.host = options.host;\n    error.port = options.port;\n    error.localAddress = options.localAddress;\n    this.destroy(error);\n  }\n}\nexports.connect = function connect(...args) {\n  args = normalizeConnectArgs(args);\n  let options = args[0];\n  const cb = args[1];\n  const allowUnauthorized = getAllowUnauthorized();\n  options = {\n    rejectUnauthorized: !allowUnauthorized,\n    ciphers: tls.DEFAULT_CIPHERS,\n    checkServerIdentity: tls.checkServerIdentity,\n    minDHSize: 1024,\n    ...options\n  };\n  if (!options.keepAlive)\n    options.singleUse = true;\n  assert(typeof options.checkServerIdentity === \"function\");\n  assert(typeof options.minDHSize === \"number\", \"options.minDHSize is not a number: \" + options.minDHSize);\n  assert(options.minDHSize > 0, \"options.minDHSize is not a positive number: \" + options.minDHSize);\n  const context = options.secureContext || tls.createSecureContext(options);\n  const tlssock = new TLSSocket(options.socket, {\n    allowHalfOpen: options.allowHalfOpen,\n    pipe: !!options.path,\n    secureContext: context,\n    isServer: false,\n    requestCert: true,\n    rejectUnauthorized: options.rejectUnauthorized !== false,\n    session: options.session,\n    ALPNProtocols: options.ALPNProtocols,\n    requestOCSP: options.requestOCSP,\n    enableTrace: options.enableTrace,\n    pskCallback: options.pskCallback,\n    highWaterMark: options.highWaterMark,\n    onread: options.onread,\n    signal: options.signal\n  });\n  options.rejectUnauthorized = options.rejectUnauthorized !== false;\n  tlssock[kConnectOptions] = options;\n  if (cb)\n    tlssock.once(\"secureConnect\", cb);\n  if (!options.socket) {\n    if (options.timeout) {\n      tlssock.setTimeout(options.timeout);\n    }\n    tlssock.connect(options, tlssock._start);\n  }\n  tlssock._releaseControl();\n  if (options.session)\n    tlssock.setSession(options.session);\n  if (options.servername) {\n    if (!ipServernameWarned && net.isIP(options.servername)) {\n      process.emitWarning(\"Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.\", \"DeprecationWarning\", \"DEP0123\");\n      ipServernameWarned = true;\n    }\n    tlssock.setServername(options.servername);\n  }\n  if (options.socket)\n    tlssock._start();\n  tlssock.on(\"secure\", onConnectSecure);\n  tlssock.prependListener(\"end\", onConnectEnd);\n  return tlssock;\n};\n}"],["assert.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  Error,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  NumberIsNaN,\n  ObjectAssign,\n  ObjectIs,\n  ObjectKeys,\n  ObjectPrototypeIsPrototypeOf,\n  ReflectApply,\n  RegExpPrototypeTest,\n  SafeMap,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  codes: {\n    ERR_AMBIGUOUS_ARGUMENT,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS\n  },\n  isErrorStackTraceLimitWritable,\n  overrideStackTrace\n} = require(\"internal/errors\");\nconst AssertionError = require(\"internal/assert/assertion_error\");\nconst { openSync, closeSync, readSync } = require(\"fs\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst { isPromise, isRegExp } = require(\"internal/util/types\");\nconst { EOL } = require(\"internal/constants\");\nconst { NativeModule } = require(\"internal/bootstrap/loaders\");\nconst { isError } = require(\"internal/util\");\nconst errorCache = new SafeMap();\nconst CallTracker = require(\"internal/assert/calltracker\");\nconst {\n  validateFunction\n} = require(\"internal/validators\");\nlet isDeepEqual;\nlet isDeepStrictEqual;\nlet parseExpressionAt;\nlet findNodeAround;\nlet decoder;\nfunction lazyLoadComparison() {\n  const comparison = require(\"internal/util/comparisons\");\n  isDeepEqual = comparison.isDeepEqual;\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\n}\nconst escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\nconst meta = [\n  \"\\\\u0000\",\n  \"\\\\u0001\",\n  \"\\\\u0002\",\n  \"\\\\u0003\",\n  \"\\\\u0004\",\n  \"\\\\u0005\",\n  \"\\\\u0006\",\n  \"\\\\u0007\",\n  \"\\\\b\",\n  \"\",\n  \"\",\n  \"\\\\u000b\",\n  \"\\\\f\",\n  \"\",\n  \"\\\\u000e\",\n  \"\\\\u000f\",\n  \"\\\\u0010\",\n  \"\\\\u0011\",\n  \"\\\\u0012\",\n  \"\\\\u0013\",\n  \"\\\\u0014\",\n  \"\\\\u0015\",\n  \"\\\\u0016\",\n  \"\\\\u0017\",\n  \"\\\\u0018\",\n  \"\\\\u0019\",\n  \"\\\\u001a\",\n  \"\\\\u001b\",\n  \"\\\\u001c\",\n  \"\\\\u001d\",\n  \"\\\\u001e\",\n  \"\\\\u001f\"\n];\nconst escapeFn = (str) => meta[StringPrototypeCharCodeAt(str, 0)];\nlet warned = false;\nconst assert = module.exports = ok;\nconst NO_EXCEPTION_SENTINEL = {};\nfunction innerFail(obj) {\n  if (obj.message instanceof Error)\n    throw obj.message;\n  throw new AssertionError(obj);\n}\nfunction fail(actual, expected, message, operator, stackStartFn) {\n  const argsLen = arguments.length;\n  let internalMessage = false;\n  if (actual == null && argsLen <= 1) {\n    internalMessage = true;\n    message = \"Failed\";\n  } else if (argsLen === 1) {\n    message = actual;\n    actual = void 0;\n  } else {\n    if (warned === false) {\n      warned = true;\n      process.emitWarning(\"assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.\", \"DeprecationWarning\", \"DEP0094\");\n    }\n    if (argsLen === 2)\n      operator = \"!=\";\n  }\n  if (message instanceof Error)\n    throw message;\n  const errArgs = {\n    actual,\n    expected,\n    operator: operator === void 0 ? \"fail\" : operator,\n    stackStartFn: stackStartFn || fail,\n    message\n  };\n  const err = new AssertionError(errArgs);\n  if (internalMessage) {\n    err.generatedMessage = true;\n  }\n  throw err;\n}\nassert.fail = fail;\nassert.AssertionError = AssertionError;\nfunction findColumn(fd, column, code) {\n  if (code.length > column + 100) {\n    try {\n      return parseCode(code, column);\n    } catch {\n      if (code.length - column > 2500) {\n        throw null;\n      }\n    }\n  }\n  const bytesToRead = column - code.length + 2500;\n  const buffer = Buffer.allocUnsafe(bytesToRead);\n  const bytesRead = readSync(fd, buffer, 0, bytesToRead);\n  code += decoder.write(buffer.slice(0, bytesRead));\n  if (bytesRead < bytesToRead) {\n    return parseCode(code, column);\n  }\n  return findColumn(fd, column, code);\n}\nfunction getCode(fd, line, column) {\n  let bytesRead = 0;\n  if (line === 0) {\n    return findColumn(fd, column, \"\");\n  }\n  let lines = 0;\n  let maxReads = 32;\n  const bytesPerRead = 16384;\n  let buffer = Buffer.allocUnsafe(bytesPerRead);\n  while (maxReads-- !== 0) {\n    buffer = lines < line ? buffer : Buffer.allocUnsafe(bytesPerRead);\n    bytesRead = readSync(fd, buffer, 0, bytesPerRead);\n    for (let i = 0; i < bytesRead; i++) {\n      if (buffer[i] === 10 && ++lines === line) {\n        if (bytesRead < bytesPerRead) {\n          return parseCode(buffer.toString(\"utf8\", i + 1, bytesRead), column);\n        }\n        const code = decoder.write(buffer.slice(i + 1, bytesRead));\n        return findColumn(fd, column, code);\n      }\n    }\n  }\n}\nfunction parseCode(code, offset) {\n  if (parseExpressionAt === void 0) {\n    const Parser = require(\"internal/deps/acorn/acorn/dist/acorn\").Parser;\n    ({ findNodeAround } = require(\"internal/deps/acorn/acorn-walk/dist/walk\"));\n    parseExpressionAt = FunctionPrototypeBind(Parser.parseExpressionAt, Parser);\n  }\n  let node;\n  let start = 0;\n  do {\n    try {\n      node = parseExpressionAt(code, start, { ecmaVersion: \"latest\" });\n      start = node.end + 1 || start;\n      node = findNodeAround(node, offset, \"CallExpression\");\n    } catch (err) {\n      start += err.raisedAt || 1;\n      if (start > offset) {\n        throw null;\n      }\n    }\n  } while (node === void 0 || node.node.end < offset);\n  return [\n    node.node.start,\n    StringPrototypeReplace(StringPrototypeSlice(code, node.node.start, node.node.end), escapeSequencesRegExp, escapeFn)\n  ];\n}\nfunction getErrMessage(message, fn) {\n  const tmpLimit = Error.stackTraceLimit;\n  const errorStackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n  if (errorStackTraceLimitIsWritable)\n    Error.stackTraceLimit = 1;\n  const err = {};\n  ErrorCaptureStackTrace(err, fn);\n  if (errorStackTraceLimitIsWritable)\n    Error.stackTraceLimit = tmpLimit;\n  overrideStackTrace.set(err, (_, stack) => stack);\n  const call = err.stack[0];\n  const filename = call.getFileName();\n  const line = call.getLineNumber() - 1;\n  let column = call.getColumnNumber() - 1;\n  let identifier;\n  let code;\n  if (filename) {\n    identifier = `${filename}${line}${column}`;\n    if (StringPrototypeStartsWith(filename, \"node:\") && NativeModule.exists(StringPrototypeSlice(filename, 5))) {\n      errorCache.set(identifier, void 0);\n      return;\n    }\n  } else {\n    const fn2 = call.getFunction();\n    if (!fn2) {\n      return message;\n    }\n    code = String(fn2);\n    identifier = `${code}${line}${column}`;\n  }\n  if (errorCache.has(identifier)) {\n    return errorCache.get(identifier);\n  }\n  let fd;\n  try {\n    if (errorStackTraceLimitIsWritable)\n      Error.stackTraceLimit = 0;\n    if (filename) {\n      if (decoder === void 0) {\n        const { StringDecoder } = require(\"string_decoder\");\n        decoder = new StringDecoder(\"utf8\");\n      }\n      fd = openSync(filename, \"r\", 438);\n      ({ 0: column, 1: message } = getCode(fd, line, column));\n      decoder.end();\n    } else {\n      for (let i = 0; i < line; i++) {\n        code = StringPrototypeSlice(code, StringPrototypeIndexOf(code, \"\\n\") + 1);\n      }\n      ({ 0: column, 1: message } = parseCode(code, column));\n    }\n    if (StringPrototypeIncludes(message, \"\\n\")) {\n      if (EOL === \"\\r\\n\") {\n        message = StringPrototypeReplace(message, /\\r\\n/g, \"\\n\");\n      }\n      const frames = StringPrototypeSplit(message, \"\\n\");\n      message = ArrayPrototypeShift(frames);\n      for (const frame of frames) {\n        let pos = 0;\n        while (pos < column && (frame[pos] === \" \" || frame[pos] === \"\t\")) {\n          pos++;\n        }\n        message += `\n  ${StringPrototypeSlice(frame, pos)}`;\n      }\n    }\n    message = `The expression evaluated to a falsy value:\n\n  ${message}\n`;\n    errorCache.set(identifier, message);\n    return message;\n  } catch {\n    errorCache.set(identifier, void 0);\n  } finally {\n    if (errorStackTraceLimitIsWritable)\n      Error.stackTraceLimit = tmpLimit;\n    if (fd !== void 0)\n      closeSync(fd);\n  }\n}\nfunction innerOk(fn, argLen, value, message) {\n  if (!value) {\n    let generatedMessage = false;\n    if (argLen === 0) {\n      generatedMessage = true;\n      message = \"No value argument passed to `assert.ok()`\";\n    } else if (message == null) {\n      generatedMessage = true;\n      message = getErrMessage(message, fn);\n    } else if (message instanceof Error) {\n      throw message;\n    }\n    const err = new AssertionError({\n      actual: value,\n      expected: true,\n      message,\n      operator: \"==\",\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\nfunction ok(...args) {\n  innerOk(ok, args.length, ...args);\n}\nassert.ok = ok;\nassert.equal = function equal(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (actual != expected && (!NumberIsNaN(actual) || !NumberIsNaN(expected))) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"==\",\n      stackStartFn: equal\n    });\n  }\n};\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (actual == expected || NumberIsNaN(actual) && NumberIsNaN(expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"!=\",\n      stackStartFn: notEqual\n    });\n  }\n};\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (isDeepEqual === void 0)\n    lazyLoadComparison();\n  if (!isDeepEqual(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"deepEqual\",\n      stackStartFn: deepEqual\n    });\n  }\n};\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (isDeepEqual === void 0)\n    lazyLoadComparison();\n  if (isDeepEqual(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"notDeepEqual\",\n      stackStartFn: notDeepEqual\n    });\n  }\n};\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (isDeepEqual === void 0)\n    lazyLoadComparison();\n  if (!isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"deepStrictEqual\",\n      stackStartFn: deepStrictEqual\n    });\n  }\n};\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (isDeepEqual === void 0)\n    lazyLoadComparison();\n  if (isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"notDeepStrictEqual\",\n      stackStartFn: notDeepStrictEqual\n    });\n  }\n}\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (!ObjectIs(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"strictEqual\",\n      stackStartFn: strictEqual\n    });\n  }\n};\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS(\"actual\", \"expected\");\n  }\n  if (ObjectIs(actual, expected)) {\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: \"notStrictEqual\",\n      stackStartFn: notStrictEqual\n    });\n  }\n};\nclass Comparison {\n  constructor(obj, keys, actual) {\n    for (const key of keys) {\n      if (key in obj) {\n        if (actual !== void 0 && typeof actual[key] === \"string\" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {\n          this[key] = actual[key];\n        } else {\n          this[key] = obj[key];\n        }\n      }\n    }\n  }\n}\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\n    if (!message) {\n      const a = new Comparison(actual, keys);\n      const b = new Comparison(expected, keys, actual);\n      const err = new AssertionError({\n        actual: a,\n        expected: b,\n        operator: \"deepStrictEqual\",\n        stackStartFn: fn\n      });\n      err.actual = actual;\n      err.expected = expected;\n      err.operator = fn.name;\n      throw err;\n    }\n    innerFail({\n      actual,\n      expected,\n      message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n  }\n}\nfunction expectedException(actual, expected, message, fn) {\n  let generatedMessage = false;\n  let throwError = false;\n  if (typeof expected !== \"function\") {\n    if (isRegExp(expected)) {\n      const str = String(actual);\n      if (RegExpPrototypeTest(expected, str))\n        return;\n      if (!message) {\n        generatedMessage = true;\n        message = `The input did not match the regular expression ${inspect(expected)}. Input:\n\n${inspect(str)}\n`;\n      }\n      throwError = true;\n    } else if (typeof actual !== \"object\" || actual === null) {\n      const err = new AssertionError({\n        actual,\n        expected,\n        message,\n        operator: \"deepStrictEqual\",\n        stackStartFn: fn\n      });\n      err.operator = fn.name;\n      throw err;\n    } else {\n      const keys = ObjectKeys(expected);\n      if (expected instanceof Error) {\n        ArrayPrototypePush(keys, \"name\", \"message\");\n      } else if (keys.length === 0) {\n        throw new ERR_INVALID_ARG_VALUE(\"error\", expected, \"may not be an empty object\");\n      }\n      if (isDeepEqual === void 0)\n        lazyLoadComparison();\n      for (const key of keys) {\n        if (typeof actual[key] === \"string\" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {\n          continue;\n        }\n        compareExceptionKey(actual, expected, key, message, keys, fn);\n      }\n      return;\n    }\n  } else if (expected.prototype !== void 0 && actual instanceof expected) {\n    return;\n  } else if (ObjectPrototypeIsPrototypeOf(Error, expected)) {\n    if (!message) {\n      generatedMessage = true;\n      message = `The error is expected to be an instance of \"${expected.name}\". Received `;\n      if (isError(actual)) {\n        const name = actual.constructor && actual.constructor.name || actual.name;\n        if (expected.name === name) {\n          message += \"an error with identical name but a different prototype.\";\n        } else {\n          message += `\"${name}\"`;\n        }\n        if (actual.message) {\n          message += `\n\nError message:\n\n${actual.message}`;\n        }\n      } else {\n        message += `\"${inspect(actual, { depth: -1 })}\"`;\n      }\n    }\n    throwError = true;\n  } else {\n    const res = ReflectApply(expected, {}, [actual]);\n    if (res !== true) {\n      if (!message) {\n        generatedMessage = true;\n        const name = expected.name ? `\"${expected.name}\" ` : \"\";\n        message = `The ${name}validation function is expected to return \"true\". Received ${inspect(res)}`;\n        if (isError(actual)) {\n          message += `\n\nCaught error:\n\n${actual}`;\n        }\n      }\n      throwError = true;\n    }\n  }\n  if (throwError) {\n    const err = new AssertionError({\n      actual,\n      expected,\n      message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\nfunction getActual(fn) {\n  validateFunction(fn, \"fn\");\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION_SENTINEL;\n}\nfunction checkIsPromise(obj) {\n  return isPromise(obj) || obj !== null && typeof obj === \"object\" && typeof obj.then === \"function\" && typeof obj.catch === \"function\";\n}\nasync function waitForActual(promiseFn) {\n  let resultPromise;\n  if (typeof promiseFn === \"function\") {\n    resultPromise = promiseFn();\n    if (!checkIsPromise(resultPromise)) {\n      throw new ERR_INVALID_RETURN_VALUE(\"instance of Promise\", \"promiseFn\", resultPromise);\n    }\n  } else if (checkIsPromise(promiseFn)) {\n    resultPromise = promiseFn;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"promiseFn\", [\"Function\", \"Promise\"], promiseFn);\n  }\n  try {\n    await resultPromise;\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION_SENTINEL;\n}\nfunction expectsError(stackStartFn, actual, error, message) {\n  if (typeof error === \"string\") {\n    if (arguments.length === 4) {\n      throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n    }\n    if (typeof actual === \"object\" && actual !== null) {\n      if (actual.message === error) {\n        throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", `The error message \"${actual.message}\" is identical to the message.`);\n      }\n    } else if (actual === error) {\n      throw new ERR_AMBIGUOUS_ARGUMENT(\"error/message\", `The error \"${actual}\" is identical to the message.`);\n    }\n    message = error;\n    error = void 0;\n  } else if (error != null && typeof error !== \"object\" && typeof error !== \"function\") {\n    throw new ERR_INVALID_ARG_TYPE(\"error\", [\"Object\", \"Error\", \"Function\", \"RegExp\"], error);\n  }\n  if (actual === NO_EXCEPTION_SENTINEL) {\n    let details = \"\";\n    if (error && error.name) {\n      details += ` (${error.name})`;\n    }\n    details += message ? `: ${message}` : \".\";\n    const fnType = stackStartFn.name === \"rejects\" ? \"rejection\" : \"exception\";\n    innerFail({\n      actual: void 0,\n      expected: error,\n      operator: stackStartFn.name,\n      message: `Missing expected ${fnType}${details}`,\n      stackStartFn\n    });\n  }\n  if (!error)\n    return;\n  expectedException(actual, error, message, stackStartFn);\n}\nfunction hasMatchingError(actual, expected) {\n  if (typeof expected !== \"function\") {\n    if (isRegExp(expected)) {\n      const str = String(actual);\n      return RegExpPrototypeTest(expected, str);\n    }\n    throw new ERR_INVALID_ARG_TYPE(\"expected\", [\"Function\", \"RegExp\"], expected);\n  }\n  if (expected.prototype !== void 0 && actual instanceof expected) {\n    return true;\n  }\n  if (ObjectPrototypeIsPrototypeOf(Error, expected)) {\n    return false;\n  }\n  return ReflectApply(expected, {}, [actual]) === true;\n}\nfunction expectsNoError(stackStartFn, actual, error, message) {\n  if (actual === NO_EXCEPTION_SENTINEL)\n    return;\n  if (typeof error === \"string\") {\n    message = error;\n    error = void 0;\n  }\n  if (!error || hasMatchingError(actual, error)) {\n    const details = message ? `: ${message}` : \".\";\n    const fnType = stackStartFn.name === \"doesNotReject\" ? \"rejection\" : \"exception\";\n    innerFail({\n      actual,\n      expected: error,\n      operator: stackStartFn.name,\n      message: `Got unwanted ${fnType}${details}\nActual message: \"${actual && actual.message}\"`,\n      stackStartFn\n    });\n  }\n  throw actual;\n}\nassert.throws = function throws(promiseFn, ...args) {\n  expectsError(throws, getActual(promiseFn), ...args);\n};\nassert.rejects = async function rejects(promiseFn, ...args) {\n  expectsError(rejects, await waitForActual(promiseFn), ...args);\n};\nassert.doesNotThrow = function doesNotThrow(fn, ...args) {\n  expectsNoError(doesNotThrow, getActual(fn), ...args);\n};\nassert.doesNotReject = async function doesNotReject(fn, ...args) {\n  expectsNoError(doesNotReject, await waitForActual(fn), ...args);\n};\nassert.ifError = function ifError(err) {\n  if (err !== null && err !== void 0) {\n    let message = \"ifError got unwanted exception: \";\n    if (typeof err === \"object\" && typeof err.message === \"string\") {\n      if (err.message.length === 0 && err.constructor) {\n        message += err.constructor.name;\n      } else {\n        message += err.message;\n      }\n    } else {\n      message += inspect(err);\n    }\n    const newErr = new AssertionError({\n      actual: err,\n      expected: null,\n      operator: \"ifError\",\n      message,\n      stackStartFn: ifError\n    });\n    const origStack = err.stack;\n    if (typeof origStack === \"string\") {\n      const tmp2 = StringPrototypeSplit(origStack, \"\\n\");\n      ArrayPrototypeShift(tmp2);\n      let tmp1 = StringPrototypeSplit(newErr.stack, \"\\n\");\n      for (const errFrame of tmp2) {\n        const pos = ArrayPrototypeIndexOf(tmp1, errFrame);\n        if (pos !== -1) {\n          tmp1 = ArrayPrototypeSlice(tmp1, 0, pos);\n          break;\n        }\n      }\n      newErr.stack = `${ArrayPrototypeJoin(tmp1, \"\\n\")}\n${ArrayPrototypeJoin(tmp2, \"\\n\")}`;\n    }\n    throw newErr;\n  }\n};\nfunction internalMatch(string, regexp, message, fn) {\n  if (!isRegExp(regexp)) {\n    throw new ERR_INVALID_ARG_TYPE(\"regexp\", \"RegExp\", regexp);\n  }\n  const match2 = fn.name === \"match\";\n  if (typeof string !== \"string\" || RegExpPrototypeTest(regexp, string) !== match2) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    const generatedMessage = !message;\n    message = message || (typeof string !== \"string\" ? `The \"string\" argument must be of type string. Received type ${typeof string} (${inspect(string)})` : (match2 ? \"The input did not match the regular expression \" : \"The input was expected to not match the regular expression \") + `${inspect(regexp)}. Input:\n\n${inspect(string)}\n`);\n    const err = new AssertionError({\n      actual: string,\n      expected: regexp,\n      message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\nassert.match = function match(string, regexp, message) {\n  internalMatch(string, regexp, message, match);\n};\nassert.doesNotMatch = function doesNotMatch(string, regexp, message) {\n  internalMatch(string, regexp, message, doesNotMatch);\n};\nassert.CallTracker = CallTracker;\nfunction strict(...args) {\n  innerOk(strict, args.length, ...args);\n}\nassert.strict = ObjectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n}"],["async_hooks.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIncludes,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSplice,\n  FunctionPrototypeBind,\n  NumberIsSafeInteger,\n  ObjectDefineProperties,\n  ObjectIs,\n  ReflectApply,\n  Symbol\n} = primordials;\nconst {\n  ERR_ASYNC_CALLBACK,\n  ERR_ASYNC_TYPE,\n  ERR_INVALID_ASYNC_ID\n} = require(\"internal/errors\").codes;\nconst {\n  validateFunction,\n  validateString\n} = require(\"internal/validators\");\nconst internal_async_hooks = require(\"internal/async_hooks\");\nconst { registerDestroyHook } = internal_async_hooks;\nconst {\n  executionAsyncId,\n  triggerAsyncId,\n  hasAsyncIdStack,\n  getHookArrays,\n  enableHooks,\n  disableHooks,\n  updatePromiseHookMode,\n  executionAsyncResource,\n  newAsyncId,\n  getDefaultTriggerAsyncId,\n  emitInit,\n  emitBefore,\n  emitAfter,\n  emitDestroy,\n  enabledHooksExist,\n  initHooksExist,\n  destroyHooksExist\n} = internal_async_hooks;\nconst {\n  async_id_symbol,\n  trigger_async_id_symbol,\n  init_symbol,\n  before_symbol,\n  after_symbol,\n  destroy_symbol,\n  promise_resolve_symbol\n} = internal_async_hooks.symbols;\nconst {\n  kInit,\n  kBefore,\n  kAfter,\n  kDestroy,\n  kTotals,\n  kPromiseResolve\n} = internal_async_hooks.constants;\nclass AsyncHook {\n  constructor({ init, before, after, destroy, promiseResolve }) {\n    if (init !== void 0 && typeof init !== \"function\")\n      throw new ERR_ASYNC_CALLBACK(\"hook.init\");\n    if (before !== void 0 && typeof before !== \"function\")\n      throw new ERR_ASYNC_CALLBACK(\"hook.before\");\n    if (after !== void 0 && typeof after !== \"function\")\n      throw new ERR_ASYNC_CALLBACK(\"hook.after\");\n    if (destroy !== void 0 && typeof destroy !== \"function\")\n      throw new ERR_ASYNC_CALLBACK(\"hook.destroy\");\n    if (promiseResolve !== void 0 && typeof promiseResolve !== \"function\")\n      throw new ERR_ASYNC_CALLBACK(\"hook.promiseResolve\");\n    this[init_symbol] = init;\n    this[before_symbol] = before;\n    this[after_symbol] = after;\n    this[destroy_symbol] = destroy;\n    this[promise_resolve_symbol] = promiseResolve;\n  }\n  enable() {\n    const { 0: hooks_array, 1: hook_fields } = getHookArrays();\n    if (ArrayPrototypeIncludes(hooks_array, this))\n      return this;\n    const prev_kTotals = hook_fields[kTotals];\n    hook_fields[kTotals] = hook_fields[kInit] += +!!this[init_symbol];\n    hook_fields[kTotals] += hook_fields[kBefore] += +!!this[before_symbol];\n    hook_fields[kTotals] += hook_fields[kAfter] += +!!this[after_symbol];\n    hook_fields[kTotals] += hook_fields[kDestroy] += +!!this[destroy_symbol];\n    hook_fields[kTotals] += hook_fields[kPromiseResolve] += +!!this[promise_resolve_symbol];\n    ArrayPrototypePush(hooks_array, this);\n    if (prev_kTotals === 0 && hook_fields[kTotals] > 0) {\n      enableHooks();\n    }\n    updatePromiseHookMode();\n    return this;\n  }\n  disable() {\n    const { 0: hooks_array, 1: hook_fields } = getHookArrays();\n    const index = ArrayPrototypeIndexOf(hooks_array, this);\n    if (index === -1)\n      return this;\n    const prev_kTotals = hook_fields[kTotals];\n    hook_fields[kTotals] = hook_fields[kInit] -= +!!this[init_symbol];\n    hook_fields[kTotals] += hook_fields[kBefore] -= +!!this[before_symbol];\n    hook_fields[kTotals] += hook_fields[kAfter] -= +!!this[after_symbol];\n    hook_fields[kTotals] += hook_fields[kDestroy] -= +!!this[destroy_symbol];\n    hook_fields[kTotals] += hook_fields[kPromiseResolve] -= +!!this[promise_resolve_symbol];\n    ArrayPrototypeSplice(hooks_array, index, 1);\n    if (prev_kTotals > 0 && hook_fields[kTotals] === 0) {\n      disableHooks();\n    }\n    return this;\n  }\n}\nfunction createHook(fns) {\n  return new AsyncHook(fns);\n}\nconst destroyedSymbol = Symbol(\"destroyed\");\nclass AsyncResource {\n  constructor(type, opts = {}) {\n    validateString(type, \"type\");\n    let triggerAsyncId2 = opts;\n    let requireManualDestroy = false;\n    if (typeof opts !== \"number\") {\n      triggerAsyncId2 = opts.triggerAsyncId === void 0 ? getDefaultTriggerAsyncId() : opts.triggerAsyncId;\n      requireManualDestroy = !!opts.requireManualDestroy;\n    }\n    if (!NumberIsSafeInteger(triggerAsyncId2) || triggerAsyncId2 < -1) {\n      throw new ERR_INVALID_ASYNC_ID(\"triggerAsyncId\", triggerAsyncId2);\n    }\n    const asyncId = newAsyncId();\n    this[async_id_symbol] = asyncId;\n    this[trigger_async_id_symbol] = triggerAsyncId2;\n    if (initHooksExist()) {\n      if (enabledHooksExist() && type.length === 0) {\n        throw new ERR_ASYNC_TYPE(type);\n      }\n      emitInit(asyncId, type, triggerAsyncId2, this);\n    }\n    if (!requireManualDestroy && destroyHooksExist()) {\n      const destroyed = { destroyed: false };\n      this[destroyedSymbol] = destroyed;\n      registerDestroyHook(this, asyncId, destroyed);\n    }\n  }\n  runInAsyncScope(fn, thisArg, ...args) {\n    const asyncId = this[async_id_symbol];\n    emitBefore(asyncId, this[trigger_async_id_symbol], this);\n    try {\n      const ret = ReflectApply(fn, thisArg, args);\n      return ret;\n    } finally {\n      if (hasAsyncIdStack())\n        emitAfter(asyncId);\n    }\n  }\n  emitDestroy() {\n    if (this[destroyedSymbol] !== void 0) {\n      this[destroyedSymbol].destroyed = true;\n    }\n    emitDestroy(this[async_id_symbol]);\n    return this;\n  }\n  asyncId() {\n    return this[async_id_symbol];\n  }\n  triggerAsyncId() {\n    return this[trigger_async_id_symbol];\n  }\n  bind(fn, thisArg = this) {\n    validateFunction(fn, \"fn\");\n    const ret = FunctionPrototypeBind(this.runInAsyncScope, this, fn, thisArg);\n    ObjectDefineProperties(ret, {\n      \"length\": {\n        configurable: true,\n        enumerable: false,\n        value: fn.length,\n        writable: false\n      },\n      \"asyncResource\": {\n        configurable: true,\n        enumerable: true,\n        value: this,\n        writable: true\n      }\n    });\n    return ret;\n  }\n  static bind(fn, type, thisArg) {\n    type = type || fn.name;\n    return new AsyncResource(type || \"bound-anonymous-fn\").bind(fn, thisArg);\n  }\n}\nconst storageList = [];\nconst storageHook = createHook({\n  init(asyncId, type, triggerAsyncId2, resource) {\n    const currentResource = executionAsyncResource();\n    for (let i = 0; i < storageList.length; ++i) {\n      storageList[i]._propagate(resource, currentResource);\n    }\n  }\n});\nclass AsyncLocalStorage {\n  constructor() {\n    this.kResourceStore = Symbol(\"kResourceStore\");\n    this.enabled = false;\n  }\n  disable() {\n    if (this.enabled) {\n      this.enabled = false;\n      ArrayPrototypeSplice(storageList, ArrayPrototypeIndexOf(storageList, this), 1);\n      if (storageList.length === 0) {\n        storageHook.disable();\n      }\n    }\n  }\n  _enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      ArrayPrototypePush(storageList, this);\n      storageHook.enable();\n    }\n  }\n  _propagate(resource, triggerResource) {\n    const store = triggerResource[this.kResourceStore];\n    if (this.enabled) {\n      resource[this.kResourceStore] = store;\n    }\n  }\n  enterWith(store) {\n    this._enable();\n    const resource = executionAsyncResource();\n    resource[this.kResourceStore] = store;\n  }\n  run(store, callback, ...args) {\n    if (ObjectIs(store, this.getStore())) {\n      return ReflectApply(callback, null, args);\n    }\n    this._enable();\n    const resource = executionAsyncResource();\n    const oldStore = resource[this.kResourceStore];\n    resource[this.kResourceStore] = store;\n    try {\n      return ReflectApply(callback, null, args);\n    } finally {\n      resource[this.kResourceStore] = oldStore;\n    }\n  }\n  exit(callback, ...args) {\n    if (!this.enabled) {\n      return ReflectApply(callback, null, args);\n    }\n    this.disable();\n    try {\n      return ReflectApply(callback, null, args);\n    } finally {\n      this._enable();\n    }\n  }\n  getStore() {\n    if (this.enabled) {\n      const resource = executionAsyncResource();\n      return resource[this.kResourceStore];\n    }\n  }\n}\nmodule.exports = {\n  AsyncLocalStorage,\n  createHook,\n  executionAsyncId,\n  triggerAsyncId,\n  executionAsyncResource,\n  AsyncResource\n};\n}"],["buffer.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  Error,\n  MathFloor,\n  MathMin,\n  MathTrunc,\n  NumberIsNaN,\n  NumberMAX_SAFE_INTEGER,\n  NumberMIN_SAFE_INTEGER,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  StringPrototypeCharCodeAt,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase,\n  StringPrototypeTrim,\n  SymbolSpecies,\n  SymbolToPrimitive,\n  TypedArrayPrototypeGetByteLength,\n  TypedArrayPrototypeFill,\n  TypedArrayPrototypeSet,\n  Uint8Array,\n  Uint8ArrayPrototype\n} = primordials;\nconst {\n  byteLengthUtf8,\n  compare: _compare,\n  compareOffset,\n  createFromString,\n  fill: bindingFill,\n  indexOfBuffer,\n  indexOfNumber,\n  indexOfString,\n  swap16: _swap16,\n  swap32: _swap32,\n  swap64: _swap64,\n  kMaxLength,\n  kStringMaxLength\n} = internalBinding(\"buffer\");\nconst {\n  getOwnNonIndexProperties,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    ONLY_ENUMERABLE\n  }\n} = internalBinding(\"util\");\nconst {\n  customInspectSymbol,\n  isInsideNodeModules,\n  lazyDOMException,\n  normalizeEncoding,\n  kIsEncodingSymbol\n} = require(\"internal/util\");\nconst {\n  isAnyArrayBuffer,\n  isArrayBufferView,\n  isUint8Array\n} = require(\"internal/util/types\");\nconst {\n  inspect: utilInspect\n} = require(\"internal/util/inspect\");\nconst { encodings } = internalBinding(\"string_decoder\");\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_BUFFER_SIZE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNKNOWN_ENCODING\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst {\n  validateArray,\n  validateBuffer,\n  validateNumber,\n  validateInteger,\n  validateString\n} = require(\"internal/validators\");\nconst validateOffset = (value, name, min = 0, max = kMaxLength) => validateInteger(value, name, min, max);\nconst {\n  FastBuffer,\n  markAsUntransferable,\n  addBufferPrototypeMethods,\n  createUnsafeBuffer\n} = require(\"internal/buffer\");\nconst {\n  Blob,\n  resolveObjectURL\n} = require(\"internal/blob\");\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\nconst constants = ObjectDefineProperties({}, {\n  MAX_LENGTH: {\n    value: kMaxLength,\n    writable: false,\n    enumerable: true\n  },\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength,\n    writable: false,\n    enumerable: true\n  }\n});\nBuffer.poolSize = 8 * 1024;\nlet poolSize, poolOffset, allocPool;\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\nfunction alignPool() {\n  if (poolOffset & 7) {\n    poolOffset |= 7;\n    poolOffset++;\n  }\n}\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = \"Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.\";\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 1e4 || !require(\"internal/options\").getOptionValue(\"--pending-deprecation\") && isInsideNodeModules()) {\n    return;\n  }\n  process.emitWarning(bufferWarning, \"DeprecationWarning\", \"DEP0005\");\n  bufferWarningAlreadyEmitted = true;\n}\nfunction toInteger(n, defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) && n >= NumberMIN_SAFE_INTEGER && n <= NumberMAX_SAFE_INTEGER) {\n    return n % 1 === 0 ? n : MathFloor(n);\n  }\n  return defaultVal;\n}\nfunction _copy(source, target, targetStart, sourceStart, sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE(\"source\", [\"Buffer\", \"Uint8Array\"], source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE(\"target\", [\"Buffer\", \"Uint8Array\"], target);\n  if (targetStart === void 0) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart, 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE(\"targetStart\", \">= 0\", targetStart);\n  }\n  if (sourceStart === void 0) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart, 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE(\"sourceStart\", \">= 0\", sourceStart);\n  }\n  if (sourceEnd === void 0) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd, 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE(\"sourceEnd\", \">= 0\", sourceEnd);\n  }\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE(\"sourceStart\", `<= ${source.length}`, sourceStart);\n  }\n  return _copyActual(source, target, targetStart, sourceStart, sourceEnd);\n}\nfunction _copyActual(source, target, targetStart, sourceStart, sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);\n  TypedArrayPrototypeSet(target, source, targetStart);\n  return nb;\n}\nfunction Buffer(arg, encodingOrOffset, length) {\n  showFlaggedDeprecation();\n  if (typeof arg === \"number\") {\n    if (typeof encodingOrOffset === \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(\"string\", \"string\", arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg, encodingOrOffset, length);\n}\nObjectDefineProperty(Buffer, SymbolSpecies, {\n  enumerable: false,\n  configurable: true,\n  get() {\n    return FastBuffer;\n  }\n});\nBuffer.from = function from(value, encodingOrOffset, length) {\n  if (typeof value === \"string\")\n    return fromString(value, encodingOrOffset);\n  if (typeof value === \"object\" && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value && (typeof valueOf === \"string\" || typeof valueOf === \"object\")) {\n      return from(valueOf, encodingOrOffset, length);\n    }\n    const b = fromObject(value);\n    if (b)\n      return b;\n    if (typeof value[SymbolToPrimitive] === \"function\") {\n      const primitive = value[SymbolToPrimitive](\"string\");\n      if (typeof primitive === \"string\") {\n        return fromString(primitive, encodingOrOffset);\n      }\n    }\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"first argument\", [\"string\", \"Buffer\", \"ArrayBuffer\", \"Array\", \"Array-like Object\"], value);\n};\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\nObjectSetPrototypeOf(Buffer, Uint8Array);\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size, \"size\");\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError(\"size\", size);\n  }\n});\nBuffer.alloc = function alloc(size, fill2, encoding) {\n  assertSize(size);\n  if (fill2 !== void 0 && fill2 !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf, fill2, 0, buf.length, encoding);\n  }\n  return new FastBuffer(size);\n};\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\nObjectSetPrototypeOf(SlowBuffer.prototype, Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer, Uint8Array);\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < Buffer.poolSize >>> 1) {\n    if (size > poolSize - poolOffset)\n      createPool();\n    const b = new FastBuffer(allocPool, poolOffset, size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\nfunction fromStringFast(string, ops) {\n  const length = ops.byteLength(string);\n  if (length >= Buffer.poolSize >>> 1)\n    return createFromString(string, ops.encodingVal);\n  if (length > poolSize - poolOffset)\n    createPool();\n  let b = new FastBuffer(allocPool, poolOffset, length);\n  const actual = ops.write(b, string, 0, length);\n  if (actual !== length) {\n    b = new FastBuffer(allocPool, poolOffset, actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\nfunction fromString(string, encoding) {\n  let ops;\n  if (typeof encoding !== \"string\" || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = void 0;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === void 0)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string, ops);\n}\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  if (byteOffset === void 0) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n  const maxLength = obj.byteLength - byteOffset;\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS(\"offset\");\n  if (length === void 0) {\n    length = maxLength;\n  } else {\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS(\"length\");\n    } else {\n      length = 0;\n    }\n  }\n  return new FastBuffer(obj, byteOffset, length);\n}\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < Buffer.poolSize >>> 1) {\n    if (obj.length > poolSize - poolOffset)\n      createPool();\n    const b = new FastBuffer(allocPool, poolOffset, obj.length);\n    TypedArrayPrototypeSet(b, obj, 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\nfunction fromObject(obj) {\n  if (obj.length !== void 0 || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== \"number\") {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n  if (obj.type === \"Buffer\" && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\nBuffer.compare = function compare(buf1, buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE(\"buf1\", [\"Buffer\", \"Uint8Array\"], buf1);\n  }\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE(\"buf2\", [\"Buffer\", \"Uint8Array\"], buf2);\n  }\n  if (buf1 === buf2) {\n    return 0;\n  }\n  return _compare(buf1, buf2);\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === \"string\" && encoding.length !== 0 && normalizeEncoding(encoding) !== void 0;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\nBuffer.concat = function concat(list, length) {\n  validateArray(list, \"list\");\n  if (list.length === 0)\n    return new FastBuffer();\n  if (length === void 0) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length, \"length\");\n  }\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      throw new ERR_INVALID_ARG_TYPE(`list[${i}]`, [\"Buffer\", \"Uint8Array\"], list[i]);\n    }\n    pos += _copyActual(buf, buffer, pos, 0, buf.length);\n  }\n  if (pos < length) {\n    TypedArrayPrototypeFill(buffer, 0, pos, length);\n  }\n  return buffer;\n};\nfunction base64ByteLength(str, bytes) {\n  if (StringPrototypeCharCodeAt(str, bytes - 1) === 61)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str, bytes - 1) === 61)\n    bytes--;\n  return bytes * 3 >>> 2;\n}\nconst encodingOps = {\n  utf8: {\n    encoding: \"utf8\",\n    encodingVal: encodingsMap.utf8,\n    byteLength: byteLengthUtf8,\n    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len),\n    slice: (buf, start, end) => buf.utf8Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfString(buf, val, byteOffset, encodingsMap.utf8, dir)\n  },\n  ucs2: {\n    encoding: \"ucs2\",\n    encodingVal: encodingsMap.utf16le,\n    byteLength: (string) => string.length * 2,\n    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),\n    slice: (buf, start, end) => buf.ucs2Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfString(buf, val, byteOffset, encodingsMap.utf16le, dir)\n  },\n  utf16le: {\n    encoding: \"utf16le\",\n    encodingVal: encodingsMap.utf16le,\n    byteLength: (string) => string.length * 2,\n    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len),\n    slice: (buf, start, end) => buf.ucs2Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfString(buf, val, byteOffset, encodingsMap.utf16le, dir)\n  },\n  latin1: {\n    encoding: \"latin1\",\n    encodingVal: encodingsMap.latin1,\n    byteLength: (string) => string.length,\n    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len),\n    slice: (buf, start, end) => buf.latin1Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfString(buf, val, byteOffset, encodingsMap.latin1, dir)\n  },\n  ascii: {\n    encoding: \"ascii\",\n    encodingVal: encodingsMap.ascii,\n    byteLength: (string) => string.length,\n    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len),\n    slice: (buf, start, end) => buf.asciiSlice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, fromStringFast(val, encodingOps.ascii), byteOffset, encodingsMap.ascii, dir)\n  },\n  base64: {\n    encoding: \"base64\",\n    encodingVal: encodingsMap.base64,\n    byteLength: (string) => base64ByteLength(string, string.length),\n    write: (buf, string, offset, len) => buf.base64Write(string, offset, len),\n    slice: (buf, start, end) => buf.base64Slice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, fromStringFast(val, encodingOps.base64), byteOffset, encodingsMap.base64, dir)\n  },\n  base64url: {\n    encoding: \"base64url\",\n    encodingVal: encodingsMap.base64url,\n    byteLength: (string) => base64ByteLength(string, string.length),\n    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len),\n    slice: (buf, start, end) => buf.base64urlSlice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, fromStringFast(val, encodingOps.base64url), byteOffset, encodingsMap.base64url, dir)\n  },\n  hex: {\n    encoding: \"hex\",\n    encodingVal: encodingsMap.hex,\n    byteLength: (string) => string.length >>> 1,\n    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len),\n    slice: (buf, start, end) => buf.hexSlice(start, end),\n    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, fromStringFast(val, encodingOps.hex), byteOffset, encodingsMap.hex, dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += \"\";\n  switch (encoding.length) {\n    case 4:\n      if (encoding === \"utf8\")\n        return encodingOps.utf8;\n      if (encoding === \"ucs2\")\n        return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === \"utf8\")\n        return encodingOps.utf8;\n      if (encoding === \"ucs2\")\n        return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === \"utf-8\")\n        return encodingOps.utf8;\n      if (encoding === \"ascii\")\n        return encodingOps.ascii;\n      if (encoding === \"ucs-2\")\n        return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === \"utf-8\")\n        return encodingOps.utf8;\n      if (encoding === \"ascii\")\n        return encodingOps.ascii;\n      if (encoding === \"ucs-2\")\n        return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === \"utf16le\" || StringPrototypeToLowerCase(encoding) === \"utf16le\")\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === \"utf-16le\" || StringPrototypeToLowerCase(encoding) === \"utf-16le\")\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === \"latin1\" || encoding === \"binary\")\n        return encodingOps.latin1;\n      if (encoding === \"base64\")\n        return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === \"latin1\" || encoding === \"binary\")\n        return encodingOps.latin1;\n      if (encoding === \"base64\")\n        return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === \"hex\" || StringPrototypeToLowerCase(encoding) === \"hex\")\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === \"base64url\" || StringPrototypeToLowerCase(encoding) === \"base64url\")\n        return encodingOps.base64url;\n      break;\n  }\n}\nfunction byteLength(string, encoding) {\n  if (typeof string !== \"string\") {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n    throw new ERR_INVALID_ARG_TYPE(\"string\", [\"string\", \"Buffer\", \"ArrayBuffer\"], string);\n  }\n  const len = string.length;\n  const mustMatch = arguments.length > 2 && arguments[2] === true;\n  if (!mustMatch && len === 0)\n    return 0;\n  if (!encoding)\n    return mustMatch ? -1 : byteLengthUtf8(string);\n  const ops = getEncodingOps(encoding);\n  if (ops === void 0)\n    return mustMatch ? -1 : byteLengthUtf8(string);\n  return ops.byteLength(string);\n}\nBuffer.byteLength = byteLength;\nObjectDefineProperty(Buffer.prototype, \"parent\", {\n  enumerable: true,\n  get() {\n    if (!(this instanceof Buffer))\n      return void 0;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype, \"offset\", {\n  enumerable: true,\n  get() {\n    if (!(this instanceof Buffer))\n      return void 0;\n    return this.byteOffset;\n  }\n});\nBuffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {\n  return _copy(this, target, targetStart, sourceStart, sourceEnd);\n};\nBuffer.prototype.toString = function toString(encoding, start, end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0, this.length);\n  }\n  const len = this.length;\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return \"\";\n  else\n    start |= 0;\n  if (end === void 0 || end > len)\n    end = len;\n  else\n    end |= 0;\n  if (end <= start)\n    return \"\";\n  if (encoding === void 0)\n    return this.utf8Slice(start, end);\n  const ops = getEncodingOps(encoding);\n  if (ops === void 0)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.slice(this, start, end);\n};\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\"otherBuffer\", [\"Buffer\", \"Uint8Array\"], otherBuffer);\n  }\n  if (this === otherBuffer)\n    return true;\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n  return this.byteLength === 0 || _compare(this, otherBuffer) === 0;\n};\nlet INSPECT_MAX_BYTES = 50;\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes, ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max, this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(this.hexSlice(0, actualMax), /(.{2})/g, \"$1 \"));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? \"s\" : \"\"}`;\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this, filter), (key) => {\n      extras = true;\n      obj[key] = this[key];\n    });\n    if (extras) {\n      if (this.length !== 0)\n        str += \", \";\n      str += StringPrototypeSlice(utilInspect(obj, {\n        ...ctx,\n        breakLength: Infinity,\n        compact: true\n      }), 27, -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\nBuffer.prototype.compare = function compare2(target, targetStart, targetEnd, sourceStart, sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE(\"target\", [\"Buffer\", \"Uint8Array\"], target);\n  }\n  if (arguments.length === 1)\n    return _compare(this, target);\n  if (targetStart === void 0)\n    targetStart = 0;\n  else\n    validateOffset(targetStart, \"targetStart\");\n  if (targetEnd === void 0)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd, \"targetEnd\", 0, target.length);\n  if (sourceStart === void 0)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart, \"sourceStart\");\n  if (sourceEnd === void 0)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd, \"sourceEnd\", 0, this.length);\n  if (sourceStart >= sourceEnd)\n    return targetStart >= targetEnd ? 0 : -1;\n  if (targetStart >= targetEnd)\n    return 1;\n  return compareOffset(this, target, targetStart, sourceStart, targetEnd, sourceEnd);\n};\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  validateBuffer(buffer);\n  if (typeof byteOffset === \"string\") {\n    encoding = byteOffset;\n    byteOffset = void 0;\n  } else if (byteOffset > 2147483647) {\n    byteOffset = 2147483647;\n  } else if (byteOffset < -2147483648) {\n    byteOffset = -2147483648;\n  }\n  byteOffset = +byteOffset;\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;\n  }\n  dir = !!dir;\n  if (typeof val === \"number\")\n    return indexOfNumber(buffer, val >>> 0, byteOffset, dir);\n  let ops;\n  if (encoding === void 0)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n  if (typeof val === \"string\") {\n    if (ops === void 0)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer, val, byteOffset, dir);\n  }\n  if (isUint8Array(val)) {\n    const encodingVal = ops === void 0 ? encodingsMap.utf8 : ops.encodingVal;\n    return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"value\", [\"number\", \"string\", \"Buffer\", \"Uint8Array\"], val);\n}\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.fill = function fill(value, offset, end, encoding) {\n  return _fill(this, value, offset, end, encoding);\n};\nfunction _fill(buf, value, offset, end, encoding) {\n  if (typeof value === \"string\") {\n    if (offset === void 0 || typeof offset === \"string\") {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === \"string\") {\n      encoding = end;\n      end = buf.length;\n    }\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === void 0) {\n      validateString(encoding, \"encoding\");\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n    if (value.length === 0) {\n      value = 0;\n    } else if (value.length === 1) {\n      if (normalizedEncoding === \"utf8\") {\n        const code = StringPrototypeCharCodeAt(value, 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === \"latin1\") {\n        value = StringPrototypeCharCodeAt(value, 0);\n      }\n    }\n  } else {\n    encoding = void 0;\n  }\n  if (offset === void 0) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset, \"offset\");\n    if (end === void 0) {\n      end = buf.length;\n    } else {\n      validateOffset(end, \"end\", 0, buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n  if (typeof value === \"number\") {\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    TypedArrayPrototypeFill(buf, value, offset, end);\n  } else {\n    const res = bindingFill(buf, value, offset, end, encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE(\"value\", value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n  return buf;\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  if (offset === void 0) {\n    return this.utf8Write(string, 0, this.length);\n  }\n  if (length === void 0 && typeof offset === \"string\") {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n  } else {\n    validateOffset(offset, \"offset\", 0, this.length);\n    const remaining = this.length - offset;\n    if (length === void 0) {\n      length = remaining;\n    } else if (typeof length === \"string\") {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length, \"length\", 0, this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n  if (!encoding)\n    return this.utf8Write(string, offset, length);\n  const ops = getEncodingOps(encoding);\n  if (ops === void 0)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this, string, offset, length);\n};\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: \"Buffer\", data };\n  }\n  return { type: \"Buffer\", data: [] };\n};\nfunction adjustOffset(offset, length) {\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\nBuffer.prototype.slice = function slice(start, end) {\n  const srcLength = this.length;\n  start = adjustOffset(start, srcLength);\n  end = end !== void 0 ? adjustOffset(end, srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n};\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE(\"16-bits\");\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this, i, i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\nBuffer.prototype.swap32 = function swap32() {\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE(\"32-bits\");\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\nBuffer.prototype.swap64 = function swap64() {\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE(\"64-bits\");\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\nlet transcode;\nif (internalBinding(\"config\").hasIntl) {\n  const {\n    icuErrName,\n    transcode: _transcode\n  } = internalBinding(\"icu\");\n  transcode = function transcode2(source, fromEncoding, toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE(\"source\", [\"Buffer\", \"Uint8Array\"], source);\n    }\n    if (source.length === 0)\n      return Buffer.alloc(0);\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source, fromEncoding, toEncoding);\n    if (typeof result !== \"number\")\n      return result;\n    const code = icuErrName(result);\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\nfunction btoa(input) {\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 255)\n      throw lazyDOMException(\"Invalid character\", \"InvalidCharacterError\");\n  }\n  const buf = Buffer.from(input, \"latin1\");\n  return buf.toString(\"base64\");\n}\nconst kBase64Digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction atob(input) {\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException(\"Invalid character\", \"InvalidCharacterError\");\n  }\n  return Buffer.from(input, \"base64\").toString(\"latin1\");\n}\nmodule.exports = {\n  Blob,\n  resolveObjectURL,\n  Buffer,\n  SlowBuffer,\n  transcode,\n  kMaxLength,\n  kStringMaxLength,\n  btoa,\n  atob\n};\nObjectDefineProperties(module.exports, {\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  INSPECT_MAX_BYTES: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return INSPECT_MAX_BYTES;\n    },\n    set(val) {\n      INSPECT_MAX_BYTES = val;\n    }\n  }\n});\n}"],["child_process.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeFilter,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeLastIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Error,\n  NumberIsInteger,\n  ObjectAssign,\n  ObjectDefineProperty,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeSet,\n  StringPrototypeSlice,\n  StringPrototypeToUpperCase\n} = primordials;\nconst {\n  promisify,\n  convertToValidSignal,\n  createDeferredPromise,\n  getSystemErrorName\n} = require(\"internal/util\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"child_process\", (fn) => {\n  debug = fn;\n});\nconst { Buffer } = require(\"buffer\");\nconst { Pipe, constants: PipeConstants } = internalBinding(\"pipe_wrap\");\nconst {\n  AbortError,\n  codes: errorCodes\n} = require(\"internal/errors\");\nconst {\n  ERR_INVALID_ARG_VALUE,\n  ERR_CHILD_PROCESS_IPC_REQUIRED,\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER,\n  ERR_INVALID_ARG_TYPE,\n  ERR_OUT_OF_RANGE\n} = errorCodes;\nconst { clearTimeout, setTimeout } = require(\"timers\");\nconst { getValidatedPath } = require(\"internal/fs/utils\");\nconst {\n  isInt32,\n  validateAbortSignal,\n  validateBoolean,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst child_process = require(\"internal/child_process\");\nconst {\n  getValidStdio,\n  setupChannel,\n  ChildProcess,\n  stdioStringToArray\n} = child_process;\nconst MAX_BUFFER = 1024 * 1024;\nfunction fork(modulePath) {\n  validateString(modulePath, \"modulePath\");\n  let execArgv;\n  let options = {};\n  let args = [];\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  }\n  if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n  if (pos < arguments.length && arguments[pos] != null) {\n    if (typeof arguments[pos] !== \"object\") {\n      throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`, arguments[pos]);\n    }\n    options = { ...arguments[pos++] };\n  }\n  execArgv = options.execArgv || process.execArgv;\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv, process._eval);\n    if (index > 0) {\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv, index - 1, 2);\n    }\n  }\n  args = [...execArgv, modulePath, ...args];\n  if (typeof options.stdio === \"string\") {\n    options.stdio = stdioStringToArray(options.stdio, \"ipc\");\n  } else if (!ArrayIsArray(options.stdio)) {\n    options.stdio = stdioStringToArray(options.silent ? \"pipe\" : \"inherit\", \"ipc\");\n  } else if (!ArrayPrototypeIncludes(options.stdio, \"ipc\")) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED(\"options.stdio\");\n  }\n  options.execPath = options.execPath || process.execPath;\n  options.shell = false;\n  return spawn(options.execPath, args, options);\n}\nfunction _forkChild(fd, serializationMode) {\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process, p, serializationMode);\n  process.on(\"newListener\", function onNewListener(name) {\n    if (name === \"message\" || name === \"disconnect\")\n      control.refCounted();\n  });\n  process.on(\"removeListener\", function onRemoveListener(name) {\n    if (name === \"message\" || name === \"disconnect\")\n      control.unrefCounted();\n  });\n}\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  options = { ...options };\n  options.shell = typeof options.shell === \"string\" ? options.shell : true;\n  return {\n    file: command,\n    options,\n    callback\n  };\n}\nfunction exec(command, options, callback) {\n  const opts = normalizeExecArgs(command, options, callback);\n  return module.exports.execFile(opts.file, opts.options, opts.callback);\n}\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise, resolve, reject } = createDeferredPromise();\n    promise.child = orig(...args, (err, stdout, stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout, stderr });\n      }\n    });\n    return promise;\n  };\n};\nObjectDefineProperty(exec, promisify.custom, {\n  enumerable: false,\n  value: customPromiseExecFunction(exec)\n});\nfunction execFile(file) {\n  let args = [];\n  let callback;\n  let options;\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n  if (pos < arguments.length && typeof arguments[pos] === \"object\") {\n    options = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n  if (pos < arguments.length && typeof arguments[pos] === \"function\") {\n    callback = arguments[pos++];\n  }\n  if (!callback && pos < arguments.length && arguments[pos] != null) {\n    throw new ERR_INVALID_ARG_VALUE(\"args\", arguments[pos]);\n  }\n  options = {\n    encoding: \"utf8\",\n    timeout: 0,\n    maxBuffer: MAX_BUFFER,\n    killSignal: \"SIGTERM\",\n    cwd: null,\n    env: null,\n    shell: false,\n    ...options\n  };\n  validateTimeout(options.timeout);\n  validateMaxBuffer(options.maxBuffer);\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n  const child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    shell: options.shell,\n    signal: options.signal,\n    uid: options.uid,\n    windowsHide: !!options.windowsHide,\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== \"buffer\" && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n  let ex = null;\n  let cmd = file;\n  function exithandler(code, signal) {\n    if (exited)\n      return;\n    exited = true;\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n    if (!callback)\n      return;\n    let stdout;\n    let stderr;\n    if (encoding || child.stdout && child.stdout.readableEncoding) {\n      stdout = ArrayPrototypeJoin(_stdout, \"\");\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding || child.stderr && child.stderr.readableEncoding) {\n      stderr = ArrayPrototypeJoin(_stderr, \"\");\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n    if (args.length !== 0)\n      cmd += ` ${ArrayPrototypeJoin(args, \" \")}`;\n    if (!ex) {\n      ex = new Error(\"Command failed: \" + cmd + \"\\n\" + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code < 0 ? getSystemErrorName(code) : code;\n      ex.signal = signal;\n    }\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n  function errorhandler(e) {\n    ex = e;\n    if (child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    exithandler();\n  }\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n    if (child.stderr)\n      child.stderr.destroy();\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n    child.stdout.on(\"data\", function onChildStdout(chunk) {\n      const encoding2 = child.stdout.readableEncoding;\n      const length = encoding2 ? Buffer.byteLength(chunk, encoding2) : chunk.length;\n      const slice = encoding2 ? StringPrototypeSlice : (buf, ...args2) => buf.slice(...args2);\n      stdoutLen += length;\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout, slice(chunk, 0, truncatedLen));\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stdout\");\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout, chunk);\n      }\n    });\n  }\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n    child.stderr.on(\"data\", function onChildStderr(chunk) {\n      const encoding2 = child.stderr.readableEncoding;\n      const length = encoding2 ? Buffer.byteLength(chunk, encoding2) : chunk.length;\n      stderrLen += length;\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr, chunk.slice(0, truncatedLen));\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER(\"stderr\");\n        kill();\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n  child.addListener(\"close\", exithandler);\n  child.addListener(\"error\", errorhandler);\n  return child;\n}\nObjectDefineProperty(execFile, promisify.custom, {\n  enumerable: false,\n  value: customPromiseExecFunction(execFile)\n});\nfunction normalizeSpawnArguments(file, args, options) {\n  validateString(file, \"file\");\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"file\", file, \"cannot be empty\");\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== \"object\") {\n    throw new ERR_INVALID_ARG_TYPE(\"args\", \"object\", args);\n  } else {\n    options = args;\n    args = [];\n  }\n  if (options === void 0)\n    options = {};\n  else\n    validateObject(options, \"options\");\n  let cwd = options.cwd;\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd, \"options.cwd\");\n  }\n  if (options.detached != null) {\n    validateBoolean(options.detached, \"options.detached\");\n  }\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.uid\", \"int32\", options.uid);\n  }\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.gid\", \"int32\", options.gid);\n  }\n  if (options.shell != null && typeof options.shell !== \"boolean\" && typeof options.shell !== \"string\") {\n    throw new ERR_INVALID_ARG_TYPE(\"options.shell\", [\"boolean\", \"string\"], options.shell);\n  }\n  if (options.argv0 != null) {\n    validateString(options.argv0, \"options.argv0\");\n  }\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide, \"options.windowsHide\");\n  }\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments, \"options.windowsVerbatimArguments\");\n  }\n  if (options.shell) {\n    const command = ArrayPrototypeJoin([file, ...args], \" \");\n    if (process.platform === \"win32\") {\n      if (typeof options.shell === \"string\")\n        file = options.shell;\n      else\n        file = process.env.comspec || \"cmd.exe\";\n      if (RegExpPrototypeTest(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i, file)) {\n        args = [\"/d\", \"/s\", \"/c\", `\"${command}\"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = [\"-c\", command];\n      }\n    } else {\n      if (typeof options.shell === \"string\")\n        file = options.shell;\n      else if (process.platform === \"android\")\n        file = \"/system/bin/sh\";\n      else\n        file = \"/bin/sh\";\n      args = [\"-c\", command];\n    }\n  }\n  if (typeof options.argv0 === \"string\") {\n    ArrayPrototypeUnshift(args, options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args, file);\n  }\n  const env = options.env || process.env;\n  const envPairs = [];\n  if (process.env.NODE_V8_COVERAGE && !ObjectPrototypeHasOwnProperty(options.env || {}, \"NODE_V8_COVERAGE\")) {\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\n  }\n  let envKeys = [];\n  for (const key in env) {\n    ArrayPrototypePush(envKeys, key);\n  }\n  if (process.platform === \"win32\") {\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(ArrayPrototypeSort(envKeys), (key) => {\n      const uppercaseKey = StringPrototypeToUpperCase(key);\n      if (sawKey.has(uppercaseKey)) {\n        return false;\n      }\n      sawKey.add(uppercaseKey);\n      return true;\n    });\n  }\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== void 0) {\n      ArrayPrototypePush(envPairs, `${key}=${value}`);\n    }\n  }\n  return {\n    ...options,\n    args,\n    cwd,\n    detached: !!options.detached,\n    envPairs,\n    file,\n    windowsHide: !!options.windowsHide,\n    windowsVerbatimArguments: !!windowsVerbatimArguments\n  };\n}\nfunction abortChildProcess(child, killSignal) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit(\"error\", new AbortError());\n    }\n  } catch (err) {\n    child.emit(\"error\", err);\n  }\n}\nfunction spawn(file, args, options) {\n  options = normalizeSpawnArguments(file, args, options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal, \"options.signal\");\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n  debug(\"spawn\", options);\n  child.spawn(options);\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit(\"error\", err);\n        }\n        timeoutId = null;\n      }\n    }, options.timeout);\n    child.once(\"exit\", () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n  if (options.signal) {\n    let onAbortListener = function() {\n      abortChildProcess(child, killSignal);\n    };\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener(\"abort\", onAbortListener, { once: true });\n      child.once(\"exit\", () => signal.removeEventListener(\"abort\", onAbortListener));\n    }\n  }\n  return child;\n}\nfunction spawnSync(file, args, options) {\n  options = {\n    maxBuffer: MAX_BUFFER,\n    ...normalizeSpawnArguments(file, args, options)\n  };\n  debug(\"spawnSync\", options);\n  validateTimeout(options.timeout);\n  validateMaxBuffer(options.maxBuffer);\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n  options.stdio = getValidStdio(options.stdio || \"pipe\", true).stdio;\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === \"string\") {\n        pipe.input = Buffer.from(input, options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`, [\n          \"Buffer\",\n          \"TypedArray\",\n          \"DataView\",\n          \"string\"\n        ], input);\n      }\n    }\n  }\n  return child_process.spawnSync(options);\n}\nfunction checkExecSyncError(ret, args, cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n  } else if (ret.status !== 0) {\n    let msg = \"Command failed: \";\n    msg += cmd || ArrayPrototypeJoin(args, \" \");\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\n${ret.stderr.toString()}`;\n    err = new Error(msg);\n  }\n  if (err) {\n    ObjectAssign(err, ret);\n  }\n  return err;\n}\nfunction execFileSync(command, args, options) {\n  options = normalizeSpawnArguments(command, args, options);\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(options.file, ArrayPrototypeSlice(options.args, 1), options);\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n  const err = checkExecSyncError(ret, options.args, void 0);\n  if (err)\n    throw err;\n  return ret.stdout;\n}\nfunction execSync(command, options) {\n  const opts = normalizeExecArgs(command, options, null);\n  const inheritStderr = !opts.options.stdio;\n  const ret = spawnSync(opts.file, opts.options);\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n  const err = checkExecSyncError(ret, opts.args, command);\n  if (err)\n    throw err;\n  return ret.stdout;\n}\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"timeout\", \"an unsigned integer\", timeout);\n  }\n}\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === \"number\" && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE(\"options.maxBuffer\", \"a positive number\", maxBuffer);\n  }\n}\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === \"string\" || typeof killSignal === \"number\") {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.killSignal\", [\"string\", \"number\"], killSignal);\n  }\n}\nmodule.exports = {\n  _forkChild,\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync\n};\n}"],["cluster.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst childOrPrimary = \"NODE_UNIQUE_ID\" in process.env ? \"child\" : \"primary\";\nmodule.exports = require(`internal/cluster/${childOrPrimary}`);\n}"],["console.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"internal/console/global\");\n}"],["constants.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectAssign,\n  ObjectFreeze\n} = primordials;\nconst constants = internalBinding(\"constants\");\nObjectAssign(exports, constants.os.dlopen, constants.os.errno, constants.os.priority, constants.os.signals, constants.fs, constants.crypto);\nObjectFreeze(exports);\n}"],["crypto.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperty,\n  ObjectDefineProperties\n} = primordials;\nconst {\n  assertCrypto,\n  deprecate\n} = require(\"internal/util\");\nassertCrypto();\nconst {\n  ERR_CRYPTO_FIPS_FORCED\n} = require(\"internal/errors\").codes;\nconst constants = internalBinding(\"constants\").crypto;\nconst { getOptionValue } = require(\"internal/options\");\nconst pendingDeprecation = getOptionValue(\"--pending-deprecation\");\nconst fipsForced = getOptionValue(\"--force-fips\");\nconst {\n  getFipsCrypto,\n  setFipsCrypto,\n  timingSafeEqual\n} = internalBinding(\"crypto\");\nconst {\n  checkPrime,\n  checkPrimeSync,\n  generatePrime,\n  generatePrimeSync,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  randomInt,\n  randomUUID\n} = require(\"internal/crypto/random\");\nconst {\n  pbkdf2,\n  pbkdf2Sync\n} = require(\"internal/crypto/pbkdf2\");\nconst {\n  scrypt,\n  scryptSync\n} = require(\"internal/crypto/scrypt\");\nconst {\n  hkdf,\n  hkdfSync\n} = require(\"internal/crypto/hkdf\");\nconst {\n  generateKeyPair,\n  generateKeyPairSync,\n  generateKey,\n  generateKeySync\n} = require(\"internal/crypto/keygen\");\nconst {\n  createSecretKey,\n  createPublicKey,\n  createPrivateKey,\n  KeyObject\n} = require(\"internal/crypto/keys\");\nconst {\n  DiffieHellman,\n  DiffieHellmanGroup,\n  ECDH,\n  diffieHellman\n} = require(\"internal/crypto/diffiehellman\");\nconst {\n  Cipher,\n  Cipheriv,\n  Decipher,\n  Decipheriv,\n  privateDecrypt,\n  privateEncrypt,\n  publicDecrypt,\n  publicEncrypt,\n  getCipherInfo\n} = require(\"internal/crypto/cipher\");\nconst {\n  Sign,\n  signOneShot,\n  Verify,\n  verifyOneShot\n} = require(\"internal/crypto/sig\");\nconst {\n  Hash,\n  Hmac\n} = require(\"internal/crypto/hash\");\nconst {\n  X509Certificate\n} = require(\"internal/crypto/x509\");\nconst {\n  getCiphers,\n  getCurves,\n  getDefaultEncoding,\n  getHashes,\n  setDefaultEncoding,\n  setEngine,\n  lazyRequire,\n  secureHeapUsed\n} = require(\"internal/crypto/util\");\nconst Certificate = require(\"internal/crypto/certificate\");\nfunction createHash(algorithm, options) {\n  return new Hash(algorithm, options);\n}\nfunction createCipher(cipher, password, options) {\n  return new Cipher(cipher, password, options);\n}\nfunction createCipheriv(cipher, key, iv, options) {\n  return new Cipheriv(cipher, key, iv, options);\n}\nfunction createDecipher(cipher, password, options) {\n  return new Decipher(cipher, password, options);\n}\nfunction createDecipheriv(cipher, key, iv, options) {\n  return new Decipheriv(cipher, key, iv, options);\n}\nfunction createDiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {\n  return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);\n}\nfunction createDiffieHellmanGroup(name) {\n  return new DiffieHellmanGroup(name);\n}\nfunction createECDH(curve) {\n  return new ECDH(curve);\n}\nfunction createHmac(hmac, key, options) {\n  return new Hmac(hmac, key, options);\n}\nfunction createSign(algorithm, options) {\n  return new Sign(algorithm, options);\n}\nfunction createVerify(algorithm, options) {\n  return new Verify(algorithm, options);\n}\nmodule.exports = {\n  checkPrime,\n  checkPrimeSync,\n  createCipheriv,\n  createDecipheriv,\n  createDiffieHellman,\n  createDiffieHellmanGroup,\n  createECDH,\n  createHash,\n  createHmac,\n  createPrivateKey,\n  createPublicKey,\n  createSecretKey,\n  createSign,\n  createVerify,\n  diffieHellman,\n  generatePrime,\n  generatePrimeSync,\n  getCiphers,\n  getCipherInfo,\n  getCurves,\n  getDiffieHellman: createDiffieHellmanGroup,\n  getHashes,\n  hkdf,\n  hkdfSync,\n  pbkdf2,\n  pbkdf2Sync,\n  generateKeyPair,\n  generateKeyPairSync,\n  generateKey,\n  generateKeySync,\n  privateDecrypt,\n  privateEncrypt,\n  publicDecrypt,\n  publicEncrypt,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  randomInt,\n  randomUUID,\n  scrypt,\n  scryptSync,\n  sign: signOneShot,\n  setEngine,\n  timingSafeEqual,\n  getFips: fipsForced ? getFipsForced : getFipsCrypto,\n  setFips: fipsForced ? setFipsForced : setFipsCrypto,\n  verify: verifyOneShot,\n  Certificate,\n  Cipher,\n  Cipheriv,\n  Decipher,\n  Decipheriv,\n  DiffieHellman,\n  DiffieHellmanGroup,\n  ECDH,\n  Hash,\n  Hmac,\n  KeyObject,\n  Sign,\n  Verify,\n  X509Certificate,\n  secureHeapUsed\n};\nfunction setFipsForced(val) {\n  if (val)\n    return;\n  throw new ERR_CRYPTO_FIPS_FORCED();\n}\nfunction getFipsForced() {\n  return 1;\n}\nObjectDefineProperty(constants, \"defaultCipherList\", {\n  value: getOptionValue(\"--tls-cipher-list\")\n});\nObjectDefineProperties(module.exports, {\n  createCipher: {\n    enumerable: false,\n    value: deprecate(createCipher, \"crypto.createCipher is deprecated.\", \"DEP0106\")\n  },\n  createDecipher: {\n    enumerable: false,\n    value: deprecate(createDecipher, \"crypto.createDecipher is deprecated.\", \"DEP0106\")\n  },\n  fips: {\n    get: fipsForced ? getFipsForced : getFipsCrypto,\n    set: fipsForced ? setFipsForced : setFipsCrypto\n  },\n  DEFAULT_ENCODING: {\n    enumerable: false,\n    configurable: true,\n    get: deprecate(getDefaultEncoding, \"crypto.DEFAULT_ENCODING is deprecated.\", \"DEP0091\"),\n    set: deprecate(setDefaultEncoding, \"crypto.DEFAULT_ENCODING is deprecated.\", \"DEP0091\")\n  },\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  webcrypto: {\n    configurable: false,\n    enumerable: true,\n    get() {\n      return lazyRequire(\"internal/crypto/webcrypto\").crypto;\n    }\n  },\n  prng: {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: pendingDeprecation ? deprecate(randomBytes, \"crypto.prng is deprecated.\", \"DEP0115\") : randomBytes\n  },\n  pseudoRandomBytes: {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: pendingDeprecation ? deprecate(randomBytes, \"crypto.pseudoRandomBytes is deprecated.\", \"DEP0115\") : randomBytes\n  },\n  rng: {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: pendingDeprecation ? deprecate(randomBytes, \"crypto.rng is deprecated.\", \"DEP0115\") : randomBytes\n  }\n});\n}"],["dgram.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypePush,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  ReflectApply\n} = primordials;\nconst errors = require(\"internal/errors\");\nconst {\n  kStateSymbol,\n  _createSocketHandle,\n  newHandle\n} = require(\"internal/dgram\");\nconst { guessHandleType } = internalBinding(\"util\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_MISSING_ARGS,\n  ERR_SOCKET_ALREADY_BOUND,\n  ERR_SOCKET_BAD_BUFFER_SIZE,\n  ERR_SOCKET_BUFFER_SIZE,\n  ERR_SOCKET_DGRAM_IS_CONNECTED,\n  ERR_SOCKET_DGRAM_NOT_CONNECTED,\n  ERR_SOCKET_DGRAM_NOT_RUNNING,\n  ERR_INVALID_FD_TYPE\n} = errors.codes;\nconst {\n  isInt32,\n  validateAbortSignal,\n  validateString,\n  validateNumber,\n  validatePort\n} = require(\"internal/validators\");\nconst { Buffer } = require(\"buffer\");\nconst { deprecate } = require(\"internal/util\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst EventEmitter = require(\"events\");\nconst {\n  defaultTriggerAsyncIdScope,\n  symbols: { async_id_symbol, owner_symbol }\n} = require(\"internal/async_hooks\");\nconst { UV_UDP_REUSEADDR } = internalBinding(\"constants\").os;\nconst {\n  constants: { UV_UDP_IPV6ONLY },\n  UDP,\n  SendWrap\n} = internalBinding(\"udp_wrap\");\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster)\n    _cluster = require(\"cluster\");\n  return _cluster;\n}\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\nfunction Socket(type, listener) {\n  FunctionPrototypeCall(EventEmitter, this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n  let options;\n  if (type !== null && typeof type === \"object\") {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n  const handle = newHandle(type, lookup);\n  handle[owner_symbol] = this;\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n  if (typeof listener === \"function\")\n    this.on(\"message\", listener);\n  this[kStateSymbol] = {\n    handle,\n    receiving: false,\n    bindState: BIND_STATE_UNBOUND,\n    connectState: CONNECT_STATE_DISCONNECTED,\n    queue: void 0,\n    reuseAddr: options && options.reuseAddr,\n    ipv6Only: options && options.ipv6Only,\n    recvBufferSize,\n    sendBufferSize\n  };\n  if (options?.signal !== void 0) {\n    const { signal } = options;\n    validateAbortSignal(signal, \"options.signal\");\n    const onAborted = () => {\n      this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener(\"abort\", onAborted);\n      this.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n    }\n  }\n}\nObjectSetPrototypeOf(Socket.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(Socket, EventEmitter);\nfunction createSocket(type, listener) {\n  return new Socket(type, listener);\n}\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n  state.handle.onmessage = onMessage;\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n  if (state.recvBufferSize)\n    bufferSize(socket, state.recvBufferSize, RECV_BUFFER);\n  if (state.sendBufferSize)\n    bufferSize(socket, state.sendBufferSize, SEND_BUFFER);\n  socket.emit(\"listening\");\n}\nfunction replaceHandle(self, newHandle2) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n  newHandle2.lookup = oldHandle.lookup;\n  newHandle2.bind = oldHandle.bind;\n  newHandle2.send = oldHandle.send;\n  newHandle2[owner_symbol] = self;\n  oldHandle.close();\n  state.handle = newHandle2;\n  if (isConnected(self))\n    state.connectState = CONNECT_STATE_CONNECTED;\n}\nfunction bufferSize(self, size, buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size, buffer, ctx);\n  if (ret === void 0) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\nfunction bindServerHandle(self, options, errCb) {\n  const cluster = lazyLoadCluster();\n  const state = self[kStateSymbol];\n  cluster._getServer(self, options, (err, handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n    if (!state.handle) {\n      return handle.close();\n    }\n    replaceHandle(self, handle);\n    startListening(self);\n  });\n}\nSocket.prototype.bind = function(port_, address_) {\n  let port = port_;\n  healthCheck(this);\n  const state = this[kStateSymbol];\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n  state.bindState = BIND_STATE_BINDING;\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === \"function\") {\n    let removeListeners = function() {\n      this.removeListener(\"error\", removeListeners);\n      this.removeListener(\"listening\", onListening);\n    }, onListening = function() {\n      FunctionPrototypeCall(removeListeners, this);\n      FunctionPrototypeCall(cb, this);\n    };\n    this.on(\"error\", removeListeners);\n    this.on(\"listening\", onListening);\n  }\n  if (port !== null && typeof port === \"object\" && typeof port.recvStart === \"function\") {\n    replaceHandle(this, port);\n    startListening(this);\n    return this;\n  }\n  if (port !== null && typeof port === \"object\" && isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive2 = !!port.exclusive;\n    const state2 = this[kStateSymbol];\n    const cluster = lazyLoadCluster();\n    if (cluster.isWorker && !exclusive2) {\n      bindServerHandle(this, {\n        address: null,\n        port: null,\n        addressType: this.type,\n        fd,\n        flags: null\n      }, (err2) => {\n        const ex = errnoException(err2, \"open\");\n        state2.bindState = BIND_STATE_UNBOUND;\n        this.emit(\"error\", ex);\n      });\n      return this;\n    }\n    const type = guessHandleType(fd);\n    if (type !== \"UDP\")\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state2.handle.open(fd);\n    if (err)\n      throw errnoException(err, \"open\");\n    if (isConnected(this))\n      state2.connectState = CONNECT_STATE_CONNECTED;\n    startListening(this);\n    return this;\n  }\n  let address;\n  let exclusive;\n  if (port !== null && typeof port === \"object\") {\n    address = port.address || \"\";\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === \"function\" ? \"\" : address_;\n    exclusive = false;\n  }\n  if (!address) {\n    if (this.type === \"udp4\")\n      address = \"0.0.0.0\";\n    else\n      address = \"::\";\n  }\n  state.handle.lookup(address, (err, ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit(\"error\", err);\n      return;\n    }\n    const cluster = lazyLoadCluster();\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this, {\n        address: ip,\n        port,\n        addressType: this.type,\n        fd: -1,\n        flags\n      }, (err2) => {\n        const ex = exceptionWithHostPort(err2, \"bind\", ip, port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit(\"error\", ex);\n      });\n    } else {\n      if (!state.handle)\n        return;\n      const err2 = state.handle.bind(ip, port || 0, flags);\n      if (err2) {\n        const ex = exceptionWithHostPort(err2, \"bind\", ip, port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit(\"error\", ex);\n        return;\n      }\n      startListening(this);\n    }\n  });\n  return this;\n};\nSocket.prototype.connect = function(port, address, callback) {\n  port = validatePort(port, \"Port\", false);\n  if (typeof address === \"function\") {\n    callback = address;\n    address = \"\";\n  } else if (address === void 0) {\n    address = \"\";\n  }\n  validateString(address, \"address\");\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0, exclusive: true }, null);\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this, FunctionPrototypeBind(_connect, this, port, address, callback));\n    return;\n  }\n  ReflectApply(_connect, this, [port, address, callback]);\n};\nfunction _connect(port, address, callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once(\"connect\", callback);\n  const afterDns = (ex, ip) => {\n    defaultTriggerAsyncIdScope(this[async_id_symbol], doConnect, ex, this, ip, address, port, callback);\n  };\n  state.handle.lookup(address, afterDns);\n}\nfunction doConnect(ex, self, ip, address, port, callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n  if (!ex) {\n    const err = state.handle.connect(ip, port);\n    if (err) {\n      ex = exceptionWithHostPort(err, \"connect\", address, port);\n    }\n  }\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener(\"connect\", callback);\n        callback(ex);\n      } else {\n        self.emit(\"error\", ex);\n      }\n    });\n  }\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit(\"connect\"));\n}\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err, \"connect\");\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\nSocket.prototype.sendto = function(buffer, offset, length, port, address, callback) {\n  validateNumber(offset, \"offset\");\n  validateNumber(length, \"length\");\n  validateNumber(port, \"port\");\n  validateString(address, \"address\");\n  this.send(buffer, offset, length, port, address, callback);\n};\nfunction sliceBuffer(buffer, offset, length) {\n  if (typeof buffer === \"string\") {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\"buffer\", [\n      \"Buffer\",\n      \"TypedArray\",\n      \"DataView\",\n      \"string\"\n    ], buffer);\n  }\n  offset = offset >>> 0;\n  length = length >>> 0;\n  return Buffer.from(buffer.buffer, buffer.byteOffset + offset, length);\n}\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n  for (let i = 0, l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === \"string\")\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n  return newlist;\n}\nfunction enqueue(self, toEnqueue) {\n  const state = self[kStateSymbol];\n  if (state.queue === void 0) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor, onListenError);\n    self.once(\"listening\", onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue, toEnqueue);\n}\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor, onListenError);\n  FunctionPrototypeCall(clearQueue, this);\n}\nfunction onListenError(err) {\n  this.removeListener(\"listening\", onListenSuccess);\n  this[kStateSymbol].queue = void 0;\n}\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = void 0;\n  for (const queueEntry of queue)\n    queueEntry();\n}\nfunction isConnected(self) {\n  try {\n    self.remoteAddress();\n    return true;\n  } catch {\n    return false;\n  }\n}\nSocket.prototype.send = function(buffer, offset, length, port, address, callback) {\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || port && typeof port !== \"function\") {\n      buffer = sliceBuffer(buffer, offset, length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === \"number\") {\n      buffer = sliceBuffer(buffer, offset, length);\n      if (typeof port === \"function\") {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === \"string\") {\n      list = [Buffer.from(buffer)];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE(\"buffer\", [\n        \"Buffer\",\n        \"TypedArray\",\n        \"DataView\",\n        \"string\"\n      ], buffer);\n    } else {\n      list = [buffer];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE(\"buffer list arguments\", [\n      \"Buffer\",\n      \"TypedArray\",\n      \"DataView\",\n      \"string\"\n    ], buffer);\n  }\n  if (!connected)\n    port = validatePort(port, \"Port\", false);\n  if (typeof callback !== \"function\")\n    callback = void 0;\n  if (typeof address === \"function\") {\n    callback = address;\n    address = void 0;\n  } else if (address != null) {\n    validateString(address, \"address\");\n  }\n  healthCheck(this);\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0, exclusive: true }, null);\n  if (list.length === 0)\n    ArrayPrototypePush(list, Buffer.alloc(0));\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this, FunctionPrototypeBind(this.send, this, list, port, address, callback));\n    return;\n  }\n  const afterDns = (ex, ip) => {\n    defaultTriggerAsyncIdScope(this[async_id_symbol], doSend, ex, this, ip, list, address, port, callback);\n  };\n  if (!connected) {\n    state.handle.lookup(address, afterDns);\n  } else {\n    afterDns(null, null);\n  }\n};\nfunction doSend(ex, self, ip, list, address, port, callback) {\n  const state = self[kStateSymbol];\n  if (ex) {\n    if (typeof callback === \"function\") {\n      process.nextTick(callback, ex);\n      return;\n    }\n    process.nextTick(() => self.emit(\"error\", ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n  const req = new SendWrap();\n  req.list = list;\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n  let err;\n  if (port)\n    err = state.handle.send(req, list, list.length, port, ip, !!callback);\n  else\n    err = state.handle.send(req, list, list.length, !!callback);\n  if (err >= 1) {\n    if (callback)\n      process.nextTick(callback, null, err - 1);\n    return;\n  }\n  if (err && callback) {\n    const ex2 = exceptionWithHostPort(err, \"send\", address, port);\n    process.nextTick(callback, ex2);\n  }\n}\nfunction afterSend(err, sent) {\n  if (err) {\n    err = exceptionWithHostPort(err, \"send\", this.address, this.port);\n  } else {\n    err = null;\n  }\n  this.callback(err, sent);\n}\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  if (typeof callback === \"function\")\n    this.on(\"close\", callback);\n  if (queue !== void 0) {\n    ArrayPrototypePush(queue, FunctionPrototypeBind(this.close, this));\n    return this;\n  }\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, socketCloseNT, this);\n  return this;\n};\nfunction socketCloseNT(self) {\n  self.emit(\"close\");\n}\nSocket.prototype.address = function() {\n  healthCheck(this);\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err, \"getsockname\");\n  }\n  return out;\n};\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err, \"getpeername\");\n  return out;\n};\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, \"setBroadcast\");\n  }\n};\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl, \"ttl\");\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err, \"setTTL\");\n  }\n  return ttl;\n};\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl, \"ttl\");\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err, \"setMulticastTTL\");\n  }\n  return ttl;\n};\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, \"setMulticastLoopback\");\n  }\n  return arg;\n};\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress, \"interfaceAddress\");\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err, \"setMulticastInterface\");\n  }\n};\nSocket.prototype.addMembership = function(multicastAddress, interfaceAddress) {\n  healthCheck(this);\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS(\"multicastAddress\");\n  }\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, \"addMembership\");\n  }\n};\nSocket.prototype.dropMembership = function(multicastAddress, interfaceAddress) {\n  healthCheck(this);\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS(\"multicastAddress\");\n  }\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, \"dropMembership\");\n  }\n};\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress, groupAddress, interfaceAddress) {\n  healthCheck(this);\n  validateString(sourceAddress, \"sourceAddress\");\n  validateString(groupAddress, \"groupAddress\");\n  const err = this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, \"addSourceSpecificMembership\");\n  }\n};\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress, groupAddress, interfaceAddress) {\n  healthCheck(this);\n  validateString(sourceAddress, \"sourceAddress\");\n  validateString(groupAddress, \"groupAddress\");\n  const err = this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress, groupAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, \"dropSourceSpecificMembership\");\n  }\n};\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n  if (!state.receiving)\n    return;\n  state.handle.recvStop();\n  state.receiving = false;\n}\nfunction onMessage(nread, handle, buf, rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit(\"error\", errnoException(nread, \"recvmsg\"));\n  }\n  rinfo.size = buf.length;\n  self.emit(\"message\", buf, rinfo);\n}\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n  if (handle)\n    handle.ref();\n  return this;\n};\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n  if (handle)\n    handle.unref();\n  return this;\n};\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this, size, RECV_BUFFER);\n};\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this, size, SEND_BUFFER);\n};\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this, 0, RECV_BUFFER);\n};\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this, 0, SEND_BUFFER);\n};\nObjectDefineProperty(Socket.prototype, \"_handle\", {\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }, \"Socket.prototype._handle is deprecated\", \"DEP0112\"),\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }, \"Socket.prototype._handle is deprecated\", \"DEP0112\")\n});\nObjectDefineProperty(Socket.prototype, \"_receiving\", {\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }, \"Socket.prototype._receiving is deprecated\", \"DEP0112\"),\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }, \"Socket.prototype._receiving is deprecated\", \"DEP0112\")\n});\nObjectDefineProperty(Socket.prototype, \"_bindState\", {\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }, \"Socket.prototype._bindState is deprecated\", \"DEP0112\"),\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }, \"Socket.prototype._bindState is deprecated\", \"DEP0112\")\n});\nObjectDefineProperty(Socket.prototype, \"_queue\", {\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }, \"Socket.prototype._queue is deprecated\", \"DEP0112\"),\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }, \"Socket.prototype._queue is deprecated\", \"DEP0112\")\n});\nObjectDefineProperty(Socket.prototype, \"_reuseAddr\", {\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }, \"Socket.prototype._reuseAddr is deprecated\", \"DEP0112\"),\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }, \"Socket.prototype._reuseAddr is deprecated\", \"DEP0112\")\n});\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}, \"Socket.prototype._healthCheck() is deprecated\", \"DEP0112\");\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}, \"Socket.prototype._stopReceiving() is deprecated\", \"DEP0112\");\nObjectDefineProperty(UDP.prototype, \"owner\", {\n  get() {\n    return this[owner_symbol];\n  },\n  set(v) {\n    return this[owner_symbol] = v;\n  }\n});\nmodule.exports = {\n  _createSocketHandle: deprecate(_createSocketHandle, \"dgram._createSocketHandle() is deprecated\", \"DEP0112\"),\n  createSocket,\n  Socket\n};\n}"],["diagnostics_channel.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSplice,\n  ObjectCreate,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  SymbolHasInstance\n} = primordials;\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\n} = require(\"internal/errors\");\nconst {\n  validateFunction\n} = require(\"internal/validators\");\nconst { triggerUncaughtException } = internalBinding(\"errors\");\nconst { WeakReference } = internalBinding(\"util\");\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription, \"subscription\");\n    ArrayPrototypePush(this._subscribers, subscription);\n  }\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers, subscription);\n    if (index >= 0) {\n      ArrayPrototypeSplice(this._subscribers, index, 1);\n      if (!this._subscribers.length) {\n        ObjectSetPrototypeOf(this, Channel.prototype);\n      }\n    }\n  }\n  get hasSubscribers() {\n    return true;\n  }\n  publish(data) {\n    for (let i = 0; i < this._subscribers.length; i++) {\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data, this.name);\n      } catch (err) {\n        process.nextTick(() => {\n          triggerUncaughtException(err, false);\n        });\n      }\n    }\n  }\n}\nclass Channel {\n  constructor(name) {\n    this._subscribers = void 0;\n    this.name = name;\n  }\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype || prototype === ActiveChannel.prototype;\n  }\n  subscribe(subscription) {\n    ObjectSetPrototypeOf(this, ActiveChannel.prototype);\n    this._subscribers = [];\n    this.subscribe(subscription);\n  }\n  get hasSubscribers() {\n    return false;\n  }\n  publish() {\n  }\n}\nconst channels = ObjectCreate(null);\nfunction channel(name) {\n  let channel2;\n  const ref = channels[name];\n  if (ref)\n    channel2 = ref.get();\n  if (channel2)\n    return channel2;\n  if (typeof name !== \"string\" && typeof name !== \"symbol\") {\n    throw new ERR_INVALID_ARG_TYPE(\"channel\", [\"string\", \"symbol\"], name);\n  }\n  channel2 = new Channel(name);\n  channels[name] = new WeakReference(channel2);\n  return channel2;\n}\nfunction hasSubscribers(name) {\n  let channel2;\n  const ref = channels[name];\n  if (ref)\n    channel2 = ref.get();\n  if (!channel2) {\n    return false;\n  }\n  return channel2.hasSubscribers;\n}\nmodule.exports = {\n  channel,\n  hasSubscribers,\n  Channel\n};\n}"],["dns.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeMap,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ReflectApply\n} = primordials;\nconst cares = internalBinding(\"cares_wrap\");\nconst { toASCII } = require(\"internal/idna\");\nconst { isIP } = require(\"internal/net\");\nconst { customPromisifyArgs } = require(\"internal/util\");\nconst errors = require(\"internal/errors\");\nconst {\n  bindDefaultResolver,\n  getDefaultResolver,\n  setDefaultResolver,\n  Resolver,\n  validateHints,\n  emitInvalidHostnameWarning,\n  emitTypeCoercionDeprecationWarning,\n  getDefaultVerbatim,\n  setDefaultResultOrder\n} = require(\"internal/dns/utils\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE,\n  ERR_MISSING_ARGS\n} = errors.codes;\nconst {\n  validateCallback,\n  validatePort,\n  validateString,\n  validateOneOf\n} = require(\"internal/validators\");\nconst {\n  GetAddrInfoReqWrap,\n  GetNameInfoReqWrap,\n  QueryReqWrap\n} = cares;\nconst dnsException = errors.dnsException;\nlet promises = null;\nfunction onlookup(err, addresses) {\n  if (err) {\n    return this.callback(dnsException(err, \"getaddrinfo\", this.hostname));\n  }\n  this.callback(null, addresses[0], this.family || isIP(addresses[0]));\n}\nfunction onlookupall(err, addresses) {\n  if (err) {\n    return this.callback(dnsException(err, \"getaddrinfo\", this.hostname));\n  }\n  const family = this.family;\n  for (let i = 0; i < addresses.length; i++) {\n    const addr = addresses[i];\n    addresses[i] = {\n      address: addr,\n      family: family || isIP(addr)\n    };\n  }\n  this.callback(null, addresses);\n}\nfunction lookup(hostname, options, callback) {\n  let hints = 0;\n  let family = -1;\n  let all = false;\n  let verbatim = getDefaultVerbatim();\n  if (hostname) {\n    validateString(hostname, \"hostname\");\n  }\n  if (typeof options === \"function\") {\n    callback = options;\n    family = 0;\n  } else {\n    validateCallback(callback);\n    if (options !== null && typeof options === \"object\") {\n      if (options.hints != null && typeof options.hints !== \"number\") {\n        emitTypeCoercionDeprecationWarning();\n      }\n      hints = options.hints >>> 0;\n      if (options.family != null && typeof options.family !== \"number\") {\n        emitTypeCoercionDeprecationWarning();\n      }\n      family = options.family >>> 0;\n      if (options.all != null && typeof options.all !== \"boolean\") {\n        emitTypeCoercionDeprecationWarning();\n      }\n      all = options.all === true;\n      if (typeof options.verbatim === \"boolean\") {\n        verbatim = options.verbatim === true;\n      } else if (options.verbatim != null) {\n        emitTypeCoercionDeprecationWarning();\n      }\n      validateHints(hints);\n    } else {\n      if (options != null && typeof options !== \"number\") {\n        emitTypeCoercionDeprecationWarning();\n      }\n      family = options >>> 0;\n    }\n  }\n  validateOneOf(family, \"family\", [0, 4, 6]);\n  if (!hostname) {\n    emitInvalidHostnameWarning(hostname);\n    if (all) {\n      process.nextTick(callback, null, []);\n    } else {\n      process.nextTick(callback, null, null, family === 6 ? 6 : 4);\n    }\n    return {};\n  }\n  const matchedFamily = isIP(hostname);\n  if (matchedFamily) {\n    if (all) {\n      process.nextTick(callback, null, [{ address: hostname, family: matchedFamily }]);\n    } else {\n      process.nextTick(callback, null, hostname, matchedFamily);\n    }\n    return {};\n  }\n  const req = new GetAddrInfoReqWrap();\n  req.callback = callback;\n  req.family = family;\n  req.hostname = hostname;\n  req.oncomplete = all ? onlookupall : onlookup;\n  const err = cares.getaddrinfo(req, toASCII(hostname), family, hints, verbatim);\n  if (err) {\n    process.nextTick(callback, dnsException(err, \"getaddrinfo\", hostname));\n    return {};\n  }\n  return req;\n}\nObjectDefineProperty(lookup, customPromisifyArgs, { value: [\"address\", \"family\"], enumerable: false });\nfunction onlookupservice(err, hostname, service) {\n  if (err)\n    return this.callback(dnsException(err, \"getnameinfo\", this.hostname));\n  this.callback(null, hostname, service);\n}\nfunction lookupService(address, port, callback) {\n  if (arguments.length !== 3)\n    throw new ERR_MISSING_ARGS(\"address\", \"port\", \"callback\");\n  if (isIP(address) === 0)\n    throw new ERR_INVALID_ARG_VALUE(\"address\", address);\n  validatePort(port);\n  validateCallback(callback);\n  port = +port;\n  const req = new GetNameInfoReqWrap();\n  req.callback = callback;\n  req.hostname = address;\n  req.port = port;\n  req.oncomplete = onlookupservice;\n  const err = cares.getnameinfo(req, address, port);\n  if (err)\n    throw dnsException(err, \"getnameinfo\", address);\n  return req;\n}\nObjectDefineProperty(lookupService, customPromisifyArgs, { value: [\"hostname\", \"service\"], enumerable: false });\nfunction onresolve(err, result, ttls) {\n  if (ttls && this.ttl)\n    result = ArrayPrototypeMap(result, (address, index) => ({ address, ttl: ttls[index] }));\n  if (err)\n    this.callback(dnsException(err, this.bindingName, this.hostname));\n  else\n    this.callback(null, result);\n}\nfunction resolver(bindingName) {\n  function query(name, callback) {\n    let options;\n    if (arguments.length > 2) {\n      options = callback;\n      callback = arguments[2];\n    }\n    validateString(name, \"name\");\n    validateCallback(callback);\n    const req = new QueryReqWrap();\n    req.bindingName = bindingName;\n    req.callback = callback;\n    req.hostname = name;\n    req.oncomplete = onresolve;\n    req.ttl = !!(options && options.ttl);\n    const err = this._handle[bindingName](req, toASCII(name));\n    if (err)\n      throw dnsException(err, bindingName, name);\n    return req;\n  }\n  ObjectDefineProperty(query, \"name\", { value: bindingName });\n  return query;\n}\nconst resolveMap = ObjectCreate(null);\nResolver.prototype.resolveAny = resolveMap.ANY = resolver(\"queryAny\");\nResolver.prototype.resolve4 = resolveMap.A = resolver(\"queryA\");\nResolver.prototype.resolve6 = resolveMap.AAAA = resolver(\"queryAaaa\");\nResolver.prototype.resolveCaa = resolveMap.CAA = resolver(\"queryCaa\");\nResolver.prototype.resolveCname = resolveMap.CNAME = resolver(\"queryCname\");\nResolver.prototype.resolveMx = resolveMap.MX = resolver(\"queryMx\");\nResolver.prototype.resolveNs = resolveMap.NS = resolver(\"queryNs\");\nResolver.prototype.resolveTxt = resolveMap.TXT = resolver(\"queryTxt\");\nResolver.prototype.resolveSrv = resolveMap.SRV = resolver(\"querySrv\");\nResolver.prototype.resolvePtr = resolveMap.PTR = resolver(\"queryPtr\");\nResolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver(\"queryNaptr\");\nResolver.prototype.resolveSoa = resolveMap.SOA = resolver(\"querySoa\");\nResolver.prototype.reverse = resolver(\"getHostByAddr\");\nResolver.prototype.resolve = resolve;\nfunction resolve(hostname, rrtype, callback) {\n  let resolver2;\n  if (typeof rrtype === \"string\") {\n    resolver2 = resolveMap[rrtype];\n  } else if (typeof rrtype === \"function\") {\n    resolver2 = resolveMap.A;\n    callback = rrtype;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"rrtype\", \"string\", rrtype);\n  }\n  if (typeof resolver2 === \"function\") {\n    return ReflectApply(resolver2, this, [hostname, callback]);\n  }\n  throw new ERR_INVALID_ARG_VALUE(\"rrtype\", rrtype);\n}\nfunction defaultResolverSetServers(servers) {\n  const resolver2 = new Resolver();\n  resolver2.setServers(servers);\n  setDefaultResolver(resolver2);\n  bindDefaultResolver(module.exports, Resolver.prototype);\n  if (promises !== null)\n    bindDefaultResolver(promises, promises.Resolver.prototype);\n}\nmodule.exports = {\n  lookup,\n  lookupService,\n  Resolver,\n  setDefaultResultOrder,\n  setServers: defaultResolverSetServers,\n  ADDRCONFIG: cares.AI_ADDRCONFIG,\n  ALL: cares.AI_ALL,\n  V4MAPPED: cares.AI_V4MAPPED,\n  NODATA: \"ENODATA\",\n  FORMERR: \"EFORMERR\",\n  SERVFAIL: \"ESERVFAIL\",\n  NOTFOUND: \"ENOTFOUND\",\n  NOTIMP: \"ENOTIMP\",\n  REFUSED: \"EREFUSED\",\n  BADQUERY: \"EBADQUERY\",\n  BADNAME: \"EBADNAME\",\n  BADFAMILY: \"EBADFAMILY\",\n  BADRESP: \"EBADRESP\",\n  CONNREFUSED: \"ECONNREFUSED\",\n  TIMEOUT: \"ETIMEOUT\",\n  EOF: \"EOF\",\n  FILE: \"EFILE\",\n  NOMEM: \"ENOMEM\",\n  DESTRUCTION: \"EDESTRUCTION\",\n  BADSTR: \"EBADSTR\",\n  BADFLAGS: \"EBADFLAGS\",\n  NONAME: \"ENONAME\",\n  BADHINTS: \"EBADHINTS\",\n  NOTINITIALIZED: \"ENOTINITIALIZED\",\n  LOADIPHLPAPI: \"ELOADIPHLPAPI\",\n  ADDRGETNETWORKPARAMS: \"EADDRGETNETWORKPARAMS\",\n  CANCELLED: \"ECANCELLED\"\n};\nbindDefaultResolver(module.exports, getDefaultResolver());\nObjectDefineProperties(module.exports, {\n  promises: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      if (promises === null) {\n        promises = require(\"internal/dns/promises\");\n        promises.setServers = defaultResolverSetServers;\n        promises.setDefaultResultOrder = setDefaultResultOrder;\n      }\n      return promises;\n    }\n  }\n});\n}"],["domain.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeEvery,\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeLastIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  Error,\n  FunctionPrototypeCall,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply,\n  SafeMap,\n  Symbol\n} = primordials;\nconst EventEmitter = require(\"events\");\nconst {\n  ERR_DOMAIN_CALLBACK_NOT_AVAILABLE,\n  ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE,\n  ERR_UNHANDLED_ERROR\n} = require(\"internal/errors\").codes;\nconst { createHook } = require(\"async_hooks\");\nconst { useDomainTrampoline } = require(\"internal/async_hooks\");\nconst kWeak = Symbol(\"kWeak\");\nconst { WeakReference } = internalBinding(\"util\");\nconst _domain = [null];\nObjectDefineProperty(process, \"domain\", {\n  enumerable: true,\n  get: function() {\n    return _domain[0];\n  },\n  set: function(arg) {\n    return _domain[0] = arg;\n  }\n});\nconst pairing = new SafeMap();\nconst asyncHook = createHook({\n  init(asyncId, type, triggerAsyncId, resource) {\n    if (process.domain !== null && process.domain !== void 0) {\n      pairing.set(asyncId, process.domain[kWeak]);\n      if (type !== \"PROMISE\" || resource instanceof Promise) {\n        ObjectDefineProperty(resource, \"domain\", {\n          configurable: true,\n          enumerable: false,\n          value: process.domain,\n          writable: true\n        });\n      }\n    }\n  },\n  before(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== void 0) {\n      current.incRef();\n      current.get().enter();\n    }\n  },\n  after(asyncId) {\n    const current = pairing.get(asyncId);\n    if (current !== void 0) {\n      const domain = current.get();\n      current.decRef();\n      domain.exit();\n    }\n  },\n  destroy(asyncId) {\n    pairing.delete(asyncId);\n  }\n});\nif (process.hasUncaughtExceptionCaptureCallback()) {\n  throw new ERR_DOMAIN_CALLBACK_NOT_AVAILABLE();\n}\nconst domainRequireStack = new Error(\"require(`domain`) at this point\").stack;\nconst { setUncaughtExceptionCaptureCallback } = process;\nprocess.setUncaughtExceptionCaptureCallback = function(fn) {\n  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();\n  err.stack = err.stack + \"\\n\" + \"-\".repeat(40) + \"\\n\" + domainRequireStack;\n  throw err;\n};\nlet sendMakeCallbackDeprecation = false;\nfunction emitMakeCallbackDeprecation({ target, method }) {\n  if (!sendMakeCallbackDeprecation) {\n    process.emitWarning(`Using a domain property in MakeCallback is deprecated. Use the async_context variant of MakeCallback or the AsyncResource class instead. (Triggered by calling ${method?.name || \"<anonymous>\"} on ${target?.constructor?.name}.)`, \"DeprecationWarning\", \"DEP0097\");\n    sendMakeCallbackDeprecation = true;\n  }\n}\nfunction topLevelDomainCallback(cb, ...args) {\n  const domain = this.domain;\n  if (exports.active && domain)\n    emitMakeCallbackDeprecation({ target: this, method: cb });\n  if (domain)\n    domain.enter();\n  const ret = ReflectApply(cb, this, args);\n  if (domain)\n    domain.exit();\n  return ret;\n}\nlet stack = [];\nexports._stack = stack;\nuseDomainTrampoline(topLevelDomainCallback);\nfunction updateExceptionCapture() {\n  if (ArrayPrototypeEvery(stack, (domain) => domain.listenerCount(\"error\") === 0)) {\n    setUncaughtExceptionCaptureCallback(null);\n  } else {\n    setUncaughtExceptionCaptureCallback(null);\n    setUncaughtExceptionCaptureCallback((er) => {\n      return process.domain._errorHandler(er);\n    });\n  }\n}\nprocess.on(\"newListener\", (name, listener) => {\n  if (name === \"uncaughtException\" && listener !== domainUncaughtExceptionClear) {\n    process.removeListener(name, domainUncaughtExceptionClear);\n    process.prependListener(name, domainUncaughtExceptionClear);\n  }\n});\nprocess.on(\"removeListener\", (name, listener) => {\n  if (name === \"uncaughtException\" && listener !== domainUncaughtExceptionClear) {\n    const listeners = process.listeners(\"uncaughtException\");\n    if (listeners.length === 1 && listeners[0] === domainUncaughtExceptionClear)\n      process.removeListener(name, domainUncaughtExceptionClear);\n  }\n});\nfunction domainUncaughtExceptionClear() {\n  stack.length = 0;\n  exports.active = process.domain = null;\n  updateExceptionCapture();\n}\nclass Domain extends EventEmitter {\n  constructor() {\n    super();\n    this.members = [];\n    this[kWeak] = new WeakReference(this);\n    asyncHook.enable();\n    this.on(\"removeListener\", updateExceptionCapture);\n    this.on(\"newListener\", updateExceptionCapture);\n  }\n}\nexports.Domain = Domain;\nexports.create = exports.createDomain = function createDomain() {\n  return new Domain();\n};\nexports.active = null;\nDomain.prototype.members = void 0;\nDomain.prototype._errorHandler = function(er) {\n  let caught = false;\n  if (typeof er === \"object\" && er !== null || typeof er === \"function\") {\n    ObjectDefineProperty(er, \"domain\", {\n      configurable: true,\n      enumerable: false,\n      value: this,\n      writable: true\n    });\n    er.domainThrown = true;\n  }\n  while (exports.active === this) {\n    this.exit();\n  }\n  if (stack.length === 0) {\n    if (EventEmitter.listenerCount(this, \"error\") > 0) {\n      setUncaughtExceptionCaptureCallback(null);\n      try {\n        caught = this.emit(\"error\", er);\n      } finally {\n        updateExceptionCapture();\n      }\n    }\n  } else {\n    try {\n      caught = this.emit(\"error\", er);\n    } catch (er2) {\n      updateExceptionCapture();\n      if (stack.length) {\n        exports.active = process.domain = stack[stack.length - 1];\n        caught = process.domain._errorHandler(er2);\n      } else {\n        throw er2;\n      }\n    }\n  }\n  domainUncaughtExceptionClear();\n  return caught;\n};\nDomain.prototype.enter = function() {\n  exports.active = process.domain = this;\n  ArrayPrototypePush(stack, this);\n  updateExceptionCapture();\n};\nDomain.prototype.exit = function() {\n  const index = ArrayPrototypeLastIndexOf(stack, this);\n  if (index === -1)\n    return;\n  ArrayPrototypeSplice(stack, index);\n  exports.active = stack.length === 0 ? void 0 : stack[stack.length - 1];\n  process.domain = exports.active;\n  updateExceptionCapture();\n};\nDomain.prototype.add = function(ee) {\n  if (ee.domain === this)\n    return;\n  if (ee.domain)\n    ee.domain.remove(ee);\n  if (this.domain && ee instanceof Domain) {\n    for (let d = this.domain; d; d = d.domain) {\n      if (ee === d)\n        return;\n    }\n  }\n  ObjectDefineProperty(ee, \"domain\", {\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true\n  });\n  ArrayPrototypePush(this.members, ee);\n};\nDomain.prototype.remove = function(ee) {\n  ee.domain = null;\n  const index = ArrayPrototypeIndexOf(this.members, ee);\n  if (index !== -1)\n    ArrayPrototypeSplice(this.members, index, 1);\n};\nDomain.prototype.run = function(fn) {\n  this.enter();\n  const ret = ReflectApply(fn, this, ArrayPrototypeSlice(arguments, 1));\n  this.exit();\n  return ret;\n};\nfunction intercepted(_this, self, cb, fnargs) {\n  if (fnargs[0] && fnargs[0] instanceof Error) {\n    const er = fnargs[0];\n    er.domainBound = cb;\n    er.domainThrown = false;\n    ObjectDefineProperty(er, \"domain\", {\n      configurable: true,\n      enumerable: false,\n      value: self,\n      writable: true\n    });\n    self.emit(\"error\", er);\n    return;\n  }\n  self.enter();\n  const ret = ReflectApply(cb, _this, ArrayPrototypeSlice(fnargs, 1));\n  self.exit();\n  return ret;\n}\nDomain.prototype.intercept = function(cb) {\n  const self = this;\n  function runIntercepted() {\n    return intercepted(this, self, cb, arguments);\n  }\n  return runIntercepted;\n};\nfunction bound(_this, self, cb, fnargs) {\n  self.enter();\n  const ret = ReflectApply(cb, _this, fnargs);\n  self.exit();\n  return ret;\n}\nDomain.prototype.bind = function(cb) {\n  const self = this;\n  function runBound() {\n    return bound(this, self, cb, arguments);\n  }\n  ObjectDefineProperty(runBound, \"domain\", {\n    configurable: true,\n    enumerable: false,\n    value: this,\n    writable: true\n  });\n  return runBound;\n};\nEventEmitter.usingDomains = true;\nconst eventInit = EventEmitter.init;\nEventEmitter.init = function() {\n  ObjectDefineProperty(this, \"domain\", {\n    configurable: true,\n    enumerable: false,\n    value: null,\n    writable: true\n  });\n  if (exports.active && !(this instanceof exports.Domain)) {\n    this.domain = exports.active;\n  }\n  return FunctionPrototypeCall(eventInit, this);\n};\nconst eventEmit = EventEmitter.prototype.emit;\nEventEmitter.prototype.emit = function emit(...args) {\n  const domain = this.domain;\n  const type = args[0];\n  const shouldEmitError = type === \"error\" && this.listenerCount(type) > 0;\n  if (shouldEmitError || domain === null || domain === void 0 || this === process) {\n    return ReflectApply(eventEmit, this, args);\n  }\n  if (type === \"error\") {\n    const er = args.length > 1 && args[1] ? args[1] : new ERR_UNHANDLED_ERROR();\n    if (typeof er === \"object\") {\n      er.domainEmitter = this;\n      ObjectDefineProperty(er, \"domain\", {\n        configurable: true,\n        enumerable: false,\n        value: domain,\n        writable: true\n      });\n      er.domainThrown = false;\n    }\n    const origDomainsStack = ArrayPrototypeSlice(stack);\n    const origActiveDomain = process.domain;\n    let idx = stack.length - 1;\n    while (idx > -1 && process.domain === stack[idx]) {\n      --idx;\n    }\n    if (idx < 0) {\n      stack.length = 0;\n    } else {\n      ArrayPrototypeSplice(stack, idx + 1);\n    }\n    if (stack.length > 0) {\n      exports.active = process.domain = stack[stack.length - 1];\n    } else {\n      exports.active = process.domain = null;\n    }\n    updateExceptionCapture();\n    domain.emit(\"error\", er);\n    exports._stack = stack = origDomainsStack;\n    exports.active = process.domain = origActiveDomain;\n    updateExceptionCapture();\n    return false;\n  }\n  domain.enter();\n  const ret = ReflectApply(eventEmit, this, args);\n  domain.exit();\n  return ret;\n};\n}"],["events.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSplice,\n  Boolean,\n  Error,\n  ErrorCaptureStackTrace,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  MathMin,\n  NumberIsNaN,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectDefineProperties,\n  ObjectGetPrototypeOf,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseReject,\n  PromiseResolve,\n  ReflectOwnKeys,\n  String,\n  StringPrototypeSplit,\n  Symbol,\n  SymbolFor,\n  SymbolAsyncIterator\n} = primordials;\nconst kRejection = SymbolFor(\"nodejs.rejection\");\nconst { inspect } = require(\"internal/util/inspect\");\nlet spliceOne;\nconst {\n  AbortError,\n  kEnhanceStackBeforeInspector,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE,\n    ERR_UNHANDLED_ERROR\n  }\n} = require(\"internal/errors\");\nconst {\n  validateAbortSignal,\n  validateBoolean,\n  validateFunction\n} = require(\"internal/validators\");\nconst kCapture = Symbol(\"kCapture\");\nconst kErrorMonitor = Symbol(\"events.errorMonitor\");\nconst kMaxEventTargetListeners = Symbol(\"events.maxEventTargetListeners\");\nconst kMaxEventTargetListenersWarned = Symbol(\"events.maxEventTargetListenersWarned\");\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter, \"captureRejections\", {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  },\n  set(value) {\n    validateBoolean(value, \"EventEmitter.captureRejections\");\n    EventEmitter.prototype[kCapture] = value;\n  },\n  enumerable: true\n});\nEventEmitter.errorMonitor = kErrorMonitor;\nObjectDefineProperty(EventEmitter.prototype, kCapture, {\n  value: false,\n  writable: true,\n  enumerable: false\n});\nEventEmitter.prototype._events = void 0;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = void 0;\nlet defaultMaxListeners = 10;\nlet isEventTarget;\nfunction checkListener(listener) {\n  validateFunction(listener, \"listener\");\n}\nObjectDefineProperty(EventEmitter, \"defaultMaxListeners\", {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE(\"defaultMaxListeners\", \"a non-negative number\", arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\nObjectDefineProperties(EventEmitter, {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners,\n    enumerable: false,\n    configurable: false,\n    writable: false\n  },\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned,\n    enumerable: false,\n    configurable: false,\n    writable: false\n  }\n});\nEventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {\n  if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n))\n    throw new ERR_OUT_OF_RANGE(\"n\", \"a non-negative number\", n);\n  if (eventTargets.length === 0) {\n    defaultMaxListeners = n;\n  } else {\n    if (isEventTarget === void 0)\n      isEventTarget = require(\"internal/event_target\").isEventTarget;\n    for (let i = 0; i < eventTargets.length; i++) {\n      const target = eventTargets[i];\n      if (isEventTarget(target)) {\n        target[kMaxEventTargetListeners] = n;\n        target[kMaxEventTargetListenersWarned] = false;\n      } else if (typeof target.setMaxListeners === \"function\") {\n        target.setMaxListeners(n);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"eventTargets\", [\"EventEmitter\", \"EventTarget\"], target);\n      }\n    }\n  }\n};\nEventEmitter.init = function(opts) {\n  if (this._events === void 0 || this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || void 0;\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections, \"options.captureRejections\");\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\nfunction addCatch(that, promise, type, args) {\n  if (!that[kCapture]) {\n    return;\n  }\n  try {\n    const then = promise.then;\n    if (typeof then === \"function\") {\n      then.call(promise, void 0, function(err) {\n        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n      });\n    }\n  } catch (err) {\n    that.emit(\"error\", err);\n  }\n}\nfunction emitUnhandledRejectionOrErr(ee, err, type, args) {\n  if (typeof ee[kRejection] === \"function\") {\n    ee[kRejection](err, type, ...args);\n  } else {\n    const prev = ee[kCapture];\n    try {\n      ee[kCapture] = false;\n      ee.emit(\"error\", err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE(\"n\", \"a non-negative number\", n);\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === void 0)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nfunction identicalSequenceRange(a, b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    const pos = ArrayPrototypeIndexOf(b, a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i, rest);\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len, i];\n        }\n      }\n    }\n  }\n  return [0, 0];\n}\nfunction enhanceStackTrace(err, own) {\n  let ctorInfo = \"\";\n  try {\n    const { name } = this.constructor;\n    if (name !== \"EventEmitter\")\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n  }\n  const sep = `\nEmitted 'error' event${ctorInfo} at:\n`;\n  const errStack = ArrayPrototypeSlice(StringPrototypeSplit(err.stack, \"\\n\"), 1);\n  const ownStack = ArrayPrototypeSlice(StringPrototypeSplit(own.stack, \"\\n\"), 1);\n  const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack, off + 1, len - 2, \"    [... lines matching original stack trace ...]\");\n  }\n  return err.stack + sep + ArrayPrototypeJoin(ownStack, \"\\n\");\n}\nEventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = type === \"error\";\n  const events = this._events;\n  if (events !== void 0) {\n    if (doError && events[kErrorMonitor] !== void 0)\n      this.emit(kErrorMonitor, ...args);\n    doError = doError && events.error === void 0;\n  } else if (!doError)\n    return false;\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture, EventEmitter.prototype.emit);\n        ObjectDefineProperty(er, kEnhanceStackBeforeInspector, {\n          value: FunctionPrototypeBind(enhanceStackTrace, this, er, capture),\n          configurable: true\n        });\n      } catch {\n      }\n      throw er;\n    }\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err;\n  }\n  const handler = events[type];\n  if (handler === void 0)\n    return false;\n  if (typeof handler === \"function\") {\n    const result = handler.apply(this, args);\n    if (result !== void 0 && result !== null) {\n      addCatch(this, result, type, args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners2 = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners2[i].apply(this, args);\n      if (result !== void 0 && result !== null) {\n        addCatch(this, result, type, args);\n      }\n    }\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === void 0) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    if (events.newListener !== void 0) {\n      target.emit(\"newListener\", type, listener.listener ?? listener);\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === void 0) {\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === \"function\") {\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      const w = new Error(`Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`);\n      w.name = \"MaxListenersExceededWarning\";\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  const state = { fired: false, wrapFn: void 0, target, type, listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once2(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  checkListener(listener);\n  const events = this._events;\n  if (events === void 0)\n    return this;\n  const list = events[type];\n  if (list === void 0)\n    return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0)\n      this._events = ObjectCreate(null);\n    else {\n      delete events[type];\n      if (events.removeListener)\n        this.emit(\"removeListener\", type, list.listener || listener);\n    }\n  } else if (typeof list !== \"function\") {\n    let position = -1;\n    for (let i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        position = i;\n        break;\n      }\n    }\n    if (position < 0)\n      return this;\n    if (position === 0)\n      list.shift();\n    else {\n      if (spliceOne === void 0)\n        spliceOne = require(\"internal/util\").spliceOne;\n      spliceOne(list, position);\n    }\n    if (list.length === 1)\n      events[type] = list[0];\n    if (events.removeListener !== void 0)\n      this.emit(\"removeListener\", type, listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  const events = this._events;\n  if (events === void 0)\n    return this;\n  if (events.removeListener === void 0) {\n    if (arguments.length === 0) {\n      this._events = ObjectCreate(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== void 0) {\n      if (--this._eventsCount === 0)\n        this._events = ObjectCreate(null);\n      else\n        delete events[type];\n    }\n    return this;\n  }\n  if (arguments.length === 0) {\n    for (const key of ReflectOwnKeys(events)) {\n      if (key === \"removeListener\")\n        continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners(\"removeListener\");\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  const listeners2 = events[type];\n  if (typeof listeners2 === \"function\") {\n    this.removeListener(type, listeners2);\n  } else if (listeners2 !== void 0) {\n    for (let i = listeners2.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners2[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  const events = target._events;\n  if (events === void 0)\n    return [];\n  const evlistener = events[type];\n  if (evlistener === void 0)\n    return [];\n  if (typeof evlistener === \"function\")\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === \"function\") {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount, emitter, type);\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  const events = this._events;\n  if (events !== void 0) {\n    const evlistener = events[type];\n    if (typeof evlistener === \"function\") {\n      return 1;\n    } else if (evlistener !== void 0) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr) {\n  switch (arr.length) {\n    case 2:\n      return [arr[0], arr[1]];\n    case 3:\n      return [arr[0], arr[1], arr[2]];\n    case 4:\n      return [arr[0], arr[1], arr[2], arr[3]];\n    case 5:\n      return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6:\n      return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === \"function\")\n      ret[i] = orig;\n  }\n  return ret;\n}\nfunction getEventListeners(emitterOrTarget, type) {\n  if (typeof emitterOrTarget.listeners === \"function\") {\n    return emitterOrTarget.listeners(type);\n  }\n  const { isEventTarget: isEventTarget2, kEvents } = require(\"internal/event_target\");\n  if (isEventTarget2(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners2 = [];\n    let handler = root?.next;\n    while (handler?.listener !== void 0) {\n      const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;\n      listeners2.push(listener);\n      handler = handler.next;\n    }\n    return listeners2;\n  }\n  throw new ERR_INVALID_ARG_TYPE(\"emitter\", [\"EventEmitter\", \"EventTarget\"], emitterOrTarget);\n}\nasync function once(emitter, name, options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal, \"options.signal\");\n  if (signal?.aborted)\n    throw new AbortError();\n  return new Promise((resolve, reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name, resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === \"function\") {\n        emitter.removeListener(\"error\", errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== \"error\" && typeof emitter.once === \"function\") {\n      emitter.once(\"error\", errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter, name, resolver);\n      eventTargetAgnosticRemoveListener(emitter, \"error\", errorListener);\n      reject(new AbortError());\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(signal, \"abort\", abortListener, { once: true });\n    }\n  });\n}\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(ObjectGetPrototypeOf(async function* () {\n}).prototype);\nfunction createIterResult(value, done) {\n  return { value, done };\n}\nfunction eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {\n  if (typeof emitter.removeListener === \"function\") {\n    emitter.removeListener(name, listener);\n  } else if (typeof emitter.removeEventListener === \"function\") {\n    emitter.removeEventListener(name, listener, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"emitter\", \"EventEmitter\", emitter);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags?.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, (arg) => {\n      listener(arg);\n    }, flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"emitter\", \"EventEmitter\", emitter);\n  }\n}\nfunction on(emitter, event, options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal, \"options.signal\");\n  if (signal?.aborted)\n    throw new AbortError();\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value, false));\n      }\n      if (error) {\n        const p = PromiseReject(error);\n        error = null;\n        return p;\n      }\n      if (finished) {\n        return PromiseResolve(createIterResult(void 0, true));\n      }\n      return new Promise(function(resolve, reject) {\n        unconsumedPromises.push({ resolve, reject });\n      });\n    },\n    return() {\n      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);\n      eventTargetAgnosticRemoveListener(emitter, \"error\", errorHandler);\n      if (signal) {\n        eventTargetAgnosticRemoveListener(signal, \"abort\", abortListener, { once: true });\n      }\n      finished = true;\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(void 0, true));\n      }\n      return PromiseResolve(createIterResult(void 0, true));\n    },\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE(\"EventEmitter.AsyncIterator\", \"Error\", err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);\n      eventTargetAgnosticRemoveListener(emitter, \"error\", errorHandler);\n    },\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }, AsyncIteratorPrototype);\n  eventTargetAgnosticAddListener(emitter, event, eventHandler);\n  if (event !== \"error\" && typeof emitter.on === \"function\") {\n    emitter.on(\"error\", errorHandler);\n  }\n  if (signal) {\n    eventTargetAgnosticAddListener(signal, \"abort\", abortListener, { once: true });\n  }\n  return iterator;\n  function abortListener() {\n    errorHandler(new AbortError());\n  }\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args, false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n  function errorHandler(err) {\n    finished = true;\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n    if (toError) {\n      toError.reject(err);\n    } else {\n      error = err;\n    }\n    iterator.return();\n  }\n}\n}"],["fs.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  BigIntPrototypeToString,\n  MathMax,\n  Number,\n  ObjectCreate,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  Promise,\n  ReflectApply,\n  RegExpPrototypeExec,\n  SafeMap,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIndexOf,\n  StringPrototypeSlice\n} = primordials;\nconst { fs: constants } = internalBinding(\"constants\");\nconst {\n  S_IFIFO,\n  S_IFLNK,\n  S_IFMT,\n  S_IFREG,\n  S_IFSOCK,\n  F_OK,\n  R_OK,\n  W_OK,\n  X_OK,\n  O_WRONLY,\n  O_SYMLINK\n} = constants;\nconst pathModule = require(\"path\");\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst binding = internalBinding(\"fs\");\nconst { Buffer } = require(\"buffer\");\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_FS_FILE_TOO_LARGE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\n  },\n  AbortError,\n  uvErrmapGet,\n  uvException\n} = require(\"internal/errors\");\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require(\"internal/url\");\nconst internalUtil = require(\"internal/util\");\nconst {\n  constants: {\n    kIoMaxLength,\n    kMaxUserId\n  },\n  copyObject,\n  Dirent,\n  emitRecursiveRmdirWarning,\n  getDirents,\n  getOptions,\n  getValidatedFd,\n  getValidatedPath,\n  getValidMode,\n  handleErrorFromBinding,\n  nullCheck,\n  preprocessSymlinkDestination,\n  Stats,\n  getStatsFromBinding,\n  realpathCacheKey,\n  stringToFlags,\n  stringToSymlinkType,\n  toUnixTimestamp,\n  validateBufferArray,\n  validateCpOptions,\n  validateOffsetLengthRead,\n  validateOffsetLengthWrite,\n  validatePath,\n  validatePosition,\n  validateRmOptions,\n  validateRmOptionsSync,\n  validateRmdirOptions,\n  validateStringAfterArrayBufferView,\n  warnOnNonPortableTemplate\n} = require(\"internal/fs/utils\");\nconst {\n  Dir,\n  opendir,\n  opendirSync\n} = require(\"internal/fs/dir\");\nconst {\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH\n} = require(\"internal/constants\");\nconst {\n  isUint32,\n  parseFileMode,\n  validateBoolean,\n  validateBuffer,\n  validateCallback,\n  validateEncoding,\n  validateFunction,\n  validateInteger,\n  validateString\n} = require(\"internal/validators\");\nconst watchers = require(\"internal/fs/watchers\");\nconst ReadFileContext = require(\"internal/fs/read_file_context\");\nlet truncateWarn = true;\nlet fs;\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\nlet FileReadStream;\nlet FileWriteStream;\nconst isWindows = process.platform === \"win32\";\nconst isOSX = process.platform === \"darwin\";\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\"Using fs.truncate with a file descriptor is deprecated. Please use fs.ftruncate with a file descriptor instead.\", \"DeprecationWarning\", \"DEP0081\");\n    truncateWarn = false;\n  }\n}\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n  return cb;\n}\nfunction makeCallback(cb) {\n  validateCallback(cb);\n  return (...args) => ReflectApply(cb, this, args);\n}\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n  return (err, stats) => {\n    if (err)\n      return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  };\n}\nconst isFd = isUint32;\nfunction isFileType(stats, fileType) {\n  let mode = stats[1];\n  if (typeof mode === \"bigint\")\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\nfunction access(path, mode, callback) {\n  if (typeof mode === \"function\") {\n    callback = mode;\n    mode = F_OK;\n  }\n  path = getValidatedPath(path);\n  mode = getValidMode(mode, \"access\");\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path), mode, req);\n}\nfunction accessSync(path, mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode, \"access\");\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path), mode, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction exists(path, callback) {\n  maybeCallback(callback);\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n  try {\n    fs.access(path, F_OK, suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\nObjectDefineProperty(exists, internalUtil.promisify.custom, {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path, resolve));\n  }\n});\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath, F_OK, void 0, ctx);\n  if (isWindows && ctx.errno === void 0) {\n    binding.stat(nPath, false, void 0, ctx);\n  }\n  return ctx.errno === void 0;\n}\nfunction readFileAfterOpen(err, fd) {\n  const context = this.context;\n  if (err) {\n    context.callback(err);\n    return;\n  }\n  context.fd = fd;\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd, false, req);\n}\nfunction readFileAfterStat(err, stats) {\n  const context = this.context;\n  if (err)\n    return context.close(err);\n  const size = context.size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err2) {\n    return context.close(err2);\n  }\n  context.read();\n}\nfunction checkAborted(signal, callback) {\n  if (signal?.aborted) {\n    callback(new AbortError());\n    return true;\n  }\n  return false;\n}\nfunction readFile(path, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { flag: \"r\" });\n  const context = new ReadFileContext(callback, options.encoding);\n  context.isUserFd = isFd(path);\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context2) {\n      ReflectApply(readFileAfterOpen, { context: context2 }, [null, path]);\n    }, context);\n    return;\n  }\n  if (checkAborted(options.signal, callback))\n    return;\n  const flagsNumber = stringToFlags(options.flag, \"options.flag\");\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path), flagsNumber, 438, req);\n}\nfunction tryStatSync(fd, isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd, false, void 0, ctx);\n  if (ctx.errno !== void 0 && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\nfunction tryCreateBuffer(size, fd, isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd)\n      fs.closeSync(fd);\n  }\n  return buffer;\n}\nfunction tryReadSync(fd, isUserFd, buffer, pos, len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd, buffer, pos, len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd)\n      fs.closeSync(fd);\n  }\n  return bytesRead;\n}\nfunction readFileSync(path, options) {\n  options = getOptions(options, { flag: \"r\" });\n  const isUserFd = isFd(path);\n  const fd = isUserFd ? path : fs.openSync(path, options.flag, 438);\n  const stats = tryStatSync(fd, isUserFd);\n  const size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer;\n  let buffers;\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size, fd, isUserFd);\n  }\n  let bytesRead;\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers, buffer.slice(0, bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n  if (!isUserFd)\n    fs.closeSync(fd);\n  if (size === 0) {\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n  if (options.encoding)\n    buffer = buffer.toString(options.encoding);\n  return buffer;\n}\nfunction defaultCloseCallback(err) {\n  if (err != null)\n    throw err;\n}\nfunction close(fd, callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd, req);\n}\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.close(fd, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction open(path, flags, mode, callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = \"r\";\n    mode = 438;\n  } else if (typeof mode === \"function\") {\n    callback = mode;\n    mode = 438;\n  } else {\n    mode = parseFileMode(mode, \"mode\", 438);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.open(pathModule.toNamespacedPath(path), flagsNumber, mode, req);\n}\nfunction openSync(path, flags, mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode, \"mode\", 438);\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path), flagsNumber, mode, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction read(fd, buffer, offset, length, position, callback) {\n  fd = getValidatedFd(fd);\n  if (arguments.length <= 3) {\n    let options = {};\n    if (arguments.length < 3) {\n      callback = buffer;\n    } else {\n      options = buffer;\n      callback = offset;\n    }\n    ({\n      buffer = Buffer.alloc(16384),\n      offset = 0,\n      length = buffer.byteLength,\n      position\n    } = options);\n  }\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, \"offset\", 0);\n  }\n  length |= 0;\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null, 0, buffer);\n    });\n  }\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"buffer\", buffer, \"is empty and cannot be written\");\n  }\n  validateOffsetLengthRead(offset, length, buffer.byteLength);\n  if (position == null)\n    position = -1;\n  validatePosition(position, \"position\");\n  function wrapper(err, bytesRead) {\n    callback(err, bytesRead || 0, buffer);\n  }\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  binding.read(fd, buffer, offset, length, position, req);\n}\nObjectDefineProperty(read, internalUtil.customPromisifyArgs, { value: [\"bytesRead\", \"buffer\"], enumerable: false });\nfunction readSync(fd, buffer, offset, length, position) {\n  fd = getValidatedFd(fd);\n  validateBuffer(buffer);\n  if (arguments.length <= 3) {\n    const options = offset || {};\n    ({ offset = 0, length = buffer.byteLength, position } = options);\n  }\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset, \"offset\", 0);\n  }\n  length |= 0;\n  if (length === 0) {\n    return 0;\n  }\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\"buffer\", buffer, \"is empty and cannot be written\");\n  }\n  validateOffsetLengthRead(offset, length, buffer.byteLength);\n  if (position == null)\n    position = -1;\n  validatePosition(position, \"position\");\n  const ctx = {};\n  const result = binding.read(fd, buffer, offset, length, position, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction readv(fd, buffers, position, callback) {\n  function wrapper(err, read2) {\n    callback(err, read2 || 0, buffers);\n  }\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  if (typeof position !== \"number\")\n    position = null;\n  return binding.readBuffers(fd, buffers, position, req);\n}\nObjectDefineProperty(readv, internalUtil.customPromisifyArgs, { value: [\"bytesRead\", \"buffers\"], enumerable: false });\nfunction readvSync(fd, buffers, position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  const ctx = {};\n  if (typeof position !== \"number\")\n    position = null;\n  const result = binding.readBuffers(fd, buffers, position, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction write(fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    callback(err, written || 0, buffer);\n  }\n  fd = getValidatedFd(fd);\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === \"function\") {\n      offset = 0;\n    } else {\n      validateInteger(offset, \"offset\", 0);\n    }\n    if (typeof length !== \"number\")\n      length = buffer.byteLength - offset;\n    if (typeof position !== \"number\")\n      position = null;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    const req2 = new FSReqCallback();\n    req2.oncomplete = wrapper;\n    return binding.writeBuffer(fd, buffer, offset, length, position, req2);\n  }\n  validateStringAfterArrayBufferView(buffer, \"buffer\");\n  if (typeof position !== \"function\") {\n    if (typeof offset === \"function\") {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = \"utf8\";\n  }\n  const str = String(buffer);\n  validateEncoding(str, length);\n  callback = maybeCallback(position);\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd, str, offset, length, req);\n}\nObjectDefineProperty(write, internalUtil.customPromisifyArgs, { value: [\"bytesWritten\", \"buffer\"], enumerable: false });\nfunction writeSync(fd, buffer, offset, length, position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === void 0)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset, \"offset\", 0);\n    }\n    if (typeof length !== \"number\")\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n    result = binding.writeBuffer(fd, buffer, offset, length, position, void 0, ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer, \"buffer\");\n    validateEncoding(buffer, length);\n    if (offset === void 0)\n      offset = null;\n    result = binding.writeString(fd, buffer, offset, length, void 0, ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction writev(fd, buffers, position, callback) {\n  function wrapper(err, written) {\n    callback(err, written || 0, buffers);\n  }\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  if (typeof position !== \"number\")\n    position = null;\n  return binding.writeBuffers(fd, buffers, position, req);\n}\nObjectDefineProperty(writev, internalUtil.customPromisifyArgs, {\n  value: [\"bytesWritten\", \"buffer\"],\n  enumerable: false\n});\nfunction writevSync(fd, buffers, position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  const ctx = {};\n  if (typeof position !== \"number\")\n    position = null;\n  const result = binding.writeBuffers(fd, buffers, position, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction rename(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath, \"oldPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath), pathModule.toNamespacedPath(newPath), req);\n}\nfunction renameSync(oldPath, newPath) {\n  oldPath = getValidatedPath(oldPath, \"oldPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  const ctx = { path: oldPath, dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath), pathModule.toNamespacedPath(newPath), void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction truncate(path, len, callback) {\n  if (typeof path === \"number\") {\n    showTruncateDeprecation();\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === \"function\") {\n    callback = len;\n    len = 0;\n  } else if (len === void 0) {\n    len = 0;\n  }\n  validateInteger(len, \"len\");\n  len = MathMax(0, len);\n  callback = maybeCallback(callback);\n  fs.open(path, \"r+\", (er, fd) => {\n    if (er)\n      return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er2) {\n      fs.close(fd, (er22) => {\n        callback(aggregateTwoErrors(er22, er2));\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n}\nfunction truncateSync(path, len) {\n  if (typeof path === \"number\") {\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === void 0) {\n    len = 0;\n  }\n  const fd = fs.openSync(path, \"r+\");\n  let ret;\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\nfunction ftruncate(fd, len = 0, callback) {\n  if (typeof len === \"function\") {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len, \"len\");\n  len = MathMax(0, len);\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd, len, req);\n}\nfunction ftruncateSync(fd, len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len, \"len\");\n  len = MathMax(0, len);\n  const ctx = {};\n  binding.ftruncate(fd, len, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction lazyLoadCp() {\n  if (cpFn === void 0) {\n    ({ cpFn } = require(\"internal/fs/cp/cp\"));\n    cpFn = require(\"util\").callbackify(cpFn);\n    ({ cpSyncFn } = require(\"internal/fs/cp/cp-sync\"));\n  }\n}\nfunction lazyLoadRimraf() {\n  if (rimraf === void 0)\n    ({ rimraf, rimrafSync } = require(\"internal/fs/rimraf\"));\n}\nfunction rmdir(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(path, { ...options, force: false }, true, (err, options2) => {\n      if (err === false) {\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        return binding.rmdir(path, req);\n      }\n      if (err) {\n        return callback(err);\n      }\n      lazyLoadRimraf();\n      rimraf(path, options2, callback);\n    });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path, req);\n  }\n}\nfunction rmdirSync(path, options) {\n  path = getValidatedPath(path);\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path, { ...options, force: false }, true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path), options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path), void 0, ctx);\n  return handleErrorFromBinding(ctx);\n}\nfunction rm(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  validateRmOptions(path, options, false, (err, options2) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path), options2, callback);\n  });\n}\nfunction rmSync(path, options) {\n  options = validateRmOptionsSync(path, options, false);\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path), options);\n}\nfunction fdatasync(fd, callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n}\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction fsync(fd, callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n}\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction mkdir(path, options, callback) {\n  let mode = 511;\n  let recursive = false;\n  if (typeof options === \"function\") {\n    callback = options;\n  } else if (typeof options === \"number\" || typeof options === \"string\") {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== void 0)\n      recursive = options.recursive;\n    if (options.mode !== void 0)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateBoolean(recursive, \"options.recursive\");\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path), parseFileMode(mode, \"mode\"), recursive, req);\n}\nfunction mkdirSync(path, options) {\n  let mode = 511;\n  let recursive = false;\n  if (typeof options === \"number\" || typeof options === \"string\") {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== void 0)\n      recursive = options.recursive;\n    if (options.mode !== void 0)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive, \"options.recursive\");\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path), parseFileMode(mode, \"mode\"), recursive, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\nfunction readdir(path, options, callback) {\n  callback = makeCallback(typeof options === \"function\" ? options : callback);\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path, result, callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path), options.encoding, !!options.withFileTypes, req);\n}\nfunction readdirSync(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path), options.encoding, !!options.withFileTypes, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path, result) : result;\n}\nfunction fstat(fd, options = { bigint: false }, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd, options.bigint, req);\n}\nfunction lstat(path, options = { bigint: false }, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\nfunction stat(path, options = { bigint: false }, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === \"ENOENT\";\n  }\n  if (ctx.error) {\n    return ctx.error.code === \"ENOENT\";\n  }\n  return false;\n}\nfunction fstatSync(fd, options = { bigint: false, throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd, options.bigint, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\nfunction lstatSync(path, options = { bigint: false, throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path), options.bigint, void 0, ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return void 0;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\nfunction statSync(path, options = { bigint: false, throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path), options.bigint, void 0, ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return void 0;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\nfunction readlink(path, options, callback) {\n  callback = makeCallback(typeof options === \"function\" ? options : callback);\n  options = getOptions(options, {});\n  path = getValidatedPath(path, \"oldPath\");\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path), options.encoding, req);\n}\nfunction readlinkSync(path, options) {\n  options = getOptions(options, {});\n  path = getValidatedPath(path, \"oldPath\");\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path), options.encoding, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction symlink(target, path, type_, callback_) {\n  const type = typeof type_ === \"string\" ? type_ : null;\n  const callback = makeCallback(arguments[arguments.length - 1]);\n  target = getValidatedPath(target, \"target\");\n  path = getValidatedPath(path);\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      absoluteTarget = pathModule.resolve(path, \"..\", target);\n    } catch {\n    }\n    if (absoluteTarget !== void 0) {\n      stat(absoluteTarget, (err, stat2) => {\n        const resolvedType = !err && stat2.isDirectory() ? \"dir\" : \"file\";\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination2 = preprocessSymlinkDestination(target, resolvedType, path);\n        const req2 = new FSReqCallback();\n        req2.oncomplete = callback;\n        binding.symlink(destination2, pathModule.toNamespacedPath(path), resolvedFlags, req2);\n      });\n      return;\n    }\n  }\n  const destination = preprocessSymlinkDestination(target, type, path);\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination, pathModule.toNamespacedPath(path), flags, req);\n}\nfunction symlinkSync(target, path, type) {\n  type = typeof type === \"string\" ? type : null;\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`, \"..\", `${target}`);\n    if (statSync(absoluteTarget, { throwIfNoEntry: false })?.isDirectory()) {\n      type = \"dir\";\n    }\n  }\n  target = getValidatedPath(target, \"target\");\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n  const ctx = { path: target, dest: path };\n  binding.symlink(preprocessSymlinkDestination(target, type, path), pathModule.toNamespacedPath(path), flags, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction link(existingPath, newPath, callback) {\n  callback = makeCallback(callback);\n  existingPath = getValidatedPath(existingPath, \"existingPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.link(pathModule.toNamespacedPath(existingPath), pathModule.toNamespacedPath(newPath), req);\n}\nfunction linkSync(existingPath, newPath) {\n  existingPath = getValidatedPath(existingPath, \"existingPath\");\n  newPath = getValidatedPath(newPath, \"newPath\");\n  const ctx = { path: existingPath, dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath), pathModule.toNamespacedPath(newPath), void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction unlink(path, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path), req);\n}\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path), void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction fchmod(fd, mode, callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode, \"mode\");\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd, mode, req);\n}\nfunction fchmodSync(fd, mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode, \"mode\");\n  const ctx = {};\n  binding.fchmod(fd, mode, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction lchmod(path, mode, callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode, \"mode\");\n  fs.open(path, O_WRONLY | O_SYMLINK, (err, fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    fs.fchmod(fd, mode, (err2) => {\n      fs.close(fd, (err22) => {\n        callback(aggregateTwoErrors(err22, err2));\n      });\n    });\n  });\n}\nfunction lchmodSync(path, mode) {\n  const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd, mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\nfunction chmod(path, mode, callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, \"mode\");\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path), mode, req);\n}\nfunction chmodSync(path, mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode, \"mode\");\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path), mode, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction lchown(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path), uid, gid, req);\n}\nfunction lchownSync(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path), uid, gid, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction fchown(fd, uid, gid, callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd, uid, gid, req);\n}\nfunction fchownSync(fd, uid, gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  const ctx = {};\n  binding.fchown(fd, uid, gid, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction chown(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path), uid, gid, req);\n}\nfunction chownSync(path, uid, gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid, \"uid\", -1, kMaxUserId);\n  validateInteger(gid, \"gid\", -1, kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path), uid, gid, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction utimes(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), req);\n}\nfunction utimesSync(path, atime, mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction futimes(fd, atime, mtime, callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime, \"atime\");\n  mtime = toUnixTimestamp(mtime, \"mtime\");\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd, atime, mtime, req);\n}\nfunction futimesSync(fd, atime, mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime, \"atime\");\n  mtime = toUnixTimestamp(mtime, \"mtime\");\n  const ctx = {};\n  binding.futimes(fd, atime, mtime, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction lutimes(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), req);\n}\nfunction lutimesSync(path, atime, mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction writeAll(fd, isUserFd, buffer, offset, length, signal, callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError();\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd, (err) => {\n        callback(aggregateTwoErrors(err, abortError));\n      });\n    }\n    return;\n  }\n  fs.write(fd, buffer, offset, length, null, (writeErr, written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd, (err) => {\n          callback(aggregateTwoErrors(err, writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd, callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd, isUserFd, buffer, offset, length, signal, callback);\n    }\n  });\n}\nfunction writeFile(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"w\" });\n  const flag = options.flag || \"w\";\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data, \"data\");\n    data = Buffer.from(String(data), options.encoding || \"utf8\");\n  }\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path, isUserFd, data, 0, data.byteLength, signal, callback);\n    return;\n  }\n  if (checkAborted(options.signal, callback))\n    return;\n  fs.open(path, flag, options.mode, (openErr, fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd, isUserFd, data, 0, data.byteLength, signal, callback);\n    }\n  });\n}\nfunction writeFileSync(path, data, options) {\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"w\" });\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data, \"data\");\n    data = Buffer.from(String(data), options.encoding || \"utf8\");\n  }\n  const flag = options.flag || \"w\";\n  const isUserFd = isFd(path);\n  const fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd, data, offset, length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd)\n      fs.closeSync(fd);\n  }\n}\nfunction appendFile(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"a\" });\n  options = copyObject(options);\n  if (!options.flag || isFd(path))\n    options.flag = \"a\";\n  fs.writeFile(path, data, options, callback);\n}\nfunction appendFileSync(path, data, options) {\n  options = getOptions(options, { encoding: \"utf8\", mode: 438, flag: \"a\" });\n  options = copyObject(options);\n  if (!options.flag || isFd(path))\n    options.flag = \"a\";\n  fs.writeFileSync(path, data, options);\n}\nfunction watch(filename, options, listener) {\n  if (typeof options === \"function\") {\n    listener = options;\n  }\n  options = getOptions(options, {});\n  options = copyObject(options);\n  if (options.persistent === void 0)\n    options.persistent = true;\n  if (options.recursive === void 0)\n    options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM(\"watch recursively\");\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename, options.persistent, options.recursive, options.encoding);\n  if (listener) {\n    watcher.addListener(\"change\", listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener2 = () => watcher.close();\n      options.signal.addEventListener(\"abort\", listener2);\n      watcher.once(\"close\", () => {\n        options.signal.removeEventListener(\"abort\", listener2);\n      });\n    }\n  }\n  return watcher;\n}\nconst statWatchers = new SafeMap();\nfunction watchFile(filename, options, listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat2;\n  if (options === null || typeof options !== \"object\") {\n    listener = options;\n    options = null;\n  }\n  options = {\n    interval: 5007,\n    persistent: true,\n    ...options\n  };\n  validateFunction(listener, \"listener\");\n  stat2 = statWatchers.get(filename);\n  if (stat2 === void 0) {\n    stat2 = new watchers.StatWatcher(options.bigint);\n    stat2[watchers.kFSStatWatcherStart](filename, options.persistent, options.interval);\n    statWatchers.set(filename, stat2);\n  } else {\n    stat2[watchers.kFSStatWatcherAddOrCleanRef](\"add\");\n  }\n  stat2.addListener(\"change\", listener);\n  return stat2;\n}\nfunction unwatchFile(filename, listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat2 = statWatchers.get(filename);\n  if (stat2 === void 0)\n    return;\n  if (typeof listener === \"function\") {\n    const beforeListenerCount = stat2.listenerCount(\"change\");\n    stat2.removeListener(\"change\", listener);\n    if (stat2.listenerCount(\"change\") < beforeListenerCount)\n      stat2[watchers.kFSStatWatcherAddOrCleanRef](\"clean\");\n  } else {\n    stat2.removeAllListeners(\"change\");\n    stat2[watchers.kFSStatWatcherAddOrCleanRef](\"cleanAll\");\n  }\n  if (stat2.listenerCount(\"change\") === 0) {\n    stat2.stop();\n    statWatchers.delete(filename);\n  }\n}\nlet splitRoot;\nif (isWindows) {\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot2(str) {\n    return RegExpPrototypeExec(splitRootRe, str)[0];\n  };\n} else {\n  splitRoot = function splitRoot2(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str, i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str, 0, i);\n    }\n    return str;\n  };\n}\nfunction encodeRealpathResult(result, options) {\n  if (!options || !options.encoding || options.encoding === \"utf8\")\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === \"buffer\") {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart2(p, i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p, i);\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart2(p, i) {\n    return StringPrototypeIndexOf(p, \"/\", i);\n  };\n}\nconst emptyObj = ObjectCreate(null);\nfunction realpathSync(p, options) {\n  options = getOptions(options, emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== \"string\") {\n    p += \"\";\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n  let pos;\n  let current;\n  let base;\n  let previous;\n  current = base = splitRoot(p);\n  pos = current.length;\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base), false, void 0, ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n  while (pos < p.length) {\n    const result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p, pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p, pos, result + 1);\n      base = previous + StringPrototypeSlice(p, pos, result);\n      pos = result + 1;\n    }\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues, S_IFIFO) || isFileType(binding.statValues, S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong, true, void 0, ctx);\n      handleErrorFromBinding(ctx);\n      if (!isFileType(stats, S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base, base);\n        continue;\n      }\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0], 32);\n        const ino = BigIntPrototypeToString(stats[7], 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx2 = { path: base };\n        binding.stat(baseLong, false, void 0, ctx2);\n        handleErrorFromBinding(ctx2);\n        linkTarget = binding.readlink(baseLong, void 0, void 0, ctx2);\n        handleErrorFromBinding(ctx2);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      if (cache)\n        cache.set(base, resolvedLink);\n      if (!isWindows)\n        seenLinks[id] = linkTarget;\n    }\n    p = pathModule.resolve(resolvedLink, StringPrototypeSlice(p, pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base), false, void 0, ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n  cache?.set(original, p);\n  return encodeRealpathResult(p, options);\n}\nrealpathSync.native = (path, options) => {\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path, options.encoding, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\nfunction realpath(p, options, callback) {\n  callback = typeof options === \"function\" ? options : maybeCallback(callback);\n  options = getOptions(options, {});\n  p = toPathIfFileURL(p);\n  if (typeof p !== \"string\") {\n    p += \"\";\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  let pos;\n  let current;\n  let base;\n  let previous;\n  current = base = splitRoot(p);\n  pos = current.length;\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base, (err, stats) => {\n      if (err)\n        return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n  function LOOP() {\n    if (pos >= p.length) {\n      return callback(null, encodeRealpathResult(p, options));\n    }\n    const result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p, pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p, pos, result + 1);\n      base = previous + StringPrototypeSlice(p, pos, result);\n      pos = result + 1;\n    }\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues, S_IFIFO) || isFileType(binding.statValues, S_IFSOCK)) {\n        return callback(null, encodeRealpathResult(p, options));\n      }\n      return process.nextTick(LOOP);\n    }\n    return fs.lstat(base, { bigint: true }, gotStat);\n  }\n  function gotStat(err, stats) {\n    if (err)\n      return callback(err);\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev, 32);\n      const ino = BigIntPrototypeToString(stats.ino, 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null, seenLinks[id]);\n      }\n    }\n    fs.stat(base, (err2) => {\n      if (err2)\n        return callback(err2);\n      fs.readlink(base, (err3, target) => {\n        if (!isWindows)\n          seenLinks[id] = target;\n        gotTarget(err3, target);\n      });\n    });\n  }\n  function gotTarget(err, target) {\n    if (err)\n      return callback(err);\n    gotResolvedLink(pathModule.resolve(previous, target));\n  }\n  function gotResolvedLink(resolvedLink) {\n    p = pathModule.resolve(resolvedLink, StringPrototypeSlice(p, pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, (err) => {\n        if (err)\n          return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\nrealpath.native = (path, options, callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options, {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path, options.encoding, req);\n};\nfunction mkdtemp(prefix, options, callback) {\n  callback = makeCallback(typeof options === \"function\" ? options : callback);\n  options = getOptions(options, {});\n  validateString(prefix, \"prefix\");\n  nullCheck(prefix, \"prefix\");\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, req);\n}\nfunction mkdtempSync(prefix, options) {\n  options = getOptions(options, {});\n  validateString(prefix, \"prefix\");\n  nullCheck(prefix, \"prefix\");\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path, options.encoding, void 0, ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\nfunction copyFile(src, dest, mode, callback) {\n  if (typeof mode === \"function\") {\n    callback = mode;\n    mode = 0;\n  }\n  src = getValidatedPath(src, \"src\");\n  dest = getValidatedPath(dest, \"dest\");\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode, \"copyFile\");\n  callback = makeCallback(callback);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src, dest, mode, req);\n}\nfunction copyFileSync(src, dest, mode) {\n  src = getValidatedPath(src, \"src\");\n  dest = getValidatedPath(dest, \"dest\");\n  const ctx = { path: src, dest };\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode, \"copyFile\");\n  binding.copyFile(src, dest, mode, void 0, ctx);\n  handleErrorFromBinding(ctx);\n}\nfunction cp(src, dest, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = void 0;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src, \"src\"));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest, \"dest\"));\n  lazyLoadCp();\n  cpFn(src, dest, options, callback);\n}\nfunction cpSync(src, dest, options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src, \"src\"));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest, \"dest\"));\n  lazyLoadCp();\n  cpSyncFn(src, dest, options);\n}\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream, WriteStream } = require(\"internal/fs/streams\"));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\nfunction createReadStream(path, options) {\n  lazyLoadStreams();\n  return new ReadStream(path, options);\n}\nfunction createWriteStream(path, options) {\n  lazyLoadStreams();\n  return new WriteStream(path, options);\n}\nmodule.exports = fs = {\n  appendFile,\n  appendFileSync,\n  access,\n  accessSync,\n  chown,\n  chownSync,\n  chmod,\n  chmodSync,\n  close,\n  closeSync,\n  copyFile,\n  copyFileSync,\n  cp,\n  cpSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchown,\n  fchownSync,\n  fchmod,\n  fchmodSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchown,\n  lchownSync,\n  lchmod: constants.O_SYMLINK !== void 0 ? lchmod : void 0,\n  lchmodSync: constants.O_SYMLINK !== void 0 ? lchmodSync : void 0,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  lutimes,\n  lutimesSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  opendir,\n  opendirSync,\n  readdir,\n  readdirSync,\n  read,\n  readSync,\n  readv,\n  readvSync,\n  readFile,\n  readFileSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rm,\n  rmSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unwatchFile,\n  unlink,\n  unlinkSync,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  writeFile,\n  writeFileSync,\n  write,\n  writeSync,\n  writev,\n  writevSync,\n  Dir,\n  Dirent,\n  Stats,\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  },\n  set ReadStream(val) {\n    ReadStream = val;\n  },\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  },\n  set WriteStream(val) {\n    WriteStream = val;\n  },\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  },\n  set FileReadStream(val) {\n    FileReadStream = val;\n  },\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  },\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  },\n  _toUnixTimestamp: toUnixTimestamp\n};\nObjectDefineProperties(fs, {\n  F_OK: { enumerable: true, value: F_OK || 0 },\n  R_OK: { enumerable: true, value: R_OK || 0 },\n  W_OK: { enumerable: true, value: W_OK || 0 },\n  X_OK: { enumerable: true, value: X_OK || 0 },\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  promises: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      if (promises === null)\n        promises = require(\"internal/fs/promises\").exports;\n      return promises;\n    }\n  }\n});\n}"],["http.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeSlice,\n  ArrayPrototypeSort,\n  ObjectDefineProperty\n} = primordials;\nconst httpAgent = require(\"_http_agent\");\nconst { ClientRequest } = require(\"_http_client\");\nconst { methods } = require(\"_http_common\");\nconst { IncomingMessage } = require(\"_http_incoming\");\nconst {\n  validateHeaderName,\n  validateHeaderValue,\n  OutgoingMessage\n} = require(\"_http_outgoing\");\nconst {\n  _connectionListener,\n  STATUS_CODES,\n  Server,\n  ServerResponse\n} = require(\"_http_server\");\nlet maxHeaderSize;\nfunction createServer(opts, requestListener) {\n  return new Server(opts, requestListener);\n}\nfunction request(url, options, cb) {\n  return new ClientRequest(url, options, cb);\n}\nfunction get(url, options, cb) {\n  const req = request(url, options, cb);\n  req.end();\n  return req;\n}\nmodule.exports = {\n  _connectionListener,\n  METHODS: ArrayPrototypeSort(ArrayPrototypeSlice(methods)),\n  STATUS_CODES,\n  Agent: httpAgent.Agent,\n  ClientRequest,\n  IncomingMessage,\n  OutgoingMessage,\n  Server,\n  ServerResponse,\n  createServer,\n  validateHeaderName,\n  validateHeaderValue,\n  get,\n  request\n};\nObjectDefineProperty(module.exports, \"maxHeaderSize\", {\n  configurable: true,\n  enumerable: true,\n  get() {\n    if (maxHeaderSize === void 0) {\n      const { getOptionValue } = require(\"internal/options\");\n      maxHeaderSize = getOptionValue(\"--max-http-header-size\");\n    }\n    return maxHeaderSize;\n  }\n});\nObjectDefineProperty(module.exports, \"globalAgent\", {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return httpAgent.globalAgent;\n  },\n  set(value) {\n    httpAgent.globalAgent = value;\n  }\n});\n}"],["http2.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  connect,\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders,\n  Http2ServerRequest,\n  Http2ServerResponse\n} = require(\"internal/http2/core\");\nmodule.exports = {\n  connect,\n  constants,\n  createServer,\n  createSecureServer,\n  getDefaultSettings,\n  getPackedSettings,\n  getUnpackedSettings,\n  sensitiveHeaders,\n  Http2ServerRequest,\n  Http2ServerResponse\n};\n}"],["https.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeIndexOf,\n  ArrayPrototypePush,\n  ArrayPrototypeShift,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  FunctionPrototypeCall,\n  JSONStringify,\n  ObjectAssign,\n  ObjectSetPrototypeOf,\n  ReflectConstruct\n} = primordials;\nrequire(\"internal/util\").assertCrypto();\nconst tls = require(\"tls\");\nconst { Agent: HttpAgent } = require(\"_http_agent\");\nconst {\n  Server: HttpServer,\n  storeHTTPOptions,\n  _connectionListener\n} = require(\"_http_server\");\nconst { ClientRequest } = require(\"_http_client\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"https\", (fn) => {\n  debug = fn;\n});\nconst { URL, urlToHttpOptions, searchParamsSymbol } = require(\"internal/url\");\nfunction Server(opts, requestListener) {\n  if (!(this instanceof Server))\n    return new Server(opts, requestListener);\n  if (typeof opts === \"function\") {\n    requestListener = opts;\n    opts = void 0;\n  }\n  opts = { ...opts };\n  if (!opts.ALPNProtocols) {\n    opts.ALPNProtocols = [\"http/1.1\"];\n  }\n  FunctionPrototypeCall(storeHTTPOptions, this, opts);\n  FunctionPrototypeCall(tls.Server, this, opts, _connectionListener);\n  this.httpAllowHalfOpen = false;\n  if (requestListener) {\n    this.addListener(\"request\", requestListener);\n  }\n  this.addListener(\"tlsClientError\", function addListener(err, conn) {\n    if (!this.emit(\"clientError\", err, conn))\n      conn.destroy(err);\n  });\n  this.timeout = 0;\n  this.keepAliveTimeout = 5e3;\n  this.maxHeadersCount = null;\n  this.headersTimeout = 60 * 1e3;\n  this.requestTimeout = 0;\n}\nObjectSetPrototypeOf(Server.prototype, tls.Server.prototype);\nObjectSetPrototypeOf(Server, tls.Server);\nServer.prototype.setTimeout = HttpServer.prototype.setTimeout;\nfunction createServer(opts, requestListener) {\n  return new Server(opts, requestListener);\n}\nfunction createConnection(port, host, options) {\n  if (port !== null && typeof port === \"object\") {\n    options = port;\n  } else if (host !== null && typeof host === \"object\") {\n    options = { ...host };\n  } else if (options === null || typeof options !== \"object\") {\n    options = {};\n  } else {\n    options = { ...options };\n  }\n  if (typeof port === \"number\") {\n    options.port = port;\n  }\n  if (typeof host === \"string\") {\n    options.host = host;\n  }\n  debug(\"createConnection\", options);\n  if (options._agentKey) {\n    const session = this._getSession(options._agentKey);\n    if (session) {\n      debug(\"reuse session for %j\", options._agentKey);\n      options = {\n        session,\n        ...options\n      };\n    }\n  }\n  const socket = tls.connect(options);\n  if (options._agentKey) {\n    socket.on(\"session\", (session) => {\n      this._cacheSession(options._agentKey, session);\n    });\n    socket.once(\"close\", (err) => {\n      if (err)\n        this._evictSession(options._agentKey);\n    });\n  }\n  return socket;\n}\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n  FunctionPrototypeCall(HttpAgent, this, options);\n  this.defaultPort = 443;\n  this.protocol = \"https:\";\n  this.maxCachedSessions = this.options.maxCachedSessions;\n  if (this.maxCachedSessions === void 0)\n    this.maxCachedSessions = 100;\n  this._sessionCache = {\n    map: {},\n    list: []\n  };\n}\nObjectSetPrototypeOf(Agent.prototype, HttpAgent.prototype);\nObjectSetPrototypeOf(Agent, HttpAgent);\nAgent.prototype.createConnection = createConnection;\nAgent.prototype.getName = function getName(options) {\n  let name = FunctionPrototypeCall(HttpAgent.prototype.getName, this, options);\n  name += \":\";\n  if (options.ca)\n    name += options.ca;\n  name += \":\";\n  if (options.cert)\n    name += options.cert;\n  name += \":\";\n  if (options.clientCertEngine)\n    name += options.clientCertEngine;\n  name += \":\";\n  if (options.ciphers)\n    name += options.ciphers;\n  name += \":\";\n  if (options.key)\n    name += options.key;\n  name += \":\";\n  if (options.pfx)\n    name += options.pfx;\n  name += \":\";\n  if (options.rejectUnauthorized !== void 0)\n    name += options.rejectUnauthorized;\n  name += \":\";\n  if (options.servername && options.servername !== options.host)\n    name += options.servername;\n  name += \":\";\n  if (options.minVersion)\n    name += options.minVersion;\n  name += \":\";\n  if (options.maxVersion)\n    name += options.maxVersion;\n  name += \":\";\n  if (options.secureProtocol)\n    name += options.secureProtocol;\n  name += \":\";\n  if (options.crl)\n    name += options.crl;\n  name += \":\";\n  if (options.honorCipherOrder !== void 0)\n    name += options.honorCipherOrder;\n  name += \":\";\n  if (options.ecdhCurve)\n    name += options.ecdhCurve;\n  name += \":\";\n  if (options.dhparam)\n    name += options.dhparam;\n  name += \":\";\n  if (options.secureOptions !== void 0)\n    name += options.secureOptions;\n  name += \":\";\n  if (options.sessionIdContext)\n    name += options.sessionIdContext;\n  name += \":\";\n  if (options.sigalgs)\n    name += JSONStringify(options.sigalgs);\n  name += \":\";\n  if (options.privateKeyIdentifier)\n    name += options.privateKeyIdentifier;\n  name += \":\";\n  if (options.privateKeyEngine)\n    name += options.privateKeyEngine;\n  return name;\n};\nAgent.prototype._getSession = function _getSession(key) {\n  return this._sessionCache.map[key];\n};\nAgent.prototype._cacheSession = function _cacheSession(key, session) {\n  if (this.maxCachedSessions === 0)\n    return;\n  if (this._sessionCache.map[key]) {\n    this._sessionCache.map[key] = session;\n    return;\n  }\n  if (this._sessionCache.list.length >= this.maxCachedSessions) {\n    const oldKey = ArrayPrototypeShift(this._sessionCache.list);\n    debug(\"evicting %j\", oldKey);\n    delete this._sessionCache.map[oldKey];\n  }\n  ArrayPrototypePush(this._sessionCache.list, key);\n  this._sessionCache.map[key] = session;\n};\nAgent.prototype._evictSession = function _evictSession(key) {\n  const index = ArrayPrototypeIndexOf(this._sessionCache.list, key);\n  if (index === -1)\n    return;\n  ArrayPrototypeSplice(this._sessionCache.list, index, 1);\n  delete this._sessionCache.map[key];\n};\nconst globalAgent = new Agent();\nfunction request(...args) {\n  let options = {};\n  if (typeof args[0] === \"string\") {\n    const urlStr = ArrayPrototypeShift(args);\n    options = urlToHttpOptions(new URL(urlStr));\n  } else if (args[0] && args[0][searchParamsSymbol] && args[0][searchParamsSymbol][searchParamsSymbol]) {\n    options = urlToHttpOptions(ArrayPrototypeShift(args));\n  }\n  if (args[0] && typeof args[0] !== \"function\") {\n    ObjectAssign(options, ArrayPrototypeShift(args));\n  }\n  options._defaultAgent = module.exports.globalAgent;\n  ArrayPrototypeUnshift(args, options);\n  return ReflectConstruct(ClientRequest, args);\n}\nfunction get(input, options, cb) {\n  const req = request(input, options, cb);\n  req.end();\n  return req;\n}\nmodule.exports = {\n  Agent,\n  globalAgent,\n  Server,\n  createServer,\n  get,\n  request\n};\n}"],["inspector.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  JSONParse,\n  JSONStringify,\n  SafeMap,\n  Symbol\n} = primordials;\nconst {\n  ERR_INSPECTOR_ALREADY_ACTIVATED,\n  ERR_INSPECTOR_ALREADY_CONNECTED,\n  ERR_INSPECTOR_CLOSED,\n  ERR_INSPECTOR_COMMAND,\n  ERR_INSPECTOR_NOT_AVAILABLE,\n  ERR_INSPECTOR_NOT_CONNECTED,\n  ERR_INSPECTOR_NOT_ACTIVE,\n  ERR_INSPECTOR_NOT_WORKER\n} = require(\"internal/errors\").codes;\nconst { hasInspector } = internalBinding(\"config\");\nif (!hasInspector)\n  throw new ERR_INSPECTOR_NOT_AVAILABLE();\nconst EventEmitter = require(\"events\");\nconst { queueMicrotask } = require(\"internal/process/task_queues\");\nconst {\n  validateCallback,\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst { isMainThread } = require(\"worker_threads\");\nconst {\n  Connection,\n  MainThreadConnection,\n  open,\n  url,\n  isEnabled,\n  waitForDebugger\n} = internalBinding(\"inspector\");\nconst connectionSymbol = Symbol(\"connectionProperty\");\nconst messageCallbacksSymbol = Symbol(\"messageCallbacks\");\nconst nextIdSymbol = Symbol(\"nextId\");\nconst onMessageSymbol = Symbol(\"onMessage\");\nclass Session extends EventEmitter {\n  constructor() {\n    super();\n    this[connectionSymbol] = null;\n    this[nextIdSymbol] = 1;\n    this[messageCallbacksSymbol] = new SafeMap();\n  }\n  connect() {\n    if (this[connectionSymbol])\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED(\"The inspector session\");\n    this[connectionSymbol] = new Connection((message) => this[onMessageSymbol](message));\n  }\n  connectToMainThread() {\n    if (isMainThread)\n      throw new ERR_INSPECTOR_NOT_WORKER();\n    if (this[connectionSymbol])\n      throw new ERR_INSPECTOR_ALREADY_CONNECTED(\"The inspector session\");\n    this[connectionSymbol] = new MainThreadConnection((message) => queueMicrotask(() => this[onMessageSymbol](message)));\n  }\n  [onMessageSymbol](message) {\n    const parsed = JSONParse(message);\n    try {\n      if (parsed.id) {\n        const callback = this[messageCallbacksSymbol].get(parsed.id);\n        this[messageCallbacksSymbol].delete(parsed.id);\n        if (callback) {\n          if (parsed.error) {\n            return callback(new ERR_INSPECTOR_COMMAND(parsed.error.code, parsed.error.message));\n          }\n          callback(null, parsed.result);\n        }\n      } else {\n        this.emit(parsed.method, parsed);\n        this.emit(\"inspectorNotification\", parsed);\n      }\n    } catch (error) {\n      process.emitWarning(error);\n    }\n  }\n  post(method, params, callback) {\n    validateString(method, \"method\");\n    if (!callback && typeof params === \"function\") {\n      callback = params;\n      params = null;\n    }\n    if (params) {\n      validateObject(params, \"params\");\n    }\n    if (callback) {\n      validateCallback(callback);\n    }\n    if (!this[connectionSymbol]) {\n      throw new ERR_INSPECTOR_NOT_CONNECTED();\n    }\n    const id = this[nextIdSymbol]++;\n    const message = { id, method };\n    if (params) {\n      message.params = params;\n    }\n    if (callback) {\n      this[messageCallbacksSymbol].set(id, callback);\n    }\n    this[connectionSymbol].dispatch(JSONStringify(message));\n  }\n  disconnect() {\n    if (!this[connectionSymbol])\n      return;\n    this[connectionSymbol].disconnect();\n    this[connectionSymbol] = null;\n    const remainingCallbacks = this[messageCallbacksSymbol].values();\n    for (const callback of remainingCallbacks) {\n      process.nextTick(callback, new ERR_INSPECTOR_CLOSED());\n    }\n    this[messageCallbacksSymbol].clear();\n    this[nextIdSymbol] = 1;\n  }\n}\nfunction inspectorOpen(port, host, wait) {\n  if (isEnabled()) {\n    throw new ERR_INSPECTOR_ALREADY_ACTIVATED();\n  }\n  open(port, host);\n  if (wait)\n    waitForDebugger();\n}\nfunction inspectorWaitForDebugger() {\n  if (!waitForDebugger())\n    throw new ERR_INSPECTOR_NOT_ACTIVE();\n}\nmodule.exports = {\n  open: inspectorOpen,\n  close: process._debugEnd,\n  url,\n  waitForDebugger: inspectorWaitForDebugger,\n  console: require(\"internal/util/inspector\").consoleFromVM,\n  Session\n};\n}"],["module.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { findSourceMap } = require(\"internal/source_map/source_map_cache\");\nconst { Module } = require(\"internal/modules/cjs/loader\");\nconst { SourceMap } = require(\"internal/source_map/source_map\");\nModule.findSourceMap = findSourceMap;\nModule.SourceMap = SourceMap;\nmodule.exports = Module;\n}"],["net.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIndexOf,\n  Boolean,\n  Error,\n  Number,\n  NumberIsNaN,\n  NumberParseInt,\n  ObjectDefineProperty,\n  ObjectSetPrototypeOf,\n  Symbol\n} = primordials;\nconst EventEmitter = require(\"events\");\nconst stream = require(\"stream\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"net\", (fn) => {\n  debug = fn;\n});\nconst {\n  isIP,\n  isIPv4,\n  isIPv6,\n  normalizedArgsSymbol,\n  makeSyncWrite\n} = require(\"internal/net\");\nconst assert = require(\"internal/assert\");\nconst {\n  UV_EADDRINUSE,\n  UV_EINVAL,\n  UV_ENOTCONN\n} = internalBinding(\"uv\");\nconst { Buffer } = require(\"buffer\");\nconst { guessHandleType } = internalBinding(\"util\");\nconst { ShutdownWrap } = internalBinding(\"stream_wrap\");\nconst {\n  TCP,\n  TCPConnectWrap,\n  constants: TCPConstants\n} = internalBinding(\"tcp_wrap\");\nconst {\n  Pipe,\n  PipeConnectWrap,\n  constants: PipeConstants\n} = internalBinding(\"pipe_wrap\");\nconst {\n  newAsyncId,\n  defaultTriggerAsyncIdScope,\n  symbols: { async_id_symbol, owner_symbol }\n} = require(\"internal/async_hooks\");\nconst {\n  writevGeneric,\n  writeGeneric,\n  onStreamRead,\n  kAfterAsyncWrite,\n  kHandle,\n  kUpdateTimer,\n  setStreamTimeout,\n  kBuffer,\n  kBufferCb,\n  kBufferGen\n} = require(\"internal/stream_base_commons\");\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n    ERR_INVALID_FD_TYPE,\n    ERR_INVALID_IP_ADDRESS,\n    ERR_SERVER_ALREADY_LISTEN,\n    ERR_SERVER_NOT_RUNNING,\n    ERR_SOCKET_CLOSED,\n    ERR_MISSING_ARGS\n  },\n  errnoException,\n  exceptionWithHostPort,\n  uvExceptionWithHostPort\n} = require(\"internal/errors\");\nconst { isUint8Array } = require(\"internal/util/types\");\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateInt32,\n  validateNumber,\n  validatePort,\n  validateString\n} = require(\"internal/validators\");\nconst kLastWriteQueueSize = Symbol(\"lastWriteQueueSize\");\nconst {\n  DTRACE_NET_SERVER_CONNECTION,\n  DTRACE_NET_STREAM_END\n} = require(\"internal/dtrace\");\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\nconst { clearTimeout } = require(\"timers\");\nconst { kTimeout } = require(\"internal/timers\");\nconst DEFAULT_IPV4_ADDR = \"0.0.0.0\";\nconst DEFAULT_IPV6_ADDR = \"::\";\nconst isWindows = process.platform === \"win32\";\nconst noop = () => {\n};\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\nfunction createHandle(fd, is_server) {\n  validateInt32(fd, \"fd\", 0);\n  const type = guessHandleType(fd);\n  if (type === \"PIPE\") {\n    return new Pipe(is_server ? PipeConstants.SERVER : PipeConstants.SOCKET);\n  }\n  if (type === \"TCP\") {\n    return new TCP(is_server ? TCPConstants.SERVER : TCPConstants.SOCKET);\n  }\n  throw new ERR_INVALID_FD_TYPE(type);\n}\nfunction getNewAsyncId(handle) {\n  return !handle || typeof handle.getAsyncId !== \"function\" ? newAsyncId() : handle.getAsyncId();\n}\nfunction isPipeName(s) {\n  return typeof s === \"string\" && toNumber(s) === false;\n}\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug(\"createConnection\", normalized);\n  const socket = new Socket(options);\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n  return socket.connect(normalized);\n}\nfunction normalizeArgs(args) {\n  let arr;\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === \"object\" && arg0 !== null) {\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    options.path = arg0;\n  } else {\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === \"string\") {\n      options.host = args[1];\n    }\n  }\n  const cb = args[args.length - 1];\n  if (typeof cb !== \"function\")\n    arr = [options, null];\n  else\n    arr = [options, cb];\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\nconst kBytesRead = Symbol(\"kBytesRead\");\nconst kBytesWritten = Symbol(\"kBytesWritten\");\nconst kSetNoDelay = Symbol(\"kSetNoDelay\");\nfunction Socket(options) {\n  if (!(this instanceof Socket))\n    return new Socket(options);\n  this.connecting = false;\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kSetNoDelay] = false;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n  if (typeof options === \"number\")\n    options = { fd: options };\n  else\n    options = { ...options };\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  options.emitClose = false;\n  options.autoDestroy = true;\n  options.decodeStrings = false;\n  stream.Duplex.call(this, options);\n  if (options.handle) {\n    this._handle = options.handle;\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== void 0) {\n    const { fd } = options;\n    let err;\n    this._handle = createHandle(fd, false);\n    err = this._handle.open(fd);\n    if (err)\n      throw errnoException(err, \"open\");\n    this[async_id_symbol] = this._handle.getAsyncId();\n    if ((fd === 1 || fd === 2) && this._handle instanceof Pipe && isWindows) {\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, \"setBlocking\");\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      ObjectDefineProperty(this._handle, \"bytesWritten\", {\n        value: 0,\n        writable: true\n      });\n    }\n  }\n  const onread = options.onread;\n  if (onread !== null && typeof onread === \"object\" && (isUint8Array(onread.buffer) || typeof onread.buffer === \"function\") && typeof onread.callback === \"function\") {\n    if (typeof onread.buffer === \"function\") {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n  this.on(\"end\", onReadableStreamEnd);\n  initSocketHandle(this);\n  this._pendingData = null;\n  this._pendingEncoding = \"\";\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n  this.server = null;\n  this._server = null;\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype, stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket, stream.Duplex);\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\nSocket.prototype._final = function(cb) {\n  if (this.pending) {\n    debug(\"_final: not yet connected\");\n    return this.once(\"connect\", () => this._final(cb));\n  }\n  if (!this._handle)\n    return cb();\n  debug(\"_final: not ended, call shutdown()\");\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n  if (err === 1 || err === UV_ENOTCONN)\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err, \"shutdown\"));\n};\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n  debug(\"afterShutdown destroyed=%j\", self.destroyed, self._readableState);\n  this.callback();\n}\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this, chunk, encoding, cb);\n  }\n  if (typeof encoding === \"function\") {\n    cb = encoding;\n    encoding = null;\n  }\n  const er = new Error(\"This socket has been ended by the other party\");\n  er.code = \"EPIPE\";\n  if (typeof cb === \"function\") {\n    defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, cb, er);\n  }\n  this.destroy(er);\n  return false;\n}\nSocket.prototype.setTimeout = setStreamTimeout;\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug(\"_onTimeout\");\n  this.emit(\"timeout\");\n};\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once(\"connect\", enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n  const newValue = enable === void 0 ? true : !!enable;\n  if (this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = newValue;\n    this._handle.setNoDelay(newValue);\n  }\n  return this;\n};\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (!this._handle) {\n    this.once(\"connect\", () => this.setKeepAlive(setting, msecs));\n    return this;\n  }\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1e3));\n  return this;\n};\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\nObjectDefineProperty(Socket.prototype, \"_connecting\", {\n  get: function() {\n    return this.connecting;\n  }\n});\nObjectDefineProperty(Socket.prototype, \"pending\", {\n  get() {\n    return !this._handle || this.connecting;\n  },\n  configurable: true\n});\nObjectDefineProperty(Socket.prototype, \"readyState\", {\n  get: function() {\n    if (this.connecting) {\n      return \"opening\";\n    } else if (this.readable && this.writable) {\n      return \"open\";\n    } else if (this.readable && !this.writable) {\n      return \"readOnly\";\n    } else if (!this.readable && this.writable) {\n      return \"writeOnly\";\n    }\n    return \"closed\";\n  }\n});\nObjectDefineProperty(Socket.prototype, \"bufferSize\", {\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\nObjectDefineProperty(Socket.prototype, kUpdateTimer, {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\nfunction tryReadStart(socket) {\n  debug(\"Socket._handle.readStart\");\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err, \"read\"));\n}\nSocket.prototype._read = function(n) {\n  debug(\"_read\");\n  if (this.connecting || !this._handle) {\n    debug(\"_read wait for connection\");\n    this.once(\"connect\", () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\nSocket.prototype.end = function(data, encoding, callback) {\n  stream.Duplex.prototype.end.call(this, data, encoding, callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err, \"read\"));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this, n);\n};\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once(\"finish\", this.destroy);\n};\nSocket.prototype._destroy = function(exception, cb) {\n  debug(\"destroy\");\n  this.connecting = false;\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n  debug(\"close\");\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug(\"close handle\");\n    const isException = exception ? true : false;\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n    this._handle.close(() => {\n      debug(\"emit close\");\n      this.emit(\"close\", isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT, this);\n  }\n  if (this._server) {\n    debug(\"has server\");\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    this._peername = {};\n    this._handle.getpeername(this._peername);\n  }\n  return this._peername;\n};\nfunction protoGetter(name, callback) {\n  ObjectDefineProperty(Socket.prototype, name, {\n    configurable: false,\n    enumerable: true,\n    get: callback\n  });\n}\nprotoGetter(\"bytesRead\", function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\nprotoGetter(\"remoteAddress\", function remoteAddress() {\n  return this._getpeername().address;\n});\nprotoGetter(\"remoteFamily\", function remoteFamily() {\n  return this._getpeername().family;\n});\nprotoGetter(\"remotePort\", function remotePort() {\n  return this._getpeername().port;\n});\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\nprotoGetter(\"localAddress\", function localAddress() {\n  return this._getsockname().address;\n});\nprotoGetter(\"localPort\", function localPort() {\n  return this._getsockname().port;\n});\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once(\"connect\", function connect2() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = \"\";\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n  this._unrefTimer();\n  let req;\n  if (writev)\n    req = writevGeneric(this, data, cb);\n  else\n    req = writeGeneric(this, data, encoding, cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, \"\", cb);\n};\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\nprotoGetter(\"_bytesDispatched\", function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\nprotoGetter(\"bytesWritten\", function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n  if (!writableBuffer)\n    return void 0;\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ? el.chunk.length : Buffer.byteLength(el.chunk, el.encoding);\n  }\n  if (ArrayIsArray(data)) {\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk, chunk.encoding);\n    }\n  } else if (data) {\n    if (typeof data !== \"string\")\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n  return bytes;\n});\nfunction checkBindError(err, port, handle) {\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError, bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\nfunction internalConnect(self, address, port, addressType, localAddress2, localPort2, flags) {\n  assert(self.connecting);\n  let err;\n  if (localAddress2 || localPort2) {\n    if (addressType === 4) {\n      localAddress2 = localAddress2 || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress2, localPort2);\n    } else {\n      localAddress2 = localAddress2 || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress2, localPort2, flags);\n    }\n    debug(\"binding to localAddress: %s and localPort: %d (addressType: %d)\", localAddress2, localPort2, addressType);\n    err = checkBindError(err, localPort2, self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err, \"bind\", localAddress2, localPort2);\n      self.destroy(ex);\n      return;\n    }\n  }\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress2;\n    req.localPort = localPort2;\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n    err = self._handle.connect(req, address, afterConnect);\n  }\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n    if (sockname) {\n      details = sockname.address + \":\" + sockname.port;\n    }\n    const ex = exceptionWithHostPort(err, \"connect\", address, port, details);\n    self.destroy(ex);\n  }\n}\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n  if (options.port === void 0 && options.path == null)\n    throw new ERR_MISSING_ARGS([\"options\", \"port\", \"path\"]);\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n  const { path } = options;\n  const pipe = !!path;\n  debug(\"pipe\", pipe, path);\n  if (!this._handle) {\n    this._handle = pipe ? new Pipe(PipeConstants.SOCKET) : new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n  if (cb !== null) {\n    this.once(\"connect\", cb);\n  }\n  this._unrefTimer();\n  this.connecting = true;\n  if (pipe) {\n    validateString(path, \"options.path\");\n    defaultTriggerAsyncIdScope(this[async_id_symbol], internalConnect, this, path);\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\nfunction lookupAndConnect(self, options) {\n  const { localAddress: localAddress2, localPort: localPort2 } = options;\n  const host = options.host || \"localhost\";\n  let { port } = options;\n  if (localAddress2 && !isIP(localAddress2)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress2);\n  }\n  if (localPort2) {\n    validateNumber(localPort2, \"options.localPort\");\n  }\n  if (typeof port !== \"undefined\") {\n    if (typeof port !== \"number\" && typeof port !== \"string\") {\n      throw new ERR_INVALID_ARG_TYPE(\"options.port\", [\"number\", \"string\"], port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol], process.nextTick, () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(self[async_id_symbol], internalConnect, self, host, port, addressType, localAddress2, localPort2);\n    });\n    return;\n  }\n  if (options.lookup !== void 0)\n    validateFunction(options.lookup, \"options.lookup\");\n  if (dns === void 0)\n    dns = require(\"dns\");\n  const dnsopts = {\n    family: options.family,\n    hints: options.hints || 0\n  };\n  if (!isWindows && dnsopts.family !== 4 && dnsopts.family !== 6 && dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n  debug(\"connect: find host\", host);\n  debug(\"connect: dns options\", dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol], function() {\n    lookup(host, dnsopts, function emitLookup(err, ip, addressType2) {\n      self.emit(\"lookup\", err, ip, addressType2, host);\n      if (!self.connecting)\n        return;\n      if (err) {\n        process.nextTick(connectErrorNT, self, err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT, self, err);\n      } else if (addressType2 !== 4 && addressType2 !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType2, options.host, options.port);\n        process.nextTick(connectErrorNT, self, err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(self[async_id_symbol], internalConnect, self, ip, port, addressType2, localAddress2, localPort2);\n      }\n    });\n  });\n}\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once(\"connect\", this.ref);\n    return this;\n  }\n  if (typeof this._handle.ref === \"function\") {\n    this._handle.ref();\n  }\n  return this;\n};\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once(\"connect\", this.unref);\n    return this;\n  }\n  if (typeof this._handle.unref === \"function\") {\n    this._handle.unref();\n  }\n  return this;\n};\nfunction afterConnect(status, handle, req, readable, writable) {\n  let self = handle[owner_symbol];\n  if (self.constructor.name === \"ReusedHandle\") {\n    self = self.handle;\n  }\n  if (self.destroyed) {\n    return;\n  }\n  debug(\"afterConnect\");\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n    self.emit(\"connect\");\n    self.emit(\"ready\");\n    if (readable && !self.isPaused())\n      self.read(0);\n  } else {\n    self.connecting = false;\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + \":\" + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status, \"connect\", req.address, req.port, details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\nfunction addAbortSignalOption(self, options) {\n  if (options?.signal === void 0) {\n    return;\n  }\n  validateAbortSignal(options.signal, \"options.signal\");\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener(\"abort\", onAborted);\n    self.once(\"close\", () => signal.removeEventListener(\"abort\", onAborted));\n  }\n}\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n  EventEmitter.call(this);\n  if (typeof options === \"function\") {\n    connectionListener = options;\n    options = {};\n    this.on(\"connection\", connectionListener);\n  } else if (options == null || typeof options === \"object\") {\n    options = { ...options };\n    if (typeof connectionListener === \"function\") {\n      this.on(\"connection\", connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\"options\", \"Object\", options);\n  }\n  this._connections = 0;\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nObjectSetPrototypeOf(Server.prototype, EventEmitter.prototype);\nObjectSetPrototypeOf(Server, EventEmitter);\nfunction toNumber(x) {\n  return (x = Number(x)) >= 0 ? x : false;\n}\nfunction createServerHandle(address, port, addressType, fd, flags) {\n  let err = 0;\n  let handle;\n  let isTCP = false;\n  if (typeof fd === \"number\" && fd >= 0) {\n    try {\n      handle = createHandle(fd, true);\n    } catch (e) {\n      debug(\"listen invalid fd=%d:\", fd, e.message);\n      return UV_EINVAL;\n    }\n    err = handle.open(fd);\n    if (err)\n      return err;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n  if (address || port || isTCP) {\n    debug(\"bind to\", address || \"any\");\n    if (!address) {\n      err = handle.bind6(DEFAULT_IPV6_ADDR, port, flags);\n      if (err) {\n        handle.close();\n        return createServerHandle(DEFAULT_IPV4_ADDR, port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port, flags);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n  if (err) {\n    handle.close();\n    return err;\n  }\n  return handle;\n}\nfunction setupListenHandle(address, port, addressType, backlog, fd, flags) {\n  debug(\"setupListenHandle\", address, port, addressType, backlog, fd);\n  if (this._handle) {\n    debug(\"setupListenHandle: have a handle already\");\n  } else {\n    debug(\"setupListenHandle: create a handle\");\n    let rval = null;\n    if (!address && typeof fd !== \"number\") {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR, port, 6, fd, flags);\n      if (typeof rval === \"number\") {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd, flags);\n    if (typeof rval === \"number\") {\n      const error = uvExceptionWithHostPort(rval, \"listen\", address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n  const err = this._handle.listen(backlog || 511);\n  if (err) {\n    const ex = uvExceptionWithHostPort(err, \"listen\", address, port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, emitErrorNT, this, ex);\n    return;\n  }\n  this._connectionKey = addressType + \":\" + address + \":\" + port;\n  if (this._unref)\n    this.unref();\n  defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, emitListeningNT, this);\n}\nServer.prototype._listen2 = setupListenHandle;\nfunction emitErrorNT(self, err) {\n  self.emit(\"error\", err);\n}\nfunction emitListeningNT(self) {\n  if (self._handle)\n    self.emit(\"listening\");\n}\nfunction listenInCluster(server, address, port, addressType, backlog, fd, exclusive, flags) {\n  exclusive = !!exclusive;\n  if (cluster === void 0)\n    cluster = require(\"cluster\");\n  if (cluster.isPrimary || exclusive) {\n    server._listen2(address, port, addressType, backlog, fd, flags);\n    return;\n  }\n  const serverQuery = {\n    address,\n    port,\n    addressType,\n    fd,\n    flags\n  };\n  cluster._getServer(server, serverQuery, listenOnPrimaryHandle);\n  function listenOnPrimaryHandle(err, handle) {\n    err = checkBindError(err, port, handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err, \"bind\", address, port);\n      return server.emit(\"error\", ex);\n    }\n    server._handle = handle;\n    server._listen2(address, port, addressType, backlog, fd, flags);\n  }\n}\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n  if (cb !== null) {\n    this.once(\"listening\", cb);\n  }\n  const backlogFromArgs = toNumber(args.length > 1 && args[1]) || toNumber(args.length > 2 && args[2]);\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this, options);\n  if (typeof options.fd === \"number\" && options.fd >= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n  if (args.length === 0 || typeof args[0] === \"function\" || typeof options.port === \"undefined\" && \"port\" in options || options.port === null) {\n    options.port = 0;\n  }\n  let backlog;\n  if (typeof options.port === \"number\" || typeof options.port === \"string\") {\n    validatePort(options.port, \"options.port\");\n    backlog = options.backlog || backlogFromArgs;\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog, options.exclusive, flags);\n    } else {\n      listenInCluster(this, null, options.port | 0, 4, backlog, void 0, options.exclusive);\n    }\n    return this;\n  }\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this, pipeName, -1, -1, backlog, void 0, options.exclusive);\n    if (!this._handle) {\n      return this;\n    }\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err, \"uv_pipe_chmod\");\n      }\n    }\n    return this;\n  }\n  if (!(\"port\" in options || \"path\" in options)) {\n    throw new ERR_INVALID_ARG_VALUE(\"options\", options, 'must have the property \"port\" or \"path\"');\n  }\n  throw new ERR_INVALID_ARG_VALUE(\"options\", options);\n};\nfunction lookupAndListen(self, port, address, backlog, exclusive, flags) {\n  if (dns === void 0)\n    dns = require(\"dns\");\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit(\"error\", err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType, backlog, void 0, exclusive, flags);\n    }\n  });\n}\nObjectDefineProperty(Server.prototype, \"listening\", {\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true\n});\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, \"address\");\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\nfunction onconnection(err, clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n  debug(\"onconnection\");\n  if (err) {\n    self.emit(\"error\", errnoException(err, \"accept\"));\n    return;\n  }\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n  const socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit(\"connection\", socket);\n}\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n  function end(err, connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol], process.nextTick, cb, err, connections);\n  }\n  if (!this._usingWorkers) {\n    end(null, this._connections);\n    return this;\n  }\n  let left = this._workers.length;\n  let total = this._connections;\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n    total += count;\n    if (--left === 0)\n      return end(null, total);\n  }\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n  return this;\n};\nServer.prototype.close = function(cb) {\n  if (typeof cb === \"function\") {\n    if (!this._handle) {\n      this.once(\"close\", function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once(\"close\", cb);\n    }\n  }\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0)\n        return;\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n    this._connections++;\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n  return this;\n};\nServer.prototype._emitCloseIfDrained = function() {\n  debug(\"SERVER _emitCloseIfDrained\");\n  if (this._handle || this._connections) {\n    debug(\"SERVER handle? %j   connections? %d\", !!this._handle, this._connections);\n    return;\n  }\n  defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, emitCloseNT, this);\n};\nfunction emitCloseNT(self) {\n  debug(\"SERVER: emit close\");\n  self.emit(\"close\");\n}\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(err, event, sock) {\n  switch (event) {\n    case \"connection\":\n      sock.destroy(err);\n      break;\n    default:\n      this.emit(\"error\", err);\n  }\n};\nObjectDefineProperty(TCP.prototype, \"owner\", {\n  get() {\n    return this[owner_symbol];\n  },\n  set(v) {\n    return this[owner_symbol] = v;\n  }\n});\nObjectDefineProperty(Socket.prototype, \"_handle\", {\n  get() {\n    return this[kHandle];\n  },\n  set(v) {\n    return this[kHandle] = v;\n  }\n});\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once(\"exit\", (socketList2) => {\n    const index = ArrayPrototypeIndexOf(this._workers, socketList2);\n    this._workers.splice(index, 1);\n  });\n};\nServer.prototype.ref = function() {\n  this._unref = false;\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\nServer.prototype.unref = function() {\n  this._unref = true;\n  if (this._handle)\n    this._handle.unref();\n  return this;\n};\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\nif (isWindows) {\n  let simultaneousAccepts;\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\"net._setSimultaneousAccepts() is deprecated and will be removed.\", \"DeprecationWarning\", \"DEP0121\");\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === void 0) {\n      return;\n    }\n    if (simultaneousAccepts === void 0) {\n      simultaneousAccepts = process.env.NODE_MANY_ACCEPTS && process.env.NODE_MANY_ACCEPTS !== \"0\";\n    }\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\"net._setSimultaneousAccepts() is deprecated and will be removed.\", \"DeprecationWarning\", \"DEP0121\");\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  get BlockList() {\n    BlockList ??= require(\"internal/blocklist\").BlockList;\n    return BlockList;\n  },\n  get SocketAddress() {\n    SocketAddress ??= require(\"internal/socketaddress\").SocketAddress;\n    return SocketAddress;\n  },\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP,\n  isIPv4,\n  isIPv6,\n  Server,\n  Socket,\n  Stream: Socket\n};\n}"],["os.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypePush,\n  Float64Array,\n  NumberParseInt,\n  ObjectDefineProperties,\n  StringPrototypeEndsWith,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  SymbolToPrimitive\n} = primordials;\nconst { safeGetenv } = internalBinding(\"credentials\");\nconst constants = internalBinding(\"constants\").os;\nconst isWindows = process.platform === \"win32\";\nconst {\n  codes: {\n    ERR_SYSTEM_ERROR\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst { validateInt32 } = require(\"internal/validators\");\nconst {\n  getCPUs,\n  getFreeMem,\n  getHomeDirectory: _getHomeDirectory,\n  getHostname: _getHostname,\n  getInterfaceAddresses: _getInterfaceAddresses,\n  getLoadAvg,\n  getPriority: _getPriority,\n  getOSInformation: _getOSInformation,\n  getTotalMem,\n  getUserInfo,\n  getUptime,\n  isBigEndian,\n  setPriority: _setPriority\n} = internalBinding(\"os\");\nfunction getCheckedFunction(fn) {\n  return hideStackFrames(function checkError(...args) {\n    const ctx = {};\n    const ret = fn(...args, ctx);\n    if (ret === void 0) {\n      throw new ERR_SYSTEM_ERROR(ctx);\n    }\n    return ret;\n  });\n}\nconst {\n  0: type,\n  1: version,\n  2: release\n} = _getOSInformation();\nconst getHomeDirectory = getCheckedFunction(_getHomeDirectory);\nconst getHostname = getCheckedFunction(_getHostname);\nconst getInterfaceAddresses = getCheckedFunction(_getInterfaceAddresses);\nconst getOSRelease = () => release;\nconst getOSType = () => type;\nconst getOSVersion = () => version;\ngetFreeMem[SymbolToPrimitive] = () => getFreeMem();\ngetHostname[SymbolToPrimitive] = () => getHostname();\ngetOSVersion[SymbolToPrimitive] = () => getOSVersion();\ngetOSType[SymbolToPrimitive] = () => getOSType();\ngetOSRelease[SymbolToPrimitive] = () => getOSRelease();\ngetHomeDirectory[SymbolToPrimitive] = () => getHomeDirectory();\ngetTotalMem[SymbolToPrimitive] = () => getTotalMem();\ngetUptime[SymbolToPrimitive] = () => getUptime();\nconst kEndianness = isBigEndian ? \"BE\" : \"LE\";\nconst avgValues = new Float64Array(3);\nfunction loadavg() {\n  getLoadAvg(avgValues);\n  return [avgValues[0], avgValues[1], avgValues[2]];\n}\nfunction cpus() {\n  const data = getCPUs() || [];\n  const result = [];\n  let i = 0;\n  while (i < data.length) {\n    ArrayPrototypePush(result, {\n      model: data[i++],\n      speed: data[i++],\n      times: {\n        user: data[i++],\n        nice: data[i++],\n        sys: data[i++],\n        idle: data[i++],\n        irq: data[i++]\n      }\n    });\n  }\n  return result;\n}\nfunction arch() {\n  return process.arch;\n}\narch[SymbolToPrimitive] = () => process.arch;\nfunction platform() {\n  return process.platform;\n}\nplatform[SymbolToPrimitive] = () => process.platform;\nfunction tmpdir() {\n  var path;\n  if (isWindows) {\n    path = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + \"\\\\temp\";\n    if (path.length > 1 && StringPrototypeEndsWith(path, \"\\\\\") && !StringPrototypeEndsWith(path, \":\\\\\"))\n      path = StringPrototypeSlice(path, 0, -1);\n  } else {\n    path = safeGetenv(\"TMPDIR\") || safeGetenv(\"TMP\") || safeGetenv(\"TEMP\") || \"/tmp\";\n    if (path.length > 1 && StringPrototypeEndsWith(path, \"/\"))\n      path = StringPrototypeSlice(path, 0, -1);\n  }\n  return path;\n}\ntmpdir[SymbolToPrimitive] = () => tmpdir();\nfunction endianness() {\n  return kEndianness;\n}\nendianness[SymbolToPrimitive] = () => kEndianness;\nfunction countBinaryOnes(n) {\n  n = n - (n >>> 1 & 1431655765);\n  n = (n & 858993459) + (n >>> 2 & 858993459);\n  return (n + (n >>> 4) & 252645135) * 16843009 >>> 24;\n}\nfunction getCIDR(address, netmask, family) {\n  let ones = 0;\n  let split = \".\";\n  let range = 10;\n  let groupLength = 8;\n  let hasZeros = false;\n  if (family === \"IPv6\") {\n    split = \":\";\n    range = 16;\n    groupLength = 16;\n  }\n  const parts = StringPrototypeSplit(netmask, split);\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] !== \"\") {\n      const binary = NumberParseInt(parts[i], range);\n      const tmp = countBinaryOnes(binary);\n      ones += tmp;\n      if (hasZeros) {\n        if (tmp !== 0) {\n          return null;\n        }\n      } else if (tmp !== groupLength) {\n        if ((binary & 1) !== 0) {\n          return null;\n        }\n        hasZeros = true;\n      }\n    }\n  }\n  return `${address}/${ones}`;\n}\nfunction networkInterfaces() {\n  const data = getInterfaceAddresses();\n  const result = {};\n  if (data === void 0)\n    return result;\n  for (var i = 0; i < data.length; i += 7) {\n    const name = data[i];\n    const entry = {\n      address: data[i + 1],\n      netmask: data[i + 2],\n      family: data[i + 3],\n      mac: data[i + 4],\n      internal: data[i + 5],\n      cidr: getCIDR(data[i + 1], data[i + 2], data[i + 3])\n    };\n    const scopeid = data[i + 6];\n    if (scopeid !== -1)\n      entry.scopeid = scopeid;\n    const existing = result[name];\n    if (existing !== void 0)\n      ArrayPrototypePush(existing, entry);\n    else\n      result[name] = [entry];\n  }\n  return result;\n}\nfunction setPriority(pid, priority) {\n  if (priority === void 0) {\n    priority = pid;\n    pid = 0;\n  }\n  validateInt32(pid, \"pid\");\n  validateInt32(priority, \"priority\", -20, 19);\n  const ctx = {};\n  if (_setPriority(pid, priority, ctx) !== 0)\n    throw new ERR_SYSTEM_ERROR(ctx);\n}\nfunction getPriority(pid) {\n  if (pid === void 0)\n    pid = 0;\n  else\n    validateInt32(pid, \"pid\");\n  const ctx = {};\n  const priority = _getPriority(pid, ctx);\n  if (priority === void 0)\n    throw new ERR_SYSTEM_ERROR(ctx);\n  return priority;\n}\nfunction userInfo(options) {\n  if (typeof options !== \"object\")\n    options = null;\n  const ctx = {};\n  const user = getUserInfo(options, ctx);\n  if (user === void 0)\n    throw new ERR_SYSTEM_ERROR(ctx);\n  return user;\n}\nmodule.exports = {\n  arch,\n  cpus,\n  endianness,\n  freemem: getFreeMem,\n  getPriority,\n  homedir: getHomeDirectory,\n  hostname: getHostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release: getOSRelease,\n  setPriority,\n  tmpdir,\n  totalmem: getTotalMem,\n  type: getOSType,\n  userInfo,\n  uptime: getUptime,\n  version: getOSVersion\n};\nObjectDefineProperties(module.exports, {\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  EOL: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: isWindows ? \"\\r\\n\" : \"\\n\"\n  },\n  devNull: {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n    value: isWindows ? \"\\\\\\\\.\\\\nul\" : \"/dev/null\"\n  }\n});\n}"],["path.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  FunctionPrototypeBind,\n  StringPrototypeCharCodeAt,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeToLowerCase\n} = primordials;\nconst {\n  CHAR_UPPERCASE_A,\n  CHAR_LOWERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_LOWERCASE_Z,\n  CHAR_DOT,\n  CHAR_FORWARD_SLASH,\n  CHAR_BACKWARD_SLASH,\n  CHAR_COLON,\n  CHAR_QUESTION_MARK\n} = require(\"internal/constants\");\nconst {\n  validateObject,\n  validateString\n} = require(\"internal/validators\");\nconst platformIsWin32 = process.platform === \"win32\";\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path, i);\n    else if (isPathSeparator2(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n    if (isPathSeparator2(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || StringPrototypeCharCodeAt(res, res.length - 1) !== CHAR_DOT || StringPrototypeCharCodeAt(res, res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res, 0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - StringPrototypeLastIndexOf(res, separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i)}`;\n        else\n          res = StringPrototypeSlice(path, lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  validateObject(pathObject, \"pathObject\");\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || \"\"}${pathObject.ext || \"\"}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nconst win32 = {\n  resolve(...args) {\n    let resolvedDevice = \"\";\n    let resolvedTail = \"\";\n    let resolvedAbsolute = false;\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path, \"path\");\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n        if (path === void 0 || StringPrototypeToLowerCase(StringPrototypeSlice(path, 0, 2)) !== StringPrototypeToLowerCase(resolvedDevice) && StringPrototypeCharCodeAt(path, 2) === CHAR_BACKWARD_SLASH) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n      const len = path.length;\n      let rootEnd = 0;\n      let device = \"\";\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path, 0);\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        isAbsolute = true;\n        if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n          let j = 2;\n          let last = j;\n          while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path, last, j);\n            last = j;\n            while (j < len && isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              last = j;\n              while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                device = `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n        device = StringPrototypeSlice(path, 0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !== StringPrototypeToLowerCase(resolvedDevice))\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail = `${StringPrototypeSlice(path, rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\n    return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0)\n      return \".\";\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path, 0);\n    if (len === 1) {\n      return isPosixPathSeparator(code) ? \"\\\\\" : path;\n    }\n    if (isPathSeparator(code)) {\n      isAbsolute = true;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path, last, j);\n          last = j;\n          while (j < len && isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last)}\\\\`;\n            }\n            if (j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path, last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      device = StringPrototypeSlice(path, 0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n    let tail = rootEnd < len ? normalizeString(StringPrototypeSlice(path, rootEnd), !isAbsolute, \"\\\\\", isPathSeparator) : \"\";\n    if (tail.length === 0 && !isAbsolute)\n      tail = \".\";\n    if (tail.length > 0 && isPathSeparator(StringPrototypeCharCodeAt(path, len - 1)))\n      tail += \"\\\\\";\n    if (device === void 0) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0)\n      return false;\n    const code = StringPrototypeCharCodeAt(path, 0);\n    return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON && isPathSeparator(StringPrototypeCharCodeAt(path, 2));\n  },\n  join(...args) {\n    if (args.length === 0)\n      return \".\";\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, \"path\");\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n    if (joined === void 0)\n      return \".\";\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 && isPathSeparator(StringPrototypeCharCodeAt(firstPart, 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart, 2)))\n            ++slashCount;\n          else {\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      while (slashCount < joined.length && isPathSeparator(StringPrototypeCharCodeAt(joined, slashCount))) {\n        slashCount++;\n      }\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined, slashCount)}`;\n    }\n    return win32.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to)\n      return \"\";\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n    if (fromOrig === toOrig)\n      return \"\";\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n    if (from === to)\n      return \"\";\n    let fromStart = 0;\n    while (fromStart < from.length && StringPrototypeCharCodeAt(from, fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    let fromEnd = from.length;\n    while (fromEnd - 1 > fromStart && StringPrototypeCharCodeAt(from, fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 0;\n    while (toStart < to.length && StringPrototypeCharCodeAt(to, toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart && StringPrototypeCharCodeAt(to, toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) === CHAR_BACKWARD_SLASH) {\n          return StringPrototypeSlice(toOrig, toStart + i + 1);\n        }\n        if (i === 2) {\n          return StringPrototypeSlice(toOrig, toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) === CHAR_BACKWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 2) {\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || StringPrototypeCharCodeAt(from, i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"\\\\..\";\n      }\n    }\n    toStart += lastCommonSep;\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig, toStart, toEnd)}`;\n    if (StringPrototypeCharCodeAt(toOrig, toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig, toStart, toEnd);\n  },\n  toNamespacedPath(path) {\n    if (typeof path !== \"string\" || path.length === 0)\n      return path;\n    const resolvedPath = win32.resolve(path);\n    if (resolvedPath.length <= 2)\n      return path;\n    if (StringPrototypeCharCodeAt(resolvedPath, 0) === CHAR_BACKWARD_SLASH) {\n      if (StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath, 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath, 2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath, 0)) && StringPrototypeCharCodeAt(resolvedPath, 1) === CHAR_COLON && StringPrototypeCharCodeAt(resolvedPath, 2) === CHAR_BACKWARD_SLASH) {\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    const len = path.length;\n    if (len === 0)\n      return \".\";\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path, 0);\n    if (len === 1) {\n      return isPathSeparator(code) ? path : \".\";\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = offset = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          last = j;\n          while (j < len && isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              return path;\n            }\n            if (j !== last) {\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      rootEnd = len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path, 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1)\n        return \".\";\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path, 0, end);\n  },\n  basename(path, ext) {\n    if (ext !== void 0)\n      validateString(ext, \"ext\");\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    if (path.length >= 2 && isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0)) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      start = 2;\n    }\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (isPathSeparator(code)) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === StringPrototypeCharCodeAt(ext, extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, i))) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return StringPrototypeSlice(path, start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    if (path.length >= 2 && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON && isWindowsDeviceRoot(StringPrototypeCharCodeAt(path, 0))) {\n      start = startPart = 2;\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n  format: FunctionPrototypeBind(_format, null, \"\\\\\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0)\n      return ret;\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path, 0);\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          last = j;\n          while (j < len && isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(StringPrototypeCharCodeAt(path, j))) {\n              j++;\n            }\n            if (j === len) {\n              rootEnd = j;\n            } else if (j !== last) {\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && StringPrototypeCharCodeAt(path, 1) === CHAR_COLON) {\n      if (len <= 2) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path, 2))) {\n        if (len === 3) {\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path, 0, rootEnd);\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path, i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = StringPrototypeSlice(path, startPart, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, startPart, startDot);\n        ret.base = StringPrototypeSlice(path, startPart, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else\n      ret.dir = ret.root;\n    return ret;\n  },\n  sep: \"\\\\\",\n  delimiter: \";\",\n  win32: null,\n  posix: null\n};\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd(), regexp, \"/\");\n      return StringPrototypeSlice(cwd, StringPrototypeIndexOf(cwd, \"/\"));\n    };\n  }\n  return () => process.cwd();\n})();\nconst posix = {\n  resolve(...args) {\n    let resolvedPath = \"\";\n    let resolvedAbsolute = false;\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n      validateString(path, \"path\");\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    }\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : \".\";\n  },\n  normalize(path) {\n    validateString(path, \"path\");\n    if (path.length === 0)\n      return \".\";\n    const isAbsolute = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = StringPrototypeCharCodeAt(path, path.length - 1) === CHAR_FORWARD_SLASH;\n    path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n    if (path.length === 0) {\n      if (isAbsolute)\n        return \"/\";\n      return trailingSeparator ? \"./\" : \".\";\n    }\n    if (trailingSeparator)\n      path += \"/\";\n    return isAbsolute ? `/${path}` : path;\n  },\n  isAbsolute(path) {\n    validateString(path, \"path\");\n    return path.length > 0 && StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n  },\n  join(...args) {\n    if (args.length === 0)\n      return \".\";\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg, \"path\");\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === void 0)\n      return \".\";\n    return posix.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, \"from\");\n    validateString(to, \"to\");\n    if (from === to)\n      return \"\";\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to)\n      return \"\";\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from, fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to, toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to, toStart + i) === CHAR_FORWARD_SLASH) {\n          return StringPrototypeSlice(to, toStart + i + 1);\n        }\n        if (i === 0) {\n          return StringPrototypeSlice(to, toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from, fromStart + i) === CHAR_FORWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 0) {\n          lastCommonSep = 0;\n        }\n      }\n    }\n    let out = \"\";\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || StringPrototypeCharCodeAt(from, i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? \"..\" : \"/..\";\n      }\n    }\n    return `${out}${StringPrototypeSlice(to, toStart + lastCommonSep)}`;\n  },\n  toNamespacedPath(path) {\n    return path;\n  },\n  dirname(path) {\n    validateString(path, \"path\");\n    if (path.length === 0)\n      return \".\";\n    const hasRoot = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : \".\";\n    if (hasRoot && end === 1)\n      return \"//\";\n    return StringPrototypeSlice(path, 0, end);\n  },\n  basename(path, ext) {\n    if (ext !== void 0)\n      validateString(ext, \"ext\");\n    validateString(path, \"path\");\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path, i);\n        if (code === CHAR_FORWARD_SLASH) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === StringPrototypeCharCodeAt(ext, extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path, start, end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path, i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return StringPrototypeSlice(path, start, end);\n  },\n  extname(path) {\n    validateString(path, \"path\");\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return StringPrototypeSlice(path, startDot, end);\n  },\n  format: FunctionPrototypeBind(_format, null, \"/\"),\n  parse(path) {\n    validateString(path, \"path\");\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute = StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = \"/\";\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path, i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      const start2 = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = StringPrototypeSlice(path, start2, end);\n      } else {\n        ret.name = StringPrototypeSlice(path, start2, startDot);\n        ret.base = StringPrototypeSlice(path, start2, end);\n        ret.ext = StringPrototypeSlice(path, startDot, end);\n      }\n    }\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path, 0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = \"/\";\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\nmodule.exports = platformIsWin32 ? win32 : posix;\n}"],["perf_hooks.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperty\n} = primordials;\nconst {\n  constants\n} = internalBinding(\"performance\");\nconst { PerformanceEntry } = require(\"internal/perf/performance_entry\");\nconst {\n  PerformanceObserver,\n  PerformanceObserverEntryList\n} = require(\"internal/perf/observe\");\nconst {\n  PerformanceMark,\n  PerformanceMeasure\n} = require(\"internal/perf/usertiming\");\nconst { InternalPerformance } = require(\"internal/perf/performance\");\nconst {\n  createHistogram\n} = require(\"internal/histogram\");\nconst monitorEventLoopDelay = require(\"internal/perf/event_loop_delay\");\nmodule.exports = {\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  monitorEventLoopDelay,\n  createHistogram,\n  performance: new InternalPerformance()\n};\nObjectDefineProperty(module.exports, \"constants\", {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n}"],["process.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = process;\n}"],["punycode.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst { getOptionValue } = require(\"internal/options\");\nif (getOptionValue(\"--pending-deprecation\")) {\n  process.emitWarning(\"The `punycode` module is deprecated. Please use a userland alternative instead.\", \"DeprecationWarning\", \"DEP0040\");\n}\nconst maxInt = 2147483647;\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128;\nconst delimiter = \"-\";\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/;\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst errors = {\n  \"overflow\": \"Overflow: input needs wider integers to process\",\n  \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n  \"invalid-input\": \"Invalid input\"\n};\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\nfunction error(type) {\n  throw new RangeError(errors[type]);\n}\nfunction map(array, fn) {\n  const result = [];\n  let length = array.length;\n  while (length--) {\n    result[length] = fn(array[length]);\n  }\n  return result;\n}\nfunction mapDomain(string, fn) {\n  const parts = string.split(\"@\");\n  let result = \"\";\n  if (parts.length > 1) {\n    result = parts[0] + \"@\";\n    string = parts[1];\n  }\n  string = string.replace(regexSeparators, \".\");\n  const labels = string.split(\".\");\n  const encoded = map(labels, fn).join(\".\");\n  return result + encoded;\n}\nfunction ucs2decode(string) {\n  const output = [];\n  let counter = 0;\n  const length = string.length;\n  while (counter < length) {\n    const value = string.charCodeAt(counter++);\n    if (value >= 55296 && value <= 56319 && counter < length) {\n      const extra = string.charCodeAt(counter++);\n      if ((extra & 64512) == 56320) {\n        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      } else {\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n}\nconst ucs2encode = (array) => String.fromCodePoint(...array);\nconst basicToDigit = function(codePoint) {\n  if (codePoint - 48 < 10) {\n    return codePoint - 22;\n  }\n  if (codePoint - 65 < 26) {\n    return codePoint - 65;\n  }\n  if (codePoint - 97 < 26) {\n    return codePoint - 97;\n  }\n  return base;\n};\nconst digitToBasic = function(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\nconst adapt = function(delta, numPoints, firstTime) {\n  let k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\nconst decode = function(input) {\n  const output = [];\n  const inputLength = input.length;\n  let i = 0;\n  let n = initialN;\n  let bias = initialBias;\n  let basic = input.lastIndexOf(delimiter);\n  if (basic < 0) {\n    basic = 0;\n  }\n  for (let j = 0; j < basic; ++j) {\n    if (input.charCodeAt(j) >= 128) {\n      error(\"not-basic\");\n    }\n    output.push(input.charCodeAt(j));\n  }\n  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n    let oldi = i;\n    for (let w = 1, k = base; ; k += base) {\n      if (index >= inputLength) {\n        error(\"invalid-input\");\n      }\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base || digit > floor((maxInt - i) / w)) {\n        error(\"overflow\");\n      }\n      i += digit * w;\n      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n      if (digit < t) {\n        break;\n      }\n      const baseMinusT = base - t;\n      if (w > floor(maxInt / baseMinusT)) {\n        error(\"overflow\");\n      }\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    bias = adapt(i - oldi, out, oldi == 0);\n    if (floor(i / out) > maxInt - n) {\n      error(\"overflow\");\n    }\n    n += floor(i / out);\n    i %= out;\n    output.splice(i++, 0, n);\n  }\n  return String.fromCodePoint(...output);\n};\nconst encode = function(input) {\n  const output = [];\n  input = ucs2decode(input);\n  let inputLength = input.length;\n  let n = initialN;\n  let delta = 0;\n  let bias = initialBias;\n  for (const currentValue of input) {\n    if (currentValue < 128) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n  let basicLength = output.length;\n  let handledCPCount = basicLength;\n  if (basicLength) {\n    output.push(delimiter);\n  }\n  while (handledCPCount < inputLength) {\n    let m = maxInt;\n    for (const currentValue of input) {\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      error(\"overflow\");\n    }\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n    for (const currentValue of input) {\n      if (currentValue < n && ++delta > maxInt) {\n        error(\"overflow\");\n      }\n      if (currentValue === n) {\n        let q = delta;\n        for (let k = base; ; k += base) {\n          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (q < t) {\n            break;\n          }\n          const qMinusT = q - t;\n          const baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n          q = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q, 0)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n    ++delta;\n    ++n;\n  }\n  return output.join(\"\");\n};\nconst toUnicode = function(input) {\n  return mapDomain(input, function(string) {\n    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n  });\n};\nconst toASCII = function(input) {\n  return mapDomain(input, function(string) {\n    return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n  });\n};\nconst punycode = {\n  \"version\": \"2.1.0\",\n  \"ucs2\": {\n    \"decode\": ucs2decode,\n    \"encode\": ucs2encode\n  },\n  \"decode\": decode,\n  \"encode\": encode,\n  \"toASCII\": toASCII,\n  \"toUnicode\": toUnicode\n};\nmodule.exports = punycode;\n}"],["querystring.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  Int8Array,\n  MathAbs,\n  NumberIsFinite,\n  ObjectCreate,\n  ObjectKeys,\n  String,\n  StringPrototypeCharCodeAt,\n  StringPrototypeSlice,\n  decodeURIComponent\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  encodeStr,\n  hexTable,\n  isHexTable\n} = require(\"internal/querystring\");\nconst QueryString = module.exports = {\n  unescapeBuffer,\n  unescape: qsUnescape,\n  escape: qsEscape,\n  stringify,\n  encode: stringify,\n  parse,\n  decode: parse\n};\nconst unhexTable = new Int8Array([\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n]);\nfunction unescapeBuffer(s, decodeSpaces) {\n  const out = Buffer.allocUnsafe(s.length);\n  let index = 0;\n  let outIndex = 0;\n  let currentChar;\n  let nextChar;\n  let hexHigh;\n  let hexLow;\n  const maxLength = s.length - 2;\n  let hasHex = false;\n  while (index < s.length) {\n    currentChar = StringPrototypeCharCodeAt(s, index);\n    if (currentChar === 43 && decodeSpaces) {\n      out[outIndex++] = 32;\n      index++;\n      continue;\n    }\n    if (currentChar === 37 && index < maxLength) {\n      currentChar = StringPrototypeCharCodeAt(s, ++index);\n      hexHigh = unhexTable[currentChar];\n      if (!(hexHigh >= 0)) {\n        out[outIndex++] = 37;\n        continue;\n      } else {\n        nextChar = StringPrototypeCharCodeAt(s, ++index);\n        hexLow = unhexTable[nextChar];\n        if (!(hexLow >= 0)) {\n          out[outIndex++] = 37;\n          index--;\n        } else {\n          hasHex = true;\n          currentChar = hexHigh * 16 + hexLow;\n        }\n      }\n    }\n    out[outIndex++] = currentChar;\n    index++;\n  }\n  return hasHex ? out.slice(0, outIndex) : out;\n}\nfunction qsUnescape(s, decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n  }\n}\nconst noEscape = new Int8Array([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  0\n]);\nfunction qsEscape(str) {\n  if (typeof str !== \"string\") {\n    if (typeof str === \"object\")\n      str = String(str);\n    else\n      str += \"\";\n  }\n  return encodeStr(str, noEscape, hexTable);\n}\nfunction stringifyPrimitive(v) {\n  if (typeof v === \"string\")\n    return v;\n  if (typeof v === \"number\" && NumberIsFinite(v))\n    return \"\" + v;\n  if (typeof v === \"bigint\")\n    return \"\" + v;\n  if (typeof v === \"boolean\")\n    return v ? \"true\" : \"false\";\n  return \"\";\n}\nfunction encodeStringified(v, encode) {\n  if (typeof v === \"string\")\n    return v.length ? encode(v) : \"\";\n  if (typeof v === \"number\" && NumberIsFinite(v)) {\n    return MathAbs(v) < 1e21 ? \"\" + v : encode(\"\" + v);\n  }\n  if (typeof v === \"bigint\")\n    return \"\" + v;\n  if (typeof v === \"boolean\")\n    return v ? \"true\" : \"false\";\n  return \"\";\n}\nfunction encodeStringifiedCustom(v, encode) {\n  return encode(stringifyPrimitive(v));\n}\nfunction stringify(obj, sep, eq, options) {\n  sep = sep || \"&\";\n  eq = eq || \"=\";\n  let encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === \"function\") {\n    encode = options.encodeURIComponent;\n  }\n  const convert = encode === qsEscape ? encodeStringified : encodeStringifiedCustom;\n  if (obj !== null && typeof obj === \"object\") {\n    const keys = ObjectKeys(obj);\n    const len = keys.length;\n    let fields = \"\";\n    for (let i = 0; i < len; ++i) {\n      const k = keys[i];\n      const v = obj[k];\n      let ks = convert(k, encode);\n      ks += eq;\n      if (ArrayIsArray(v)) {\n        const vlen = v.length;\n        if (vlen === 0)\n          continue;\n        if (fields)\n          fields += sep;\n        for (let j = 0; j < vlen; ++j) {\n          if (j)\n            fields += sep;\n          fields += ks;\n          fields += convert(v[j], encode);\n        }\n      } else {\n        if (fields)\n          fields += sep;\n        fields += ks;\n        fields += convert(v, encode);\n      }\n    }\n    return fields;\n  }\n  return \"\";\n}\nfunction charCodes(str) {\n  if (str.length === 0)\n    return [];\n  if (str.length === 1)\n    return [StringPrototypeCharCodeAt(str, 0)];\n  const ret = new Array(str.length);\n  for (let i = 0; i < str.length; ++i)\n    ret[i] = StringPrototypeCharCodeAt(str, i);\n  return ret;\n}\nconst defSepCodes = [38];\nconst defEqCodes = [61];\nfunction addKeyVal(obj, key, value, keyEncoded, valEncoded, decode) {\n  if (key.length > 0 && keyEncoded)\n    key = decodeStr(key, decode);\n  if (value.length > 0 && valEncoded)\n    value = decodeStr(value, decode);\n  if (obj[key] === void 0) {\n    obj[key] = value;\n  } else {\n    const curValue = obj[key];\n    if (curValue.pop)\n      curValue[curValue.length] = value;\n    else\n      obj[key] = [curValue, value];\n  }\n}\nfunction parse(qs, sep, eq, options) {\n  const obj = ObjectCreate(null);\n  if (typeof qs !== \"string\" || qs.length === 0) {\n    return obj;\n  }\n  const sepCodes = !sep ? defSepCodes : charCodes(String(sep));\n  const eqCodes = !eq ? defEqCodes : charCodes(String(eq));\n  const sepLen = sepCodes.length;\n  const eqLen = eqCodes.length;\n  let pairs = 1e3;\n  if (options && typeof options.maxKeys === \"number\") {\n    pairs = options.maxKeys > 0 ? options.maxKeys : -1;\n  }\n  let decode = QueryString.unescape;\n  if (options && typeof options.decodeURIComponent === \"function\") {\n    decode = options.decodeURIComponent;\n  }\n  const customDecode = decode !== qsUnescape;\n  let lastPos = 0;\n  let sepIdx = 0;\n  let eqIdx = 0;\n  let key = \"\";\n  let value = \"\";\n  let keyEncoded = customDecode;\n  let valEncoded = customDecode;\n  const plusChar = customDecode ? \"%20\" : \" \";\n  let encodeCheck = 0;\n  for (let i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs, i);\n    if (code === sepCodes[sepIdx]) {\n      if (++sepIdx === sepLen) {\n        const end = i - sepIdx + 1;\n        if (eqIdx < eqLen) {\n          if (lastPos < end) {\n            key += StringPrototypeSlice(qs, lastPos, end);\n          } else if (key.length === 0) {\n            if (--pairs === 0)\n              return obj;\n            lastPos = i + 1;\n            sepIdx = eqIdx = 0;\n            continue;\n          }\n        } else if (lastPos < end) {\n          value += StringPrototypeSlice(qs, lastPos, end);\n        }\n        addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);\n        if (--pairs === 0)\n          return obj;\n        keyEncoded = valEncoded = customDecode;\n        key = value = \"\";\n        encodeCheck = 0;\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n    } else {\n      sepIdx = 0;\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            const end = i - eqIdx + 1;\n            if (lastPos < end)\n              key += StringPrototypeSlice(qs, lastPos, end);\n            encodeCheck = 0;\n            lastPos = i + 1;\n          }\n          continue;\n        } else {\n          eqIdx = 0;\n          if (!keyEncoded) {\n            if (code === 37) {\n              encodeCheck = 1;\n              continue;\n            } else if (encodeCheck > 0) {\n              if (isHexTable[code] === 1) {\n                if (++encodeCheck === 3)\n                  keyEncoded = true;\n                continue;\n              } else {\n                encodeCheck = 0;\n              }\n            }\n          }\n        }\n        if (code === 43) {\n          if (lastPos < i)\n            key += StringPrototypeSlice(qs, lastPos, i);\n          key += plusChar;\n          lastPos = i + 1;\n          continue;\n        }\n      }\n      if (code === 43) {\n        if (lastPos < i)\n          value += StringPrototypeSlice(qs, lastPos, i);\n        value += plusChar;\n        lastPos = i + 1;\n      } else if (!valEncoded) {\n        if (code === 37) {\n          encodeCheck = 1;\n        } else if (encodeCheck > 0) {\n          if (isHexTable[code] === 1) {\n            if (++encodeCheck === 3)\n              valEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n  }\n  if (lastPos < qs.length) {\n    if (eqIdx < eqLen)\n      key += StringPrototypeSlice(qs, lastPos);\n    else if (sepIdx < sepLen)\n      value += StringPrototypeSlice(qs, lastPos);\n  } else if (eqIdx === 0 && key.length === 0) {\n    return obj;\n  }\n  addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);\n  return obj;\n}\nfunction decodeStr(s, decoder) {\n  try {\n    return decoder(s);\n  } catch {\n    return QueryString.unescape(s, true);\n  }\n}\n}"],["readline.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  DateNow,\n  FunctionPrototypeBind,\n  FunctionPrototypeCall,\n  ObjectDefineProperties,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseReject,\n  StringPrototypeSlice\n} = primordials;\nconst {\n  clearLine,\n  clearScreenDown,\n  cursorTo,\n  moveCursor\n} = require(\"internal/readline/callbacks\");\nconst emitKeypressEvents = require(\"internal/readline/emitKeypressEvents\");\nconst promises = require(\"readline/promises\");\nconst {\n  AbortError\n} = require(\"internal/errors\");\nconst {\n  inspect\n} = require(\"internal/util/inspect\");\nconst { promisify } = require(\"internal/util\");\nconst { validateAbortSignal } = require(\"internal/validators\");\nconst {\n  Interface: _Interface,\n  InterfaceConstructor,\n  kAddHistory,\n  kDecoder,\n  kDeleteLeft,\n  kDeleteLineLeft,\n  kDeleteLineRight,\n  kDeleteRight,\n  kDeleteWordLeft,\n  kDeleteWordRight,\n  kGetDisplayPos,\n  kHistoryNext,\n  kHistoryPrev,\n  kInsertString,\n  kLine,\n  kLine_buffer,\n  kMoveCursor,\n  kNormalWrite,\n  kOldPrompt,\n  kOnLine,\n  kPreviousKey,\n  kPrompt,\n  kQuestionCallback,\n  kQuestionCancel,\n  kRefreshLine,\n  kSawKeyPress,\n  kSawReturnAt,\n  kSetRawMode,\n  kTabComplete,\n  kTabCompleter,\n  kTtyWrite,\n  kWordLeft,\n  kWordRight,\n  kWriteToOutput\n} = require(\"internal/readline/interface\");\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n  if (input?.input && typeof input.completer === \"function\" && input.completer.length !== 2) {\n    const { completer: completer2 } = input;\n    input.completer = (v, cb) => cb(null, completer2(v));\n  } else if (typeof completer === \"function\" && completer.length !== 2) {\n    const realCompleter = completer;\n    completer = (v, cb) => cb(null, realCompleter(v));\n  }\n  FunctionPrototypeCall(InterfaceConstructor, this, input, output, completer, terminal);\n  if (process.env.TERM === \"dumb\") {\n    this._ttyWrite = FunctionPrototypeBind(_ttyWriteDumb, this);\n  }\n}\nObjectSetPrototypeOf(Interface.prototype, _Interface.prototype);\nObjectSetPrototypeOf(Interface, _Interface);\nconst superQuestion = _Interface.prototype.question;\nInterface.prototype.question = function(query, options, cb) {\n  cb = typeof options === \"function\" ? options : cb;\n  options = typeof options === \"object\" && options !== null ? options : {};\n  if (options.signal) {\n    validateAbortSignal(options.signal, \"options.signal\");\n    if (options.signal.aborted) {\n      return;\n    }\n    const onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    options.signal.addEventListener(\"abort\", onAbort, { once: true });\n    const cleanup = () => {\n      options.signal.removeEventListener(onAbort);\n    };\n    cb = typeof cb === \"function\" ? (answer) => {\n      cleanup();\n      return cb(answer);\n    } : cleanup;\n  }\n  if (typeof cb === \"function\") {\n    FunctionPrototypeCall(superQuestion, this, query, cb);\n  }\n};\nInterface.prototype.question[promisify.custom] = function(query, options) {\n  options = typeof options === \"object\" && options !== null ? options : {};\n  if (options.signal && options.signal.aborted) {\n    return PromiseReject(new AbortError());\n  }\n  return new Promise((resolve, reject) => {\n    let cb = resolve;\n    if (options.signal) {\n      const onAbort = () => {\n        reject(new AbortError());\n      };\n      options.signal.addEventListener(\"abort\", onAbort, { once: true });\n      cb = (answer) => {\n        options.signal.removeEventListener(\"abort\", onAbort);\n        resolve(answer);\n      };\n    }\n    this.question(query, options, cb);\n  });\n};\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\nObjectDefineProperties(Interface.prototype, {\n  [kSetRawMode]: {\n    get() {\n      return this._setRawMode;\n    }\n  },\n  [kOnLine]: {\n    get() {\n      return this._onLine;\n    }\n  },\n  [kWriteToOutput]: {\n    get() {\n      return this._writeToOutput;\n    }\n  },\n  [kAddHistory]: {\n    get() {\n      return this._addHistory;\n    }\n  },\n  [kRefreshLine]: {\n    get() {\n      return this._refreshLine;\n    }\n  },\n  [kNormalWrite]: {\n    get() {\n      return this._normalWrite;\n    }\n  },\n  [kInsertString]: {\n    get() {\n      return this._insertString;\n    }\n  },\n  [kTabComplete]: {\n    get() {\n      return this._tabComplete;\n    }\n  },\n  [kWordLeft]: {\n    get() {\n      return this._wordLeft;\n    }\n  },\n  [kWordRight]: {\n    get() {\n      return this._wordRight;\n    }\n  },\n  [kDeleteLeft]: {\n    get() {\n      return this._deleteLeft;\n    }\n  },\n  [kDeleteRight]: {\n    get() {\n      return this._deleteRight;\n    }\n  },\n  [kDeleteWordLeft]: {\n    get() {\n      return this._deleteWordLeft;\n    }\n  },\n  [kDeleteWordRight]: {\n    get() {\n      return this._deleteWordRight;\n    }\n  },\n  [kDeleteLineLeft]: {\n    get() {\n      return this._deleteLineLeft;\n    }\n  },\n  [kDeleteLineRight]: {\n    get() {\n      return this._deleteLineRight;\n    }\n  },\n  [kLine]: {\n    get() {\n      return this._line;\n    }\n  },\n  [kHistoryNext]: {\n    get() {\n      return this._historyNext;\n    }\n  },\n  [kHistoryPrev]: {\n    get() {\n      return this._historyPrev;\n    }\n  },\n  [kGetDisplayPos]: {\n    get() {\n      return this._getDisplayPos;\n    }\n  },\n  [kMoveCursor]: {\n    get() {\n      return this._moveCursor;\n    }\n  },\n  [kTtyWrite]: {\n    get() {\n      return this._ttyWrite;\n    }\n  },\n  _decoder: {\n    get() {\n      return this[kDecoder];\n    },\n    set(value) {\n      this[kDecoder] = value;\n    }\n  },\n  _line_buffer: {\n    get() {\n      return this[kLine_buffer];\n    },\n    set(value) {\n      this[kLine_buffer] = value;\n    }\n  },\n  _oldPrompt: {\n    get() {\n      return this[kOldPrompt];\n    },\n    set(value) {\n      this[kOldPrompt] = value;\n    }\n  },\n  _previousKey: {\n    get() {\n      return this[kPreviousKey];\n    },\n    set(value) {\n      this[kPreviousKey] = value;\n    }\n  },\n  _prompt: {\n    get() {\n      return this[kPrompt];\n    },\n    set(value) {\n      this[kPrompt] = value;\n    }\n  },\n  _questionCallback: {\n    get() {\n      return this[kQuestionCallback];\n    },\n    set(value) {\n      this[kQuestionCallback] = value;\n    }\n  },\n  _sawKeyPress: {\n    get() {\n      return this[kSawKeyPress];\n    },\n    set(value) {\n      this[kSawKeyPress] = value;\n    }\n  },\n  _sawReturnAt: {\n    get() {\n      return this[kSawReturnAt];\n    },\n    set(value) {\n      this[kSawReturnAt] = value;\n    }\n  }\n});\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  this.pause();\n  const string = StringPrototypeSlice(this.line, 0, this.cursor);\n  this.completer(string, (err, value) => {\n    this.resume();\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n    this[kTabCompleter](lastKeypressWasTab, value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\nfunction _ttyWriteDumb(s, key) {\n  key = key || {};\n  if (key.name === \"escape\")\n    return;\n  if (this[kSawReturnAt] && key.name !== \"enter\")\n    this[kSawReturnAt] = 0;\n  if (key.ctrl) {\n    if (key.name === \"c\") {\n      if (this.listenerCount(\"SIGINT\") > 0) {\n        this.emit(\"SIGINT\");\n      } else {\n        this.close();\n      }\n      return;\n    } else if (key.name === \"d\") {\n      this.close();\n      return;\n    }\n  }\n  switch (key.name) {\n    case \"return\":\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n    case \"enter\":\n      if (this[kSawReturnAt] === 0 || DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n    default:\n      if (typeof s === \"string\" && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\nmodule.exports = {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor,\n  promises\n};\n}"],["repl.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeConcat,\n  ArrayPrototypeFilter,\n  ArrayPrototypeFindIndex,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypeMap,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  ArrayPrototypeReverse,\n  ArrayPrototypeShift,\n  ArrayPrototypeSlice,\n  ArrayPrototypeSome,\n  ArrayPrototypeSort,\n  ArrayPrototypeSplice,\n  ArrayPrototypeUnshift,\n  Boolean,\n  Error,\n  FunctionPrototypeBind,\n  MathMaxApply,\n  NumberIsNaN,\n  NumberParseFloat,\n  ObjectAssign,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptor,\n  ObjectGetOwnPropertyNames,\n  ObjectGetPrototypeOf,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  Promise,\n  PromiseRace,\n  ReflectApply,\n  RegExp,\n  RegExpPrototypeExec,\n  RegExpPrototypeSymbolReplace,\n  RegExpPrototypeTest,\n  SafeSet,\n  SafeWeakSet,\n  StringPrototypeCharAt,\n  StringPrototypeCodePointAt,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeMatch,\n  StringPrototypeRepeat,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeTrim,\n  StringPrototypeTrimLeft,\n  Symbol,\n  SyntaxError,\n  SyntaxErrorPrototype,\n  globalThis\n} = primordials;\nconst {\n  makeRequireFunction,\n  addBuiltinLibsToObject\n} = require(\"internal/modules/cjs/helpers\");\nconst {\n  isIdentifierStart,\n  isIdentifierChar\n} = require(\"internal/deps/acorn/acorn/dist/acorn\");\nconst {\n  decorateErrorStack,\n  isError,\n  deprecate\n} = require(\"internal/util\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst vm = require(\"vm\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst { Interface } = require(\"readline\");\nconst {\n  commonPrefix\n} = require(\"internal/readline/utils\");\nconst { Console } = require(\"console\");\nconst CJSModule = require(\"internal/modules/cjs/loader\").Module;\nlet _builtinLibs = ArrayPrototypeFilter(CJSModule.builtinModules, (e) => !StringPrototypeStartsWith(e, \"_\") && !StringPrototypeIncludes(e, \"/\"));\nconst nodeSchemeBuiltinLibs = ArrayPrototypeMap(_builtinLibs, (lib) => `node:${lib}`);\nconst domain = require(\"domain\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"repl\", (fn) => {\n  debug = fn;\n});\nconst {\n  codes: {\n    ERR_CANNOT_WATCH_SIGINT,\n    ERR_INVALID_REPL_EVAL_CONFIG,\n    ERR_INVALID_REPL_INPUT,\n    ERR_SCRIPT_EXECUTION_INTERRUPTED\n  },\n  isErrorStackTraceLimitWritable,\n  overrideStackTrace\n} = require(\"internal/errors\");\nconst { sendInspectorCommand } = require(\"internal/util/inspector\");\nconst { getOptionValue } = require(\"internal/options\");\nconst {\n  validateFunction,\n  validateObject\n} = require(\"internal/validators\");\nconst experimentalREPLAwait = getOptionValue(\"--experimental-repl-await\");\nconst pendingDeprecation = getOptionValue(\"--pending-deprecation\");\nconst {\n  REPL_MODE_SLOPPY,\n  REPL_MODE_STRICT,\n  isRecoverableError,\n  kStandaloneREPL,\n  setupPreview,\n  setupReverseSearch\n} = require(\"internal/repl/utils\");\nconst {\n  getOwnNonIndexProperties,\n  propertyFilter: {\n    ALL_PROPERTIES,\n    SKIP_SYMBOLS\n  }\n} = internalBinding(\"util\");\nconst {\n  startSigintWatchdog,\n  stopSigintWatchdog\n} = internalBinding(\"contextify\");\nconst history = require(\"internal/repl/history\");\nconst {\n  extensionFormatMap,\n  legacyExtensionFormatMap\n} = require(\"internal/modules/esm/get_format\");\nlet nextREPLResourceNumber = 1;\nfunction getREPLResourceName() {\n  return `REPL${nextREPLResourceNumber++}`;\n}\nlet processTopLevelAwait;\nconst globalBuiltins = new SafeSet(vm.runInNewContext(\"Object.getOwnPropertyNames(globalThis)\"));\nconst parentModule = module;\nconst domainSet = new SafeWeakSet();\nconst kBufferedCommandSymbol = Symbol(\"bufferedCommand\");\nconst kContextId = Symbol(\"contextId\");\nlet addedNewListener = false;\ntry {\n  module.filename = path.resolve(\"repl\");\n} catch {\n  const dirname = path.dirname(process.execPath);\n  module.filename = path.resolve(dirname, \"repl\");\n}\nmodule.paths = CJSModule._nodeModulePaths(module.filename);\nconst writer = (obj) => inspect(obj, writer.options);\nwriter.options = { ...inspect.defaultOptions, showProxy: true };\nfunction REPLServer(prompt, stream, eval_, useGlobal, ignoreUndefined, replMode) {\n  if (!(this instanceof REPLServer)) {\n    return new REPLServer(prompt, stream, eval_, useGlobal, ignoreUndefined, replMode);\n  }\n  let options;\n  if (prompt !== null && typeof prompt === \"object\") {\n    options = { ...prompt };\n    stream = options.stream || options.socket;\n    eval_ = options.eval;\n    useGlobal = options.useGlobal;\n    ignoreUndefined = options.ignoreUndefined;\n    prompt = options.prompt;\n    replMode = options.replMode;\n  } else {\n    options = {};\n  }\n  if (!options.input && !options.output) {\n    if (!stream) {\n      stream = process;\n    }\n    options.input = stream.stdin || stream;\n    options.output = stream.stdout || stream;\n  }\n  if (options.terminal === void 0) {\n    options.terminal = options.output.isTTY;\n  }\n  options.terminal = !!options.terminal;\n  if (options.terminal && options.useColors === void 0) {\n    if (options.output.hasColors) {\n      options.useColors = options.output.hasColors();\n    } else if (process.env.NODE_DISABLE_COLORS === void 0) {\n      options.useColors = true;\n    }\n  }\n  const preview = options.terminal && (options.preview !== void 0 ? !!options.preview : !eval_);\n  ObjectDefineProperty(this, \"inputStream\", {\n    get: pendingDeprecation ? deprecate(() => this.input, \"repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead\", \"DEP0141\") : () => this.input,\n    set: pendingDeprecation ? deprecate((val) => this.input = val, \"repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead\", \"DEP0141\") : (val) => this.input = val,\n    enumerable: false,\n    configurable: true\n  });\n  ObjectDefineProperty(this, \"outputStream\", {\n    get: pendingDeprecation ? deprecate(() => this.output, \"repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead\", \"DEP0141\") : () => this.output,\n    set: pendingDeprecation ? deprecate((val) => this.output = val, \"repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead\", \"DEP0141\") : (val) => this.output = val,\n    enumerable: false,\n    configurable: true\n  });\n  this.allowBlockingCompletions = !!options.allowBlockingCompletions;\n  this.useColors = !!options.useColors;\n  this._domain = options.domain || domain.create();\n  this.useGlobal = !!useGlobal;\n  this.ignoreUndefined = !!ignoreUndefined;\n  this.replMode = replMode || module.exports.REPL_MODE_SLOPPY;\n  this.underscoreAssigned = false;\n  this.last = void 0;\n  this.underscoreErrAssigned = false;\n  this.lastError = void 0;\n  this.breakEvalOnSigint = !!options.breakEvalOnSigint;\n  this.editorMode = false;\n  this[kContextId] = void 0;\n  if (this.breakEvalOnSigint && eval_) {\n    throw new ERR_INVALID_REPL_EVAL_CONFIG();\n  }\n  if (options[kStandaloneREPL]) {\n    module.exports.repl = this;\n  } else if (!addedNewListener) {\n    process.prependListener(\"newListener\", (event, listener) => {\n      if (event === \"uncaughtException\" && process.domain && listener.name !== \"domainUncaughtExceptionClear\" && domainSet.has(process.domain)) {\n        throw new ERR_INVALID_REPL_INPUT(\"Listeners for `uncaughtException` cannot be used in the REPL\");\n      }\n    });\n    addedNewListener = true;\n  }\n  domainSet.add(this._domain);\n  const savedRegExMatches = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n  const sep = \"\\0\\0\\0\";\n  const regExMatcher = new RegExp(`^${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)$`);\n  eval_ = eval_ || defaultEval;\n  const self = this;\n  const pausedBuffer = [];\n  let paused = false;\n  function pause() {\n    paused = true;\n  }\n  function unpause() {\n    if (!paused)\n      return;\n    paused = false;\n    let entry;\n    const tmpCompletionEnabled = self.isCompletionEnabled;\n    while (entry = ArrayPrototypeShift(pausedBuffer)) {\n      const { 0: type, 1: payload, 2: isCompletionEnabled } = entry;\n      switch (type) {\n        case \"key\": {\n          const { 0: d, 1: key } = payload;\n          self.isCompletionEnabled = isCompletionEnabled;\n          self._ttyWrite(d, key);\n          break;\n        }\n        case \"close\":\n          self.emit(\"exit\");\n          break;\n      }\n      if (paused) {\n        break;\n      }\n    }\n    self.isCompletionEnabled = tmpCompletionEnabled;\n  }\n  function defaultEval(code, context, file, cb) {\n    const asyncESM = require(\"internal/process/esm_loader\");\n    let result, script, wrappedErr;\n    let err = null;\n    let wrappedCmd = false;\n    let awaitPromise = false;\n    const input = code;\n    if (RegExpPrototypeTest(/^\\s*{/, code) && !RegExpPrototypeTest(/;\\s*$/, code)) {\n      code = `(${StringPrototypeTrim(code)})\n`;\n      wrappedCmd = true;\n    }\n    if (experimentalREPLAwait && StringPrototypeIncludes(code, \"await\")) {\n      if (processTopLevelAwait === void 0) {\n        ({ processTopLevelAwait } = require(\"internal/repl/await\"));\n      }\n      try {\n        const potentialWrappedCode = processTopLevelAwait(code);\n        if (potentialWrappedCode !== null) {\n          code = potentialWrappedCode;\n          wrappedCmd = true;\n          awaitPromise = true;\n        }\n      } catch (e) {\n        let recoverableError = false;\n        if (e.name === \"SyntaxError\") {\n          let parentURL;\n          try {\n            const { pathToFileURL } = require(\"url\");\n            parentURL = pathToFileURL(path.join(process.cwd(), \"repl\")).href;\n          } catch {\n          }\n          const fallbackCode = RegExpPrototypeSymbolReplace(/\\bawait\\b/g, code, \"\");\n          try {\n            vm.createScript(fallbackCode, {\n              filename: file,\n              displayErrors: true,\n              importModuleDynamically: async (specifier) => {\n                return asyncESM.esmLoader.import(specifier, parentURL);\n              }\n            });\n          } catch (fallbackError) {\n            if (isRecoverableError(fallbackError, fallbackCode)) {\n              recoverableError = true;\n              err = new Recoverable(e);\n            }\n          }\n        }\n        if (!recoverableError) {\n          decorateErrorStack(e);\n          err = e;\n        }\n      }\n    }\n    if (code === \"\\n\")\n      return cb(null);\n    if (err === null) {\n      let parentURL;\n      try {\n        const { pathToFileURL } = require(\"url\");\n        parentURL = pathToFileURL(path.join(process.cwd(), \"repl\")).href;\n      } catch {\n      }\n      while (true) {\n        try {\n          if (self.replMode === module.exports.REPL_MODE_STRICT && !RegExpPrototypeTest(/^\\s*$/, code)) {\n            code = `'use strict'; void 0;\n${code}`;\n          }\n          script = vm.createScript(code, {\n            filename: file,\n            displayErrors: true,\n            importModuleDynamically: async (specifier) => {\n              return asyncESM.esmLoader.import(specifier, parentURL);\n            }\n          });\n        } catch (e) {\n          debug(\"parse error %j\", code, e);\n          if (wrappedCmd) {\n            wrappedCmd = false;\n            awaitPromise = false;\n            code = input;\n            wrappedErr = e;\n            continue;\n          }\n          const error = wrappedErr || e;\n          if (isRecoverableError(error, code))\n            err = new Recoverable(error);\n          else\n            err = error;\n        }\n        break;\n      }\n    }\n    RegExpPrototypeTest(regExMatcher, ArrayPrototypeJoin(savedRegExMatches, sep));\n    let finished = false;\n    function finishExecution(err2, result2) {\n      if (finished)\n        return;\n      finished = true;\n      for (let idx = 1; idx < savedRegExMatches.length; idx += 1) {\n        savedRegExMatches[idx] = RegExp[`$${idx}`];\n      }\n      cb(err2, result2);\n    }\n    if (!err) {\n      let previouslyInRawMode;\n      if (self.breakEvalOnSigint) {\n        if (!startSigintWatchdog())\n          throw new ERR_CANNOT_WATCH_SIGINT();\n        previouslyInRawMode = self._setRawMode(false);\n      }\n      try {\n        try {\n          const scriptOptions = {\n            displayErrors: false,\n            breakOnSigint: self.breakEvalOnSigint\n          };\n          if (self.useGlobal) {\n            result = script.runInThisContext(scriptOptions);\n          } else {\n            result = script.runInContext(context, scriptOptions);\n          }\n        } finally {\n          if (self.breakEvalOnSigint) {\n            self._setRawMode(previouslyInRawMode);\n            if (stopSigintWatchdog()) {\n              self.emit(\"SIGINT\");\n            }\n          }\n        }\n      } catch (e) {\n        err = e;\n        if (process.domain) {\n          debug(\"not recoverable, send to domain\");\n          process.domain.emit(\"error\", err);\n          process.domain.exit();\n          return;\n        }\n      }\n      if (awaitPromise && !err) {\n        let sigintListener;\n        pause();\n        let promise = result;\n        if (self.breakEvalOnSigint) {\n          const interrupt = new Promise((resolve, reject) => {\n            sigintListener = () => {\n              const tmp = Error.stackTraceLimit;\n              if (isErrorStackTraceLimitWritable())\n                Error.stackTraceLimit = 0;\n              const err2 = new ERR_SCRIPT_EXECUTION_INTERRUPTED();\n              if (isErrorStackTraceLimitWritable())\n                Error.stackTraceLimit = tmp;\n              reject(err2);\n            };\n            prioritizedSigintQueue.add(sigintListener);\n          });\n          promise = PromiseRace([promise, interrupt]);\n        }\n        (async () => {\n          try {\n            const result2 = await promise;\n            finishExecution(null, result2);\n          } catch (err2) {\n            if (err2 && process.domain) {\n              debug(\"not recoverable, send to domain\");\n              process.domain.emit(\"error\", err2);\n              process.domain.exit();\n              return;\n            }\n            finishExecution(err2);\n          } finally {\n            prioritizedSigintQueue.delete(sigintListener);\n            unpause();\n          }\n        })();\n      }\n    }\n    if (!awaitPromise || err) {\n      finishExecution(err, result);\n    }\n  }\n  self.eval = self._domain.bind(eval_);\n  self._domain.on(\"error\", function debugDomainError(e) {\n    debug(\"domain error\");\n    let errStack = \"\";\n    if (typeof e === \"object\" && e !== null) {\n      overrideStackTrace.set(e, (error, stackFrames) => {\n        let frames;\n        if (typeof stackFrames === \"object\") {\n          const idx = ArrayPrototypeFindIndex(ArrayPrototypeReverse(stackFrames), (frame) => frame.getFunctionName() === null);\n          frames = ArrayPrototypeSplice(stackFrames, idx + 1);\n        } else {\n          frames = stackFrames;\n        }\n        if (typeof Error.prepareStackTrace === \"function\") {\n          return Error.prepareStackTrace(error, frames);\n        }\n        ArrayPrototypePush(frames, error);\n        return ArrayPrototypeJoin(ArrayPrototypeReverse(frames), \"\\n    at \");\n      });\n      decorateErrorStack(e);\n      if (e.domainThrown) {\n        delete e.domain;\n        delete e.domainThrown;\n      }\n      if (isError(e)) {\n        if (e.stack) {\n          if (e.name === \"SyntaxError\") {\n            e.stack = StringPrototypeReplace(StringPrototypeReplace(e.stack, /^REPL\\d+:\\d+\\r?\\n/, \"\"), /^\\s+at\\s.*\\n?/gm, \"\");\n            const importErrorStr = \"Cannot use import statement outside a module\";\n            if (StringPrototypeIncludes(e.message, importErrorStr)) {\n              e.message = \"Cannot use import statement inside the Node.js REPL, alternatively use dynamic import\";\n              e.stack = StringPrototypeReplace(e.stack, /SyntaxError:.*\\n/, `SyntaxError: ${e.message}\n`);\n            }\n          } else if (self.replMode === module.exports.REPL_MODE_STRICT) {\n            e.stack = StringPrototypeReplace(e.stack, /(\\s+at\\s+REPL\\d+:)(\\d+)/, (_, pre, line) => pre + (line - 1));\n          }\n        }\n        errStack = self.writer(e);\n        if (errStack[0] === \"[\" && errStack[errStack.length - 1] === \"]\") {\n          errStack = StringPrototypeSlice(errStack, 1, -1);\n        }\n      }\n    }\n    if (!self.underscoreErrAssigned) {\n      self.lastError = e;\n    }\n    if (options[kStandaloneREPL] && process.listenerCount(\"uncaughtException\") !== 0) {\n      process.nextTick(() => {\n        process.emit(\"uncaughtException\", e);\n        self.clearBufferedCommand();\n        self.lines.level = [];\n        self.displayPrompt();\n      });\n    } else {\n      if (errStack === \"\") {\n        errStack = self.writer(e);\n      }\n      const lines = StringPrototypeSplit(errStack, /(?<=\\n)/);\n      let matched = false;\n      errStack = \"\";\n      ArrayPrototypeForEach(lines, (line) => {\n        if (!matched && RegExpPrototypeTest(/^\\[?([A-Z][a-z0-9_]*)*Error/, line)) {\n          errStack += writer.options.breakLength >= line.length ? `Uncaught ${line}` : `Uncaught:\n${line}`;\n          matched = true;\n        } else {\n          errStack += line;\n        }\n      });\n      if (!matched) {\n        const ln = lines.length === 1 ? \" \" : \":\\n\";\n        errStack = `Uncaught${ln}${errStack}`;\n      }\n      errStack += StringPrototypeEndsWith(errStack, \"\\n\") ? \"\" : \"\\n\";\n      self.output.write(errStack);\n      self.clearBufferedCommand();\n      self.lines.level = [];\n      self.displayPrompt();\n    }\n  });\n  self.clearBufferedCommand();\n  function completer(text, cb) {\n    ReflectApply(complete, self, [text, self.editorMode ? self.completeOnEditorMode(cb) : cb]);\n  }\n  ReflectApply(Interface, this, [{\n    input: options.input,\n    output: options.output,\n    completer: options.completer || completer,\n    terminal: options.terminal,\n    historySize: options.historySize,\n    prompt\n  }]);\n  self.resetContext();\n  this.commands = ObjectCreate(null);\n  defineDefaultCommands(this);\n  self.writer = options.writer || module.exports.writer;\n  if (self.writer === writer) {\n    writer.options.colors = self.useColors;\n    if (options[kStandaloneREPL]) {\n      ObjectDefineProperty(inspect, \"replDefaults\", {\n        get() {\n          return writer.options;\n        },\n        set(options2) {\n          validateObject(options2, \"options\");\n          return ObjectAssign(writer.options, options2);\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  function _parseREPLKeyword(keyword, rest) {\n    const cmd = this.commands[keyword];\n    if (cmd) {\n      ReflectApply(cmd.action, this, [rest]);\n      return true;\n    }\n    return false;\n  }\n  self.on(\"close\", function emitExit() {\n    if (paused) {\n      ArrayPrototypePush(pausedBuffer, [\"close\"]);\n      return;\n    }\n    self.emit(\"exit\");\n  });\n  let sawSIGINT = false;\n  let sawCtrlD = false;\n  const prioritizedSigintQueue = new SafeSet();\n  self.on(\"SIGINT\", function onSigInt() {\n    if (prioritizedSigintQueue.size > 0) {\n      for (const task of prioritizedSigintQueue) {\n        task();\n      }\n      return;\n    }\n    const empty = self.line.length === 0;\n    self.clearLine();\n    _turnOffEditorMode(self);\n    const cmd = self[kBufferedCommandSymbol];\n    if (!(cmd && cmd.length > 0) && empty) {\n      if (sawSIGINT) {\n        self.close();\n        sawSIGINT = false;\n        return;\n      }\n      self.output.write(\"(To exit, press Ctrl+C again or Ctrl+D or type .exit)\\n\");\n      sawSIGINT = true;\n    } else {\n      sawSIGINT = false;\n    }\n    self.clearBufferedCommand();\n    self.lines.level = [];\n    self.displayPrompt();\n  });\n  self.on(\"line\", function onLine(cmd) {\n    debug(\"line %j\", cmd);\n    cmd = cmd || \"\";\n    sawSIGINT = false;\n    if (self.editorMode) {\n      self[kBufferedCommandSymbol] += cmd + \"\\n\";\n      const matches = self._sawKeyPress ? StringPrototypeMatch(cmd, /^\\s+/) : null;\n      if (matches) {\n        const prefix = matches[0];\n        self.write(prefix);\n        self.line = prefix;\n        self.cursor = prefix.length;\n      }\n      ReflectApply(_memory, self, [cmd]);\n      return;\n    }\n    const trimmedCmd = StringPrototypeTrim(cmd);\n    if (trimmedCmd) {\n      if (StringPrototypeCharAt(trimmedCmd, 0) === \".\" && StringPrototypeCharAt(trimmedCmd, 1) !== \".\" && NumberIsNaN(NumberParseFloat(trimmedCmd))) {\n        const matches = StringPrototypeMatch(trimmedCmd, /^\\.([^\\s]+)\\s*(.*)$/);\n        const keyword = matches && matches[1];\n        const rest = matches && matches[2];\n        if (ReflectApply(_parseREPLKeyword, self, [keyword, rest]) === true) {\n          return;\n        }\n        if (!self[kBufferedCommandSymbol]) {\n          self.output.write(\"Invalid REPL keyword\\n\");\n          finish(null);\n          return;\n        }\n      }\n    }\n    const evalCmd = self[kBufferedCommandSymbol] + cmd + \"\\n\";\n    debug(\"eval %j\", evalCmd);\n    self.eval(evalCmd, self.context, getREPLResourceName(), finish);\n    function finish(e, ret) {\n      debug(\"finish\", e, ret);\n      ReflectApply(_memory, self, [cmd]);\n      if (e && !self[kBufferedCommandSymbol] && StringPrototypeStartsWith(StringPrototypeTrim(cmd), \"npm \")) {\n        self.output.write(\"npm should be run outside of the Node.js REPL, in your normal shell.\\n(Press Ctrl+D to exit.)\\n\");\n        self.displayPrompt();\n        return;\n      }\n      if (e) {\n        if (e instanceof Recoverable && !sawCtrlD) {\n          self[kBufferedCommandSymbol] += cmd + \"\\n\";\n          self.displayPrompt();\n          return;\n        }\n        self._domain.emit(\"error\", e.err || e);\n      }\n      self.clearBufferedCommand();\n      sawCtrlD = false;\n      if (!e && arguments.length === 2 && (!self.ignoreUndefined || ret !== void 0)) {\n        if (!self.underscoreAssigned) {\n          self.last = ret;\n        }\n        self.output.write(self.writer(ret) + \"\\n\");\n      }\n      if (!e) {\n        self.displayPrompt();\n      }\n    }\n  });\n  self.on(\"SIGCONT\", function onSigCont() {\n    if (self.editorMode) {\n      self.output.write(`${self._initialPrompt}.editor\n`);\n      self.output.write(\"// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)\\n\");\n      self.output.write(`${self[kBufferedCommandSymbol]}\n`);\n      self.prompt(true);\n    } else {\n      self.displayPrompt(true);\n    }\n  });\n  const { reverseSearch } = setupReverseSearch(this);\n  const {\n    clearPreview,\n    showPreview\n  } = setupPreview(this, kContextId, kBufferedCommandSymbol, preview);\n  const ttyWrite = FunctionPrototypeBind(self._ttyWrite, self);\n  self._ttyWrite = (d, key) => {\n    key = key || {};\n    if (paused && !(self.breakEvalOnSigint && key.ctrl && key.name === \"c\")) {\n      ArrayPrototypePush(pausedBuffer, [\"key\", [d, key], self.isCompletionEnabled]);\n      return;\n    }\n    if (!self.editorMode || !self.terminal) {\n      if (key.ctrl && key.name === \"d\" && self.cursor === 0 && self.line.length === 0) {\n        self.clearLine();\n      }\n      clearPreview(key);\n      if (!reverseSearch(d, key)) {\n        ttyWrite(d, key);\n        showPreview();\n      }\n      return;\n    }\n    if (key.ctrl && !key.shift) {\n      switch (key.name) {\n        case \"d\":\n          _turnOffEditorMode(self);\n          sawCtrlD = true;\n          ttyWrite(d, { name: \"return\" });\n          break;\n        case \"n\":\n        case \"p\":\n          break;\n        default:\n          ttyWrite(d, key);\n      }\n    } else {\n      switch (key.name) {\n        case \"up\":\n        case \"down\":\n          break;\n        case \"tab\":\n          self._previousKey = null;\n          ttyWrite(d, key);\n          break;\n        default:\n          ttyWrite(d, key);\n      }\n    }\n  };\n  self.displayPrompt();\n}\nObjectSetPrototypeOf(REPLServer.prototype, Interface.prototype);\nObjectSetPrototypeOf(REPLServer, Interface);\nfunction start(prompt, source, eval_, useGlobal, ignoreUndefined, replMode) {\n  return new REPLServer(prompt, source, eval_, useGlobal, ignoreUndefined, replMode);\n}\nREPLServer.prototype.setupHistory = function setupHistory(historyFile, cb) {\n  history(this, historyFile, cb);\n};\nREPLServer.prototype.clearBufferedCommand = function clearBufferedCommand() {\n  this[kBufferedCommandSymbol] = \"\";\n};\nREPLServer.prototype.close = function close() {\n  if (this.terminal && this._flushing && !this._closingOnFlush) {\n    this._closingOnFlush = true;\n    this.once(\"flushHistory\", () => ReflectApply(Interface.prototype.close, this, []));\n    return;\n  }\n  process.nextTick(() => ReflectApply(Interface.prototype.close, this, []));\n};\nREPLServer.prototype.createContext = function() {\n  let context;\n  if (this.useGlobal) {\n    context = globalThis;\n  } else {\n    sendInspectorCommand((session) => {\n      session.post(\"Runtime.enable\");\n      session.once(\"Runtime.executionContextCreated\", ({ params }) => {\n        this[kContextId] = params.context.id;\n      });\n      context = vm.createContext();\n      session.post(\"Runtime.disable\");\n    }, () => {\n      context = vm.createContext();\n    });\n    ArrayPrototypeForEach(ObjectGetOwnPropertyNames(globalThis), (name) => {\n      if (!globalBuiltins.has(name)) {\n        ObjectDefineProperty(context, name, ObjectGetOwnPropertyDescriptor(globalThis, name));\n      }\n    });\n    context.global = context;\n    const _console = new Console(this.output);\n    ObjectDefineProperty(context, \"console\", {\n      configurable: true,\n      writable: true,\n      value: _console\n    });\n  }\n  const replModule = new CJSModule(\"<repl>\");\n  replModule.paths = CJSModule._resolveLookupPaths(\"<repl>\", parentModule);\n  ObjectDefineProperty(context, \"module\", {\n    configurable: true,\n    writable: true,\n    value: replModule\n  });\n  ObjectDefineProperty(context, \"require\", {\n    configurable: true,\n    writable: true,\n    value: makeRequireFunction(replModule)\n  });\n  addBuiltinLibsToObject(context, \"<REPL>\");\n  return context;\n};\nREPLServer.prototype.resetContext = function() {\n  this.context = this.createContext();\n  this.underscoreAssigned = false;\n  this.underscoreErrAssigned = false;\n  this.lines = [];\n  this.lines.level = [];\n  ObjectDefineProperty(this.context, \"_\", {\n    configurable: true,\n    get: () => this.last,\n    set: (value) => {\n      this.last = value;\n      if (!this.underscoreAssigned) {\n        this.underscoreAssigned = true;\n        this.output.write(\"Expression assignment to _ now disabled.\\n\");\n      }\n    }\n  });\n  ObjectDefineProperty(this.context, \"_error\", {\n    configurable: true,\n    get: () => this.lastError,\n    set: (value) => {\n      this.lastError = value;\n      if (!this.underscoreErrAssigned) {\n        this.underscoreErrAssigned = true;\n        this.output.write(\"Expression assignment to _error now disabled.\\n\");\n      }\n    }\n  });\n  this.emit(\"reset\", this.context);\n};\nREPLServer.prototype.displayPrompt = function(preserveCursor) {\n  let prompt = this._initialPrompt;\n  if (this[kBufferedCommandSymbol].length) {\n    prompt = \"...\";\n    const len = this.lines.level.length ? this.lines.level.length - 1 : 0;\n    const levelInd = StringPrototypeRepeat(\"..\", len);\n    prompt += levelInd + \" \";\n  }\n  ReflectApply(Interface.prototype.setPrompt, this, [prompt]);\n  this.prompt(preserveCursor);\n};\nREPLServer.prototype.setPrompt = function setPrompt(prompt) {\n  this._initialPrompt = prompt;\n  ReflectApply(Interface.prototype.setPrompt, this, [prompt]);\n};\nconst importRE = /\\bimport\\s*\\(\\s*['\"`](([\\w@./:-]+\\/)?(?:[\\w@./:-]*))(?![^'\"`])$/;\nconst requireRE = /\\brequire\\s*\\(\\s*['\"`](([\\w@./:-]+\\/)?(?:[\\w@./:-]*))(?![^'\"`])$/;\nconst fsAutoCompleteRE = /fs(?:\\.promises)?\\.\\s*[a-z][a-zA-Z]+\\(\\s*[\"'](.*)/;\nconst simpleExpressionRE = /(?:[a-zA-Z_$](?:\\w|\\$)*\\??\\.)*[a-zA-Z_$](?:\\w|\\$)*\\??\\.?$/;\nconst versionedFileNamesRe = /-\\d+\\.\\d+/;\nfunction isIdentifier(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const first = StringPrototypeCodePointAt(str, 0);\n  if (!isIdentifierStart(first)) {\n    return false;\n  }\n  const firstLen = first > 65535 ? 2 : 1;\n  for (let i = firstLen; i < str.length; i += 1) {\n    const cp = StringPrototypeCodePointAt(str, i);\n    if (!isIdentifierChar(cp)) {\n      return false;\n    }\n    if (cp > 65535) {\n      i += 1;\n    }\n  }\n  return true;\n}\nfunction isNotLegacyObjectPrototypeMethod(str) {\n  return isIdentifier(str) && str !== \"__defineGetter__\" && str !== \"__defineSetter__\" && str !== \"__lookupGetter__\" && str !== \"__lookupSetter__\";\n}\nfunction filteredOwnPropertyNames(obj) {\n  if (!obj)\n    return [];\n  let isObjectPrototype = false;\n  if (ObjectGetPrototypeOf(obj) === null) {\n    const ctorDescriptor = ObjectGetOwnPropertyDescriptor(obj, \"constructor\");\n    if (ctorDescriptor && ctorDescriptor.value) {\n      const ctorProto = ObjectGetPrototypeOf(ctorDescriptor.value);\n      isObjectPrototype = ctorProto && ObjectGetPrototypeOf(ctorProto) === obj;\n    }\n  }\n  const filter = ALL_PROPERTIES | SKIP_SYMBOLS;\n  return ArrayPrototypeFilter(getOwnNonIndexProperties(obj, filter), isObjectPrototype ? isNotLegacyObjectPrototypeMethod : isIdentifier);\n}\nfunction getGlobalLexicalScopeNames(contextId) {\n  return sendInspectorCommand((session) => {\n    let names = [];\n    session.post(\"Runtime.globalLexicalScopeNames\", {\n      executionContextId: contextId\n    }, (error, result) => {\n      if (!error)\n        names = result.names;\n    });\n    return names;\n  }, () => []);\n}\nREPLServer.prototype.complete = function() {\n  ReflectApply(this.completer, this, arguments);\n};\nfunction gracefulReaddir(...args) {\n  try {\n    return ReflectApply(fs.readdirSync, null, args);\n  } catch {\n  }\n}\nfunction completeFSFunctions(line) {\n  let baseName = \"\";\n  let filePath = StringPrototypeMatch(line, fsAutoCompleteRE)[1];\n  let fileList = gracefulReaddir(filePath, { withFileTypes: true });\n  if (!fileList) {\n    baseName = path.basename(filePath);\n    filePath = path.dirname(filePath);\n    fileList = gracefulReaddir(filePath, { withFileTypes: true }) || [];\n  }\n  const completions = ArrayPrototypeMap(ArrayPrototypeFilter(fileList, (dirent) => StringPrototypeStartsWith(dirent.name, baseName)), (d) => d.name);\n  return [[completions], baseName];\n}\nfunction complete(line, callback) {\n  let completionGroups = [];\n  let completeOn, group;\n  line = StringPrototypeTrimLeft(line);\n  let filter = \"\";\n  if (RegExpPrototypeTest(/^\\s*\\.(\\w*)$/, line)) {\n    ArrayPrototypePush(completionGroups, ObjectKeys(this.commands));\n    completeOn = StringPrototypeMatch(line, /^\\s*\\.(\\w*)$/)[1];\n    if (completeOn.length) {\n      filter = completeOn;\n    }\n  } else if (RegExpPrototypeTest(requireRE, line) && this.allowBlockingCompletions) {\n    const extensions = ObjectKeys(this.context.require.extensions);\n    const indexes = ArrayPrototypeMap(extensions, (extension) => `index${extension}`);\n    ArrayPrototypePush(indexes, \"package.json\", \"index\");\n    const match = StringPrototypeMatch(line, requireRE);\n    completeOn = match[1];\n    const subdir = match[2] || \"\";\n    filter = completeOn;\n    group = [];\n    let paths = [];\n    if (completeOn === \".\") {\n      group = [\"./\", \"../\"];\n    } else if (completeOn === \"..\") {\n      group = [\"../\"];\n    } else if (RegExpPrototypeTest(/^\\.\\.?\\//, completeOn)) {\n      paths = [process.cwd()];\n    } else {\n      paths = ArrayPrototypeConcat(module.paths, CJSModule.globalPaths);\n    }\n    ArrayPrototypeForEach(paths, (dir) => {\n      dir = path.resolve(dir, subdir);\n      const dirents = gracefulReaddir(dir, { withFileTypes: true }) || [];\n      ArrayPrototypeForEach(dirents, (dirent) => {\n        if (RegExpPrototypeTest(versionedFileNamesRe, dirent.name) || dirent.name === \".npm\") {\n          return;\n        }\n        const extension = path.extname(dirent.name);\n        const base = StringPrototypeSlice(dirent.name, 0, -extension.length);\n        if (!dirent.isDirectory()) {\n          if (StringPrototypeIncludes(extensions, extension) && (!subdir || base !== \"index\")) {\n            ArrayPrototypePush(group, `${subdir}${base}`);\n          }\n          return;\n        }\n        ArrayPrototypePush(group, `${subdir}${dirent.name}/`);\n        const absolute = path.resolve(dir, dirent.name);\n        if (ArrayPrototypeSome(gracefulReaddir(absolute) || [], (subfile) => ArrayPrototypeIncludes(indexes, subfile))) {\n          ArrayPrototypePush(group, `${subdir}${dirent.name}`);\n        }\n      });\n    });\n    if (group.length) {\n      ArrayPrototypePush(completionGroups, group);\n    }\n    if (!subdir) {\n      ArrayPrototypePush(completionGroups, _builtinLibs, nodeSchemeBuiltinLibs);\n    }\n  } else if (RegExpPrototypeTest(importRE, line) && this.allowBlockingCompletions) {\n    const extensions = ObjectKeys(getOptionValue(\"--experimental-specifier-resolution\") === \"node\" ? legacyExtensionFormatMap : extensionFormatMap);\n    const indexes = ArrayPrototypeMap(extensions, (ext) => `index${ext}`);\n    ArrayPrototypePush(indexes, \"package.json\");\n    const match = StringPrototypeMatch(line, importRE);\n    completeOn = match[1];\n    const subdir = match[2] || \"\";\n    filter = completeOn;\n    group = [];\n    let paths = [];\n    if (completeOn === \".\") {\n      group = [\"./\", \"../\"];\n    } else if (completeOn === \"..\") {\n      group = [\"../\"];\n    } else if (RegExpPrototypeTest(/^\\.\\.?\\//, completeOn)) {\n      paths = [process.cwd()];\n    } else {\n      paths = ArrayPrototypeSlice(module.paths);\n    }\n    ArrayPrototypeForEach(paths, (dir) => {\n      dir = path.resolve(dir, subdir);\n      const isInNodeModules = path.basename(dir) === \"node_modules\";\n      const dirents = gracefulReaddir(dir, { withFileTypes: true }) || [];\n      ArrayPrototypeForEach(dirents, (dirent) => {\n        const { name } = dirent;\n        if (RegExpPrototypeTest(versionedFileNamesRe, name) || name === \".npm\") {\n          return;\n        }\n        if (!dirent.isDirectory()) {\n          const extension = path.extname(name);\n          if (StringPrototypeIncludes(extensions, extension)) {\n            ArrayPrototypePush(group, `${subdir}${name}`);\n          }\n          return;\n        }\n        ArrayPrototypePush(group, `${subdir}${name}/`);\n        if (!subdir && isInNodeModules) {\n          const absolute = path.resolve(dir, name);\n          const subfiles = gracefulReaddir(absolute) || [];\n          if (ArrayPrototypeSome(subfiles, (subfile) => {\n            return ArrayPrototypeIncludes(indexes, subfile);\n          })) {\n            ArrayPrototypePush(group, `${subdir}${name}`);\n          }\n        }\n      });\n    });\n    if (group.length) {\n      ArrayPrototypePush(completionGroups, group);\n    }\n    if (!subdir) {\n      ArrayPrototypePush(completionGroups, _builtinLibs, nodeSchemeBuiltinLibs);\n    }\n  } else if (RegExpPrototypeTest(fsAutoCompleteRE, line) && this.allowBlockingCompletions) {\n    ({ 0: completionGroups, 1: completeOn } = completeFSFunctions(line));\n  } else if (line.length === 0 || RegExpPrototypeTest(/\\w|\\.|\\$/, line[line.length - 1])) {\n    const { 0: match } = RegExpPrototypeExec(simpleExpressionRE, line) || [\"\"];\n    if (line.length !== 0 && !match) {\n      completionGroupsLoaded();\n      return;\n    }\n    let expr = \"\";\n    completeOn = match;\n    if (StringPrototypeEndsWith(line, \".\")) {\n      expr = StringPrototypeSlice(match, 0, -1);\n    } else if (line.length !== 0) {\n      const bits = StringPrototypeSplit(match, \".\");\n      filter = ArrayPrototypePop(bits);\n      expr = ArrayPrototypeJoin(bits, \".\");\n    }\n    if (!expr) {\n      ArrayPrototypePush(completionGroups, getGlobalLexicalScopeNames(this[kContextId]));\n      let contextProto = this.context;\n      while (contextProto = ObjectGetPrototypeOf(contextProto)) {\n        ArrayPrototypePush(completionGroups, filteredOwnPropertyNames(contextProto));\n      }\n      const contextOwnNames = filteredOwnPropertyNames(this.context);\n      if (!this.useGlobal) {\n        ArrayPrototypePush(contextOwnNames, ...globalBuiltins);\n      }\n      ArrayPrototypePush(completionGroups, contextOwnNames);\n      if (filter !== \"\")\n        addCommonWords(completionGroups);\n      completionGroupsLoaded();\n      return;\n    }\n    let chaining = \".\";\n    if (StringPrototypeEndsWith(expr, \"?\")) {\n      expr = StringPrototypeSlice(expr, 0, -1);\n      chaining = \"?.\";\n    }\n    const memberGroups = [];\n    const evalExpr = `try { ${expr} } catch {}`;\n    this.eval(evalExpr, this.context, getREPLResourceName(), (e, obj) => {\n      try {\n        let p;\n        if (typeof obj === \"object\" && obj !== null || typeof obj === \"function\") {\n          memberGroups.push(filteredOwnPropertyNames(obj));\n          p = ObjectGetPrototypeOf(obj);\n        } else {\n          p = obj.constructor ? obj.constructor.prototype : null;\n        }\n        let sentinel = 5;\n        while (p !== null && sentinel-- !== 0) {\n          memberGroups.push(filteredOwnPropertyNames(p));\n          p = ObjectGetPrototypeOf(p);\n        }\n      } catch {\n      }\n      if (memberGroups.length) {\n        expr += chaining;\n        ArrayPrototypeForEach(memberGroups, (group2) => {\n          ArrayPrototypePush(completionGroups, ArrayPrototypeMap(group2, (member) => `${expr}${member}`));\n        });\n        if (filter) {\n          filter = `${expr}${filter}`;\n        }\n      }\n      completionGroupsLoaded();\n    });\n    return;\n  }\n  return completionGroupsLoaded();\n  function completionGroupsLoaded() {\n    if (completionGroups.length && filter) {\n      const newCompletionGroups = [];\n      ArrayPrototypeForEach(completionGroups, (group2) => {\n        const filteredGroup = ArrayPrototypeFilter(group2, (str) => StringPrototypeStartsWith(str, filter));\n        if (filteredGroup.length) {\n          ArrayPrototypePush(newCompletionGroups, filteredGroup);\n        }\n      });\n      completionGroups = newCompletionGroups;\n    }\n    const completions = [];\n    const uniqueSet = new SafeSet();\n    uniqueSet.add(\"\");\n    ArrayPrototypeForEach(completionGroups, (group2) => {\n      ArrayPrototypeSort(group2, (a, b) => b > a ? 1 : -1);\n      const setSize = uniqueSet.size;\n      ArrayPrototypeForEach(group2, (entry) => {\n        if (!uniqueSet.has(entry)) {\n          ArrayPrototypeUnshift(completions, entry);\n          uniqueSet.add(entry);\n        }\n      });\n      if (uniqueSet.size !== setSize) {\n        ArrayPrototypeUnshift(completions, \"\");\n      }\n    });\n    if (completions[0] === \"\") {\n      ArrayPrototypeShift(completions);\n    }\n    callback(null, [completions, completeOn]);\n  }\n}\nREPLServer.prototype.completeOnEditorMode = (callback) => (err, results) => {\n  if (err)\n    return callback(err);\n  const { 0: completions, 1: completeOn = \"\" } = results;\n  let result = ArrayPrototypeFilter(completions, Boolean);\n  if (completeOn && result.length !== 0) {\n    result = [commonPrefix(result)];\n  }\n  callback(null, [result, completeOn]);\n};\nREPLServer.prototype.defineCommand = function(keyword, cmd) {\n  if (typeof cmd === \"function\") {\n    cmd = { action: cmd };\n  } else {\n    validateFunction(cmd.action, \"cmd.action\");\n  }\n  this.commands[keyword] = cmd;\n};\nfunction _memory(cmd) {\n  const self = this;\n  self.lines = self.lines || [];\n  self.lines.level = self.lines.level || [];\n  if (cmd) {\n    const len = self.lines.level.length ? self.lines.level.length - 1 : 0;\n    ArrayPrototypePush(self.lines, StringPrototypeRepeat(\"  \", len) + cmd);\n  } else {\n    ArrayPrototypePush(self.lines, \"\");\n  }\n  if (!cmd) {\n    self.lines.level = [];\n    return;\n  }\n  let dw = StringPrototypeMatch(cmd, /[{(]/g);\n  let up = StringPrototypeMatch(cmd, /[})]/g);\n  up = up ? up.length : 0;\n  dw = dw ? dw.length : 0;\n  let depth = dw - up;\n  if (depth) {\n    (function workIt() {\n      if (depth > 0) {\n        ArrayPrototypePush(self.lines.level, {\n          line: self.lines.length - 1,\n          depth\n        });\n      } else if (depth < 0) {\n        const curr = ArrayPrototypePop(self.lines.level);\n        if (curr) {\n          const tmp = curr.depth + depth;\n          if (tmp < 0) {\n            depth += curr.depth;\n            workIt();\n          } else if (tmp > 0) {\n            curr.depth += depth;\n            ArrayPrototypePush(self.lines.level, curr);\n          }\n        }\n      }\n    })();\n  }\n}\nfunction addCommonWords(completionGroups) {\n  ArrayPrototypePush(completionGroups, [\n    \"async\",\n    \"await\",\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"else\",\n    \"export\",\n    \"false\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"let\",\n    \"new\",\n    \"null\",\n    \"return\",\n    \"switch\",\n    \"this\",\n    \"throw\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"while\",\n    \"with\",\n    \"yield\"\n  ]);\n}\nfunction _turnOnEditorMode(repl) {\n  repl.editorMode = true;\n  ReflectApply(Interface.prototype.setPrompt, repl, [\"\"]);\n}\nfunction _turnOffEditorMode(repl) {\n  repl.editorMode = false;\n  repl.setPrompt(repl._initialPrompt);\n}\nfunction defineDefaultCommands(repl) {\n  repl.defineCommand(\"break\", {\n    help: \"Sometimes you get stuck, this gets you out\",\n    action: function() {\n      this.clearBufferedCommand();\n      this.displayPrompt();\n    }\n  });\n  let clearMessage;\n  if (repl.useGlobal) {\n    clearMessage = \"Alias for .break\";\n  } else {\n    clearMessage = \"Break, and also clear the local context\";\n  }\n  repl.defineCommand(\"clear\", {\n    help: clearMessage,\n    action: function() {\n      this.clearBufferedCommand();\n      if (!this.useGlobal) {\n        this.output.write(\"Clearing context...\\n\");\n        this.resetContext();\n      }\n      this.displayPrompt();\n    }\n  });\n  repl.defineCommand(\"exit\", {\n    help: \"Exit the REPL\",\n    action: function() {\n      this.close();\n    }\n  });\n  repl.defineCommand(\"help\", {\n    help: \"Print this help message\",\n    action: function() {\n      const names = ArrayPrototypeSort(ObjectKeys(this.commands));\n      const longestNameLength = MathMaxApply(ArrayPrototypeMap(names, (name) => name.length));\n      ArrayPrototypeForEach(names, (name) => {\n        const cmd = this.commands[name];\n        const spaces = StringPrototypeRepeat(\" \", longestNameLength - name.length + 3);\n        const line = `.${name}${cmd.help ? spaces + cmd.help : \"\"}\n`;\n        this.output.write(line);\n      });\n      this.output.write(\"\\nPress Ctrl+C to abort current expression, Ctrl+D to exit the REPL\\n\");\n      this.displayPrompt();\n    }\n  });\n  repl.defineCommand(\"save\", {\n    help: \"Save all evaluated commands in this REPL session to a file\",\n    action: function(file) {\n      try {\n        fs.writeFileSync(file, ArrayPrototypeJoin(this.lines, \"\\n\"));\n        this.output.write(`Session saved to: ${file}\n`);\n      } catch {\n        this.output.write(`Failed to save: ${file}\n`);\n      }\n      this.displayPrompt();\n    }\n  });\n  repl.defineCommand(\"load\", {\n    help: \"Load JS from a file into the REPL session\",\n    action: function(file) {\n      try {\n        const stats = fs.statSync(file);\n        if (stats && stats.isFile()) {\n          _turnOnEditorMode(this);\n          const data = fs.readFileSync(file, \"utf8\");\n          this.write(data);\n          _turnOffEditorMode(this);\n          this.write(\"\\n\");\n        } else {\n          this.output.write(`Failed to load: ${file} is not a valid file\n`);\n        }\n      } catch {\n        this.output.write(`Failed to load: ${file}\n`);\n      }\n      this.displayPrompt();\n    }\n  });\n  if (repl.terminal) {\n    repl.defineCommand(\"editor\", {\n      help: \"Enter editor mode\",\n      action() {\n        _turnOnEditorMode(this);\n        this.output.write(\"// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)\\n\");\n      }\n    });\n  }\n}\nfunction Recoverable(err) {\n  this.err = err;\n}\nObjectSetPrototypeOf(Recoverable.prototype, SyntaxErrorPrototype);\nObjectSetPrototypeOf(Recoverable, SyntaxError);\nmodule.exports = {\n  start,\n  writer,\n  REPLServer,\n  REPL_MODE_SLOPPY,\n  REPL_MODE_STRICT,\n  Recoverable\n};\nObjectDefineProperty(module.exports, \"builtinModules\", {\n  get: () => _builtinLibs,\n  set: (val) => _builtinLibs = val,\n  enumerable: true,\n  configurable: true\n});\nObjectDefineProperty(module.exports, \"_builtinLibs\", {\n  get: pendingDeprecation ? deprecate(() => _builtinLibs, \"repl._builtinLibs is deprecated. Check module.builtinModules instead\", \"DEP0142\") : () => _builtinLibs,\n  set: pendingDeprecation ? deprecate((val) => _builtinLibs = val, \"repl._builtinLibs is deprecated. Check module.builtinModules instead\", \"DEP0142\") : (val) => _builtinLibs = val,\n  enumerable: false,\n  configurable: true\n});\n}"],["stream.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ObjectDefineProperty\n} = primordials;\nconst {\n  promisify: { custom: customPromisify }\n} = require(\"internal/util\");\nconst compose = require(\"internal/streams/compose\");\nconst { pipeline } = require(\"internal/streams/pipeline\");\nconst { destroyer } = require(\"internal/streams/destroy\");\nconst eos = require(\"internal/streams/end-of-stream\");\nconst internalBuffer = require(\"internal/buffer\");\nconst promises = require(\"stream/promises\");\nconst Stream = module.exports = require(\"internal/streams/legacy\").Stream;\nStream.isDisturbed = require(\"internal/streams/utils\").isDisturbed;\nStream.Readable = require(\"internal/streams/readable\");\nStream.Writable = require(\"internal/streams/writable\");\nStream.Duplex = require(\"internal/streams/duplex\");\nStream.Transform = require(\"internal/streams/transform\");\nStream.PassThrough = require(\"internal/streams/passthrough\");\nStream.pipeline = pipeline;\nconst { addAbortSignal } = require(\"internal/streams/add-abort-signal\");\nStream.addAbortSignal = addAbortSignal;\nStream.finished = eos;\nStream.destroy = destroyer;\nStream.compose = compose;\nObjectDefineProperty(Stream, \"promises\", {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return promises;\n  }\n});\nObjectDefineProperty(pipeline, customPromisify, {\n  enumerable: true,\n  get() {\n    return promises.pipeline;\n  }\n});\nObjectDefineProperty(eos, customPromisify, {\n  enumerable: true,\n  get() {\n    return promises.finished;\n  }\n});\nStream.Stream = Stream;\nStream._isUint8Array = require(\"internal/util/types\").isUint8Array;\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n  return new internalBuffer.FastBuffer(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n};\n}"],["string_decoder.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBufferIsView,\n  ObjectDefineProperties,\n  Symbol,\n  TypedArrayPrototypeSubarray\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst {\n  kIncompleteCharactersStart,\n  kIncompleteCharactersEnd,\n  kMissingBytes,\n  kBufferedBytes,\n  kEncodingField,\n  kSize,\n  decode,\n  flush,\n  encodings\n} = internalBinding(\"string_decoder\");\nconst internalUtil = require(\"internal/util\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_UNKNOWN_ENCODING\n} = require(\"internal/errors\").codes;\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\nconst kNativeDecoder = Symbol(\"kNativeDecoder\");\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (nenc === void 0) {\n    if (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc))\n      throw new ERR_UNKNOWN_ENCODING(enc);\n    return enc;\n  }\n  return nenc;\n}\nconst encodingsMap = {};\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  this[kNativeDecoder] = Buffer.alloc(kSize);\n  this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n}\nStringDecoder.prototype.write = function write(buf) {\n  if (typeof buf === \"string\")\n    return buf;\n  if (!ArrayBufferIsView(buf))\n    throw new ERR_INVALID_ARG_TYPE(\"buf\", [\"Buffer\", \"TypedArray\", \"DataView\"], buf);\n  return decode(this[kNativeDecoder], buf);\n};\nStringDecoder.prototype.end = function end(buf) {\n  let ret = \"\";\n  if (buf !== void 0)\n    ret = this.write(buf);\n  if (this[kNativeDecoder][kBufferedBytes] > 0)\n    ret += flush(this[kNativeDecoder]);\n  return ret;\n};\nStringDecoder.prototype.text = function text(buf, offset) {\n  this[kNativeDecoder][kMissingBytes] = 0;\n  this[kNativeDecoder][kBufferedBytes] = 0;\n  return this.write(buf.slice(offset));\n};\nObjectDefineProperties(StringDecoder.prototype, {\n  lastChar: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return TypedArrayPrototypeSubarray(this[kNativeDecoder], kIncompleteCharactersStart, kIncompleteCharactersEnd);\n    }\n  },\n  lastNeed: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this[kNativeDecoder][kMissingBytes];\n    }\n  },\n  lastTotal: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this[kNativeDecoder][kBufferedBytes] + this[kNativeDecoder][kMissingBytes];\n    }\n  }\n});\nexports.StringDecoder = StringDecoder;\n}"],["sys.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nmodule.exports = require(\"util\");\nprocess.emitWarning(\"sys is deprecated. Use util instead.\", \"DeprecationWarning\", \"DEP0025\");\n}"],["timers.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  MathTrunc,\n  ObjectCreate,\n  ObjectDefineProperty,\n  SymbolToPrimitive\n} = primordials;\nconst {\n  immediateInfo,\n  toggleImmediateRef\n} = internalBinding(\"timers\");\nconst L = require(\"internal/linkedlist\");\nconst {\n  async_id_symbol,\n  Timeout,\n  Immediate,\n  decRefCount,\n  immediateInfoFields: {\n    kCount,\n    kRefCount\n  },\n  kRefed,\n  kHasPrimitive,\n  getTimerDuration,\n  timerListMap,\n  timerListQueue,\n  immediateQueue,\n  active,\n  unrefActive,\n  insert\n} = require(\"internal/timers\");\nconst {\n  promisify: { custom: customPromisify },\n  deprecate\n} = require(\"internal/util\");\nlet debug = require(\"internal/util/debuglog\").debuglog(\"timer\", (fn) => {\n  debug = fn;\n});\nconst { validateCallback } = require(\"internal/validators\");\nlet timersPromises;\nconst {\n  destroyHooksExist,\n  emitDestroy\n} = require(\"internal/async_hooks\");\nconst knownTimersById = ObjectCreate(null);\nfunction unenroll(item) {\n  if (item._destroyed)\n    return;\n  item._destroyed = true;\n  if (item[kHasPrimitive])\n    delete knownTimersById[item[async_id_symbol]];\n  if (destroyHooksExist() && item[async_id_symbol] !== void 0)\n    emitDestroy(item[async_id_symbol]);\n  L.remove(item);\n  if (item[kRefed]) {\n    const msecs = MathTrunc(item._idleTimeout);\n    const list = timerListMap[msecs];\n    if (list !== void 0 && L.isEmpty(list)) {\n      debug(\"unenroll: list empty\");\n      timerListQueue.removeAt(list.priorityQueuePosition);\n      delete timerListMap[list.msecs];\n    }\n    decRefCount();\n  }\n  item._idleTimeout = -1;\n}\nfunction enroll(item, msecs) {\n  msecs = getTimerDuration(msecs, \"msecs\");\n  if (item._idleNext)\n    unenroll(item);\n  L.init(item);\n  item._idleTimeout = msecs;\n}\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  validateCallback(callback);\n  let i, args;\n  switch (arguments.length) {\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n  const timeout = new Timeout(callback, after, args, false, true);\n  insert(timeout, timeout._idleTimeout);\n  return timeout;\n}\nObjectDefineProperty(setTimeout, customPromisify, {\n  enumerable: true,\n  get() {\n    if (!timersPromises)\n      timersPromises = require(\"timers/promises\");\n    return timersPromises.setTimeout;\n  }\n});\nfunction clearTimeout(timer) {\n  if (timer && timer._onTimeout) {\n    timer._onTimeout = null;\n    unenroll(timer);\n    return;\n  }\n  if (typeof timer === \"number\" || typeof timer === \"string\") {\n    const timerInstance = knownTimersById[timer];\n    if (timerInstance !== void 0) {\n      timerInstance._onTimeout = null;\n      unenroll(timerInstance);\n    }\n  }\n}\nfunction setInterval(callback, repeat, arg1, arg2, arg3) {\n  validateCallback(callback);\n  let i, args;\n  switch (arguments.length) {\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n  const timeout = new Timeout(callback, repeat, args, true, true);\n  insert(timeout, timeout._idleTimeout);\n  return timeout;\n}\nfunction clearInterval(timer) {\n  clearTimeout(timer);\n}\nTimeout.prototype.close = function() {\n  clearTimeout(this);\n  return this;\n};\nTimeout.prototype[SymbolToPrimitive] = function() {\n  const id = this[async_id_symbol];\n  if (!this[kHasPrimitive]) {\n    this[kHasPrimitive] = true;\n    knownTimersById[id] = this;\n  }\n  return id;\n};\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  validateCallback(callback);\n  let i, args;\n  switch (arguments.length) {\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n  return new Immediate(callback, args);\n}\nObjectDefineProperty(setImmediate, customPromisify, {\n  enumerable: true,\n  get() {\n    if (!timersPromises)\n      timersPromises = require(\"timers/promises\");\n    return timersPromises.setImmediate;\n  }\n});\nfunction clearImmediate(immediate) {\n  if (!immediate || immediate._destroyed)\n    return;\n  immediateInfo[kCount]--;\n  immediate._destroyed = true;\n  if (immediate[kRefed] && --immediateInfo[kRefCount] === 0)\n    toggleImmediateRef(false);\n  immediate[kRefed] = null;\n  if (destroyHooksExist() && immediate[async_id_symbol] !== void 0) {\n    emitDestroy(immediate[async_id_symbol]);\n  }\n  immediate._onImmediate = null;\n  immediateQueue.remove(immediate);\n}\nmodule.exports = {\n  setTimeout,\n  clearTimeout,\n  setImmediate,\n  clearImmediate,\n  setInterval,\n  clearInterval,\n  _unrefActive: deprecate(unrefActive, \"timers._unrefActive() is deprecated. Please use timeout.refresh() instead.\", \"DEP0127\"),\n  active: deprecate(active, \"timers.active() is deprecated. Please use timeout.refresh() instead.\", \"DEP0126\"),\n  unenroll: deprecate(unenroll, \"timers.unenroll() is deprecated. Please use clearTimeout instead.\", \"DEP0096\"),\n  enroll: deprecate(enroll, \"timers.enroll() is deprecated. Please use setTimeout instead.\", \"DEP0095\")\n};\n}"],["tls.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayIsArray,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  ArrayPrototypeReduce,\n  ArrayPrototypeSome,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  RegExpPrototypeTest,\n  StringFromCharCode,\n  StringPrototypeCharCodeAt,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith\n} = primordials;\nconst {\n  ERR_TLS_CERT_ALTNAME_INVALID,\n  ERR_OUT_OF_RANGE\n} = require(\"internal/errors\").codes;\nconst internalUtil = require(\"internal/util\");\ninternalUtil.assertCrypto();\nconst { isArrayBufferView } = require(\"internal/util/types\");\nconst net = require(\"net\");\nconst { getOptionValue } = require(\"internal/options\");\nconst { getRootCertificates, getSSLCiphers } = internalBinding(\"crypto\");\nconst { Buffer } = require(\"buffer\");\nconst { URL } = require(\"internal/url\");\nconst { canonicalizeIP } = internalBinding(\"cares_wrap\");\nconst _tls_common = require(\"_tls_common\");\nconst _tls_wrap = require(\"_tls_wrap\");\nconst { createSecurePair } = require(\"internal/tls/secure-pair\");\nconst { parseCertString } = require(\"internal/tls/parse-cert-string\");\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\nexports.DEFAULT_CIPHERS = getOptionValue(\"--tls-cipher-list\");\nexports.DEFAULT_ECDH_CURVE = \"auto\";\nif (getOptionValue(\"--tls-min-v1.0\"))\n  exports.DEFAULT_MIN_VERSION = \"TLSv1\";\nelse if (getOptionValue(\"--tls-min-v1.1\"))\n  exports.DEFAULT_MIN_VERSION = \"TLSv1.1\";\nelse if (getOptionValue(\"--tls-min-v1.2\"))\n  exports.DEFAULT_MIN_VERSION = \"TLSv1.2\";\nelse if (getOptionValue(\"--tls-min-v1.3\"))\n  exports.DEFAULT_MIN_VERSION = \"TLSv1.3\";\nelse\n  exports.DEFAULT_MIN_VERSION = \"TLSv1.2\";\nif (getOptionValue(\"--tls-max-v1.3\"))\n  exports.DEFAULT_MAX_VERSION = \"TLSv1.3\";\nelse if (getOptionValue(\"--tls-max-v1.2\"))\n  exports.DEFAULT_MAX_VERSION = \"TLSv1.2\";\nelse\n  exports.DEFAULT_MAX_VERSION = \"TLSv1.3\";\nexports.getCiphers = internalUtil.cachedResult(() => internalUtil.filterDuplicateStrings(getSSLCiphers(), true));\nlet rootCertificates;\nfunction cacheRootCertificates() {\n  rootCertificates = ObjectFreeze(getRootCertificates());\n}\nObjectDefineProperty(exports, \"rootCertificates\", {\n  configurable: false,\n  enumerable: true,\n  get: () => {\n    if (!rootCertificates)\n      cacheRootCertificates();\n    return rootCertificates;\n  }\n});\nfunction convertProtocols(protocols) {\n  const lens = new Array(protocols.length);\n  const buff = Buffer.allocUnsafe(ArrayPrototypeReduce(protocols, (p, c, i) => {\n    const len = Buffer.byteLength(c);\n    if (len > 255) {\n      throw new ERR_OUT_OF_RANGE(`The byte length of the protocol at index ${i} exceeds the maximum length.`, \"<= 255\", len, true);\n    }\n    lens[i] = len;\n    return p + 1 + len;\n  }, 0));\n  let offset = 0;\n  for (let i = 0, c = protocols.length; i < c; i++) {\n    buff[offset++] = lens[i];\n    buff.write(protocols[i], offset);\n    offset += lens[i];\n  }\n  return buff;\n}\nexports.convertALPNProtocols = function convertALPNProtocols(protocols, out) {\n  if (ArrayIsArray(protocols)) {\n    out.ALPNProtocols = convertProtocols(protocols);\n  } else if (isArrayBufferView(protocols)) {\n    out.ALPNProtocols = Buffer.from(protocols);\n  }\n};\nfunction unfqdn(host) {\n  return StringPrototypeReplace(host, /[.]$/, \"\");\n}\nfunction toLowerCase(c) {\n  return StringFromCharCode(32 + StringPrototypeCharCodeAt(c, 0));\n}\nfunction splitHost(host) {\n  return StringPrototypeSplit(StringPrototypeReplace(unfqdn(host), /[A-Z]/g, toLowerCase), \".\");\n}\nfunction check(hostParts, pattern, wildcards) {\n  if (!pattern)\n    return false;\n  const patternParts = splitHost(pattern);\n  if (hostParts.length !== patternParts.length)\n    return false;\n  if (ArrayPrototypeIncludes(patternParts, \"\"))\n    return false;\n  const isBad = (s) => RegExpPrototypeTest(/[^\\u0021-\\u007F]/u, s);\n  if (ArrayPrototypeSome(patternParts, isBad))\n    return false;\n  for (let i = hostParts.length - 1; i > 0; i -= 1) {\n    if (hostParts[i] !== patternParts[i])\n      return false;\n  }\n  const hostSubdomain = hostParts[0];\n  const patternSubdomain = patternParts[0];\n  const patternSubdomainParts = StringPrototypeSplit(patternSubdomain, \"*\");\n  if (patternSubdomainParts.length === 1 || StringPrototypeIncludes(patternSubdomain, \"xn--\"))\n    return hostSubdomain === patternSubdomain;\n  if (!wildcards)\n    return false;\n  if (patternSubdomainParts.length > 2)\n    return false;\n  if (patternParts.length <= 2)\n    return false;\n  const { 0: prefix, 1: suffix } = patternSubdomainParts;\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return false;\n  if (!StringPrototypeStartsWith(hostSubdomain, prefix))\n    return false;\n  if (!StringPrototypeEndsWith(hostSubdomain, suffix))\n    return false;\n  return true;\n}\nexports.checkServerIdentity = function checkServerIdentity(hostname, cert) {\n  const subject = cert.subject;\n  const altNames = cert.subjectaltname;\n  const dnsNames = [];\n  const uriNames = [];\n  const ips = [];\n  hostname = \"\" + hostname;\n  if (altNames) {\n    const splitAltNames = StringPrototypeSplit(altNames, \", \");\n    ArrayPrototypeForEach(splitAltNames, (name) => {\n      if (StringPrototypeStartsWith(name, \"DNS:\")) {\n        ArrayPrototypePush(dnsNames, StringPrototypeSlice(name, 4));\n      } else if (StringPrototypeStartsWith(name, \"URI:\")) {\n        const uri = new URL(StringPrototypeSlice(name, 4));\n        ArrayPrototypePush(uriNames, uri.hostname);\n      } else if (StringPrototypeStartsWith(name, \"IP Address:\")) {\n        ArrayPrototypePush(ips, canonicalizeIP(StringPrototypeSlice(name, 11)));\n      }\n    });\n  }\n  let valid = false;\n  let reason = \"Unknown reason\";\n  const hasAltNames = dnsNames.length > 0 || ips.length > 0 || uriNames.length > 0;\n  hostname = unfqdn(hostname);\n  if (net.isIP(hostname)) {\n    valid = ArrayPrototypeIncludes(ips, canonicalizeIP(hostname));\n    if (!valid)\n      reason = `IP: ${hostname} is not in the cert's list: ` + ArrayPrototypeJoin(ips, \", \");\n  } else if (hasAltNames || subject) {\n    const hostParts = splitHost(hostname);\n    const wildcard = (pattern) => check(hostParts, pattern, true);\n    if (hasAltNames) {\n      const noWildcard = (pattern) => check(hostParts, pattern, false);\n      valid = ArrayPrototypeSome(dnsNames, wildcard) || ArrayPrototypeSome(uriNames, noWildcard);\n      if (!valid)\n        reason = `Host: ${hostname}. is not in the cert's altnames: ${altNames}`;\n    } else {\n      const cn = subject.CN;\n      if (ArrayIsArray(cn))\n        valid = ArrayPrototypeSome(cn, wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n      if (!valid)\n        reason = `Host: ${hostname}. is not cert's CN: ${cn}`;\n    }\n  } else {\n    reason = \"Cert is empty\";\n  }\n  if (!valid) {\n    return new ERR_TLS_CERT_ALTNAME_INVALID(reason, hostname, cert);\n  }\n};\nexports.createSecureContext = _tls_common.createSecureContext;\nexports.SecureContext = _tls_common.SecureContext;\nexports.TLSSocket = _tls_wrap.TLSSocket;\nexports.Server = _tls_wrap.Server;\nexports.createServer = _tls_wrap.createServer;\nexports.connect = _tls_wrap.connect;\nexports.parseCertString = internalUtil.deprecate(parseCertString, \"tls.parseCertString() is deprecated. Please use querystring.parse() instead.\", \"DEP0076\");\nexports.createSecurePair = internalUtil.deprecate(createSecurePair, \"tls.createSecurePair() is deprecated. Please use tls.TLSSocket instead.\", \"DEP0064\");\n}"],["trace_events.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  SafeSet,\n  Symbol\n} = primordials;\nconst { hasTracing } = internalBinding(\"config\");\nconst kHandle = Symbol(\"handle\");\nconst kEnabled = Symbol(\"enabled\");\nconst kCategories = Symbol(\"categories\");\nconst kMaxTracingCount = 10;\nconst {\n  ERR_TRACE_EVENTS_CATEGORY_REQUIRED,\n  ERR_TRACE_EVENTS_UNAVAILABLE,\n  ERR_INVALID_ARG_TYPE\n} = require(\"internal/errors\").codes;\nconst { ownsProcessState } = require(\"internal/worker\");\nif (!hasTracing || !ownsProcessState)\n  throw new ERR_TRACE_EVENTS_UNAVAILABLE();\nconst { CategorySet, getEnabledCategories } = internalBinding(\"trace_events\");\nconst { customInspectSymbol } = require(\"internal/util\");\nconst { format } = require(\"internal/util/inspect\");\nconst {\n  validateObject\n} = require(\"internal/validators\");\nconst enabledTracingObjects = new SafeSet();\nclass Tracing {\n  constructor(categories) {\n    this[kHandle] = new CategorySet(categories);\n    this[kCategories] = categories;\n    this[kEnabled] = false;\n  }\n  enable() {\n    if (!this[kEnabled]) {\n      this[kEnabled] = true;\n      this[kHandle].enable();\n      enabledTracingObjects.add(this);\n      if (enabledTracingObjects.size > kMaxTracingCount) {\n        process.emitWarning(`Possible trace_events memory leak detected. There are more than ${kMaxTracingCount} enabled Tracing objects.`);\n      }\n    }\n  }\n  disable() {\n    if (this[kEnabled]) {\n      this[kEnabled] = false;\n      this[kHandle].disable();\n      enabledTracingObjects.delete(this);\n    }\n  }\n  get enabled() {\n    return this[kEnabled];\n  }\n  get categories() {\n    return ArrayPrototypeJoin(this[kCategories], \",\");\n  }\n  [customInspectSymbol](depth, opts) {\n    if (typeof depth === \"number\" && depth < 0)\n      return this;\n    const obj = {\n      enabled: this.enabled,\n      categories: this.categories\n    };\n    return `Tracing ${format(obj)}`;\n  }\n}\nfunction createTracing(options) {\n  validateObject(options, \"options\");\n  if (!ArrayIsArray(options.categories)) {\n    throw new ERR_INVALID_ARG_TYPE(\"options.categories\", \"string[]\", options.categories);\n  }\n  if (options.categories.length <= 0)\n    throw new ERR_TRACE_EVENTS_CATEGORY_REQUIRED();\n  return new Tracing(options.categories);\n}\nmodule.exports = {\n  createTracing,\n  getEnabledCategories\n};\n}"],["tty.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  NumberIsInteger,\n  ObjectSetPrototypeOf\n} = primordials;\nconst net = require(\"net\");\nconst { TTY, isTTY } = internalBinding(\"tty_wrap\");\nconst errors = require(\"internal/errors\");\nconst { ERR_INVALID_FD, ERR_TTY_INIT_FAILED } = errors.codes;\nconst {\n  getColorDepth,\n  hasColors\n} = require(\"internal/tty\");\nlet readline;\nfunction isatty(fd) {\n  return NumberIsInteger(fd) && fd >= 0 && fd <= 2147483647 && isTTY(fd);\n}\nfunction ReadStream(fd, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(fd, options);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n  const ctx = {};\n  const tty = new TTY(fd, ctx);\n  if (ctx.code !== void 0) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n  net.Socket.call(this, {\n    readableHighWaterMark: 0,\n    handle: tty,\n    manualStart: true,\n    ...options\n  });\n  this.isRaw = false;\n  this.isTTY = true;\n}\nObjectSetPrototypeOf(ReadStream.prototype, net.Socket.prototype);\nObjectSetPrototypeOf(ReadStream, net.Socket);\nReadStream.prototype.setRawMode = function(flag) {\n  flag = !!flag;\n  const err = this._handle.setRawMode(flag);\n  if (err) {\n    this.emit(\"error\", errors.errnoException(err, \"setRawMode\"));\n    return this;\n  }\n  this.isRaw = flag;\n  return this;\n};\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(fd);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n  const ctx = {};\n  const tty = new TTY(fd, ctx);\n  if (ctx.code !== void 0) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n  net.Socket.call(this, {\n    readableHighWaterMark: 0,\n    handle: tty,\n    manualStart: true\n  });\n  this._handle.setBlocking(true);\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (!err) {\n    this.columns = winSize[0];\n    this.rows = winSize[1];\n  }\n}\nObjectSetPrototypeOf(WriteStream.prototype, net.Socket.prototype);\nObjectSetPrototypeOf(WriteStream, net.Socket);\nWriteStream.prototype.isTTY = true;\nWriteStream.prototype.getColorDepth = getColorDepth;\nWriteStream.prototype.hasColors = hasColors;\nWriteStream.prototype._refreshSize = function() {\n  const oldCols = this.columns;\n  const oldRows = this.rows;\n  const winSize = new Array(2);\n  const err = this._handle.getWindowSize(winSize);\n  if (err) {\n    this.emit(\"error\", errors.errnoException(err, \"getWindowSize\"));\n    return;\n  }\n  const { 0: newCols, 1: newRows } = winSize;\n  if (oldCols !== newCols || oldRows !== newRows) {\n    this.columns = newCols;\n    this.rows = newRows;\n    this.emit(\"resize\");\n  }\n};\nWriteStream.prototype.cursorTo = function(x, y, callback) {\n  if (readline === void 0)\n    readline = require(\"readline\");\n  return readline.cursorTo(this, x, y, callback);\n};\nWriteStream.prototype.moveCursor = function(dx, dy, callback) {\n  if (readline === void 0)\n    readline = require(\"readline\");\n  return readline.moveCursor(this, dx, dy, callback);\n};\nWriteStream.prototype.clearLine = function(dir, callback) {\n  if (readline === void 0)\n    readline = require(\"readline\");\n  return readline.clearLine(this, dir, callback);\n};\nWriteStream.prototype.clearScreenDown = function(callback) {\n  if (readline === void 0)\n    readline = require(\"readline\");\n  return readline.clearScreenDown(this, callback);\n};\nWriteStream.prototype.getWindowSize = function() {\n  return [this.columns, this.rows];\n};\nmodule.exports = { isatty, ReadStream, WriteStream };\n}"],["url.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Int8Array,\n  ObjectCreate,\n  ObjectKeys,\n  SafeSet,\n  StringPrototypeCharCodeAt,\n  decodeURIComponent\n} = primordials;\nconst { toASCII } = require(\"internal/idna\");\nconst { encodeStr, hexTable } = require(\"internal/querystring\");\nconst querystring = require(\"querystring\");\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_URL\n} = require(\"internal/errors\").codes;\nconst { validateString } = require(\"internal/validators\");\nconst { spliceOne } = require(\"internal/util\");\nconst {\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  fileURLToPath,\n  formatSymbol,\n  pathToFileURL,\n  urlToHttpOptions\n} = require(\"internal/url\");\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\nconst protocolPattern = /^[a-z0-9.+-]+:/i;\nconst portPattern = /:[0-9]*$/;\nconst hostPattern = /^\\/\\/[^@/]+@[^@/]+/;\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/;\nconst hostnameMaxLen = 255;\nconst unsafeProtocol = new SafeSet([\n  \"javascript\",\n  \"javascript:\"\n]);\nconst hostlessProtocol = new SafeSet([\n  \"javascript\",\n  \"javascript:\"\n]);\nconst slashedProtocol = new SafeSet([\n  \"http\",\n  \"http:\",\n  \"https\",\n  \"https:\",\n  \"ftp\",\n  \"ftp:\",\n  \"gopher\",\n  \"gopher:\",\n  \"file\",\n  \"file:\",\n  \"ws\",\n  \"ws:\",\n  \"wss\",\n  \"wss:\"\n]);\nconst {\n  CHAR_SPACE,\n  CHAR_TAB,\n  CHAR_CARRIAGE_RETURN,\n  CHAR_LINE_FEED,\n  CHAR_FORM_FEED,\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE,\n  CHAR_HASH,\n  CHAR_FORWARD_SLASH,\n  CHAR_LEFT_SQUARE_BRACKET,\n  CHAR_RIGHT_SQUARE_BRACKET,\n  CHAR_LEFT_ANGLE_BRACKET,\n  CHAR_RIGHT_ANGLE_BRACKET,\n  CHAR_LEFT_CURLY_BRACKET,\n  CHAR_RIGHT_CURLY_BRACKET,\n  CHAR_QUESTION_MARK,\n  CHAR_LOWERCASE_A,\n  CHAR_LOWERCASE_Z,\n  CHAR_UPPERCASE_A,\n  CHAR_UPPERCASE_Z,\n  CHAR_DOT,\n  CHAR_0,\n  CHAR_9,\n  CHAR_HYPHEN_MINUS,\n  CHAR_PLUS,\n  CHAR_UNDERSCORE,\n  CHAR_DOUBLE_QUOTE,\n  CHAR_SINGLE_QUOTE,\n  CHAR_PERCENT,\n  CHAR_SEMICOLON,\n  CHAR_BACKWARD_SLASH,\n  CHAR_CIRCUMFLEX_ACCENT,\n  CHAR_GRAVE_ACCENT,\n  CHAR_VERTICAL_LINE,\n  CHAR_AT\n} = require(\"internal/constants\");\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url instanceof Url)\n    return url;\n  const urlObject = new Url();\n  urlObject.parse(url, parseQueryString, slashesDenoteHost);\n  return urlObject;\n}\nfunction isIpv6Hostname(hostname) {\n  return StringPrototypeCharCodeAt(hostname, 0) === CHAR_LEFT_SQUARE_BRACKET && StringPrototypeCharCodeAt(hostname, hostname.length - 1) === CHAR_RIGHT_SQUARE_BRACKET;\n}\nconst forbiddenHostChars = /[\\t\\n\\r #%/:<>?@[\\\\\\]^|]/;\nUrl.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n  validateString(url, \"url\");\n  let hasHash = false;\n  let start = -1;\n  let end = -1;\n  let rest = \"\";\n  let lastPos = 0;\n  for (let i = 0, inWs = false, split = false; i < url.length; ++i) {\n    const code = url.charCodeAt(i);\n    const isWs = code === CHAR_SPACE || code === CHAR_TAB || code === CHAR_CARRIAGE_RETURN || code === CHAR_LINE_FEED || code === CHAR_FORM_FEED || code === CHAR_NO_BREAK_SPACE || code === CHAR_ZERO_WIDTH_NOBREAK_SPACE;\n    if (start === -1) {\n      if (isWs)\n        continue;\n      lastPos = start = i;\n    } else if (inWs) {\n      if (!isWs) {\n        end = -1;\n        inWs = false;\n      }\n    } else if (isWs) {\n      end = i;\n      inWs = true;\n    }\n    if (!split) {\n      switch (code) {\n        case CHAR_HASH:\n          hasHash = true;\n        case CHAR_QUESTION_MARK:\n          split = true;\n          break;\n        case CHAR_BACKWARD_SLASH:\n          if (i - lastPos > 0)\n            rest += url.slice(lastPos, i);\n          rest += \"/\";\n          lastPos = i + 1;\n          break;\n      }\n    } else if (!hasHash && code === CHAR_HASH) {\n      hasHash = true;\n    }\n  }\n  if (start !== -1) {\n    if (lastPos === start) {\n      if (end === -1) {\n        if (start === 0)\n          rest = url;\n        else\n          rest = url.slice(start);\n      } else {\n        rest = url.slice(start, end);\n      }\n    } else if (end === -1 && lastPos < url.length) {\n      rest += url.slice(lastPos);\n    } else if (end !== -1 && lastPos < end) {\n      rest += url.slice(lastPos, end);\n    }\n  }\n  if (!slashesDenoteHost && !hasHash) {\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.slice(1));\n        } else {\n          this.query = this.search.slice(1);\n        }\n      } else if (parseQueryString) {\n        this.search = null;\n        this.query = ObjectCreate(null);\n      }\n      return this;\n    }\n  }\n  let proto = protocolPattern.exec(rest);\n  let lowerProto;\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.slice(proto.length);\n  }\n  let slashes;\n  if (slashesDenoteHost || proto || hostPattern.test(rest)) {\n    slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;\n    if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {\n      rest = rest.slice(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {\n    let hostEnd = -1;\n    let atSign = -1;\n    let nonHost = -1;\n    for (let i = 0; i < rest.length; ++i) {\n      switch (rest.charCodeAt(i)) {\n        case CHAR_TAB:\n        case CHAR_LINE_FEED:\n        case CHAR_CARRIAGE_RETURN:\n        case CHAR_SPACE:\n        case CHAR_DOUBLE_QUOTE:\n        case CHAR_PERCENT:\n        case CHAR_SINGLE_QUOTE:\n        case CHAR_SEMICOLON:\n        case CHAR_LEFT_ANGLE_BRACKET:\n        case CHAR_RIGHT_ANGLE_BRACKET:\n        case CHAR_BACKWARD_SLASH:\n        case CHAR_CIRCUMFLEX_ACCENT:\n        case CHAR_GRAVE_ACCENT:\n        case CHAR_LEFT_CURLY_BRACKET:\n        case CHAR_VERTICAL_LINE:\n        case CHAR_RIGHT_CURLY_BRACKET:\n          if (nonHost === -1)\n            nonHost = i;\n          break;\n        case CHAR_HASH:\n        case CHAR_FORWARD_SLASH:\n        case CHAR_QUESTION_MARK:\n          if (nonHost === -1)\n            nonHost = i;\n          hostEnd = i;\n          break;\n        case CHAR_AT:\n          atSign = i;\n          nonHost = -1;\n          break;\n      }\n      if (hostEnd !== -1)\n        break;\n    }\n    start = 0;\n    if (atSign !== -1) {\n      this.auth = decodeURIComponent(rest.slice(0, atSign));\n      start = atSign + 1;\n    }\n    if (nonHost === -1) {\n      this.host = rest.slice(start);\n      rest = \"\";\n    } else {\n      this.host = rest.slice(start, nonHost);\n      rest = rest.slice(nonHost);\n    }\n    this.parseHost();\n    if (typeof this.hostname !== \"string\")\n      this.hostname = \"\";\n    const hostname = this.hostname;\n    const ipv6Hostname = isIpv6Hostname(hostname);\n    if (!ipv6Hostname) {\n      rest = getHostname(this, rest, hostname);\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \"\";\n    } else {\n      this.hostname = this.hostname.toLowerCase();\n    }\n    if (!ipv6Hostname && this.hostname !== \"\") {\n      this.hostname = toASCII(this.hostname, true);\n      if (this.hostname === \"\" || forbiddenHostChars.test(this.hostname)) {\n        throw new ERR_INVALID_URL(url);\n      }\n    }\n    const p = this.port ? \":\" + this.port : \"\";\n    const h = this.hostname || \"\";\n    this.host = h + p;\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.slice(1, -1);\n      if (rest[0] !== \"/\") {\n        rest = \"/\" + rest;\n      }\n    }\n  }\n  if (!unsafeProtocol.has(lowerProto)) {\n    rest = autoEscapeStr(rest);\n  }\n  let questionIdx = -1;\n  let hashIdx = -1;\n  for (let i = 0; i < rest.length; ++i) {\n    const code = rest.charCodeAt(i);\n    if (code === CHAR_HASH) {\n      this.hash = rest.slice(i);\n      hashIdx = i;\n      break;\n    } else if (code === CHAR_QUESTION_MARK && questionIdx === -1) {\n      questionIdx = i;\n    }\n  }\n  if (questionIdx !== -1) {\n    if (hashIdx === -1) {\n      this.search = rest.slice(questionIdx);\n      this.query = rest.slice(questionIdx + 1);\n    } else {\n      this.search = rest.slice(questionIdx, hashIdx);\n      this.query = rest.slice(questionIdx + 1, hashIdx);\n    }\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n  } else if (parseQueryString) {\n    this.search = null;\n    this.query = ObjectCreate(null);\n  }\n  const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);\n  const firstIdx = useQuestionIdx ? questionIdx : hashIdx;\n  if (firstIdx === -1) {\n    if (rest.length > 0)\n      this.pathname = rest;\n  } else if (firstIdx > 0) {\n    this.pathname = rest.slice(0, firstIdx);\n  }\n  if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {\n    this.pathname = \"/\";\n  }\n  if (this.pathname || this.search) {\n    const p = this.pathname || \"\";\n    const s = this.search || \"\";\n    this.path = p + s;\n  }\n  this.href = this.format();\n  return this;\n};\nfunction getHostname(self, rest, hostname) {\n  for (let i = 0; i < hostname.length; ++i) {\n    const code = hostname.charCodeAt(i);\n    const isValid = code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z || code === CHAR_DOT || code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_0 && code <= CHAR_9 || code === CHAR_HYPHEN_MINUS || code === CHAR_PLUS || code === CHAR_UNDERSCORE || code > 127;\n    if (!isValid) {\n      self.hostname = hostname.slice(0, i);\n      return `/${hostname.slice(i)}${rest}`;\n    }\n  }\n  return rest;\n}\nconst escapedCodes = [\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%09\",\n  \"%0A\",\n  \"\",\n  \"\",\n  \"%0D\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%20\",\n  \"\",\n  \"%22\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%27\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%3C\",\n  \"\",\n  \"%3E\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%5C\",\n  \"\",\n  \"%5E\",\n  \"\",\n  \"%60\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"%7B\",\n  \"%7C\",\n  \"%7D\"\n];\nfunction autoEscapeStr(rest) {\n  let escaped = \"\";\n  let lastEscapedPos = 0;\n  for (let i = 0; i < rest.length; ++i) {\n    const escapedChar = escapedCodes[rest.charCodeAt(i)];\n    if (escapedChar) {\n      if (i > lastEscapedPos)\n        escaped += rest.slice(lastEscapedPos, i);\n      escaped += escapedChar;\n      lastEscapedPos = i + 1;\n    }\n  }\n  if (lastEscapedPos === 0)\n    return rest;\n  if (lastEscapedPos < rest.length)\n    escaped += rest.slice(lastEscapedPos);\n  return escaped;\n}\nfunction urlFormat(urlObject, options) {\n  if (typeof urlObject === \"string\") {\n    urlObject = urlParse(urlObject);\n  } else if (typeof urlObject !== \"object\" || urlObject === null) {\n    throw new ERR_INVALID_ARG_TYPE(\"urlObject\", [\"Object\", \"string\"], urlObject);\n  } else if (!(urlObject instanceof Url)) {\n    const format2 = urlObject[formatSymbol];\n    return format2 ? format2.call(urlObject, options) : Url.prototype.format.call(urlObject);\n  }\n  return urlObject.format();\n}\nconst noEscapeAuth = new Int8Array([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  0\n]);\nUrl.prototype.format = function format() {\n  let auth = this.auth || \"\";\n  if (auth) {\n    auth = encodeStr(auth, noEscapeAuth, hexTable);\n    auth += \"@\";\n  }\n  let protocol = this.protocol || \"\";\n  let pathname = this.pathname || \"\";\n  let hash = this.hash || \"\";\n  let host = \"\";\n  let query = \"\";\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.includes(\":\") && !isIpv6Hostname(this.hostname) ? \"[\" + this.hostname + \"]\" : this.hostname);\n    if (this.port) {\n      host += \":\" + this.port;\n    }\n  }\n  if (this.query !== null && typeof this.query === \"object\") {\n    query = querystring.stringify(this.query);\n  }\n  let search = this.search || query && \"?\" + query || \"\";\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)\n    protocol += \":\";\n  let newPathname = \"\";\n  let lastPos = 0;\n  for (let i = 0; i < pathname.length; ++i) {\n    switch (pathname.charCodeAt(i)) {\n      case CHAR_HASH:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += \"%23\";\n        lastPos = i + 1;\n        break;\n      case CHAR_QUESTION_MARK:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += \"%3F\";\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos > 0) {\n    if (lastPos !== pathname.length)\n      pathname = newPathname + pathname.slice(lastPos);\n    else\n      pathname = newPathname;\n  }\n  if (this.slashes || slashedProtocol.has(protocol)) {\n    if (this.slashes || host) {\n      if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH)\n        pathname = \"/\" + pathname;\n      host = \"//\" + host;\n    } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {\n      host = \"//\";\n    }\n  }\n  search = search.replace(/#/g, \"%23\");\n  if (hash && hash.charCodeAt(0) !== CHAR_HASH)\n    hash = \"#\" + hash;\n  if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK)\n    search = \"?\" + search;\n  return protocol + host + pathname + search + hash;\n};\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\nUrl.prototype.resolve = function resolve(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\nfunction urlResolveObject(source, relative) {\n  if (!source)\n    return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\nUrl.prototype.resolveObject = function resolveObject(relative) {\n  if (typeof relative === \"string\") {\n    const rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n  const result = new Url();\n  const tkeys = ObjectKeys(this);\n  for (let tk = 0; tk < tkeys.length; tk++) {\n    const tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n  result.hash = relative.hash;\n  if (relative.href === \"\") {\n    result.href = result.format();\n    return result;\n  }\n  if (relative.slashes && !relative.protocol) {\n    const rkeys = ObjectKeys(relative);\n    for (let rk = 0; rk < rkeys.length; rk++) {\n      const rkey = rkeys[rk];\n      if (rkey !== \"protocol\")\n        result[rkey] = relative[rkey];\n    }\n    if (slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {\n      result.path = result.pathname = \"/\";\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol.has(relative.protocol)) {\n      const keys = ObjectKeys(relative);\n      for (let v = 0; v < keys.length; v++) {\n        const k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n    result.protocol = relative.protocol;\n    if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol.has(relative.protocol)) {\n      const relPath2 = (relative.pathname || \"\").split(\"/\");\n      while (relPath2.length && !(relative.host = relPath2.shift()))\n        ;\n      if (!relative.host)\n        relative.host = \"\";\n      if (!relative.hostname)\n        relative.hostname = \"\";\n      if (relPath2[0] !== \"\")\n        relPath2.unshift(\"\");\n      if (relPath2.length < 2)\n        relPath2.unshift(\"\");\n      result.pathname = relPath2.join(\"/\");\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || \"\";\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    if (result.pathname || result.search) {\n      const p = result.pathname || \"\";\n      const s = result.search || \"\";\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n  const isSourceAbs = result.pathname && result.pathname.charAt(0) === \"/\";\n  const isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \"/\";\n  let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;\n  const removeAllDots = mustEndAbs;\n  let srcPath = result.pathname && result.pathname.split(\"/\") || [];\n  const relPath = relative.pathname && relative.pathname.split(\"/\") || [];\n  const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);\n  if (noLeadingSlashes) {\n    result.hostname = \"\";\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === \"\")\n        srcPath[0] = result.host;\n      else\n        srcPath.unshift(result.host);\n    }\n    result.host = \"\";\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      result.auth = null;\n      if (relative.host) {\n        if (relPath[0] === \"\")\n          relPath[0] = relative.host;\n        else\n          relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n  if (isRelAbs) {\n    if (relative.host || relative.host === \"\") {\n      if (result.host !== relative.host)\n        result.auth = null;\n      result.host = relative.host;\n      result.port = relative.port;\n    }\n    if (relative.hostname || relative.hostname === \"\") {\n      if (result.hostname !== relative.hostname)\n        result.auth = null;\n      result.hostname = relative.hostname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n  } else if (relPath.length) {\n    if (!srcPath)\n      srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search !== null && relative.search !== void 0) {\n    if (noLeadingSlashes) {\n      result.hostname = result.host = srcPath.shift();\n      const authInHost = result.host && result.host.indexOf(\"@\") > 0 && result.host.split(\"@\");\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : \"\") + (result.search ? result.search : \"\");\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    if (result.search) {\n      result.path = \"/\" + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n  let last = srcPath.slice(-1)[0];\n  const hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \".\" || last === \"..\") || last === \"\";\n  let up = 0;\n  for (let i = srcPath.length - 1; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === \".\") {\n      spliceOne(srcPath, i);\n    } else if (last === \"..\") {\n      spliceOne(srcPath, i);\n      up++;\n    } else if (up) {\n      spliceOne(srcPath, i);\n      up--;\n    }\n  }\n  if (!mustEndAbs && !removeAllDots) {\n    while (up--) {\n      srcPath.unshift(\"..\");\n    }\n  }\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charAt(0) !== \"/\")) {\n    srcPath.unshift(\"\");\n  }\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\") {\n    srcPath.push(\"\");\n  }\n  const isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charAt(0) === \"/\";\n  if (noLeadingSlashes) {\n    result.hostname = result.host = isAbsolute ? \"\" : srcPath.length ? srcPath.shift() : \"\";\n    const authInHost = result.host && result.host.indexOf(\"@\") > 0 ? result.host.split(\"@\") : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\"\");\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join(\"/\");\n  }\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : \"\") + (result.search ? result.search : \"\");\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\nUrl.prototype.parseHost = function parseHost() {\n  let host = this.host;\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== \":\") {\n      this.port = port.slice(1);\n    }\n    host = host.slice(0, host.length - port.length);\n  }\n  if (host)\n    this.hostname = host;\n};\nmodule.exports = {\n  Url,\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  pathToFileURL,\n  fileURLToPath,\n  urlToHttpOptions\n};\n}"],["util.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  Date,\n  DatePrototypeGetDate,\n  DatePrototypeGetHours,\n  DatePrototypeGetMinutes,\n  DatePrototypeGetMonth,\n  DatePrototypeGetSeconds,\n  Error,\n  FunctionPrototypeBind,\n  NumberIsSafeInteger,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectGetOwnPropertyDescriptors,\n  ObjectKeys,\n  ObjectPrototypeToString,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  StringPrototypePadStart\n} = primordials;\nconst {\n  codes: {\n    ERR_FALSY_VALUE_REJECTION,\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE\n  },\n  errnoException,\n  exceptionWithHostPort,\n  hideStackFrames\n} = require(\"internal/errors\");\nconst {\n  format,\n  formatWithOptions,\n  inspect\n} = require(\"internal/util/inspect\");\nconst { debuglog } = require(\"internal/util/debuglog\");\nconst {\n  validateFunction,\n  validateNumber\n} = require(\"internal/validators\");\nconst { TextDecoder, TextEncoder } = require(\"internal/encoding\");\nconst { isBuffer } = require(\"buffer\").Buffer;\nconst types = require(\"internal/util/types\");\nconst {\n  deprecate,\n  getSystemErrorMap,\n  getSystemErrorName: internalErrorName,\n  promisify,\n  toUSVString\n} = require(\"internal/util\");\nlet internalDeepEqual;\nfunction isBoolean(arg) {\n  return typeof arg === \"boolean\";\n}\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return arg === null || arg === void 0;\n}\nfunction isNumber(arg) {\n  return typeof arg === \"number\";\n}\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\nfunction isSymbol(arg) {\n  return typeof arg === \"symbol\";\n}\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nfunction isObject(arg) {\n  return arg !== null && typeof arg === \"object\";\n}\nfunction isError(e) {\n  return ObjectPrototypeToString(e) === \"[object Error]\" || e instanceof Error;\n}\nfunction isFunction(arg) {\n  return typeof arg === \"function\";\n}\nfunction isPrimitive(arg) {\n  return arg === null || typeof arg !== \"object\" && typeof arg !== \"function\";\n}\nfunction pad(n) {\n  return StringPrototypePadStart(n.toString(), 2, \"0\");\n}\nconst months = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\"\n];\nfunction timestamp() {\n  const d = new Date();\n  const t = ArrayPrototypeJoin([\n    pad(DatePrototypeGetHours(d)),\n    pad(DatePrototypeGetMinutes(d)),\n    pad(DatePrototypeGetSeconds(d))\n  ], \":\");\n  return `${DatePrototypeGetDate(d)} ${months[DatePrototypeGetMonth(d)]} ${t}`;\n}\nlet console;\nfunction log(...args) {\n  if (!console) {\n    console = require(\"internal/console/global\");\n  }\n  console.log(\"%s - %s\", timestamp(), format(...args));\n}\nfunction inherits(ctor, superCtor) {\n  if (ctor === void 0 || ctor === null)\n    throw new ERR_INVALID_ARG_TYPE(\"ctor\", \"Function\", ctor);\n  if (superCtor === void 0 || superCtor === null)\n    throw new ERR_INVALID_ARG_TYPE(\"superCtor\", \"Function\", superCtor);\n  if (superCtor.prototype === void 0) {\n    throw new ERR_INVALID_ARG_TYPE(\"superCtor.prototype\", \"Object\", superCtor.prototype);\n  }\n  ObjectDefineProperty(ctor, \"super_\", {\n    value: superCtor,\n    writable: true,\n    configurable: true\n  });\n  ObjectSetPrototypeOf(ctor.prototype, superCtor.prototype);\n}\nfunction _extend(target, source) {\n  if (source === null || typeof source !== \"object\")\n    return target;\n  const keys = ObjectKeys(source);\n  let i = keys.length;\n  while (i--) {\n    target[keys[i]] = source[keys[i]];\n  }\n  return target;\n}\nconst callbackifyOnRejected = hideStackFrames((reason, cb) => {\n  if (!reason) {\n    reason = new ERR_FALSY_VALUE_REJECTION(reason);\n  }\n  return cb(reason);\n});\nfunction callbackify(original) {\n  validateFunction(original, \"original\");\n  function callbackified(...args) {\n    const maybeCb = ArrayPrototypePop(args);\n    validateFunction(maybeCb, \"last argument\");\n    const cb = FunctionPrototypeBind(maybeCb, this);\n    ReflectApply(original, this, args).then((ret) => process.nextTick(cb, null, ret), (rej) => process.nextTick(callbackifyOnRejected, rej, cb));\n  }\n  const descriptors = ObjectGetOwnPropertyDescriptors(original);\n  if (typeof descriptors.length.value === \"number\") {\n    descriptors.length.value++;\n  }\n  if (typeof descriptors.name.value === \"string\") {\n    descriptors.name.value += \"Callbackified\";\n  }\n  ObjectDefineProperties(callbackified, descriptors);\n  return callbackified;\n}\nfunction getSystemErrorName(err) {\n  validateNumber(err, \"err\");\n  if (err >= 0 || !NumberIsSafeInteger(err)) {\n    throw new ERR_OUT_OF_RANGE(\"err\", \"a negative integer\", err);\n  }\n  return internalErrorName(err);\n}\nmodule.exports = {\n  _errnoException: errnoException,\n  _exceptionWithHostPort: exceptionWithHostPort,\n  _extend,\n  callbackify,\n  debug: debuglog,\n  debuglog,\n  deprecate,\n  format,\n  formatWithOptions,\n  getSystemErrorMap,\n  getSystemErrorName,\n  inherits,\n  inspect,\n  isArray: ArrayIsArray,\n  isBoolean,\n  isBuffer,\n  isDeepStrictEqual(a, b) {\n    if (internalDeepEqual === void 0) {\n      internalDeepEqual = require(\"internal/util/comparisons\").isDeepStrictEqual;\n    }\n    return internalDeepEqual(a, b);\n  },\n  isNull,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  isSymbol,\n  isUndefined,\n  isRegExp: types.isRegExp,\n  isObject,\n  isDate: types.isDate,\n  isError,\n  isFunction,\n  isPrimitive,\n  log,\n  promisify,\n  toUSVString,\n  TextDecoder,\n  TextEncoder,\n  types\n};\n}"],["v8.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  Array,\n  ArrayBuffer,\n  ArrayPrototypeForEach,\n  ArrayPrototypePush,\n  DataView,\n  Error,\n  Float32Array,\n  Float64Array,\n  Int16Array,\n  Int32Array,\n  Int8Array,\n  ObjectPrototypeToString,\n  SafeMap,\n  Uint16Array,\n  Uint32Array,\n  Uint8Array,\n  Uint8ClampedArray\n} = primordials;\nconst { Buffer } = require(\"buffer\");\nconst { validateString } = require(\"internal/validators\");\nconst {\n  Serializer,\n  Deserializer\n} = internalBinding(\"serdes\");\nlet profiler = {};\nif (internalBinding(\"config\").hasInspector) {\n  profiler = internalBinding(\"profiler\");\n}\nconst assert = require(\"internal/assert\");\nconst { copy } = internalBinding(\"buffer\");\nconst { inspect } = require(\"internal/util/inspect\");\nconst { FastBuffer } = require(\"internal/buffer\");\nconst { getValidatedPath } = require(\"internal/fs/utils\");\nconst { toNamespacedPath } = require(\"path\");\nconst {\n  createHeapSnapshotStream,\n  triggerHeapSnapshot\n} = internalBinding(\"heap_utils\");\nconst { HeapSnapshotStream } = require(\"internal/heap_utils\");\nfunction writeHeapSnapshot(filename) {\n  if (filename !== void 0) {\n    filename = getValidatedPath(filename);\n    filename = toNamespacedPath(filename);\n  }\n  return triggerHeapSnapshot(filename);\n}\nfunction getHeapSnapshot() {\n  const handle = createHeapSnapshotStream();\n  assert(handle);\n  return new HeapSnapshotStream(handle);\n}\nconst binding = internalBinding(\"v8\");\nconst {\n  cachedDataVersionTag,\n  setFlagsFromString: _setFlagsFromString,\n  updateHeapStatisticsBuffer,\n  updateHeapSpaceStatisticsBuffer,\n  updateHeapCodeStatisticsBuffer,\n  kTotalHeapSizeIndex,\n  kTotalHeapSizeExecutableIndex,\n  kTotalPhysicalSizeIndex,\n  kTotalAvailableSize,\n  kUsedHeapSizeIndex,\n  kHeapSizeLimitIndex,\n  kDoesZapGarbageIndex,\n  kMallocedMemoryIndex,\n  kPeakMallocedMemoryIndex,\n  kNumberOfNativeContextsIndex,\n  kNumberOfDetachedContextsIndex,\n  kHeapSpaces,\n  kSpaceSizeIndex,\n  kSpaceUsedSizeIndex,\n  kSpaceAvailableSizeIndex,\n  kPhysicalSpaceSizeIndex,\n  kCodeAndMetadataSizeIndex,\n  kBytecodeAndMetadataSizeIndex,\n  kExternalScriptSourceSizeIndex\n} = binding;\nconst kNumberOfHeapSpaces = kHeapSpaces.length;\nfunction setFlagsFromString(flags) {\n  validateString(flags, \"flags\");\n  _setFlagsFromString(flags);\n}\nfunction getHeapStatistics() {\n  const buffer = binding.heapStatisticsBuffer;\n  updateHeapStatisticsBuffer();\n  return {\n    total_heap_size: buffer[kTotalHeapSizeIndex],\n    total_heap_size_executable: buffer[kTotalHeapSizeExecutableIndex],\n    total_physical_size: buffer[kTotalPhysicalSizeIndex],\n    total_available_size: buffer[kTotalAvailableSize],\n    used_heap_size: buffer[kUsedHeapSizeIndex],\n    heap_size_limit: buffer[kHeapSizeLimitIndex],\n    malloced_memory: buffer[kMallocedMemoryIndex],\n    peak_malloced_memory: buffer[kPeakMallocedMemoryIndex],\n    does_zap_garbage: buffer[kDoesZapGarbageIndex],\n    number_of_native_contexts: buffer[kNumberOfNativeContextsIndex],\n    number_of_detached_contexts: buffer[kNumberOfDetachedContextsIndex]\n  };\n}\nfunction getHeapSpaceStatistics() {\n  const heapSpaceStatistics = new Array(kNumberOfHeapSpaces);\n  const buffer = binding.heapSpaceStatisticsBuffer;\n  for (let i = 0; i < kNumberOfHeapSpaces; i++) {\n    updateHeapSpaceStatisticsBuffer(i);\n    heapSpaceStatistics[i] = {\n      space_name: kHeapSpaces[i],\n      space_size: buffer[kSpaceSizeIndex],\n      space_used_size: buffer[kSpaceUsedSizeIndex],\n      space_available_size: buffer[kSpaceAvailableSizeIndex],\n      physical_space_size: buffer[kPhysicalSpaceSizeIndex]\n    };\n  }\n  return heapSpaceStatistics;\n}\nfunction getHeapCodeStatistics() {\n  const buffer = binding.heapCodeStatisticsBuffer;\n  updateHeapCodeStatisticsBuffer();\n  return {\n    code_and_metadata_size: buffer[kCodeAndMetadataSizeIndex],\n    bytecode_and_metadata_size: buffer[kBytecodeAndMetadataSizeIndex],\n    external_script_source_size: buffer[kExternalScriptSourceSizeIndex]\n  };\n}\nSerializer.prototype._getDataCloneError = Error;\nDeserializer.prototype.readRawBytes = function readRawBytes(length) {\n  const offset = this._readRawBytes(length);\n  return new FastBuffer(this.buffer.buffer, this.buffer.byteOffset + offset, length);\n};\nconst arrayBufferViewTypes = [\n  Int8Array,\n  Uint8Array,\n  Uint8ClampedArray,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  DataView\n];\nconst arrayBufferViewTypeToIndex = new SafeMap();\n{\n  const dummy = new ArrayBuffer();\n  ArrayPrototypeForEach(arrayBufferViewTypes, (ctor, i) => {\n    const tag = ObjectPrototypeToString(new ctor(dummy));\n    arrayBufferViewTypeToIndex.set(tag, i);\n  });\n}\nconst bufferConstructorIndex = ArrayPrototypePush(arrayBufferViewTypes, FastBuffer) - 1;\nclass DefaultSerializer extends Serializer {\n  constructor() {\n    super();\n    this._setTreatArrayBufferViewsAsHostObjects(true);\n  }\n  _writeHostObject(abView) {\n    let i = 0;\n    if (abView.constructor === Buffer) {\n      i = bufferConstructorIndex;\n    } else {\n      const tag = ObjectPrototypeToString(abView);\n      i = arrayBufferViewTypeToIndex.get(tag);\n      if (i === void 0) {\n        throw new this._getDataCloneError(`Unserializable host object: ${inspect(abView)}`);\n      }\n    }\n    this.writeUint32(i);\n    this.writeUint32(abView.byteLength);\n    this.writeRawBytes(new Uint8Array(abView.buffer, abView.byteOffset, abView.byteLength));\n  }\n}\nclass DefaultDeserializer extends Deserializer {\n  _readHostObject() {\n    const typeIndex = this.readUint32();\n    const ctor = arrayBufferViewTypes[typeIndex];\n    const byteLength = this.readUint32();\n    const byteOffset = this._readRawBytes(byteLength);\n    const BYTES_PER_ELEMENT = ctor.BYTES_PER_ELEMENT || 1;\n    const offset = this.buffer.byteOffset + byteOffset;\n    if (offset % BYTES_PER_ELEMENT === 0) {\n      return new ctor(this.buffer.buffer, offset, byteLength / BYTES_PER_ELEMENT);\n    }\n    const buffer_copy = Buffer.allocUnsafe(byteLength);\n    copy(this.buffer, buffer_copy, 0, byteOffset, byteOffset + byteLength);\n    return new ctor(buffer_copy.buffer, buffer_copy.byteOffset, byteLength / BYTES_PER_ELEMENT);\n  }\n}\nfunction serialize(value) {\n  const ser = new DefaultSerializer();\n  ser.writeHeader();\n  ser.writeValue(value);\n  return ser.releaseBuffer();\n}\nfunction deserialize(buffer) {\n  const der = new DefaultDeserializer(buffer);\n  der.readHeader();\n  return der.readValue();\n}\nmodule.exports = {\n  cachedDataVersionTag,\n  getHeapSnapshot,\n  getHeapStatistics,\n  getHeapSpaceStatistics,\n  getHeapCodeStatistics,\n  setFlagsFromString,\n  Serializer,\n  Deserializer,\n  DefaultSerializer,\n  DefaultDeserializer,\n  deserialize,\n  takeCoverage: profiler.takeCoverage,\n  stopCoverage: profiler.stopCoverage,\n  serialize,\n  writeHeapSnapshot\n};\n}"],["vm.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeUnshift,\n  Symbol,\n  PromiseReject,\n  ReflectApply\n} = primordials;\nconst {\n  ContextifyScript,\n  MicrotaskQueue,\n  makeContext,\n  isContext: _isContext,\n  constants,\n  compileFunction: _compileFunction,\n  measureMemory: _measureMemory\n} = internalBinding(\"contextify\");\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED,\n  ERR_INVALID_ARG_TYPE\n} = require(\"internal/errors\").codes;\nconst {\n  isArrayBufferView\n} = require(\"internal/util/types\");\nconst {\n  validateArray,\n  validateBoolean,\n  validateBuffer,\n  validateFunction,\n  validateInt32,\n  validateObject,\n  validateOneOf,\n  validateString,\n  validateUint32\n} = require(\"internal/validators\");\nconst {\n  kVmBreakFirstLineSymbol,\n  emitExperimentalWarning\n} = require(\"internal/util\");\nconst kParsingContext = Symbol(\"script parsing context\");\nclass Script extends ContextifyScript {\n  constructor(code, options = {}) {\n    code = `${code}`;\n    if (typeof options === \"string\") {\n      options = { filename: options };\n    } else {\n      validateObject(options, \"options\");\n    }\n    const {\n      filename = \"evalmachine.<anonymous>\",\n      lineOffset = 0,\n      columnOffset = 0,\n      cachedData,\n      produceCachedData = false,\n      importModuleDynamically,\n      [kParsingContext]: parsingContext\n    } = options;\n    validateString(filename, \"options.filename\");\n    validateInt32(lineOffset, \"options.lineOffset\");\n    validateInt32(columnOffset, \"options.columnOffset\");\n    if (cachedData !== void 0 && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.cachedData\", [\"Buffer\", \"TypedArray\", \"DataView\"], cachedData);\n    }\n    validateBoolean(produceCachedData, \"options.produceCachedData\");\n    try {\n      super(code, filename, lineOffset, columnOffset, cachedData, produceCachedData, parsingContext);\n    } catch (e) {\n      throw e;\n    }\n    if (importModuleDynamically !== void 0) {\n      validateFunction(importModuleDynamically, \"options.importModuleDynamically\");\n      const { importModuleDynamicallyWrap } = require(\"internal/vm/module\");\n      const { callbackMap } = internalBinding(\"module_wrap\");\n      callbackMap.set(this, {\n        importModuleDynamically: importModuleDynamicallyWrap(importModuleDynamically)\n      });\n    }\n  }\n  runInThisContext(options) {\n    const { breakOnSigint, args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount(\"SIGINT\") > 0) {\n      return sigintHandlersWrap(super.runInThisContext, this, args);\n    }\n    return ReflectApply(super.runInThisContext, this, args);\n  }\n  runInContext(contextifiedObject, options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint, args } = getRunInContextArgs(options);\n    ArrayPrototypeUnshift(args, contextifiedObject);\n    if (breakOnSigint && process.listenerCount(\"SIGINT\") > 0) {\n      return sigintHandlersWrap(super.runInContext, this, args);\n    }\n    return ReflectApply(super.runInContext, this, args);\n  }\n  runInNewContext(contextObject, options) {\n    const context = createContext(contextObject, getContextOptions(options));\n    return this.runInContext(context, options);\n  }\n}\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE(\"contextifiedObject\", \"vm.Context\", contextifiedObject);\n  }\n}\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options, \"options\");\n  let timeout = options.timeout;\n  if (timeout === void 0) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout, \"options.timeout\", true);\n  }\n  const {\n    displayErrors = true,\n    breakOnSigint = false,\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\n  } = options;\n  validateBoolean(displayErrors, \"options.displayErrors\");\n  validateBoolean(breakOnSigint, \"options.breakOnSigint\");\n  return {\n    breakOnSigint,\n    args: [timeout, displayErrors, breakOnSigint, breakFirstLine]\n  };\n}\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName,\n    origin: options.contextOrigin,\n    codeGeneration: void 0,\n    microtaskMode: options.microtaskMode\n  };\n  if (contextOptions.name !== void 0)\n    validateString(contextOptions.name, \"options.contextName\");\n  if (contextOptions.origin !== void 0)\n    validateString(contextOptions.origin, \"options.contextOrigin\");\n  if (options.contextCodeGeneration !== void 0) {\n    validateObject(options.contextCodeGeneration, \"options.contextCodeGeneration\");\n    const { strings, wasm } = options.contextCodeGeneration;\n    if (strings !== void 0)\n      validateBoolean(strings, \"options.contextCodeGeneration.strings\");\n    if (wasm !== void 0)\n      validateBoolean(wasm, \"options.contextCodeGeneration.wasm\");\n    contextOptions.codeGeneration = { strings, wasm };\n  }\n  if (options.microtaskMode !== void 0)\n    validateString(options.microtaskMode, \"options.microtaskMode\");\n  return contextOptions;\n}\nfunction isContext(object) {\n  validateObject(object, \"object\", { allowArray: true });\n  return _isContext(object);\n}\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}, options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n  validateObject(options, \"options\");\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`,\n    origin,\n    codeGeneration,\n    microtaskMode\n  } = options;\n  validateString(name, \"options.name\");\n  if (origin !== void 0)\n    validateString(origin, \"options.origin\");\n  if (codeGeneration !== void 0)\n    validateObject(codeGeneration, \"options.codeGeneration\");\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== void 0) {\n    ({ strings = true, wasm = true } = codeGeneration);\n    validateBoolean(strings, \"options.codeGeneration.strings\");\n    validateBoolean(wasm, \"options.codeGeneration.wasm\");\n  }\n  let microtaskQueue = null;\n  if (microtaskMode !== void 0) {\n    validateOneOf(microtaskMode, \"options.microtaskMode\", [\"afterEvaluate\", void 0]);\n    if (microtaskMode === \"afterEvaluate\")\n      microtaskQueue = new MicrotaskQueue();\n  }\n  makeContext(contextObject, name, origin, strings, wasm, microtaskQueue);\n  return contextObject;\n}\nfunction createScript(code, options) {\n  return new Script(code, options);\n}\nfunction sigintHandlersWrap(fn, thisArg, argsArray) {\n  const sigintListeners = process.rawListeners(\"SIGINT\");\n  process.removeAllListeners(\"SIGINT\");\n  try {\n    return ReflectApply(fn, thisArg, argsArray);\n  } finally {\n    ArrayPrototypeForEach(sigintListeners, (listener) => {\n      process.addListener(\"SIGINT\", listener);\n    });\n  }\n}\nfunction runInContext(code, contextifiedObject, options) {\n  validateContext(contextifiedObject);\n  if (typeof options === \"string\") {\n    options = {\n      filename: options,\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options, [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code, options).runInContext(contextifiedObject, options);\n}\nfunction runInNewContext(code, contextObject, options) {\n  if (typeof options === \"string\") {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject, getContextOptions(options));\n  options = { ...options, [kParsingContext]: contextObject };\n  return createScript(code, options).runInNewContext(contextObject, options);\n}\nfunction runInThisContext(code, options) {\n  if (typeof options === \"string\") {\n    options = { filename: options };\n  }\n  return createScript(code, options).runInThisContext(options);\n}\nfunction compileFunction(code, params, options = {}) {\n  validateString(code, \"code\");\n  if (params !== void 0) {\n    validateArray(params, \"params\");\n    ArrayPrototypeForEach(params, (param, i) => validateString(param, `params[${i}]`));\n  }\n  const {\n    filename = \"\",\n    columnOffset = 0,\n    lineOffset = 0,\n    cachedData = void 0,\n    produceCachedData = false,\n    parsingContext = void 0,\n    contextExtensions = [],\n    importModuleDynamically\n  } = options;\n  validateString(filename, \"options.filename\");\n  validateUint32(columnOffset, \"options.columnOffset\");\n  validateUint32(lineOffset, \"options.lineOffset\");\n  if (cachedData !== void 0)\n    validateBuffer(cachedData, \"options.cachedData\");\n  validateBoolean(produceCachedData, \"options.produceCachedData\");\n  if (parsingContext !== void 0) {\n    if (typeof parsingContext !== \"object\" || parsingContext === null || !isContext(parsingContext)) {\n      throw new ERR_INVALID_ARG_TYPE(\"options.parsingContext\", \"Context\", parsingContext);\n    }\n  }\n  validateArray(contextExtensions, \"options.contextExtensions\");\n  ArrayPrototypeForEach(contextExtensions, (extension, i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension, name, { nullable: true });\n  });\n  const result = _compileFunction(code, filename, lineOffset, columnOffset, cachedData, produceCachedData, parsingContext, contextExtensions, params);\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n  if (importModuleDynamically !== void 0) {\n    validateFunction(importModuleDynamically, \"options.importModuleDynamically\");\n    const { importModuleDynamicallyWrap } = require(\"internal/vm/module\");\n    const { callbackMap } = internalBinding(\"module_wrap\");\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey, {\n      importModuleDynamically: (s, _k) => wrapped(s, func)\n    });\n  }\n  return result.function;\n}\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY,\n  detailed: constants.measureMemory.mode.DETAILED\n};\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT,\n  eager: constants.measureMemory.execution.EAGER\n};\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning(\"vm.measureMemory\");\n  validateObject(options, \"options\");\n  const { mode = \"summary\", execution = \"default\" } = options;\n  validateOneOf(mode, \"options.mode\", [\"summary\", \"detailed\"]);\n  validateOneOf(execution, \"options.execution\", [\"default\", \"eager\"]);\n  const result = _measureMemory(measureMemoryModes[mode], measureMemoryExecutions[execution]);\n  if (result === void 0) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\nmodule.exports = {\n  Script,\n  createContext,\n  createScript,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext,\n  compileFunction,\n  measureMemory\n};\n}"],["wasi.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayPrototypeForEach,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  FunctionPrototypeBind,\n  ObjectEntries,\n  String,\n  Symbol\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_WASI_ALREADY_STARTED\n} = require(\"internal/errors\").codes;\nconst { emitExperimentalWarning } = require(\"internal/util\");\nconst { isArrayBuffer } = require(\"internal/util/types\");\nconst {\n  validateArray,\n  validateBoolean,\n  validateFunction,\n  validateInt32,\n  validateObject,\n  validateUndefined\n} = require(\"internal/validators\");\nconst { WASI: _WASI } = internalBinding(\"wasi\");\nconst kExitCode = Symbol(\"kExitCode\");\nconst kSetMemory = Symbol(\"kSetMemory\");\nconst kStarted = Symbol(\"kStarted\");\nconst kInstance = Symbol(\"kInstance\");\nemitExperimentalWarning(\"WASI\");\nfunction setupInstance(self, instance) {\n  validateObject(instance, \"instance\");\n  validateObject(instance.exports, \"instance.exports\");\n  validateObject(instance.exports.memory, \"instance.exports.memory\");\n  if (!isArrayBuffer(instance.exports.memory.buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\"instance.exports.memory.buffer\", [\"WebAssembly.Memory\"], instance.exports.memory.buffer);\n  }\n  self[kInstance] = instance;\n  self[kSetMemory](instance.exports.memory);\n}\nclass WASI {\n  constructor(options = {}) {\n    validateObject(options, \"options\");\n    if (options.args !== void 0)\n      validateArray(options.args, \"options.args\");\n    const args = ArrayPrototypeMap(options.args || [], String);\n    const env = [];\n    if (options.env !== void 0) {\n      validateObject(options.env, \"options.env\");\n      ArrayPrototypeForEach(ObjectEntries(options.env), ({ 0: key, 1: value }) => {\n        if (value !== void 0)\n          ArrayPrototypePush(env, `${key}=${value}`);\n      });\n    }\n    const preopens = [];\n    if (options.preopens !== void 0) {\n      validateObject(options.preopens, \"options.preopens\");\n      ArrayPrototypeForEach(ObjectEntries(options.preopens), ({ 0: key, 1: value }) => ArrayPrototypePush(preopens, String(key), String(value)));\n    }\n    const { stdin = 0, stdout = 1, stderr = 2 } = options;\n    validateInt32(stdin, \"options.stdin\", 0);\n    validateInt32(stdout, \"options.stdout\", 0);\n    validateInt32(stderr, \"options.stderr\", 0);\n    const stdio = [stdin, stdout, stderr];\n    const wrap = new _WASI(args, env, preopens, stdio);\n    for (const prop in wrap) {\n      wrap[prop] = FunctionPrototypeBind(wrap[prop], wrap);\n    }\n    if (options.returnOnExit !== void 0) {\n      validateBoolean(options.returnOnExit, \"options.returnOnExit\");\n      if (options.returnOnExit)\n        wrap.proc_exit = FunctionPrototypeBind(wasiReturnOnProcExit, this);\n    }\n    this[kSetMemory] = wrap._setMemory;\n    delete wrap._setMemory;\n    this.wasiImport = wrap;\n    this[kStarted] = false;\n    this[kExitCode] = 0;\n    this[kInstance] = void 0;\n  }\n  start(instance) {\n    if (this[kStarted]) {\n      throw new ERR_WASI_ALREADY_STARTED();\n    }\n    this[kStarted] = true;\n    setupInstance(this, instance);\n    const { _start, _initialize } = this[kInstance].exports;\n    validateFunction(_start, \"instance.exports._start\");\n    validateUndefined(_initialize, \"instance.exports._initialize\");\n    try {\n      _start();\n    } catch (err) {\n      if (err !== kExitCode) {\n        throw err;\n      }\n    }\n    return this[kExitCode];\n  }\n  initialize(instance) {\n    if (this[kStarted]) {\n      throw new ERR_WASI_ALREADY_STARTED();\n    }\n    this[kStarted] = true;\n    setupInstance(this, instance);\n    const { _start, _initialize } = this[kInstance].exports;\n    validateUndefined(_start, \"instance.exports._start\");\n    if (_initialize !== void 0) {\n      validateFunction(_initialize, \"instance.exports._initialize\");\n      _initialize();\n    }\n  }\n}\nmodule.exports = { WASI };\nfunction wasiReturnOnProcExit(rval) {\n  this[kExitCode] = rval;\n  throw kExitCode;\n}\n}"],["worker_threads.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  isMainThread,\n  SHARE_ENV,\n  resourceLimits,\n  setEnvironmentData,\n  getEnvironmentData,\n  threadId,\n  Worker\n} = require(\"internal/worker\");\nconst {\n  MessagePort,\n  MessageChannel,\n  moveMessagePortToContext,\n  receiveMessageOnPort,\n  BroadcastChannel\n} = require(\"internal/worker/io\");\nconst {\n  markAsUntransferable\n} = require(\"internal/buffer\");\nmodule.exports = {\n  isMainThread,\n  MessagePort,\n  MessageChannel,\n  markAsUntransferable,\n  moveMessagePortToContext,\n  receiveMessageOnPort,\n  resourceLimits,\n  threadId,\n  SHARE_ENV,\n  Worker,\n  parentPort: null,\n  workerData: null,\n  BroadcastChannel,\n  setEnvironmentData,\n  getEnvironmentData\n};\n}"],["zlib.js","function (exports, require, module, process, internalBinding, primordials) { \n  \"use strict\";\nconst {\n  ArrayBuffer,\n  ArrayPrototypeForEach,\n  ArrayPrototypeMap,\n  ArrayPrototypePush,\n  Error,\n  FunctionPrototypeBind,\n  MathMaxApply,\n  NumberIsFinite,\n  NumberIsNaN,\n  ObjectDefineProperties,\n  ObjectDefineProperty,\n  ObjectFreeze,\n  ObjectKeys,\n  ObjectSetPrototypeOf,\n  ReflectApply,\n  StringPrototypeStartsWith,\n  Symbol,\n  TypedArrayPrototypeFill,\n  Uint32Array\n} = primordials;\nconst {\n  codes: {\n    ERR_BROTLI_INVALID_PARAM,\n    ERR_BUFFER_TOO_LARGE,\n    ERR_INVALID_ARG_TYPE,\n    ERR_OUT_OF_RANGE,\n    ERR_ZLIB_INITIALIZATION_FAILED\n  },\n  hideStackFrames\n} = require(\"internal/errors\");\nconst { Transform, finished } = require(\"stream\");\nconst {\n  deprecate\n} = require(\"internal/util\");\nconst {\n  isArrayBufferView,\n  isAnyArrayBuffer,\n  isUint8Array\n} = require(\"internal/util/types\");\nconst binding = internalBinding(\"zlib\");\nconst assert = require(\"internal/assert\");\nconst {\n  Buffer,\n  kMaxLength\n} = require(\"buffer\");\nconst { owner_symbol } = require(\"internal/async_hooks\").symbols;\nconst {\n  validateFunction,\n  validateNumber\n} = require(\"internal/validators\");\nconst kFlushFlag = Symbol(\"kFlushFlag\");\nconst kError = Symbol(\"kError\");\nconst constants = internalBinding(\"constants\").zlib;\nconst {\n  Z_NO_FLUSH,\n  Z_BLOCK,\n  Z_PARTIAL_FLUSH,\n  Z_SYNC_FLUSH,\n  Z_FULL_FLUSH,\n  Z_FINISH,\n  Z_MIN_CHUNK,\n  Z_MIN_WINDOWBITS,\n  Z_MAX_WINDOWBITS,\n  Z_MIN_LEVEL,\n  Z_MAX_LEVEL,\n  Z_MIN_MEMLEVEL,\n  Z_MAX_MEMLEVEL,\n  Z_DEFAULT_CHUNK,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFAULT_WINDOWBITS,\n  Z_DEFAULT_MEMLEVEL,\n  Z_FIXED,\n  DEFLATE,\n  DEFLATERAW,\n  INFLATE,\n  INFLATERAW,\n  GZIP,\n  GUNZIP,\n  UNZIP,\n  BROTLI_DECODE,\n  BROTLI_ENCODE,\n  BROTLI_OPERATION_PROCESS,\n  BROTLI_OPERATION_FLUSH,\n  BROTLI_OPERATION_FINISH,\n  BROTLI_OPERATION_EMIT_METADATA\n} = constants;\nconst codes = {\n  Z_OK: constants.Z_OK,\n  Z_STREAM_END: constants.Z_STREAM_END,\n  Z_NEED_DICT: constants.Z_NEED_DICT,\n  Z_ERRNO: constants.Z_ERRNO,\n  Z_STREAM_ERROR: constants.Z_STREAM_ERROR,\n  Z_DATA_ERROR: constants.Z_DATA_ERROR,\n  Z_MEM_ERROR: constants.Z_MEM_ERROR,\n  Z_BUF_ERROR: constants.Z_BUF_ERROR,\n  Z_VERSION_ERROR: constants.Z_VERSION_ERROR\n};\nfor (const ckey of ObjectKeys(codes)) {\n  codes[codes[ckey]] = ckey;\n}\nfunction zlibBuffer(engine, buffer, callback) {\n  validateFunction(callback, \"callback\");\n  if (isArrayBufferView(buffer) && !isUint8Array(buffer)) {\n    buffer = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (isAnyArrayBuffer(buffer)) {\n    buffer = Buffer.from(buffer);\n  }\n  engine.buffers = null;\n  engine.nread = 0;\n  engine.cb = callback;\n  engine.on(\"data\", zlibBufferOnData);\n  engine.on(\"error\", zlibBufferOnError);\n  engine.on(\"end\", zlibBufferOnEnd);\n  engine.end(buffer);\n}\nfunction zlibBufferOnData(chunk) {\n  if (!this.buffers)\n    this.buffers = [chunk];\n  else\n    ArrayPrototypePush(this.buffers, chunk);\n  this.nread += chunk.length;\n  if (this.nread > this._maxOutputLength) {\n    this.close();\n    this.removeAllListeners(\"end\");\n    this.cb(new ERR_BUFFER_TOO_LARGE(this._maxOutputLength));\n  }\n}\nfunction zlibBufferOnError(err) {\n  this.removeAllListeners(\"end\");\n  this.cb(err);\n}\nfunction zlibBufferOnEnd() {\n  let buf;\n  if (this.nread === 0) {\n    buf = Buffer.alloc(0);\n  } else {\n    const bufs = this.buffers;\n    buf = bufs.length === 1 ? bufs[0] : Buffer.concat(bufs, this.nread);\n  }\n  this.close();\n  if (this._info)\n    this.cb(null, { buffer: buf, engine: this });\n  else\n    this.cb(null, buf);\n}\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === \"string\") {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    if (isAnyArrayBuffer(buffer)) {\n      buffer = Buffer.from(buffer);\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\"buffer\", [\"string\", \"Buffer\", \"TypedArray\", \"DataView\", \"ArrayBuffer\"], buffer);\n    }\n  }\n  buffer = processChunkSync(engine, buffer, engine._finishFlushFlag);\n  if (engine._info)\n    return { buffer, engine };\n  return buffer;\n}\nfunction zlibOnError(message, errno, code) {\n  const self = this[owner_symbol];\n  const error = new Error(message);\n  error.errno = errno;\n  error.code = code;\n  self.destroy(error);\n  self[kError] = error;\n}\nconst checkFiniteNumber = hideStackFrames((number, name) => {\n  if (number === void 0) {\n    return false;\n  }\n  if (NumberIsFinite(number)) {\n    return true;\n  }\n  if (NumberIsNaN(number)) {\n    return false;\n  }\n  validateNumber(number, name);\n  throw new ERR_OUT_OF_RANGE(name, \"a finite number\", number);\n});\nconst checkRangesOrGetDefault = hideStackFrames((number, name, lower, upper, def) => {\n  if (!checkFiniteNumber(number, name)) {\n    return def;\n  }\n  if (number < lower || number > upper) {\n    throw new ERR_OUT_OF_RANGE(name, `>= ${lower} and <= ${upper}`, number);\n  }\n  return number;\n});\nconst FLUSH_BOUND = [\n  [Z_NO_FLUSH, Z_BLOCK],\n  [BROTLI_OPERATION_PROCESS, BROTLI_OPERATION_EMIT_METADATA]\n];\nconst FLUSH_BOUND_IDX_NORMAL = 0;\nconst FLUSH_BOUND_IDX_BROTLI = 1;\nfunction ZlibBase(opts, mode, handle, { flush, finishFlush, fullFlush }) {\n  let chunkSize = Z_DEFAULT_CHUNK;\n  let maxOutputLength = kMaxLength;\n  assert(typeof mode === \"number\");\n  assert(mode >= DEFLATE && mode <= BROTLI_ENCODE);\n  let flushBoundIdx;\n  if (mode !== BROTLI_ENCODE && mode !== BROTLI_DECODE) {\n    flushBoundIdx = FLUSH_BOUND_IDX_NORMAL;\n  } else {\n    flushBoundIdx = FLUSH_BOUND_IDX_BROTLI;\n  }\n  if (opts) {\n    chunkSize = opts.chunkSize;\n    if (!checkFiniteNumber(chunkSize, \"options.chunkSize\")) {\n      chunkSize = Z_DEFAULT_CHUNK;\n    } else if (chunkSize < Z_MIN_CHUNK) {\n      throw new ERR_OUT_OF_RANGE(\"options.chunkSize\", `>= ${Z_MIN_CHUNK}`, chunkSize);\n    }\n    flush = checkRangesOrGetDefault(opts.flush, \"options.flush\", FLUSH_BOUND[flushBoundIdx][0], FLUSH_BOUND[flushBoundIdx][1], flush);\n    finishFlush = checkRangesOrGetDefault(opts.finishFlush, \"options.finishFlush\", FLUSH_BOUND[flushBoundIdx][0], FLUSH_BOUND[flushBoundIdx][1], finishFlush);\n    maxOutputLength = checkRangesOrGetDefault(opts.maxOutputLength, \"options.maxOutputLength\", 1, kMaxLength, kMaxLength);\n    if (opts.encoding || opts.objectMode || opts.writableObjectMode) {\n      opts = { ...opts };\n      opts.encoding = null;\n      opts.objectMode = false;\n      opts.writableObjectMode = false;\n    }\n  }\n  ReflectApply(Transform, this, [{ autoDestroy: true, ...opts }]);\n  this[kError] = null;\n  this.bytesWritten = 0;\n  this._handle = handle;\n  handle[owner_symbol] = this;\n  handle.onerror = zlibOnError;\n  this._outBuffer = Buffer.allocUnsafe(chunkSize);\n  this._outOffset = 0;\n  this._chunkSize = chunkSize;\n  this._defaultFlushFlag = flush;\n  this._finishFlushFlag = finishFlush;\n  this._defaultFullFlushFlag = fullFlush;\n  this._info = opts && opts.info;\n  this._maxOutputLength = maxOutputLength;\n}\nObjectSetPrototypeOf(ZlibBase.prototype, Transform.prototype);\nObjectSetPrototypeOf(ZlibBase, Transform);\nObjectDefineProperty(ZlibBase.prototype, \"_closed\", {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return !this._handle;\n  }\n});\nObjectDefineProperty(ZlibBase.prototype, \"bytesRead\", {\n  configurable: true,\n  enumerable: true,\n  get: deprecate(function() {\n    return this.bytesWritten;\n  }, \"zlib.bytesRead is deprecated and will change its meaning in the future. Use zlib.bytesWritten instead.\", \"DEP0108\"),\n  set: deprecate(function(value) {\n    this.bytesWritten = value;\n  }, \"Setting zlib.bytesRead is deprecated. This feature will be removed in the future.\", \"DEP0108\")\n});\nZlibBase.prototype.reset = function() {\n  if (!this._handle)\n    assert(false, \"zlib binding closed\");\n  return this._handle.reset();\n};\nZlibBase.prototype._flush = function(callback) {\n  this._transform(Buffer.alloc(0), \"\", callback);\n};\nZlibBase.prototype._final = function(callback) {\n  callback();\n};\nconst flushiness = [];\nlet i = 0;\nconst kFlushFlagList = [\n  Z_NO_FLUSH,\n  Z_BLOCK,\n  Z_PARTIAL_FLUSH,\n  Z_SYNC_FLUSH,\n  Z_FULL_FLUSH,\n  Z_FINISH\n];\nfor (const flushFlag of kFlushFlagList) {\n  flushiness[flushFlag] = i++;\n}\nfunction maxFlush(a, b) {\n  return flushiness[a] > flushiness[b] ? a : b;\n}\nconst kFlushBuffers = [];\n{\n  const dummyArrayBuffer = new ArrayBuffer();\n  for (const flushFlag of kFlushFlagList) {\n    kFlushBuffers[flushFlag] = Buffer.from(dummyArrayBuffer);\n    kFlushBuffers[flushFlag][kFlushFlag] = flushFlag;\n  }\n}\nZlibBase.prototype.flush = function(kind, callback) {\n  if (typeof kind === \"function\" || kind === void 0 && !callback) {\n    callback = kind;\n    kind = this._defaultFullFlushFlag;\n  }\n  if (this.writableFinished) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (this.writableEnded) {\n    if (callback)\n      this.once(\"end\", callback);\n  } else {\n    this.write(kFlushBuffers[kind], \"\", callback);\n  }\n};\nZlibBase.prototype.close = function(callback) {\n  if (callback)\n    finished(this, callback);\n  this.destroy();\n};\nZlibBase.prototype._destroy = function(err, callback) {\n  _close(this);\n  callback(err);\n};\nZlibBase.prototype._transform = function(chunk, encoding, cb) {\n  let flushFlag = this._defaultFlushFlag;\n  if (typeof chunk[kFlushFlag] === \"number\") {\n    flushFlag = chunk[kFlushFlag];\n  }\n  if (this.writableEnded && this.writableLength === chunk.byteLength) {\n    flushFlag = maxFlush(flushFlag, this._finishFlushFlag);\n  }\n  processChunk(this, chunk, flushFlag, cb);\n};\nZlibBase.prototype._processChunk = function(chunk, flushFlag, cb) {\n  if (typeof cb === \"function\")\n    processChunk(this, chunk, flushFlag, cb);\n  else\n    return processChunkSync(this, chunk, flushFlag);\n};\nfunction processChunkSync(self, chunk, flushFlag) {\n  let availInBefore = chunk.byteLength;\n  let availOutBefore = self._chunkSize - self._outOffset;\n  let inOff = 0;\n  let availOutAfter;\n  let availInAfter;\n  let buffers = null;\n  let nread = 0;\n  let inputRead = 0;\n  const state = self._writeState;\n  const handle = self._handle;\n  let buffer = self._outBuffer;\n  let offset = self._outOffset;\n  const chunkSize = self._chunkSize;\n  let error;\n  self.on(\"error\", function onError(er) {\n    error = er;\n  });\n  while (true) {\n    handle.writeSync(flushFlag, chunk, inOff, availInBefore, buffer, offset, availOutBefore);\n    if (error)\n      throw error;\n    else if (self[kError])\n      throw self[kError];\n    availOutAfter = state[0];\n    availInAfter = state[1];\n    const inDelta = availInBefore - availInAfter;\n    inputRead += inDelta;\n    const have = availOutBefore - availOutAfter;\n    if (have > 0) {\n      const out = buffer.slice(offset, offset + have);\n      offset += have;\n      if (!buffers)\n        buffers = [out];\n      else\n        ArrayPrototypePush(buffers, out);\n      nread += out.byteLength;\n      if (nread > self._maxOutputLength) {\n        _close(self);\n        throw new ERR_BUFFER_TOO_LARGE(self._maxOutputLength);\n      }\n    } else {\n      assert(have === 0, \"have should not go down\");\n    }\n    if (availOutAfter === 0 || offset >= chunkSize) {\n      availOutBefore = chunkSize;\n      offset = 0;\n      buffer = Buffer.allocUnsafe(chunkSize);\n    }\n    if (availOutAfter === 0) {\n      inOff += inDelta;\n      availInBefore = availInAfter;\n    } else {\n      break;\n    }\n  }\n  self.bytesWritten = inputRead;\n  _close(self);\n  if (nread === 0)\n    return Buffer.alloc(0);\n  return buffers.length === 1 ? buffers[0] : Buffer.concat(buffers, nread);\n}\nfunction processChunk(self, chunk, flushFlag, cb) {\n  const handle = self._handle;\n  if (!handle)\n    return process.nextTick(cb);\n  handle.buffer = chunk;\n  handle.cb = cb;\n  handle.availOutBefore = self._chunkSize - self._outOffset;\n  handle.availInBefore = chunk.byteLength;\n  handle.inOff = 0;\n  handle.flushFlag = flushFlag;\n  handle.write(flushFlag, chunk, 0, handle.availInBefore, self._outBuffer, self._outOffset, handle.availOutBefore);\n}\nfunction processCallback() {\n  const handle = this;\n  const self = this[owner_symbol];\n  const state = self._writeState;\n  if (self.destroyed) {\n    this.buffer = null;\n    this.cb();\n    return;\n  }\n  const availOutAfter = state[0];\n  const availInAfter = state[1];\n  const inDelta = handle.availInBefore - availInAfter;\n  self.bytesWritten += inDelta;\n  const have = handle.availOutBefore - availOutAfter;\n  if (have > 0) {\n    const out = self._outBuffer.slice(self._outOffset, self._outOffset + have);\n    self._outOffset += have;\n    self.push(out);\n  } else {\n    assert(have === 0, \"have should not go down\");\n  }\n  if (self.destroyed) {\n    this.cb();\n    return;\n  }\n  if (availOutAfter === 0 || self._outOffset >= self._chunkSize) {\n    handle.availOutBefore = self._chunkSize;\n    self._outOffset = 0;\n    self._outBuffer = Buffer.allocUnsafe(self._chunkSize);\n  }\n  if (availOutAfter === 0) {\n    handle.inOff += inDelta;\n    handle.availInBefore = availInAfter;\n    this.write(handle.flushFlag, this.buffer, handle.inOff, handle.availInBefore, self._outBuffer, self._outOffset, self._chunkSize);\n    return;\n  }\n  if (availInAfter > 0) {\n    self.push(null);\n  }\n  this.buffer = null;\n  this.cb();\n}\nfunction _close(engine) {\n  if (!engine._handle)\n    return;\n  engine._handle.close();\n  engine._handle = null;\n}\nconst zlibDefaultOpts = {\n  flush: Z_NO_FLUSH,\n  finishFlush: Z_FINISH,\n  fullFlush: Z_FULL_FLUSH\n};\nfunction Zlib(opts, mode) {\n  let windowBits = Z_DEFAULT_WINDOWBITS;\n  let level = Z_DEFAULT_COMPRESSION;\n  let memLevel = Z_DEFAULT_MEMLEVEL;\n  let strategy = Z_DEFAULT_STRATEGY;\n  let dictionary;\n  if (opts) {\n    if ((opts.windowBits == null || opts.windowBits === 0) && (mode === INFLATE || mode === GUNZIP || mode === UNZIP)) {\n      windowBits = 0;\n    } else {\n      const min = Z_MIN_WINDOWBITS + (mode === GZIP ? 1 : 0);\n      windowBits = checkRangesOrGetDefault(opts.windowBits, \"options.windowBits\", min, Z_MAX_WINDOWBITS, Z_DEFAULT_WINDOWBITS);\n    }\n    level = checkRangesOrGetDefault(opts.level, \"options.level\", Z_MIN_LEVEL, Z_MAX_LEVEL, Z_DEFAULT_COMPRESSION);\n    memLevel = checkRangesOrGetDefault(opts.memLevel, \"options.memLevel\", Z_MIN_MEMLEVEL, Z_MAX_MEMLEVEL, Z_DEFAULT_MEMLEVEL);\n    strategy = checkRangesOrGetDefault(opts.strategy, \"options.strategy\", Z_DEFAULT_STRATEGY, Z_FIXED, Z_DEFAULT_STRATEGY);\n    dictionary = opts.dictionary;\n    if (dictionary !== void 0 && !isArrayBufferView(dictionary)) {\n      if (isAnyArrayBuffer(dictionary)) {\n        dictionary = Buffer.from(dictionary);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\"options.dictionary\", [\"Buffer\", \"TypedArray\", \"DataView\", \"ArrayBuffer\"], dictionary);\n      }\n    }\n  }\n  const handle = new binding.Zlib(mode);\n  this._writeState = new Uint32Array(2);\n  handle.init(windowBits, level, memLevel, strategy, this._writeState, processCallback, dictionary);\n  ReflectApply(ZlibBase, this, [opts, mode, handle, zlibDefaultOpts]);\n  this._level = level;\n  this._strategy = strategy;\n}\nObjectSetPrototypeOf(Zlib.prototype, ZlibBase.prototype);\nObjectSetPrototypeOf(Zlib, ZlibBase);\nfunction paramsAfterFlushCallback(level, strategy, callback) {\n  assert(this._handle, \"zlib binding closed\");\n  this._handle.params(level, strategy);\n  if (!this.destroyed) {\n    this._level = level;\n    this._strategy = strategy;\n    if (callback)\n      callback();\n  }\n}\nZlib.prototype.params = function params(level, strategy, callback) {\n  checkRangesOrGetDefault(level, \"level\", Z_MIN_LEVEL, Z_MAX_LEVEL);\n  checkRangesOrGetDefault(strategy, \"strategy\", Z_DEFAULT_STRATEGY, Z_FIXED);\n  if (this._level !== level || this._strategy !== strategy) {\n    this.flush(Z_SYNC_FLUSH, FunctionPrototypeBind(paramsAfterFlushCallback, this, level, strategy, callback));\n  } else {\n    process.nextTick(callback);\n  }\n};\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate))\n    return new Deflate(opts);\n  ReflectApply(Zlib, this, [opts, DEFLATE]);\n}\nObjectSetPrototypeOf(Deflate.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Deflate, Zlib);\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate))\n    return new Inflate(opts);\n  ReflectApply(Zlib, this, [opts, INFLATE]);\n}\nObjectSetPrototypeOf(Inflate.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Inflate, Zlib);\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip))\n    return new Gzip(opts);\n  ReflectApply(Zlib, this, [opts, GZIP]);\n}\nObjectSetPrototypeOf(Gzip.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Gzip, Zlib);\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip))\n    return new Gunzip(opts);\n  ReflectApply(Zlib, this, [opts, GUNZIP]);\n}\nObjectSetPrototypeOf(Gunzip.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Gunzip, Zlib);\nfunction DeflateRaw(opts) {\n  if (opts && opts.windowBits === 8)\n    opts.windowBits = 9;\n  if (!(this instanceof DeflateRaw))\n    return new DeflateRaw(opts);\n  ReflectApply(Zlib, this, [opts, DEFLATERAW]);\n}\nObjectSetPrototypeOf(DeflateRaw.prototype, Zlib.prototype);\nObjectSetPrototypeOf(DeflateRaw, Zlib);\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw))\n    return new InflateRaw(opts);\n  ReflectApply(Zlib, this, [opts, INFLATERAW]);\n}\nObjectSetPrototypeOf(InflateRaw.prototype, Zlib.prototype);\nObjectSetPrototypeOf(InflateRaw, Zlib);\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip))\n    return new Unzip(opts);\n  ReflectApply(Zlib, this, [opts, UNZIP]);\n}\nObjectSetPrototypeOf(Unzip.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Unzip, Zlib);\nfunction createConvenienceMethod(ctor, sync) {\n  if (sync) {\n    return function syncBufferWrapper(buffer, opts) {\n      return zlibBufferSync(new ctor(opts), buffer);\n    };\n  }\n  return function asyncBufferWrapper(buffer, opts, callback) {\n    if (typeof opts === \"function\") {\n      callback = opts;\n      opts = {};\n    }\n    return zlibBuffer(new ctor(opts), buffer, callback);\n  };\n}\nconst kMaxBrotliParam = MathMaxApply(ArrayPrototypeMap(ObjectKeys(constants), (key) => StringPrototypeStartsWith(key, \"BROTLI_PARAM_\") ? constants[key] : 0));\nconst brotliInitParamsArray = new Uint32Array(kMaxBrotliParam + 1);\nconst brotliDefaultOpts = {\n  flush: BROTLI_OPERATION_PROCESS,\n  finishFlush: BROTLI_OPERATION_FINISH,\n  fullFlush: BROTLI_OPERATION_FLUSH\n};\nfunction Brotli(opts, mode) {\n  assert(mode === BROTLI_DECODE || mode === BROTLI_ENCODE);\n  TypedArrayPrototypeFill(brotliInitParamsArray, -1);\n  if (opts?.params) {\n    ArrayPrototypeForEach(ObjectKeys(opts.params), (origKey) => {\n      const key = +origKey;\n      if (NumberIsNaN(key) || key < 0 || key > kMaxBrotliParam || (brotliInitParamsArray[key] | 0) !== -1) {\n        throw new ERR_BROTLI_INVALID_PARAM(origKey);\n      }\n      const value = opts.params[origKey];\n      if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n        throw new ERR_INVALID_ARG_TYPE(\"options.params[key]\", \"number\", opts.params[origKey]);\n      }\n      brotliInitParamsArray[key] = value;\n    });\n  }\n  const handle = mode === BROTLI_DECODE ? new binding.BrotliDecoder(mode) : new binding.BrotliEncoder(mode);\n  this._writeState = new Uint32Array(2);\n  if (!handle.init(brotliInitParamsArray, this._writeState, processCallback)) {\n    throw new ERR_ZLIB_INITIALIZATION_FAILED();\n  }\n  ReflectApply(ZlibBase, this, [opts, mode, handle, brotliDefaultOpts]);\n}\nObjectSetPrototypeOf(Brotli.prototype, Zlib.prototype);\nObjectSetPrototypeOf(Brotli, Zlib);\nfunction BrotliCompress(opts) {\n  if (!(this instanceof BrotliCompress))\n    return new BrotliCompress(opts);\n  ReflectApply(Brotli, this, [opts, BROTLI_ENCODE]);\n}\nObjectSetPrototypeOf(BrotliCompress.prototype, Brotli.prototype);\nObjectSetPrototypeOf(BrotliCompress, Brotli);\nfunction BrotliDecompress(opts) {\n  if (!(this instanceof BrotliDecompress))\n    return new BrotliDecompress(opts);\n  ReflectApply(Brotli, this, [opts, BROTLI_DECODE]);\n}\nObjectSetPrototypeOf(BrotliDecompress.prototype, Brotli.prototype);\nObjectSetPrototypeOf(BrotliDecompress, Brotli);\nfunction createProperty(ctor) {\n  return {\n    configurable: true,\n    enumerable: true,\n    value: function(options) {\n      return new ctor(options);\n    }\n  };\n}\nObjectDefineProperty(binding.Zlib.prototype, \"jsref\", {\n  get() {\n    return this[owner_symbol];\n  },\n  set(v) {\n    return this[owner_symbol] = v;\n  }\n});\nmodule.exports = {\n  Deflate,\n  Inflate,\n  Gzip,\n  Gunzip,\n  DeflateRaw,\n  InflateRaw,\n  Unzip,\n  BrotliCompress,\n  BrotliDecompress,\n  deflate: createConvenienceMethod(Deflate, false),\n  deflateSync: createConvenienceMethod(Deflate, true),\n  gzip: createConvenienceMethod(Gzip, false),\n  gzipSync: createConvenienceMethod(Gzip, true),\n  deflateRaw: createConvenienceMethod(DeflateRaw, false),\n  deflateRawSync: createConvenienceMethod(DeflateRaw, true),\n  unzip: createConvenienceMethod(Unzip, false),\n  unzipSync: createConvenienceMethod(Unzip, true),\n  inflate: createConvenienceMethod(Inflate, false),\n  inflateSync: createConvenienceMethod(Inflate, true),\n  gunzip: createConvenienceMethod(Gunzip, false),\n  gunzipSync: createConvenienceMethod(Gunzip, true),\n  inflateRaw: createConvenienceMethod(InflateRaw, false),\n  inflateRawSync: createConvenienceMethod(InflateRaw, true),\n  brotliCompress: createConvenienceMethod(BrotliCompress, false),\n  brotliCompressSync: createConvenienceMethod(BrotliCompress, true),\n  brotliDecompress: createConvenienceMethod(BrotliDecompress, false),\n  brotliDecompressSync: createConvenienceMethod(BrotliDecompress, true)\n};\nObjectDefineProperties(module.exports, {\n  createDeflate: createProperty(Deflate),\n  createInflate: createProperty(Inflate),\n  createDeflateRaw: createProperty(DeflateRaw),\n  createInflateRaw: createProperty(InflateRaw),\n  createGzip: createProperty(Gzip),\n  createGunzip: createProperty(Gunzip),\n  createUnzip: createProperty(Unzip),\n  createBrotliCompress: createProperty(BrotliCompress),\n  createBrotliDecompress: createProperty(BrotliDecompress),\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  codes: {\n    enumerable: true,\n    writable: false,\n    value: ObjectFreeze(codes)\n  }\n});\nfor (const bkey of ObjectKeys(constants)) {\n  if (StringPrototypeStartsWith(bkey, \"BROTLI\"))\n    continue;\n  ObjectDefineProperty(module.exports, bkey, {\n    enumerable: false,\n    value: constants[bkey],\n    writable: false\n  });\n}\n}"]]