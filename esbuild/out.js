"use strict";const{ArrayPrototypeIncludes,ArrayPrototypeIndexOf,ArrayPrototypePop,ArrayPrototypePush,ArrayPrototypeShift,ArrayPrototypeSome,ArrayPrototypeSplice,FunctionPrototypeCall,NumberIsNaN,ObjectCreate,ObjectKeys,ObjectSetPrototypeOf,ObjectValues,StringPrototypeIndexOf,StringPrototypeSplit,StringPrototypeStartsWith,StringPrototypeSubstr,Symbol}=primordials,net=require("net"),EventEmitter=require("events");let debug=require("internal/util/debuglog").debuglog("http",i=>{debug=i});const{AsyncResource}=require("async_hooks"),{async_id_symbol}=require("internal/async_hooks").symbols,{codes:{ERR_OUT_OF_RANGE}}=require("internal/errors"),{once}=require("internal/util"),{validateNumber,validateOneOf,validateString}=require("internal/validators"),kOnKeylog=Symbol("onkeylog"),kRequestOptions=Symbol("requestOptions"),kRequestAsyncResource=Symbol("requestAsyncResource");class ReusedHandle{constructor(e,t){this.type=e,this.handle=t}}function freeSocketErrorListener(i){const e=this;debug("SOCKET ERROR on FREE socket:",i.message,i.stack),e.destroy(),e.emit("agentRemove")}function Agent(i){if(!(this instanceof Agent))return new Agent(i);if(FunctionPrototypeCall(EventEmitter,this),this.defaultPort=80,this.protocol="http:",this.options={__proto__:null,...i},this.options.path=null,this.requests=ObjectCreate(null),this.sockets=ObjectCreate(null),this.freeSockets=ObjectCreate(null),this.keepAliveMsecs=this.options.keepAliveMsecs||1e3,this.keepAlive=this.options.keepAlive||!1,this.maxSockets=this.options.maxSockets||Agent.defaultMaxSockets,this.maxFreeSockets=this.options.maxFreeSockets||256,this.scheduling=this.options.scheduling||"lifo",this.maxTotalSockets=this.options.maxTotalSockets,this.totalSocketCount=0,validateOneOf(this.scheduling,"scheduling",["fifo","lifo"]),this.maxTotalSockets!==void 0){if(validateNumber(this.maxTotalSockets,"maxTotalSockets"),this.maxTotalSockets<=0||NumberIsNaN(this.maxTotalSockets))throw new ERR_OUT_OF_RANGE("maxTotalSockets","> 0",this.maxTotalSockets)}else this.maxTotalSockets=1/0;this.on("free",(e,t)=>{const s=this.getName(t);if(debug("agent.on(free)",s),!e.writable){e.destroy();return}const c=this.requests[s];if(c&&c.length){const a=ArrayPrototypeShift(c),h=a[kRequestAsyncResource];h?(h.runInAsyncScope(()=>{asyncResetHandle(e),setRequestSocket(this,a,e)}),a[kRequestAsyncResource]=null):setRequestSocket(this,a,e),c.length===0&&delete this.requests[s];return}const r=e._httpMessage;if(!r||!r.shouldKeepAlive||!this.keepAlive){e.destroy();return}const n=this.freeSockets[s]||[],o=n.length;let l=o;if(this.sockets[s]&&(l+=this.sockets[s].length),this.totalSocketCount>this.maxTotalSockets||l>this.maxSockets||o>=this.maxFreeSockets||!this.keepSocketAlive(e)){e.destroy();return}this.freeSockets[s]=n,e[async_id_symbol]=-1,e._httpMessage=null,this.removeSocket(e,t),e.once("error",freeSocketErrorListener),ArrayPrototypePush(n,e)}),this.on("newListener",maybeEnableKeylog)}ObjectSetPrototypeOf(Agent.prototype,EventEmitter.prototype),ObjectSetPrototypeOf(Agent,EventEmitter);function maybeEnableKeylog(i){if(i==="keylog"){this.removeListener("newListener",maybeEnableKeylog);const e=this;this[kOnKeylog]=function(c){e.emit("keylog",c,this)};const t=ObjectValues(this.sockets);for(let s=0;s<t.length;s++)t[s].on("keylog",this[kOnKeylog])}}Agent.defaultMaxSockets=1/0,Agent.prototype.createConnection=net.createConnection,Agent.prototype.getName=function(e){let t=e.host||"localhost";return t+=":",e.port&&(t+=e.port),t+=":",e.localAddress&&(t+=e.localAddress),(e.family===4||e.family===6)&&(t+=`:${e.family}`),e.socketPath&&(t+=`:${e.socketPath}`),t},Agent.prototype.addRequest=function(e,t,s,c){typeof t=="string"&&(t={__proto__:null,host:t,port:s,localAddress:c}),t={__proto__:null,...t,...this.options},t.socketPath&&(t.path=t.socketPath),!t.servername&&t.servername!==""&&(t.servername=calculateServerName(t,e));const r=this.getName(t);this.sockets[r]||(this.sockets[r]=[]);const n=this.freeSockets[r];let o;if(n){for(;n.length&&n[0].destroyed;)ArrayPrototypeShift(n);o=this.scheduling==="fifo"?ArrayPrototypeShift(n):ArrayPrototypePop(n),n.length||delete this.freeSockets[r]}const l=n?n.length:0,a=l+this.sockets[r].length;o?(asyncResetHandle(o),this.reuseSocket(o,e),setRequestSocket(this,e,o),ArrayPrototypePush(this.sockets[r],o),this.totalSocketCount++):a<this.maxSockets&&this.totalSocketCount<this.maxTotalSockets?(debug("call onSocket",a,l),this.createSocket(e,t,(h,u)=>{h?e.onSocket(u,h):setRequestSocket(this,e,u)})):(debug("wait for socket"),this.requests[r]||(this.requests[r]=[]),e[kRequestOptions]=t,e[kRequestAsyncResource]=new AsyncResource("QueuedRequest"),ArrayPrototypePush(this.requests[r],e))},Agent.prototype.createSocket=function(e,t,s){t={__proto__:null,...t,...this.options},t.socketPath&&(t.path=t.socketPath),!t.servername&&t.servername!==""&&(t.servername=calculateServerName(t,e));const c=this.getName(t);t._agentKey=c,debug("createConnection",c,t),t.encoding=null;const r=once((o,l)=>{if(o)return s(o);this.sockets[c]||(this.sockets[c]=[]),ArrayPrototypePush(this.sockets[c],l),this.totalSocketCount++,debug("sockets",c,this.sockets[c].length,this.totalSocketCount),installListeners(this,l,t),s(null,l)}),n=this.createConnection(t,r);n&&r(null,n)};function calculateServerName(i,e){let t=i.host;const s=e.getHeader("host");if(s)if(validateString(s,"options.headers.host"),StringPrototypeStartsWith(s,"[")){const c=StringPrototypeIndexOf(s,"]");c===-1?t=s:t=StringPrototypeSubstr(s,1,c-1)}else t=StringPrototypeSplit(s,":",1)[0];return net.isIP(t)&&(t=""),t}function installListeners(i,e,t){function s(){debug("CLIENT socket onFree"),i.emit("free",e,t)}e.on("free",s);function c(o){debug("CLIENT socket onClose"),i.removeSocket(e,t)}e.on("close",c);function r(){debug("CLIENT socket onTimeout");const o=i.freeSockets;if(ArrayPrototypeSome(ObjectKeys(o),l=>ArrayPrototypeIncludes(o[l],e)))return e.destroy()}e.on("timeout",r);function n(){debug("CLIENT socket onRemove"),i.removeSocket(e,t),e.removeListener("close",c),e.removeListener("free",s),e.removeListener("timeout",r),e.removeListener("agentRemove",n)}e.on("agentRemove",n),i[kOnKeylog]&&e.on("keylog",i[kOnKeylog])}Agent.prototype.removeSocket=function(e,t){const s=this.getName(t);debug("removeSocket",s,"writable:",e.writable);const c=[this.sockets];e.writable||ArrayPrototypePush(c,this.freeSockets);for(let n=0;n<c.length;n++){const o=c[n];if(o[s]){const l=ArrayPrototypeIndexOf(o[s],e);l!==-1&&(ArrayPrototypeSplice(o[s],l,1),o[s].length===0&&delete o[s],this.totalSocketCount--)}}let r;if(this.requests[s]&&this.requests[s].length)debug("removeSocket, have a request, make a socket"),r=this.requests[s][0];else{const n=ObjectKeys(this.requests);for(let o=0;o<n.length;o++){const l=n[o];if(this.sockets[l]&&this.sockets[l].length)break;debug("removeSocket, have a request with different origin, make a socket"),r=this.requests[l][0],t=r[kRequestOptions];break}}r&&t&&(r[kRequestOptions]=void 0,this.createSocket(r,t,(n,o)=>{n?r.onSocket(o,n):o.emit("free")}))},Agent.prototype.keepSocketAlive=function(e){e.setKeepAlive(!0,this.keepAliveMsecs),e.unref();const t=this.options.timeout||0;return e.timeout!==t&&e.setTimeout(t),!0},Agent.prototype.reuseSocket=function(e,t){debug("have free socket"),e.removeListener("error",freeSocketErrorListener),t.reusedSocket=!0,e.ref()},Agent.prototype.destroy=function(){const e=[this.freeSockets,this.sockets];for(let t=0;t<e.length;t++){const s=e[t],c=ObjectKeys(s);for(let r=0;r<c.length;r++){const n=s[c[r]];for(let o=0;o<n.length;o++)n[o].destroy()}}};function setRequestSocket(i,e,t){e.onSocket(t);const s=i.options.timeout||0;e.timeout===void 0||e.timeout===s||t.setTimeout(e.timeout)}function asyncResetHandle(i){const e=i._handle;e&&typeof e.asyncReset=="function"&&(e.asyncReset(new ReusedHandle(e.getProviderType(),i)),i[async_id_symbol]=e.getAsyncId())}module.exports={Agent,globalAgent:new Agent};
